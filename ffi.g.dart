// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

class NativeLibrary {
  /// Holds the Dynamic library.
  final ffi.DynamicLibrary _dylib;

  /// The symbols are looked up in [dynamicLibrary].
  NativeLibrary(ffi.DynamicLibrary dynamicLibrary) : _dylib = dynamicLibrary;

  /// Extract the bitstream ID and the frame size from AC-3 data.
  int av_ac3_parse_header(
    ffi.Pointer<ffi.Uint8> buf,
    int size,
    ffi.Pointer<ffi.Uint8> bitstream_id,
    ffi.Pointer<ffi.Uint16> frame_size,
  ) {
    _av_ac3_parse_header ??= _dylib.lookupFunction<_c_av_ac3_parse_header,
        _dart_av_ac3_parse_header>('av_ac3_parse_header');
    return _av_ac3_parse_header(
      buf,
      size,
      bitstream_id,
      frame_size,
    );
  }

  _dart_av_ac3_parse_header _av_ac3_parse_header;

  /// Extract the number of samples and frames from AAC data.
  /// @param[in]  buf     pointer to AAC data buffer
  /// @param[out] samples Pointer to where number of samples is written
  /// @param[out] frames  Pointer to where number of frames is written
  /// @return Returns 0 on success, error code on failure.
  int av_adts_header_parse(
    ffi.Pointer<ffi.Uint8> buf,
    ffi.Pointer<ffi.Uint32> samples,
    ffi.Pointer<ffi.Uint8> frames,
  ) {
    _av_adts_header_parse ??= _dylib.lookupFunction<_c_av_adts_header_parse,
        _dart_av_adts_header_parse>('av_adts_header_parse');
    return _av_adts_header_parse(
      buf,
      samples,
      frames,
    );
  }

  _dart_av_adts_header_parse _av_adts_header_parse;

  /// Return the LIBAVUTIL_VERSION_INT constant.
  int avutil_version() {
    _avutil_version ??=
        _dylib.lookupFunction<_c_avutil_version, _dart_avutil_version>(
            'avutil_version');
    return _avutil_version();
  }

  _dart_avutil_version _avutil_version;

  /// Return an informative version string. This usually is the actual release
  /// version number or a git commit description. This string has no fixed format
  /// and can change any time. It should never be parsed by code.
  ffi.Pointer<ffi.Int8> av_version_info() {
    _av_version_info ??=
        _dylib.lookupFunction<_c_av_version_info, _dart_av_version_info>(
            'av_version_info');
    return _av_version_info();
  }

  _dart_av_version_info _av_version_info;

  /// Return the libavutil build-time configuration.
  ffi.Pointer<ffi.Int8> avutil_configuration() {
    _avutil_configuration ??= _dylib.lookupFunction<_c_avutil_configuration,
        _dart_avutil_configuration>('avutil_configuration');
    return _avutil_configuration();
  }

  _dart_avutil_configuration _avutil_configuration;

  /// Return the libavutil license.
  ffi.Pointer<ffi.Int8> avutil_license() {
    _avutil_license ??=
        _dylib.lookupFunction<_c_avutil_license, _dart_avutil_license>(
            'avutil_license');
    return _avutil_license();
  }

  _dart_avutil_license _avutil_license;

  /// Return a string describing the media_type enum, NULL if media_type
  /// is unknown.
  ffi.Pointer<ffi.Int8> av_get_media_type_string(
    int media_type,
  ) {
    _av_get_media_type_string ??= _dylib.lookupFunction<
        _c_av_get_media_type_string,
        _dart_av_get_media_type_string>('av_get_media_type_string');
    return _av_get_media_type_string(
      media_type,
    );
  }

  _dart_av_get_media_type_string _av_get_media_type_string;

  /// Return a single letter to describe the given picture type
  /// pict_type.
  ///
  /// @param[in] pict_type the picture type @return a single character
  /// representing the picture type, '?' if pict_type is unknown
  int av_get_picture_type_char(
    int pict_type,
  ) {
    _av_get_picture_type_char ??= _dylib.lookupFunction<
        _c_av_get_picture_type_char,
        _dart_av_get_picture_type_char>('av_get_picture_type_char');
    return _av_get_picture_type_char(
      pict_type,
    );
  }

  _dart_av_get_picture_type_char _av_get_picture_type_char;

  int av_log2(
    int v,
  ) {
    _av_log2 ??= _dylib.lookupFunction<_c_av_log2, _dart_av_log2>('av_log2');
    return _av_log2(
      v,
    );
  }

  _dart_av_log2 _av_log2;

  int av_log2_16bit(
    int v,
  ) {
    _av_log2_16bit ??= _dylib
        .lookupFunction<_c_av_log2_16bit, _dart_av_log2_16bit>('av_log2_16bit');
    return _av_log2_16bit(
      v,
    );
  }

  _dart_av_log2_16bit _av_log2_16bit;

  /// Clip a signed integer value into the amin-amax range.
  /// @param a value to clip
  /// @param amin minimum value of the clip range
  /// @param amax maximum value of the clip range
  /// @return clipped value
  int av_clip_c(
    int a,
    int amin,
    int amax,
  ) {
    _av_clip_c ??=
        _dylib.lookupFunction<_c_av_clip_c, _dart_av_clip_c>('av_clip_c');
    return _av_clip_c(
      a,
      amin,
      amax,
    );
  }

  _dart_av_clip_c _av_clip_c;

  /// Clip a signed 64bit integer value into the amin-amax range.
  /// @param a value to clip
  /// @param amin minimum value of the clip range
  /// @param amax maximum value of the clip range
  /// @return clipped value
  int av_clip64_c(
    int a,
    int amin,
    int amax,
  ) {
    _av_clip64_c ??=
        _dylib.lookupFunction<_c_av_clip64_c, _dart_av_clip64_c>('av_clip64_c');
    return _av_clip64_c(
      a,
      amin,
      amax,
    );
  }

  _dart_av_clip64_c _av_clip64_c;

  /// Clip a signed integer value into the 0-255 range.
  /// @param a value to clip
  /// @return clipped value
  int av_clip_uint8_c(
    int a,
  ) {
    _av_clip_uint8_c ??=
        _dylib.lookupFunction<_c_av_clip_uint8_c, _dart_av_clip_uint8_c>(
            'av_clip_uint8_c');
    return _av_clip_uint8_c(
      a,
    );
  }

  _dart_av_clip_uint8_c _av_clip_uint8_c;

  /// Clip a signed integer value into the -128,127 range.
  /// @param a value to clip
  /// @return clipped value
  int av_clip_int8_c(
    int a,
  ) {
    _av_clip_int8_c ??=
        _dylib.lookupFunction<_c_av_clip_int8_c, _dart_av_clip_int8_c>(
            'av_clip_int8_c');
    return _av_clip_int8_c(
      a,
    );
  }

  _dart_av_clip_int8_c _av_clip_int8_c;

  /// Clip a signed integer value into the 0-65535 range.
  /// @param a value to clip
  /// @return clipped value
  int av_clip_uint16_c(
    int a,
  ) {
    _av_clip_uint16_c ??=
        _dylib.lookupFunction<_c_av_clip_uint16_c, _dart_av_clip_uint16_c>(
            'av_clip_uint16_c');
    return _av_clip_uint16_c(
      a,
    );
  }

  _dart_av_clip_uint16_c _av_clip_uint16_c;

  /// Clip a signed integer value into the -32768,32767 range.
  /// @param a value to clip
  /// @return clipped value
  int av_clip_int16_c(
    int a,
  ) {
    _av_clip_int16_c ??=
        _dylib.lookupFunction<_c_av_clip_int16_c, _dart_av_clip_int16_c>(
            'av_clip_int16_c');
    return _av_clip_int16_c(
      a,
    );
  }

  _dart_av_clip_int16_c _av_clip_int16_c;

  /// Clip a signed 64-bit integer value into the -2147483648,2147483647 range.
  /// @param a value to clip
  /// @return clipped value
  int av_clipl_int32_c(
    int a,
  ) {
    _av_clipl_int32_c ??=
        _dylib.lookupFunction<_c_av_clipl_int32_c, _dart_av_clipl_int32_c>(
            'av_clipl_int32_c');
    return _av_clipl_int32_c(
      a,
    );
  }

  _dart_av_clipl_int32_c _av_clipl_int32_c;

  /// Clip a signed integer into the -(2^p),(2^p-1) range.
  /// @param  a value to clip
  /// @param  p bit position to clip at
  /// @return clipped value
  int av_clip_intp2_c(
    int a,
    int p,
  ) {
    _av_clip_intp2_c ??=
        _dylib.lookupFunction<_c_av_clip_intp2_c, _dart_av_clip_intp2_c>(
            'av_clip_intp2_c');
    return _av_clip_intp2_c(
      a,
      p,
    );
  }

  _dart_av_clip_intp2_c _av_clip_intp2_c;

  /// Clip a signed integer to an unsigned power of two range.
  /// @param  a value to clip
  /// @param  p bit position to clip at
  /// @return clipped value
  int av_clip_uintp2_c(
    int a,
    int p,
  ) {
    _av_clip_uintp2_c ??=
        _dylib.lookupFunction<_c_av_clip_uintp2_c, _dart_av_clip_uintp2_c>(
            'av_clip_uintp2_c');
    return _av_clip_uintp2_c(
      a,
      p,
    );
  }

  _dart_av_clip_uintp2_c _av_clip_uintp2_c;

  /// Clear high bits from an unsigned integer starting with specific bit position
  /// @param  a value to clip
  /// @param  p bit position to clip at
  /// @return clipped value
  int av_mod_uintp2_c(
    int a,
    int p,
  ) {
    _av_mod_uintp2_c ??=
        _dylib.lookupFunction<_c_av_mod_uintp2_c, _dart_av_mod_uintp2_c>(
            'av_mod_uintp2_c');
    return _av_mod_uintp2_c(
      a,
      p,
    );
  }

  _dart_av_mod_uintp2_c _av_mod_uintp2_c;

  /// Add two signed 32-bit values with saturation.
  ///
  /// @param  a one value
  /// @param  b another value
  /// @return sum with signed saturation
  int av_sat_add32_c(
    int a,
    int b,
  ) {
    _av_sat_add32_c ??=
        _dylib.lookupFunction<_c_av_sat_add32_c, _dart_av_sat_add32_c>(
            'av_sat_add32_c');
    return _av_sat_add32_c(
      a,
      b,
    );
  }

  _dart_av_sat_add32_c _av_sat_add32_c;

  /// Add a doubled value to another value with saturation at both stages.
  ///
  /// @param  a first value
  /// @param  b value doubled and added to a
  /// @return sum sat(a + sat(2*b)) with signed saturation
  int av_sat_dadd32_c(
    int a,
    int b,
  ) {
    _av_sat_dadd32_c ??=
        _dylib.lookupFunction<_c_av_sat_dadd32_c, _dart_av_sat_dadd32_c>(
            'av_sat_dadd32_c');
    return _av_sat_dadd32_c(
      a,
      b,
    );
  }

  _dart_av_sat_dadd32_c _av_sat_dadd32_c;

  /// Subtract two signed 32-bit values with saturation.
  ///
  /// @param  a one value
  /// @param  b another value
  /// @return difference with signed saturation
  int av_sat_sub32_c(
    int a,
    int b,
  ) {
    _av_sat_sub32_c ??=
        _dylib.lookupFunction<_c_av_sat_sub32_c, _dart_av_sat_sub32_c>(
            'av_sat_sub32_c');
    return _av_sat_sub32_c(
      a,
      b,
    );
  }

  _dart_av_sat_sub32_c _av_sat_sub32_c;

  /// Subtract a doubled value from another value with saturation at both stages.
  ///
  /// @param  a first value
  /// @param  b value doubled and subtracted from a
  /// @return difference sat(a - sat(2*b)) with signed saturation
  int av_sat_dsub32_c(
    int a,
    int b,
  ) {
    _av_sat_dsub32_c ??=
        _dylib.lookupFunction<_c_av_sat_dsub32_c, _dart_av_sat_dsub32_c>(
            'av_sat_dsub32_c');
    return _av_sat_dsub32_c(
      a,
      b,
    );
  }

  _dart_av_sat_dsub32_c _av_sat_dsub32_c;

  /// Add two signed 64-bit values with saturation.
  ///
  /// @param  a one value
  /// @param  b another value
  /// @return sum with signed saturation
  int av_sat_add64_c(
    int a,
    int b,
  ) {
    _av_sat_add64_c ??=
        _dylib.lookupFunction<_c_av_sat_add64_c, _dart_av_sat_add64_c>(
            'av_sat_add64_c');
    return _av_sat_add64_c(
      a,
      b,
    );
  }

  _dart_av_sat_add64_c _av_sat_add64_c;

  /// Subtract two signed 64-bit values with saturation.
  ///
  /// @param  a one value
  /// @param  b another value
  /// @return difference with signed saturation
  int av_sat_sub64_c(
    int a,
    int b,
  ) {
    _av_sat_sub64_c ??=
        _dylib.lookupFunction<_c_av_sat_sub64_c, _dart_av_sat_sub64_c>(
            'av_sat_sub64_c');
    return _av_sat_sub64_c(
      a,
      b,
    );
  }

  _dart_av_sat_sub64_c _av_sat_sub64_c;

  /// Clip a float value into the amin-amax range.
  /// @param a value to clip
  /// @param amin minimum value of the clip range
  /// @param amax maximum value of the clip range
  /// @return clipped value
  double av_clipf_c(
    double a,
    double amin,
    double amax,
  ) {
    _av_clipf_c ??=
        _dylib.lookupFunction<_c_av_clipf_c, _dart_av_clipf_c>('av_clipf_c');
    return _av_clipf_c(
      a,
      amin,
      amax,
    );
  }

  _dart_av_clipf_c _av_clipf_c;

  /// Clip a double value into the amin-amax range.
  /// @param a value to clip
  /// @param amin minimum value of the clip range
  /// @param amax maximum value of the clip range
  /// @return clipped value
  double av_clipd_c(
    double a,
    double amin,
    double amax,
  ) {
    _av_clipd_c ??=
        _dylib.lookupFunction<_c_av_clipd_c, _dart_av_clipd_c>('av_clipd_c');
    return _av_clipd_c(
      a,
      amin,
      amax,
    );
  }

  _dart_av_clipd_c _av_clipd_c;

  /// Compute ceil(log2(x)).
  /// @param x value used to compute ceil(log2(x))
  /// @return computed ceiling of log2(x)
  int av_ceil_log2_c(
    int x,
  ) {
    _av_ceil_log2_c ??=
        _dylib.lookupFunction<_c_av_ceil_log2_c, _dart_av_ceil_log2_c>(
            'av_ceil_log2_c');
    return _av_ceil_log2_c(
      x,
    );
  }

  _dart_av_ceil_log2_c _av_ceil_log2_c;

  /// Count number of bits set to one in x
  /// @param x value to count bits of
  /// @return the number of bits set to one in x
  int av_popcount_c(
    int x,
  ) {
    _av_popcount_c ??= _dylib
        .lookupFunction<_c_av_popcount_c, _dart_av_popcount_c>('av_popcount_c');
    return _av_popcount_c(
      x,
    );
  }

  _dart_av_popcount_c _av_popcount_c;

  /// Count number of bits set to one in x
  /// @param x value to count bits of
  /// @return the number of bits set to one in x
  int av_popcount64_c(
    int x,
  ) {
    _av_popcount64_c ??=
        _dylib.lookupFunction<_c_av_popcount64_c, _dart_av_popcount64_c>(
            'av_popcount64_c');
    return _av_popcount64_c(
      x,
    );
  }

  _dart_av_popcount64_c _av_popcount64_c;

  int av_parity_c(
    int v,
  ) {
    _av_parity_c ??=
        _dylib.lookupFunction<_c_av_parity_c, _dart_av_parity_c>('av_parity_c');
    return _av_parity_c(
      v,
    );
  }

  _dart_av_parity_c _av_parity_c;

  /// Put a description of the AVERROR code errnum in errbuf.
  /// In case of failure the global variable errno is set to indicate the
  /// error. Even in case of failure av_strerror() will print a generic
  /// error message indicating the errnum provided to errbuf.
  ///
  /// @param errnum      error code to describe
  /// @param errbuf      buffer to which description is written
  /// @param errbuf_size the size in bytes of errbuf
  /// @return 0 on success, a negative value if a description for errnum
  /// cannot be found
  int av_strerror(
    int errnum,
    ffi.Pointer<ffi.Int8> errbuf,
    int errbuf_size,
  ) {
    _av_strerror ??=
        _dylib.lookupFunction<_c_av_strerror, _dart_av_strerror>('av_strerror');
    return _av_strerror(
      errnum,
      errbuf,
      errbuf_size,
    );
  }

  _dart_av_strerror _av_strerror;

  /// Fill the provided buffer with a string containing an error string
  /// corresponding to the AVERROR code errnum.
  ///
  /// @param errbuf         a buffer
  /// @param errbuf_size    size in bytes of errbuf
  /// @param errnum         error code to describe
  /// @return the buffer in input, filled with the error description
  /// @see av_strerror()
  ffi.Pointer<ffi.Int8> av_make_error_string(
    ffi.Pointer<ffi.Int8> errbuf,
    int errbuf_size,
    int errnum,
  ) {
    _av_make_error_string ??= _dylib.lookupFunction<_c_av_make_error_string,
        _dart_av_make_error_string>('av_make_error_string');
    return _av_make_error_string(
      errbuf,
      errbuf_size,
      errnum,
    );
  }

  _dart_av_make_error_string _av_make_error_string;

  /// Allocate a memory block with alignment suitable for all memory accesses
  /// (including vectors if available on the CPU).
  ///
  /// @param size Size in bytes for the memory block to be allocated
  /// @return Pointer to the allocated block, or `NULL` if the block cannot
  /// be allocated
  /// @see av_mallocz()
  ffi.Pointer<ffi.Void> av_malloc(
    int size,
  ) {
    _av_malloc ??=
        _dylib.lookupFunction<_c_av_malloc, _dart_av_malloc>('av_malloc');
    return _av_malloc(
      size,
    );
  }

  _dart_av_malloc _av_malloc;

  /// Allocate a memory block with alignment suitable for all memory accesses
  /// (including vectors if available on the CPU) and zero all the bytes of the
  /// block.
  ///
  /// @param size Size in bytes for the memory block to be allocated
  /// @return Pointer to the allocated block, or `NULL` if it cannot be allocated
  /// @see av_malloc()
  ffi.Pointer<ffi.Void> av_mallocz(
    int size,
  ) {
    _av_mallocz ??=
        _dylib.lookupFunction<_c_av_mallocz, _dart_av_mallocz>('av_mallocz');
    return _av_mallocz(
      size,
    );
  }

  _dart_av_mallocz _av_mallocz;

  /// Allocate a memory block for an array with av_malloc().
  ///
  /// The allocated memory will have size `size * nmemb` bytes.
  ///
  /// @param nmemb Number of element
  /// @param size  Size of a single element
  /// @return Pointer to the allocated block, or `NULL` if the block cannot
  /// be allocated
  /// @see av_malloc()
  ffi.Pointer<ffi.Void> av_malloc_array(
    int nmemb,
    int size,
  ) {
    _av_malloc_array ??=
        _dylib.lookupFunction<_c_av_malloc_array, _dart_av_malloc_array>(
            'av_malloc_array');
    return _av_malloc_array(
      nmemb,
      size,
    );
  }

  _dart_av_malloc_array _av_malloc_array;

  /// Allocate a memory block for an array with av_mallocz().
  ///
  /// The allocated memory will have size `size * nmemb` bytes.
  ///
  /// @param nmemb Number of elements
  /// @param size  Size of the single element
  /// @return Pointer to the allocated block, or `NULL` if the block cannot
  /// be allocated
  ///
  /// @see av_mallocz()
  /// @see av_malloc_array()
  ffi.Pointer<ffi.Void> av_mallocz_array(
    int nmemb,
    int size,
  ) {
    _av_mallocz_array ??=
        _dylib.lookupFunction<_c_av_mallocz_array, _dart_av_mallocz_array>(
            'av_mallocz_array');
    return _av_mallocz_array(
      nmemb,
      size,
    );
  }

  _dart_av_mallocz_array _av_mallocz_array;

  /// Non-inlined equivalent of av_mallocz_array().
  ///
  /// Created for symmetry with the calloc() C function.
  ffi.Pointer<ffi.Void> av_calloc(
    int nmemb,
    int size,
  ) {
    _av_calloc ??=
        _dylib.lookupFunction<_c_av_calloc, _dart_av_calloc>('av_calloc');
    return _av_calloc(
      nmemb,
      size,
    );
  }

  _dart_av_calloc _av_calloc;

  /// Allocate, reallocate, or free a block of memory.
  ///
  /// If `ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
  /// zero, free the memory block pointed to by `ptr`. Otherwise, expand or
  /// shrink that block of memory according to `size`.
  ///
  /// @param ptr  Pointer to a memory block already allocated with
  /// av_realloc() or `NULL`
  /// @param size Size in bytes of the memory block to be allocated or
  /// reallocated
  ///
  /// @return Pointer to a newly-reallocated block or `NULL` if the block
  /// cannot be reallocated or the function is used to free the memory block
  ///
  /// @warning Unlike av_malloc(), the returned pointer is not guaranteed to be
  /// correctly aligned.
  /// @see av_fast_realloc()
  /// @see av_reallocp()
  ffi.Pointer<ffi.Void> av_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
  ) {
    _av_realloc ??=
        _dylib.lookupFunction<_c_av_realloc, _dart_av_realloc>('av_realloc');
    return _av_realloc(
      ptr,
      size,
    );
  }

  _dart_av_realloc _av_realloc;

  /// Allocate, reallocate, or free a block of memory through a pointer to a
  /// pointer.
  ///
  /// If `*ptr` is `NULL` and `size` > 0, allocate a new block. If `size` is
  /// zero, free the memory block pointed to by `*ptr`. Otherwise, expand or
  /// shrink that block of memory according to `size`.
  ///
  /// @param[in,out] ptr  Pointer to a pointer to a memory block already allocated
  /// with av_realloc(), or a pointer to `NULL`. The pointer
  /// is updated on success, or freed on failure.
  /// @param[in]     size Size in bytes for the memory block to be allocated or
  /// reallocated
  ///
  /// @return Zero on success, an AVERROR error code on failure
  ///
  /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
  /// correctly aligned.
  int av_reallocp(
    ffi.Pointer<ffi.Void> ptr,
    int size,
  ) {
    _av_reallocp ??=
        _dylib.lookupFunction<_c_av_reallocp, _dart_av_reallocp>('av_reallocp');
    return _av_reallocp(
      ptr,
      size,
    );
  }

  _dart_av_reallocp _av_reallocp;

  /// Allocate, reallocate, or free a block of memory.
  ///
  /// This function does the same thing as av_realloc(), except:
  /// - It takes two size arguments and allocates `nelem * elsize` bytes,
  /// after checking the result of the multiplication for integer overflow.
  /// - It frees the input block in case of failure, thus avoiding the memory
  /// leak with the classic
  /// @code{.c}
  /// buf = realloc(buf);
  /// if (!buf)
  /// return -1;
  /// @endcode
  /// pattern.
  ffi.Pointer<ffi.Void> av_realloc_f(
    ffi.Pointer<ffi.Void> ptr,
    int nelem,
    int elsize,
  ) {
    _av_realloc_f ??= _dylib
        .lookupFunction<_c_av_realloc_f, _dart_av_realloc_f>('av_realloc_f');
    return _av_realloc_f(
      ptr,
      nelem,
      elsize,
    );
  }

  _dart_av_realloc_f _av_realloc_f;

  /// Allocate, reallocate, or free an array.
  ///
  /// If `ptr` is `NULL` and `nmemb` > 0, allocate a new block. If
  /// `nmemb` is zero, free the memory block pointed to by `ptr`.
  ///
  /// @param ptr   Pointer to a memory block already allocated with
  /// av_realloc() or `NULL`
  /// @param nmemb Number of elements in the array
  /// @param size  Size of the single element of the array
  ///
  /// @return Pointer to a newly-reallocated block or NULL if the block
  /// cannot be reallocated or the function is used to free the memory block
  ///
  /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
  /// correctly aligned.
  /// @see av_reallocp_array()
  ffi.Pointer<ffi.Void> av_realloc_array(
    ffi.Pointer<ffi.Void> ptr,
    int nmemb,
    int size,
  ) {
    _av_realloc_array ??=
        _dylib.lookupFunction<_c_av_realloc_array, _dart_av_realloc_array>(
            'av_realloc_array');
    return _av_realloc_array(
      ptr,
      nmemb,
      size,
    );
  }

  _dart_av_realloc_array _av_realloc_array;

  /// Allocate, reallocate, or free an array through a pointer to a pointer.
  ///
  /// If `*ptr` is `NULL` and `nmemb` > 0, allocate a new block. If `nmemb` is
  /// zero, free the memory block pointed to by `*ptr`.
  ///
  /// @param[in,out] ptr   Pointer to a pointer to a memory block already
  /// allocated with av_realloc(), or a pointer to `NULL`.
  /// The pointer is updated on success, or freed on failure.
  /// @param[in]     nmemb Number of elements
  /// @param[in]     size  Size of the single element
  ///
  /// @return Zero on success, an AVERROR error code on failure
  ///
  /// @warning Unlike av_malloc(), the allocated memory is not guaranteed to be
  /// correctly aligned.
  int av_reallocp_array(
    ffi.Pointer<ffi.Void> ptr,
    int nmemb,
    int size,
  ) {
    _av_reallocp_array ??=
        _dylib.lookupFunction<_c_av_reallocp_array, _dart_av_reallocp_array>(
            'av_reallocp_array');
    return _av_reallocp_array(
      ptr,
      nmemb,
      size,
    );
  }

  _dart_av_reallocp_array _av_reallocp_array;

  /// Reallocate the given buffer if it is not large enough, otherwise do nothing.
  ///
  /// If the given buffer is `NULL`, then a new uninitialized buffer is allocated.
  ///
  /// If the given buffer is not large enough, and reallocation fails, `NULL` is
  /// returned and `*size` is set to 0, but the original buffer is not changed or
  /// freed.
  ///
  /// A typical use pattern follows:
  ///
  /// @code{.c}
  /// uint8_t *buf = ...;
  /// uint8_t *new_buf = av_fast_realloc(buf, &current_size, size_needed);
  /// if (!new_buf) {
  /// // Allocation failed; clean up original buffer
  /// av_freep(&buf);
  /// return AVERROR(ENOMEM);
  /// }
  /// @endcode
  ///
  /// @param[in,out] ptr      Already allocated buffer, or `NULL`
  /// @param[in,out] size     Pointer to the size of buffer `ptr`. `*size` is
  /// updated to the new allocated size, in particular 0
  /// in case of failure.
  /// @param[in]     min_size Desired minimal size of buffer `ptr`
  /// @return `ptr` if the buffer is large enough, a pointer to newly reallocated
  /// buffer if the buffer was not large enough, or `NULL` in case of
  /// error
  /// @see av_realloc()
  /// @see av_fast_malloc()
  ffi.Pointer<ffi.Void> av_fast_realloc(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.Uint32> size,
    int min_size,
  ) {
    _av_fast_realloc ??=
        _dylib.lookupFunction<_c_av_fast_realloc, _dart_av_fast_realloc>(
            'av_fast_realloc');
    return _av_fast_realloc(
      ptr,
      size,
      min_size,
    );
  }

  _dart_av_fast_realloc _av_fast_realloc;

  /// Allocate a buffer, reusing the given one if large enough.
  ///
  /// Contrary to av_fast_realloc(), the current buffer contents might not be
  /// preserved and on error the old buffer is freed, thus no special handling to
  /// avoid memleaks is necessary.
  ///
  /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
  /// `size_needed` is greater than 0.
  ///
  /// @code{.c}
  /// uint8_t *buf = ...;
  /// av_fast_malloc(&buf, &current_size, size_needed);
  /// if (!buf) {
  /// // Allocation failed; buf already freed
  /// return AVERROR(ENOMEM);
  /// }
  /// @endcode
  ///
  /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
  /// `*ptr` will be overwritten with pointer to new
  /// buffer on success or `NULL` on failure
  /// @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
  /// updated to the new allocated size, in particular 0
  /// in case of failure.
  /// @param[in]     min_size Desired minimal size of buffer `*ptr`
  /// @see av_realloc()
  /// @see av_fast_mallocz()
  void av_fast_malloc(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.Uint32> size,
    int min_size,
  ) {
    _av_fast_malloc ??=
        _dylib.lookupFunction<_c_av_fast_malloc, _dart_av_fast_malloc>(
            'av_fast_malloc');
    return _av_fast_malloc(
      ptr,
      size,
      min_size,
    );
  }

  _dart_av_fast_malloc _av_fast_malloc;

  /// Allocate and clear a buffer, reusing the given one if large enough.
  ///
  /// Like av_fast_malloc(), but all newly allocated space is initially cleared.
  /// Reused buffer is not cleared.
  ///
  /// `*ptr` is allowed to be `NULL`, in which case allocation always happens if
  /// `size_needed` is greater than 0.
  ///
  /// @param[in,out] ptr      Pointer to pointer to an already allocated buffer.
  /// `*ptr` will be overwritten with pointer to new
  /// buffer on success or `NULL` on failure
  /// @param[in,out] size     Pointer to the size of buffer `*ptr`. `*size` is
  /// updated to the new allocated size, in particular 0
  /// in case of failure.
  /// @param[in]     min_size Desired minimal size of buffer `*ptr`
  /// @see av_fast_malloc()
  void av_fast_mallocz(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.Uint32> size,
    int min_size,
  ) {
    _av_fast_mallocz ??=
        _dylib.lookupFunction<_c_av_fast_mallocz, _dart_av_fast_mallocz>(
            'av_fast_mallocz');
    return _av_fast_mallocz(
      ptr,
      size,
      min_size,
    );
  }

  _dart_av_fast_mallocz _av_fast_mallocz;

  /// Free a memory block which has been allocated with a function of av_malloc()
  /// or av_realloc() family.
  ///
  /// @param ptr Pointer to the memory block which should be freed.
  ///
  /// @note `ptr = NULL` is explicitly allowed.
  /// @note It is recommended that you use av_freep() instead, to prevent leaving
  /// behind dangling pointers.
  /// @see av_freep()
  void av_free(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    _av_free ??= _dylib.lookupFunction<_c_av_free, _dart_av_free>('av_free');
    return _av_free(
      ptr,
    );
  }

  _dart_av_free _av_free;

  /// Free a memory block which has been allocated with a function of av_malloc()
  /// or av_realloc() family, and set the pointer pointing to it to `NULL`.
  ///
  /// @code{.c}
  /// uint8_t *buf = av_malloc(16);
  /// av_free(buf);
  /// // buf now contains a dangling pointer to freed memory, and accidental
  /// // dereference of buf will result in a use-after-free, which may be a
  /// // security risk.
  ///
  /// uint8_t *buf = av_malloc(16);
  /// av_freep(&buf);
  /// // buf is now NULL, and accidental dereference will only result in a
  /// // NULL-pointer dereference.
  /// @endcode
  ///
  /// @param ptr Pointer to the pointer to the memory block which should be freed
  /// @note `*ptr = NULL` is safe and leads to no action.
  /// @see av_free()
  void av_freep(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    _av_freep ??=
        _dylib.lookupFunction<_c_av_freep, _dart_av_freep>('av_freep');
    return _av_freep(
      ptr,
    );
  }

  _dart_av_freep _av_freep;

  /// Duplicate a string.
  ///
  /// @param s String to be duplicated
  /// @return Pointer to a newly-allocated string containing a
  /// copy of `s` or `NULL` if the string cannot be allocated
  /// @see av_strndup()
  ffi.Pointer<ffi.Int8> av_strdup(
    ffi.Pointer<ffi.Int8> s,
  ) {
    _av_strdup ??=
        _dylib.lookupFunction<_c_av_strdup, _dart_av_strdup>('av_strdup');
    return _av_strdup(
      s,
    );
  }

  _dart_av_strdup _av_strdup;

  /// Duplicate a substring of a string.
  ///
  /// @param s   String to be duplicated
  /// @param len Maximum length of the resulting string (not counting the
  /// terminating byte)
  /// @return Pointer to a newly-allocated string containing a
  /// substring of `s` or `NULL` if the string cannot be allocated
  ffi.Pointer<ffi.Int8> av_strndup(
    ffi.Pointer<ffi.Int8> s,
    int len,
  ) {
    _av_strndup ??=
        _dylib.lookupFunction<_c_av_strndup, _dart_av_strndup>('av_strndup');
    return _av_strndup(
      s,
      len,
    );
  }

  _dart_av_strndup _av_strndup;

  /// Duplicate a buffer with av_malloc().
  ///
  /// @param p    Buffer to be duplicated
  /// @param size Size in bytes of the buffer copied
  /// @return Pointer to a newly allocated buffer containing a
  /// copy of `p` or `NULL` if the buffer cannot be allocated
  ffi.Pointer<ffi.Void> av_memdup(
    ffi.Pointer<ffi.Void> p,
    int size,
  ) {
    _av_memdup ??=
        _dylib.lookupFunction<_c_av_memdup, _dart_av_memdup>('av_memdup');
    return _av_memdup(
      p,
      size,
    );
  }

  _dart_av_memdup _av_memdup;

  /// Overlapping memcpy() implementation.
  ///
  /// @param dst  Destination buffer
  /// @param back Number of bytes back to start copying (i.e. the initial size of
  /// the overlapping window); must be > 0
  /// @param cnt  Number of bytes to copy; must be >= 0
  ///
  /// @note `cnt > back` is valid, this will copy the bytes we just copied,
  /// thus creating a repeating pattern with a period length of `back`.
  void av_memcpy_backptr(
    ffi.Pointer<ffi.Uint8> dst,
    int back,
    int cnt,
  ) {
    _av_memcpy_backptr ??=
        _dylib.lookupFunction<_c_av_memcpy_backptr, _dart_av_memcpy_backptr>(
            'av_memcpy_backptr');
    return _av_memcpy_backptr(
      dst,
      back,
      cnt,
    );
  }

  _dart_av_memcpy_backptr _av_memcpy_backptr;

  /// Add the pointer to an element to a dynamic array.
  ///
  /// The array to grow is supposed to be an array of pointers to
  /// structures, and the element to add must be a pointer to an already
  /// allocated structure.
  ///
  /// The array is reallocated when its size reaches powers of 2.
  /// Therefore, the amortized cost of adding an element is constant.
  ///
  /// In case of success, the pointer to the array is updated in order to
  /// point to the new grown array, and the number pointed to by `nb_ptr`
  /// is incremented.
  /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
  /// `*nb_ptr` is set to 0.
  ///
  /// @param[in,out] tab_ptr Pointer to the array to grow
  /// @param[in,out] nb_ptr  Pointer to the number of elements in the array
  /// @param[in]     elem    Element to add
  /// @see av_dynarray_add_nofree(), av_dynarray2_add()
  void av_dynarray_add(
    ffi.Pointer<ffi.Void> tab_ptr,
    ffi.Pointer<ffi.Int32> nb_ptr,
    ffi.Pointer<ffi.Void> elem,
  ) {
    _av_dynarray_add ??=
        _dylib.lookupFunction<_c_av_dynarray_add, _dart_av_dynarray_add>(
            'av_dynarray_add');
    return _av_dynarray_add(
      tab_ptr,
      nb_ptr,
      elem,
    );
  }

  _dart_av_dynarray_add _av_dynarray_add;

  /// Add an element to a dynamic array.
  ///
  /// Function has the same functionality as av_dynarray_add(),
  /// but it doesn't free memory on fails. It returns error code
  /// instead and leave current buffer untouched.
  ///
  /// @return >=0 on success, negative otherwise
  /// @see av_dynarray_add(), av_dynarray2_add()
  int av_dynarray_add_nofree(
    ffi.Pointer<ffi.Void> tab_ptr,
    ffi.Pointer<ffi.Int32> nb_ptr,
    ffi.Pointer<ffi.Void> elem,
  ) {
    _av_dynarray_add_nofree ??= _dylib.lookupFunction<_c_av_dynarray_add_nofree,
        _dart_av_dynarray_add_nofree>('av_dynarray_add_nofree');
    return _av_dynarray_add_nofree(
      tab_ptr,
      nb_ptr,
      elem,
    );
  }

  _dart_av_dynarray_add_nofree _av_dynarray_add_nofree;

  /// Add an element of size `elem_size` to a dynamic array.
  ///
  /// The array is reallocated when its number of elements reaches powers of 2.
  /// Therefore, the amortized cost of adding an element is constant.
  ///
  /// In case of success, the pointer to the array is updated in order to
  /// point to the new grown array, and the number pointed to by `nb_ptr`
  /// is incremented.
  /// In case of failure, the array is freed, `*tab_ptr` is set to `NULL` and
  /// `*nb_ptr` is set to 0.
  ///
  /// @param[in,out] tab_ptr   Pointer to the array to grow
  /// @param[in,out] nb_ptr    Pointer to the number of elements in the array
  /// @param[in]     elem_size Size in bytes of an element in the array
  /// @param[in]     elem_data Pointer to the data of the element to add. If
  /// `NULL`, the space of the newly added element is
  /// allocated but left uninitialized.
  ///
  /// @return Pointer to the data of the element to copy in the newly allocated
  /// space
  /// @see av_dynarray_add(), av_dynarray_add_nofree()
  ffi.Pointer<ffi.Void> av_dynarray2_add(
    ffi.Pointer<ffi.Pointer<ffi.Void>> tab_ptr,
    ffi.Pointer<ffi.Int32> nb_ptr,
    int elem_size,
    ffi.Pointer<ffi.Uint8> elem_data,
  ) {
    _av_dynarray2_add ??=
        _dylib.lookupFunction<_c_av_dynarray2_add, _dart_av_dynarray2_add>(
            'av_dynarray2_add');
    return _av_dynarray2_add(
      tab_ptr,
      nb_ptr,
      elem_size,
      elem_data,
    );
  }

  _dart_av_dynarray2_add _av_dynarray2_add;

  /// Multiply two `size_t` values checking for overflow.
  ///
  /// @param[in]  a,b Operands of multiplication
  /// @param[out] r   Pointer to the result of the operation
  /// @return 0 on success, AVERROR(EINVAL) on overflow
  int av_size_mult(
    int a,
    int b,
    ffi.Pointer<ffi.Uint64> r,
  ) {
    _av_size_mult ??= _dylib
        .lookupFunction<_c_av_size_mult, _dart_av_size_mult>('av_size_mult');
    return _av_size_mult(
      a,
      b,
      r,
    );
  }

  _dart_av_size_mult _av_size_mult;

  /// Set the maximum size that may be allocated in one block.
  ///
  /// The value specified with this function is effective for all libavutil's @ref
  /// lavu_mem_funcs "heap management functions."
  ///
  /// By default, the max value is defined as `INT_MAX`.
  ///
  /// @param max Value to be set as the new maximum size
  ///
  /// @warning Exercise extreme caution when using this function. Don't touch
  /// this if you do not understand the full consequence of doing so.
  void av_max_alloc(
    int max,
  ) {
    _av_max_alloc ??= _dylib
        .lookupFunction<_c_av_max_alloc, _dart_av_max_alloc>('av_max_alloc');
    return _av_max_alloc(
      max,
    );
  }

  _dart_av_max_alloc _av_max_alloc;

  /// Reduce a fraction.
  ///
  /// This is useful for framerate calculations.
  ///
  /// @param[out] dst_num Destination numerator
  /// @param[out] dst_den Destination denominator
  /// @param[in]      num Source numerator
  /// @param[in]      den Source denominator
  /// @param[in]      max Maximum allowed values for `dst_num` & `dst_den`
  /// @return 1 if the operation is exact, 0 otherwise
  int av_reduce(
    ffi.Pointer<ffi.Int32> dst_num,
    ffi.Pointer<ffi.Int32> dst_den,
    int num,
    int den,
    int max,
  ) {
    _av_reduce ??=
        _dylib.lookupFunction<_c_av_reduce, _dart_av_reduce>('av_reduce');
    return _av_reduce(
      dst_num,
      dst_den,
      num,
      den,
      max,
    );
  }

  _dart_av_reduce _av_reduce;

  /// Reinterpret a 32-bit integer as a float.
  double av_int2float(
    int i,
  ) {
    _av_int2float ??= _dylib
        .lookupFunction<_c_av_int2float, _dart_av_int2float>('av_int2float');
    return _av_int2float(
      i,
    );
  }

  _dart_av_int2float _av_int2float;

  /// Reinterpret a float as a 32-bit integer.
  int av_float2int(
    double f,
  ) {
    _av_float2int ??= _dylib
        .lookupFunction<_c_av_float2int, _dart_av_float2int>('av_float2int');
    return _av_float2int(
      f,
    );
  }

  _dart_av_float2int _av_float2int;

  /// Reinterpret a 64-bit integer as a double.
  double av_int2double(
    int i,
  ) {
    _av_int2double ??= _dylib
        .lookupFunction<_c_av_int2double, _dart_av_int2double>('av_int2double');
    return _av_int2double(
      i,
    );
  }

  _dart_av_int2double _av_int2double;

  /// Reinterpret a double as a 64-bit integer.
  int av_double2int(
    double f,
  ) {
    _av_double2int ??= _dylib
        .lookupFunction<_c_av_double2int, _dart_av_double2int>('av_double2int');
    return _av_double2int(
      f,
    );
  }

  _dart_av_double2int _av_double2int;

  /// Compute the greatest common divisor of two integer operands.
  ///
  /// @param a,b Operands
  /// @return GCD of a and b up to sign; if a >= 0 and b >= 0, return value is >= 0;
  /// if a == 0 and b == 0, returns 0.
  int av_gcd(
    int a,
    int b,
  ) {
    _av_gcd ??= _dylib.lookupFunction<_c_av_gcd, _dart_av_gcd>('av_gcd');
    return _av_gcd(
      a,
      b,
    );
  }

  _dart_av_gcd _av_gcd;

  /// Rescale a 64-bit integer with rounding to nearest.
  ///
  /// The operation is mathematically equivalent to `a * b / c`, but writing that
  /// directly can overflow.
  ///
  /// This function is equivalent to av_rescale_rnd() with #AV_ROUND_NEAR_INF.
  ///
  /// @see av_rescale_rnd(), av_rescale_q(), av_rescale_q_rnd()
  int av_rescale(
    int a,
    int b,
    int c,
  ) {
    _av_rescale ??=
        _dylib.lookupFunction<_c_av_rescale, _dart_av_rescale>('av_rescale');
    return _av_rescale(
      a,
      b,
      c,
    );
  }

  _dart_av_rescale _av_rescale;

  /// Rescale a 64-bit integer with specified rounding.
  ///
  /// The operation is mathematically equivalent to `a * b / c`, but writing that
  /// directly can overflow, and does not support different rounding methods.
  ///
  /// @see av_rescale(), av_rescale_q(), av_rescale_q_rnd()
  int av_rescale_rnd(
    int a,
    int b,
    int c,
    int rnd,
  ) {
    _av_rescale_rnd ??=
        _dylib.lookupFunction<_c_av_rescale_rnd, _dart_av_rescale_rnd>(
            'av_rescale_rnd');
    return _av_rescale_rnd(
      a,
      b,
      c,
      rnd,
    );
  }

  _dart_av_rescale_rnd _av_rescale_rnd;

  /// Compare the remainders of two integer operands divided by a common divisor.
  ///
  /// In other words, compare the least significant `log2(mod)` bits of integers
  /// `a` and `b`.
  ///
  /// @code{.c}
  /// av_compare_mod(0x11, 0x02, 0x10) < 0 // since 0x11 % 0x10  (0x1) < 0x02 % 0x10  (0x2)
  /// av_compare_mod(0x11, 0x02, 0x20) > 0 // since 0x11 % 0x20 (0x11) > 0x02 % 0x20 (0x02)
  /// @endcode
  ///
  /// @param a,b Operands
  /// @param mod Divisor; must be a power of 2
  /// @return
  /// - a negative value if `a % mod < b % mod`
  /// - a positive value if `a % mod > b % mod`
  /// - zero             if `a % mod == b % mod`
  int av_compare_mod(
    int a,
    int b,
    int mod,
  ) {
    _av_compare_mod ??=
        _dylib.lookupFunction<_c_av_compare_mod, _dart_av_compare_mod>(
            'av_compare_mod');
    return _av_compare_mod(
      a,
      b,
      mod,
    );
  }

  _dart_av_compare_mod _av_compare_mod;

  /// Send the specified message to the log if the level is less than or equal
  /// to the current av_log_level. By default, all logging messages are sent to
  /// stderr. This behavior can be altered by setting a different logging callback
  /// function.
  /// @see av_log_set_callback
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct or NULL if general log.
  /// @param level The importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant".
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  void av_log(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    _av_log ??= _dylib.lookupFunction<_c_av_log, _dart_av_log>('av_log');
    return _av_log(
      avcl,
      level,
      fmt,
    );
  }

  _dart_av_log _av_log;

  /// Send the specified message to the log once with the initial_level and then with
  /// the subsequent_level. By default, all logging messages are sent to
  /// stderr. This behavior can be altered by setting a different logging callback
  /// function.
  /// @see av_log
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct or NULL if general log.
  /// @param initial_level importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant" for the first occurance.
  /// @param subsequent_level importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant" after the first occurance.
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  /// @param state a variable to keep trak of if a message has already been printed
  /// this must be initialized to 0 before the first use. The same state
  /// must not be accessed by 2 Threads simultaneously.
  void av_log_once(
    ffi.Pointer<ffi.Void> avcl,
    int initial_level,
    int subsequent_level,
    ffi.Pointer<ffi.Int32> state,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    _av_log_once ??=
        _dylib.lookupFunction<_c_av_log_once, _dart_av_log_once>('av_log_once');
    return _av_log_once(
      avcl,
      initial_level,
      subsequent_level,
      state,
      fmt,
    );
  }

  _dart_av_log_once _av_log_once;

  /// Send the specified message to the log if the level is less than or equal
  /// to the current av_log_level. By default, all logging messages are sent to
  /// stderr. This behavior can be altered by setting a different logging callback
  /// function.
  /// @see av_log_set_callback
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant".
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  /// @param vl The arguments referenced by the format string.
  void av_vlog(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<__va_list_tag> vl,
  ) {
    _av_vlog ??= _dylib.lookupFunction<_c_av_vlog, _dart_av_vlog>('av_vlog');
    return _av_vlog(
      avcl,
      level,
      fmt,
      vl,
    );
  }

  _dart_av_vlog _av_vlog;

  /// Get the current log level
  ///
  /// @see lavu_log_constants
  ///
  /// @return Current log level
  int av_log_get_level() {
    _av_log_get_level ??=
        _dylib.lookupFunction<_c_av_log_get_level, _dart_av_log_get_level>(
            'av_log_get_level');
    return _av_log_get_level();
  }

  _dart_av_log_get_level _av_log_get_level;

  /// Set the log level
  ///
  /// @see lavu_log_constants
  ///
  /// @param level Logging level
  void av_log_set_level(
    int level,
  ) {
    _av_log_set_level ??=
        _dylib.lookupFunction<_c_av_log_set_level, _dart_av_log_set_level>(
            'av_log_set_level');
    return _av_log_set_level(
      level,
    );
  }

  _dart_av_log_set_level _av_log_set_level;

  /// Set the logging callback
  ///
  /// @note The callback must be thread safe, even if the application does not use
  /// threads itself as some codecs are multithreaded.
  ///
  /// @see av_log_default_callback
  ///
  /// @param callback A logging function with a compatible signature.
  void av_log_set_callback(
    ffi.Pointer<ffi.NativeFunction<_typedefC_7>> callback,
  ) {
    _av_log_set_callback ??= _dylib.lookupFunction<_c_av_log_set_callback,
        _dart_av_log_set_callback>('av_log_set_callback');
    return _av_log_set_callback(
      callback,
    );
  }

  _dart_av_log_set_callback _av_log_set_callback;

  /// Default logging callback
  ///
  /// It prints the message to stderr, optionally colorizing it.
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message expressed using a @ref
  /// lavu_log_constants "Logging Constant".
  /// @param fmt The format string (printf-compatible) that specifies how
  /// subsequent arguments are converted to output.
  /// @param vl The arguments referenced by the format string.
  void av_log_default_callback(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<__va_list_tag> vl,
  ) {
    _av_log_default_callback ??= _dylib.lookupFunction<
        _c_av_log_default_callback,
        _dart_av_log_default_callback>('av_log_default_callback');
    return _av_log_default_callback(
      avcl,
      level,
      fmt,
      vl,
    );
  }

  _dart_av_log_default_callback _av_log_default_callback;

  /// Return the context name
  ///
  /// @param  ctx The AVClass context
  ///
  /// @return The AVClass class_name
  ffi.Pointer<ffi.Int8> av_default_item_name(
    ffi.Pointer<ffi.Void> ctx,
  ) {
    _av_default_item_name ??= _dylib.lookupFunction<_c_av_default_item_name,
        _dart_av_default_item_name>('av_default_item_name');
    return _av_default_item_name(
      ctx,
    );
  }

  _dart_av_default_item_name _av_default_item_name;

  int av_default_get_category(
    ffi.Pointer<ffi.Void> ptr,
  ) {
    _av_default_get_category ??= _dylib.lookupFunction<
        _c_av_default_get_category,
        _dart_av_default_get_category>('av_default_get_category');
    return _av_default_get_category(
      ptr,
    );
  }

  _dart_av_default_get_category _av_default_get_category;

  /// Format a line of log the same way as the default callback.
  /// @param line          buffer to receive the formatted line
  /// @param line_size     size of the buffer
  /// @param print_prefix  used to store whether the prefix must be printed;
  /// must point to a persistent integer initially set to 1
  void av_log_format_line(
    ffi.Pointer<ffi.Void> ptr,
    int level,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<__va_list_tag> vl,
    ffi.Pointer<ffi.Int8> line,
    int line_size,
    ffi.Pointer<ffi.Int32> print_prefix,
  ) {
    _av_log_format_line ??=
        _dylib.lookupFunction<_c_av_log_format_line, _dart_av_log_format_line>(
            'av_log_format_line');
    return _av_log_format_line(
      ptr,
      level,
      fmt,
      vl,
      line,
      line_size,
      print_prefix,
    );
  }

  _dart_av_log_format_line _av_log_format_line;

  /// Format a line of log the same way as the default callback.
  /// @param line          buffer to receive the formatted line;
  /// may be NULL if line_size is 0
  /// @param line_size     size of the buffer; at most line_size-1 characters will
  /// be written to the buffer, plus one null terminator
  /// @param print_prefix  used to store whether the prefix must be printed;
  /// must point to a persistent integer initially set to 1
  /// @return Returns a negative value if an error occurred, otherwise returns
  /// the number of characters that would have been written for a
  /// sufficiently large buffer, not including the terminating null
  /// character. If the return value is not less than line_size, it means
  /// that the log message was truncated to fit the buffer.
  int av_log_format_line2(
    ffi.Pointer<ffi.Void> ptr,
    int level,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<__va_list_tag> vl,
    ffi.Pointer<ffi.Int8> line,
    int line_size,
    ffi.Pointer<ffi.Int32> print_prefix,
  ) {
    _av_log_format_line2 ??= _dylib.lookupFunction<_c_av_log_format_line2,
        _dart_av_log_format_line2>('av_log_format_line2');
    return _av_log_format_line2(
      ptr,
      level,
      fmt,
      vl,
      line,
      line_size,
      print_prefix,
    );
  }

  _dart_av_log_format_line2 _av_log_format_line2;

  void av_log_set_flags(
    int arg,
  ) {
    _av_log_set_flags ??=
        _dylib.lookupFunction<_c_av_log_set_flags, _dart_av_log_set_flags>(
            'av_log_set_flags');
    return _av_log_set_flags(
      arg,
    );
  }

  _dart_av_log_set_flags _av_log_set_flags;

  int av_log_get_flags() {
    _av_log_get_flags ??=
        _dylib.lookupFunction<_c_av_log_get_flags, _dart_av_log_get_flags>(
            'av_log_get_flags');
    return _av_log_get_flags();
  }

  _dart_av_log_get_flags _av_log_get_flags;

  /// Return x default pointer in case p is NULL.
  ffi.Pointer<ffi.Void> av_x_if_null(
    ffi.Pointer<ffi.Void> p,
    ffi.Pointer<ffi.Void> x,
  ) {
    _av_x_if_null ??= _dylib
        .lookupFunction<_c_av_x_if_null, _dart_av_x_if_null>('av_x_if_null');
    return _av_x_if_null(
      p,
      x,
    );
  }

  _dart_av_x_if_null _av_x_if_null;

  /// Compute the length of an integer list.
  ///
  /// @param elsize  size in bytes of each list element (only 1, 2, 4 or 8)
  /// @param term    list terminator (usually 0 or -1)
  /// @param list    pointer to the list
  /// @return  length of the list, in elements, not counting the terminator
  int av_int_list_length_for_size(
    int elsize,
    ffi.Pointer<ffi.Void> list,
    int term,
  ) {
    _av_int_list_length_for_size ??= _dylib.lookupFunction<
        _c_av_int_list_length_for_size,
        _dart_av_int_list_length_for_size>('av_int_list_length_for_size');
    return _av_int_list_length_for_size(
      elsize,
      list,
      term,
    );
  }

  _dart_av_int_list_length_for_size _av_int_list_length_for_size;

  /// Open a file using a UTF-8 filename.
  /// The API of this function matches POSIX fopen(), errors are returned through
  /// errno.
  ffi.Pointer<_IO_FILE> av_fopen_utf8(
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> mode,
  ) {
    _av_fopen_utf8 ??= _dylib
        .lookupFunction<_c_av_fopen_utf8, _dart_av_fopen_utf8>('av_fopen_utf8');
    return _av_fopen_utf8(
      path,
      mode,
    );
  }

  _dart_av_fopen_utf8 _av_fopen_utf8;

  /// Fill the provided buffer with a string containing a FourCC (four-character
  /// code) representation.
  ///
  /// @param buf    a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE
  /// @param fourcc the fourcc to represent
  /// @return the buffer in input
  ffi.Pointer<ffi.Int8> av_fourcc_make_string(
    ffi.Pointer<ffi.Int8> buf,
    int fourcc,
  ) {
    _av_fourcc_make_string ??= _dylib.lookupFunction<_c_av_fourcc_make_string,
        _dart_av_fourcc_make_string>('av_fourcc_make_string');
    return _av_fourcc_make_string(
      buf,
      fourcc,
    );
  }

  _dart_av_fourcc_make_string _av_fourcc_make_string;

  /// Return the name of sample_fmt, or NULL if sample_fmt is not
  /// recognized.
  ffi.Pointer<ffi.Int8> av_get_sample_fmt_name(
    int sample_fmt,
  ) {
    _av_get_sample_fmt_name ??= _dylib.lookupFunction<_c_av_get_sample_fmt_name,
        _dart_av_get_sample_fmt_name>('av_get_sample_fmt_name');
    return _av_get_sample_fmt_name(
      sample_fmt,
    );
  }

  _dart_av_get_sample_fmt_name _av_get_sample_fmt_name;

  /// Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE
  /// on error.
  int av_get_sample_fmt(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_get_sample_fmt ??=
        _dylib.lookupFunction<_c_av_get_sample_fmt, _dart_av_get_sample_fmt>(
            'av_get_sample_fmt');
    return _av_get_sample_fmt(
      name,
    );
  }

  _dart_av_get_sample_fmt _av_get_sample_fmt;

  /// Return the planar<->packed alternative form of the given sample format, or
  /// AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the
  /// requested planar/packed format, the format returned is the same as the
  /// input.
  int av_get_alt_sample_fmt(
    int sample_fmt,
    int planar,
  ) {
    _av_get_alt_sample_fmt ??= _dylib.lookupFunction<_c_av_get_alt_sample_fmt,
        _dart_av_get_alt_sample_fmt>('av_get_alt_sample_fmt');
    return _av_get_alt_sample_fmt(
      sample_fmt,
      planar,
    );
  }

  _dart_av_get_alt_sample_fmt _av_get_alt_sample_fmt;

  /// Get the packed alternative form of the given sample format.
  ///
  /// If the passed sample_fmt is already in packed format, the format returned is
  /// the same as the input.
  ///
  /// @return  the packed alternative form of the given sample format or
  /// AV_SAMPLE_FMT_NONE on error.
  int av_get_packed_sample_fmt(
    int sample_fmt,
  ) {
    _av_get_packed_sample_fmt ??= _dylib.lookupFunction<
        _c_av_get_packed_sample_fmt,
        _dart_av_get_packed_sample_fmt>('av_get_packed_sample_fmt');
    return _av_get_packed_sample_fmt(
      sample_fmt,
    );
  }

  _dart_av_get_packed_sample_fmt _av_get_packed_sample_fmt;

  /// Get the planar alternative form of the given sample format.
  ///
  /// If the passed sample_fmt is already in planar format, the format returned is
  /// the same as the input.
  ///
  /// @return  the planar alternative form of the given sample format or
  /// AV_SAMPLE_FMT_NONE on error.
  int av_get_planar_sample_fmt(
    int sample_fmt,
  ) {
    _av_get_planar_sample_fmt ??= _dylib.lookupFunction<
        _c_av_get_planar_sample_fmt,
        _dart_av_get_planar_sample_fmt>('av_get_planar_sample_fmt');
    return _av_get_planar_sample_fmt(
      sample_fmt,
    );
  }

  _dart_av_get_planar_sample_fmt _av_get_planar_sample_fmt;

  /// Generate a string corresponding to the sample format with
  /// sample_fmt, or a header if sample_fmt is negative.
  ///
  /// @param buf the buffer where to write the string
  /// @param buf_size the size of buf
  /// @param sample_fmt the number of the sample format to print the
  /// corresponding info string, or a negative value to print the
  /// corresponding header.
  /// @return the pointer to the filled buffer or NULL if sample_fmt is
  /// unknown or in case of other errors
  ffi.Pointer<ffi.Int8> av_get_sample_fmt_string(
    ffi.Pointer<ffi.Int8> buf,
    int buf_size,
    int sample_fmt,
  ) {
    _av_get_sample_fmt_string ??= _dylib.lookupFunction<
        _c_av_get_sample_fmt_string,
        _dart_av_get_sample_fmt_string>('av_get_sample_fmt_string');
    return _av_get_sample_fmt_string(
      buf,
      buf_size,
      sample_fmt,
    );
  }

  _dart_av_get_sample_fmt_string _av_get_sample_fmt_string;

  /// Return number of bytes per sample.
  ///
  /// @param sample_fmt the sample format
  /// @return number of bytes per sample or zero if unknown for the given
  /// sample format
  int av_get_bytes_per_sample(
    int sample_fmt,
  ) {
    _av_get_bytes_per_sample ??= _dylib.lookupFunction<
        _c_av_get_bytes_per_sample,
        _dart_av_get_bytes_per_sample>('av_get_bytes_per_sample');
    return _av_get_bytes_per_sample(
      sample_fmt,
    );
  }

  _dart_av_get_bytes_per_sample _av_get_bytes_per_sample;

  /// Check if the sample format is planar.
  ///
  /// @param sample_fmt the sample format to inspect
  /// @return 1 if the sample format is planar, 0 if it is interleaved
  int av_sample_fmt_is_planar(
    int sample_fmt,
  ) {
    _av_sample_fmt_is_planar ??= _dylib.lookupFunction<
        _c_av_sample_fmt_is_planar,
        _dart_av_sample_fmt_is_planar>('av_sample_fmt_is_planar');
    return _av_sample_fmt_is_planar(
      sample_fmt,
    );
  }

  _dart_av_sample_fmt_is_planar _av_sample_fmt_is_planar;

  /// Get the required buffer size for the given audio parameters.
  ///
  /// @param[out] linesize calculated linesize, may be NULL
  /// @param nb_channels   the number of channels
  /// @param nb_samples    the number of samples in a single channel
  /// @param sample_fmt    the sample format
  /// @param align         buffer size alignment (0 = default, 1 = no alignment)
  /// @return              required buffer size, or negative error code on failure
  int av_samples_get_buffer_size(
    ffi.Pointer<ffi.Int32> linesize,
    int nb_channels,
    int nb_samples,
    int sample_fmt,
    int align,
  ) {
    _av_samples_get_buffer_size ??= _dylib.lookupFunction<
        _c_av_samples_get_buffer_size,
        _dart_av_samples_get_buffer_size>('av_samples_get_buffer_size');
    return _av_samples_get_buffer_size(
      linesize,
      nb_channels,
      nb_samples,
      sample_fmt,
      align,
    );
  }

  _dart_av_samples_get_buffer_size _av_samples_get_buffer_size;

  /// Fill plane data pointers and linesize for samples with sample
  /// format sample_fmt.
  ///
  /// The audio_data array is filled with the pointers to the samples data planes:
  /// for planar, set the start point of each channel's data within the buffer,
  /// for packed, set the start point of the entire buffer only.
  ///
  /// The value pointed to by linesize is set to the aligned size of each
  /// channel's data buffer for planar layout, or to the aligned size of the
  /// buffer for all channels for packed layout.
  ///
  /// The buffer in buf must be big enough to contain all the samples
  /// (use av_samples_get_buffer_size() to compute its minimum size),
  /// otherwise the audio_data pointers will point to invalid data.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param[out] audio_data  array to be filled with the pointer for each channel
  /// @param[out] linesize    calculated linesize, may be NULL
  /// @param buf              the pointer to a buffer containing the samples
  /// @param nb_channels      the number of channels
  /// @param nb_samples       the number of samples in a single channel
  /// @param sample_fmt       the sample format
  /// @param align            buffer size alignment (0 = default, 1 = no alignment)
  /// @return                 >=0 on success or a negative error code on failure
  /// @todo return minimum size in bytes required for the buffer in case
  /// of success at the next bump
  int av_samples_fill_arrays(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
    ffi.Pointer<ffi.Int32> linesize,
    ffi.Pointer<ffi.Uint8> buf,
    int nb_channels,
    int nb_samples,
    int sample_fmt,
    int align,
  ) {
    _av_samples_fill_arrays ??= _dylib.lookupFunction<_c_av_samples_fill_arrays,
        _dart_av_samples_fill_arrays>('av_samples_fill_arrays');
    return _av_samples_fill_arrays(
      audio_data,
      linesize,
      buf,
      nb_channels,
      nb_samples,
      sample_fmt,
      align,
    );
  }

  _dart_av_samples_fill_arrays _av_samples_fill_arrays;

  /// Allocate a samples buffer for nb_samples samples, and fill data pointers and
  /// linesize accordingly.
  /// The allocated samples buffer can be freed by using av_freep(&audio_data[0])
  /// Allocated data will be initialized to silence.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param[out] audio_data  array to be filled with the pointer for each channel
  /// @param[out] linesize    aligned size for audio buffer(s), may be NULL
  /// @param nb_channels      number of audio channels
  /// @param nb_samples       number of samples per channel
  /// @param align            buffer size alignment (0 = default, 1 = no alignment)
  /// @return                 >=0 on success or a negative error code on failure
  /// @todo return the size of the allocated buffer in case of success at the next bump
  /// @see av_samples_fill_arrays()
  /// @see av_samples_alloc_array_and_samples()
  int av_samples_alloc(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
    ffi.Pointer<ffi.Int32> linesize,
    int nb_channels,
    int nb_samples,
    int sample_fmt,
    int align,
  ) {
    _av_samples_alloc ??=
        _dylib.lookupFunction<_c_av_samples_alloc, _dart_av_samples_alloc>(
            'av_samples_alloc');
    return _av_samples_alloc(
      audio_data,
      linesize,
      nb_channels,
      nb_samples,
      sample_fmt,
      align,
    );
  }

  _dart_av_samples_alloc _av_samples_alloc;

  /// Allocate a data pointers array, samples buffer for nb_samples
  /// samples, and fill data pointers and linesize accordingly.
  ///
  /// This is the same as av_samples_alloc(), but also allocates the data
  /// pointers array.
  ///
  /// @see av_samples_alloc()
  int av_samples_alloc_array_and_samples(
    ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>> audio_data,
    ffi.Pointer<ffi.Int32> linesize,
    int nb_channels,
    int nb_samples,
    int sample_fmt,
    int align,
  ) {
    _av_samples_alloc_array_and_samples ??= _dylib.lookupFunction<
            _c_av_samples_alloc_array_and_samples,
            _dart_av_samples_alloc_array_and_samples>(
        'av_samples_alloc_array_and_samples');
    return _av_samples_alloc_array_and_samples(
      audio_data,
      linesize,
      nb_channels,
      nb_samples,
      sample_fmt,
      align,
    );
  }

  _dart_av_samples_alloc_array_and_samples _av_samples_alloc_array_and_samples;

  /// Copy samples from src to dst.
  ///
  /// @param dst destination array of pointers to data planes
  /// @param src source array of pointers to data planes
  /// @param dst_offset offset in samples at which the data will be written to dst
  /// @param src_offset offset in samples at which the data will be read from src
  /// @param nb_samples number of samples to be copied
  /// @param nb_channels number of audio channels
  /// @param sample_fmt audio sample format
  int av_samples_copy(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src,
    int dst_offset,
    int src_offset,
    int nb_samples,
    int nb_channels,
    int sample_fmt,
  ) {
    _av_samples_copy ??=
        _dylib.lookupFunction<_c_av_samples_copy, _dart_av_samples_copy>(
            'av_samples_copy');
    return _av_samples_copy(
      dst,
      src,
      dst_offset,
      src_offset,
      nb_samples,
      nb_channels,
      sample_fmt,
    );
  }

  _dart_av_samples_copy _av_samples_copy;

  /// Fill an audio buffer with silence.
  ///
  /// @param audio_data  array of pointers to data planes
  /// @param offset      offset in samples at which to start filling
  /// @param nb_samples  number of samples to fill
  /// @param nb_channels number of audio channels
  /// @param sample_fmt  audio sample format
  int av_samples_set_silence(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
    int offset,
    int nb_samples,
    int nb_channels,
    int sample_fmt,
  ) {
    _av_samples_set_silence ??= _dylib.lookupFunction<_c_av_samples_set_silence,
        _dart_av_samples_set_silence>('av_samples_set_silence');
    return _av_samples_set_silence(
      audio_data,
      offset,
      nb_samples,
      nb_channels,
      sample_fmt,
    );
  }

  _dart_av_samples_set_silence _av_samples_set_silence;

  /// Allocate an AVBuffer of the given size using av_malloc().
  ///
  /// @return an AVBufferRef of given size or NULL when out of memory
  ffi.Pointer<AVBufferRef> av_buffer_alloc(
    int size,
  ) {
    _av_buffer_alloc ??=
        _dylib.lookupFunction<_c_av_buffer_alloc, _dart_av_buffer_alloc>(
            'av_buffer_alloc');
    return _av_buffer_alloc(
      size,
    );
  }

  _dart_av_buffer_alloc _av_buffer_alloc;

  /// Same as av_buffer_alloc(), except the returned buffer will be initialized
  /// to zero.
  ffi.Pointer<AVBufferRef> av_buffer_allocz(
    int size,
  ) {
    _av_buffer_allocz ??=
        _dylib.lookupFunction<_c_av_buffer_allocz, _dart_av_buffer_allocz>(
            'av_buffer_allocz');
    return _av_buffer_allocz(
      size,
    );
  }

  _dart_av_buffer_allocz _av_buffer_allocz;

  /// Create an AVBuffer from an existing array.
  ///
  /// If this function is successful, data is owned by the AVBuffer. The caller may
  /// only access data through the returned AVBufferRef and references derived from
  /// it.
  /// If this function fails, data is left untouched.
  /// @param data   data array
  /// @param size   size of data in bytes
  /// @param free   a callback for freeing this buffer's data
  /// @param opaque parameter to be got for processing or passed to free
  /// @param flags  a combination of AV_BUFFER_FLAG_*
  ///
  /// @return an AVBufferRef referring to data on success, NULL on failure.
  ffi.Pointer<AVBufferRef> av_buffer_create(
    ffi.Pointer<ffi.Uint8> data,
    int size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_8>> free,
    ffi.Pointer<ffi.Void> opaque,
    int flags,
  ) {
    _av_buffer_create ??=
        _dylib.lookupFunction<_c_av_buffer_create, _dart_av_buffer_create>(
            'av_buffer_create');
    return _av_buffer_create(
      data,
      size,
      free,
      opaque,
      flags,
    );
  }

  _dart_av_buffer_create _av_buffer_create;

  /// Default free callback, which calls av_free() on the buffer data.
  /// This function is meant to be passed to av_buffer_create(), not called
  /// directly.
  void av_buffer_default_free(
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.Uint8> data,
  ) {
    _av_buffer_default_free ??= _dylib.lookupFunction<_c_av_buffer_default_free,
        _dart_av_buffer_default_free>('av_buffer_default_free');
    return _av_buffer_default_free(
      opaque,
      data,
    );
  }

  _dart_av_buffer_default_free _av_buffer_default_free;

  /// Create a new reference to an AVBuffer.
  ///
  /// @return a new AVBufferRef referring to the same AVBuffer as buf or NULL on
  /// failure.
  ffi.Pointer<AVBufferRef> av_buffer_ref(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    _av_buffer_ref ??= _dylib
        .lookupFunction<_c_av_buffer_ref, _dart_av_buffer_ref>('av_buffer_ref');
    return _av_buffer_ref(
      buf,
    );
  }

  _dart_av_buffer_ref _av_buffer_ref;

  /// Free a given reference and automatically free the buffer if there are no more
  /// references to it.
  ///
  /// @param buf the reference to be freed. The pointer is set to NULL on return.
  void av_buffer_unref(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
  ) {
    _av_buffer_unref ??=
        _dylib.lookupFunction<_c_av_buffer_unref, _dart_av_buffer_unref>(
            'av_buffer_unref');
    return _av_buffer_unref(
      buf,
    );
  }

  _dart_av_buffer_unref _av_buffer_unref;

  /// @return 1 if the caller may write to the data referred to by buf (which is
  /// true if and only if buf is the only reference to the underlying AVBuffer).
  /// Return 0 otherwise.
  /// A positive answer is valid until av_buffer_ref() is called on buf.
  int av_buffer_is_writable(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    _av_buffer_is_writable ??= _dylib.lookupFunction<_c_av_buffer_is_writable,
        _dart_av_buffer_is_writable>('av_buffer_is_writable');
    return _av_buffer_is_writable(
      buf,
    );
  }

  _dart_av_buffer_is_writable _av_buffer_is_writable;

  /// @return the opaque parameter set by av_buffer_create.
  ffi.Pointer<ffi.Void> av_buffer_get_opaque(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    _av_buffer_get_opaque ??= _dylib.lookupFunction<_c_av_buffer_get_opaque,
        _dart_av_buffer_get_opaque>('av_buffer_get_opaque');
    return _av_buffer_get_opaque(
      buf,
    );
  }

  _dart_av_buffer_get_opaque _av_buffer_get_opaque;

  int av_buffer_get_ref_count(
    ffi.Pointer<AVBufferRef> buf,
  ) {
    _av_buffer_get_ref_count ??= _dylib.lookupFunction<
        _c_av_buffer_get_ref_count,
        _dart_av_buffer_get_ref_count>('av_buffer_get_ref_count');
    return _av_buffer_get_ref_count(
      buf,
    );
  }

  _dart_av_buffer_get_ref_count _av_buffer_get_ref_count;

  /// Create a writable reference from a given buffer reference, avoiding data copy
  /// if possible.
  ///
  /// @param buf buffer reference to make writable. On success, buf is either left
  /// untouched, or it is unreferenced and a new writable AVBufferRef is
  /// written in its place. On failure, buf is left untouched.
  /// @return 0 on success, a negative AVERROR on failure.
  int av_buffer_make_writable(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
  ) {
    _av_buffer_make_writable ??= _dylib.lookupFunction<
        _c_av_buffer_make_writable,
        _dart_av_buffer_make_writable>('av_buffer_make_writable');
    return _av_buffer_make_writable(
      buf,
    );
  }

  _dart_av_buffer_make_writable _av_buffer_make_writable;

  /// Reallocate a given buffer.
  ///
  /// @param buf  a buffer reference to reallocate. On success, buf will be
  /// unreferenced and a new reference with the required size will be
  /// written in its place. On failure buf will be left untouched. *buf
  /// may be NULL, then a new buffer is allocated.
  /// @param size required new buffer size.
  /// @return 0 on success, a negative AVERROR on failure.
  ///
  /// @note the buffer is actually reallocated with av_realloc() only if it was
  /// initially allocated through av_buffer_realloc(NULL) and there is only one
  /// reference to it (i.e. the one passed to this function). In all other cases
  /// a new buffer is allocated and the data is copied.
  int av_buffer_realloc(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
    int size,
  ) {
    _av_buffer_realloc ??=
        _dylib.lookupFunction<_c_av_buffer_realloc, _dart_av_buffer_realloc>(
            'av_buffer_realloc');
    return _av_buffer_realloc(
      buf,
      size,
    );
  }

  _dart_av_buffer_realloc _av_buffer_realloc;

  /// Ensure dst refers to the same data as src.
  ///
  /// When *dst is already equivalent to src, do nothing. Otherwise unreference dst
  /// and replace it with a new reference to src.
  ///
  /// @param dst Pointer to either a valid buffer reference or NULL. On success,
  /// this will point to a buffer reference equivalent to src. On
  /// failure, dst will be left untouched.
  /// @param src A buffer reference to replace dst with. May be NULL, then this
  /// function is equivalent to av_buffer_unref(dst).
  /// @return 0 on success
  /// AVERROR(ENOMEM) on memory allocation failure.
  int av_buffer_replace(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> dst,
    ffi.Pointer<AVBufferRef> src,
  ) {
    _av_buffer_replace ??=
        _dylib.lookupFunction<_c_av_buffer_replace, _dart_av_buffer_replace>(
            'av_buffer_replace');
    return _av_buffer_replace(
      dst,
      src,
    );
  }

  _dart_av_buffer_replace _av_buffer_replace;

  /// Allocate and initialize a buffer pool.
  ///
  /// @param size size of each buffer in this pool
  /// @param alloc a function that will be used to allocate new buffers when the
  /// pool is empty. May be NULL, then the default allocator will be used
  /// (av_buffer_alloc()).
  /// @return newly created buffer pool on success, NULL on error.
  ffi.Pointer<AVBufferPool> av_buffer_pool_init(
    int size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_9>> alloc,
  ) {
    _av_buffer_pool_init ??= _dylib.lookupFunction<_c_av_buffer_pool_init,
        _dart_av_buffer_pool_init>('av_buffer_pool_init');
    return _av_buffer_pool_init(
      size,
      alloc,
    );
  }

  _dart_av_buffer_pool_init _av_buffer_pool_init;

  /// Allocate and initialize a buffer pool with a more complex allocator.
  ///
  /// @param size size of each buffer in this pool
  /// @param opaque arbitrary user data used by the allocator
  /// @param alloc a function that will be used to allocate new buffers when the
  /// pool is empty. May be NULL, then the default allocator will be
  /// used (av_buffer_alloc()).
  /// @param pool_free a function that will be called immediately before the pool
  /// is freed. I.e. after av_buffer_pool_uninit() is called
  /// by the caller and all the frames are returned to the pool
  /// and freed. It is intended to uninitialize the user opaque
  /// data. May be NULL.
  /// @return newly created buffer pool on success, NULL on error.
  ffi.Pointer<AVBufferPool> av_buffer_pool_init2(
    int size,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.NativeFunction<_typedefC_10>> alloc,
    ffi.Pointer<ffi.NativeFunction<_typedefC_11>> pool_free,
  ) {
    _av_buffer_pool_init2 ??= _dylib.lookupFunction<_c_av_buffer_pool_init2,
        _dart_av_buffer_pool_init2>('av_buffer_pool_init2');
    return _av_buffer_pool_init2(
      size,
      opaque,
      alloc,
      pool_free,
    );
  }

  _dart_av_buffer_pool_init2 _av_buffer_pool_init2;

  /// Mark the pool as being available for freeing. It will actually be freed only
  /// once all the allocated buffers associated with the pool are released. Thus it
  /// is safe to call this function while some of the allocated buffers are still
  /// in use.
  ///
  /// @param pool pointer to the pool to be freed. It will be set to NULL.
  void av_buffer_pool_uninit(
    ffi.Pointer<ffi.Pointer<AVBufferPool>> pool,
  ) {
    _av_buffer_pool_uninit ??= _dylib.lookupFunction<_c_av_buffer_pool_uninit,
        _dart_av_buffer_pool_uninit>('av_buffer_pool_uninit');
    return _av_buffer_pool_uninit(
      pool,
    );
  }

  _dart_av_buffer_pool_uninit _av_buffer_pool_uninit;

  /// Allocate a new AVBuffer, reusing an old buffer from the pool when available.
  /// This function may be called simultaneously from multiple threads.
  ///
  /// @return a reference to the new buffer on success, NULL on error.
  ffi.Pointer<AVBufferRef> av_buffer_pool_get(
    ffi.Pointer<AVBufferPool> pool,
  ) {
    _av_buffer_pool_get ??=
        _dylib.lookupFunction<_c_av_buffer_pool_get, _dart_av_buffer_pool_get>(
            'av_buffer_pool_get');
    return _av_buffer_pool_get(
      pool,
    );
  }

  _dart_av_buffer_pool_get _av_buffer_pool_get;

  /// Query the original opaque parameter of an allocated buffer in the pool.
  ///
  /// @param ref a buffer reference to a buffer returned by av_buffer_pool_get.
  /// @return the opaque parameter set by the buffer allocator function of the
  /// buffer pool.
  ///
  /// @note the opaque parameter of ref is used by the buffer pool implementation,
  /// therefore you have to use this function to access the original opaque
  /// parameter of an allocated buffer.
  ffi.Pointer<ffi.Void> av_buffer_pool_buffer_get_opaque(
    ffi.Pointer<AVBufferRef> ref,
  ) {
    _av_buffer_pool_buffer_get_opaque ??= _dylib.lookupFunction<
            _c_av_buffer_pool_buffer_get_opaque,
            _dart_av_buffer_pool_buffer_get_opaque>(
        'av_buffer_pool_buffer_get_opaque');
    return _av_buffer_pool_buffer_get_opaque(
      ref,
    );
  }

  _dart_av_buffer_pool_buffer_get_opaque _av_buffer_pool_buffer_get_opaque;

  /// Return the flags which specify extensions supported by the CPU.
  /// The returned value is affected by av_force_cpu_flags() if that was used
  /// before. So av_get_cpu_flags() can easily be used in an application to
  /// detect the enabled cpu flags.
  int av_get_cpu_flags() {
    _av_get_cpu_flags ??=
        _dylib.lookupFunction<_c_av_get_cpu_flags, _dart_av_get_cpu_flags>(
            'av_get_cpu_flags');
    return _av_get_cpu_flags();
  }

  _dart_av_get_cpu_flags _av_get_cpu_flags;

  /// Disables cpu detection and forces the specified flags.
  /// -1 is a special case that disables forcing of specific flags.
  void av_force_cpu_flags(
    int flags,
  ) {
    _av_force_cpu_flags ??=
        _dylib.lookupFunction<_c_av_force_cpu_flags, _dart_av_force_cpu_flags>(
            'av_force_cpu_flags');
    return _av_force_cpu_flags(
      flags,
    );
  }

  _dart_av_force_cpu_flags _av_force_cpu_flags;

  /// Set a mask on flags returned by av_get_cpu_flags().
  /// This function is mainly useful for testing.
  /// Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible
  void av_set_cpu_flags_mask(
    int mask,
  ) {
    _av_set_cpu_flags_mask ??= _dylib.lookupFunction<_c_av_set_cpu_flags_mask,
        _dart_av_set_cpu_flags_mask>('av_set_cpu_flags_mask');
    return _av_set_cpu_flags_mask(
      mask,
    );
  }

  _dart_av_set_cpu_flags_mask _av_set_cpu_flags_mask;

  /// Parse CPU flags from a string.
  ///
  /// The returned flags contain the specified flags as well as related unspecified flags.
  ///
  /// This function exists only for compatibility with libav.
  /// Please use av_parse_cpu_caps() when possible.
  /// @return a combination of AV_CPU_* flags, negative on error.
  int av_parse_cpu_flags(
    ffi.Pointer<ffi.Int8> s,
  ) {
    _av_parse_cpu_flags ??=
        _dylib.lookupFunction<_c_av_parse_cpu_flags, _dart_av_parse_cpu_flags>(
            'av_parse_cpu_flags');
    return _av_parse_cpu_flags(
      s,
    );
  }

  _dart_av_parse_cpu_flags _av_parse_cpu_flags;

  /// Parse CPU caps from a string and update the given AV_CPU_* flags based on that.
  ///
  /// @return negative on error.
  int av_parse_cpu_caps(
    ffi.Pointer<ffi.Uint32> flags,
    ffi.Pointer<ffi.Int8> s,
  ) {
    _av_parse_cpu_caps ??=
        _dylib.lookupFunction<_c_av_parse_cpu_caps, _dart_av_parse_cpu_caps>(
            'av_parse_cpu_caps');
    return _av_parse_cpu_caps(
      flags,
      s,
    );
  }

  _dart_av_parse_cpu_caps _av_parse_cpu_caps;

  /// @return the number of logical CPU cores present.
  int av_cpu_count() {
    _av_cpu_count ??= _dylib
        .lookupFunction<_c_av_cpu_count, _dart_av_cpu_count>('av_cpu_count');
    return _av_cpu_count();
  }

  _dart_av_cpu_count _av_cpu_count;

  /// Get the maximum data alignment that may be required by FFmpeg.
  ///
  /// Note that this is affected by the build configuration and the CPU flags mask,
  /// so e.g. if the CPU supports AVX, but libavutil has been built with
  /// --disable-avx or the AV_CPU_FLAG_AVX flag has been disabled through
  /// av_set_cpu_flags_mask(), then this function will behave as if AVX is not
  /// present.
  int av_cpu_max_align() {
    _av_cpu_max_align ??=
        _dylib.lookupFunction<_c_av_cpu_max_align, _dart_av_cpu_max_align>(
            'av_cpu_max_align');
    return _av_cpu_max_align();
  }

  _dart_av_cpu_max_align _av_cpu_max_align;

  /// Return a channel layout id that matches name, or 0 if no match is found.
  ///
  /// name can be one or several of the following notations,
  /// separated by '+' or '|':
  /// - the name of an usual channel layout (mono, stereo, 4.0, quad, 5.0,
  /// 5.0(side), 5.1, 5.1(side), 7.1, 7.1(wide), downmix);
  /// - the name of a single channel (FL, FR, FC, LFE, BL, BR, FLC, FRC, BC,
  /// SL, SR, TC, TFL, TFC, TFR, TBL, TBC, TBR, DL, DR);
  /// - a number of channels, in decimal, followed by 'c', yielding
  /// the default channel layout for that number of channels (@see
  /// av_get_default_channel_layout);
  /// - a channel layout mask, in hexadecimal starting with "0x" (see the
  /// AV_CH_* macros).
  ///
  /// Example: "stereo+FC" = "2c+FC" = "2c+1c" = "0x7"
  int av_get_channel_layout(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_get_channel_layout ??= _dylib.lookupFunction<_c_av_get_channel_layout,
        _dart_av_get_channel_layout>('av_get_channel_layout');
    return _av_get_channel_layout(
      name,
    );
  }

  _dart_av_get_channel_layout _av_get_channel_layout;

  /// Return a channel layout and the number of channels based on the specified name.
  ///
  /// This function is similar to (@see av_get_channel_layout), but can also parse
  /// unknown channel layout specifications.
  ///
  /// @param[in]  name             channel layout specification string
  /// @param[out] channel_layout   parsed channel layout (0 if unknown)
  /// @param[out] nb_channels      number of channels
  ///
  /// @return 0 on success, AVERROR(EINVAL) if the parsing fails.
  int av_get_extended_channel_layout(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Uint64> channel_layout,
    ffi.Pointer<ffi.Int32> nb_channels,
  ) {
    _av_get_extended_channel_layout ??= _dylib.lookupFunction<
        _c_av_get_extended_channel_layout,
        _dart_av_get_extended_channel_layout>('av_get_extended_channel_layout');
    return _av_get_extended_channel_layout(
      name,
      channel_layout,
      nb_channels,
    );
  }

  _dart_av_get_extended_channel_layout _av_get_extended_channel_layout;

  /// Return a description of a channel layout.
  /// If nb_channels is <= 0, it is guessed from the channel_layout.
  ///
  /// @param buf put here the string containing the channel layout
  /// @param buf_size size in bytes of the buffer
  void av_get_channel_layout_string(
    ffi.Pointer<ffi.Int8> buf,
    int buf_size,
    int nb_channels,
    int channel_layout,
  ) {
    _av_get_channel_layout_string ??= _dylib.lookupFunction<
        _c_av_get_channel_layout_string,
        _dart_av_get_channel_layout_string>('av_get_channel_layout_string');
    return _av_get_channel_layout_string(
      buf,
      buf_size,
      nb_channels,
      channel_layout,
    );
  }

  _dart_av_get_channel_layout_string _av_get_channel_layout_string;

  /// Append a description of a channel layout to a bprint buffer.
  void av_bprint_channel_layout(
    ffi.Pointer<AVBPrint> bp,
    int nb_channels,
    int channel_layout,
  ) {
    _av_bprint_channel_layout ??= _dylib.lookupFunction<
        _c_av_bprint_channel_layout,
        _dart_av_bprint_channel_layout>('av_bprint_channel_layout');
    return _av_bprint_channel_layout(
      bp,
      nb_channels,
      channel_layout,
    );
  }

  _dart_av_bprint_channel_layout _av_bprint_channel_layout;

  /// Return the number of channels in the channel layout.
  int av_get_channel_layout_nb_channels(
    int channel_layout,
  ) {
    _av_get_channel_layout_nb_channels ??= _dylib.lookupFunction<
            _c_av_get_channel_layout_nb_channels,
            _dart_av_get_channel_layout_nb_channels>(
        'av_get_channel_layout_nb_channels');
    return _av_get_channel_layout_nb_channels(
      channel_layout,
    );
  }

  _dart_av_get_channel_layout_nb_channels _av_get_channel_layout_nb_channels;

  /// Return default channel layout for a given number of channels.
  int av_get_default_channel_layout(
    int nb_channels,
  ) {
    _av_get_default_channel_layout ??= _dylib.lookupFunction<
        _c_av_get_default_channel_layout,
        _dart_av_get_default_channel_layout>('av_get_default_channel_layout');
    return _av_get_default_channel_layout(
      nb_channels,
    );
  }

  _dart_av_get_default_channel_layout _av_get_default_channel_layout;

  /// Get the index of a channel in channel_layout.
  ///
  /// @param channel a channel layout describing exactly one channel which must be
  /// present in channel_layout.
  ///
  /// @return index of channel in channel_layout on success, a negative AVERROR
  /// on error.
  int av_get_channel_layout_channel_index(
    int channel_layout,
    int channel,
  ) {
    _av_get_channel_layout_channel_index ??= _dylib.lookupFunction<
            _c_av_get_channel_layout_channel_index,
            _dart_av_get_channel_layout_channel_index>(
        'av_get_channel_layout_channel_index');
    return _av_get_channel_layout_channel_index(
      channel_layout,
      channel,
    );
  }

  _dart_av_get_channel_layout_channel_index
      _av_get_channel_layout_channel_index;

  /// Get the channel with the given index in channel_layout.
  int av_channel_layout_extract_channel(
    int channel_layout,
    int index,
  ) {
    _av_channel_layout_extract_channel ??= _dylib.lookupFunction<
            _c_av_channel_layout_extract_channel,
            _dart_av_channel_layout_extract_channel>(
        'av_channel_layout_extract_channel');
    return _av_channel_layout_extract_channel(
      channel_layout,
      index,
    );
  }

  _dart_av_channel_layout_extract_channel _av_channel_layout_extract_channel;

  /// Get the name of a given channel.
  ///
  /// @return channel name on success, NULL on error.
  ffi.Pointer<ffi.Int8> av_get_channel_name(
    int channel,
  ) {
    _av_get_channel_name ??= _dylib.lookupFunction<_c_av_get_channel_name,
        _dart_av_get_channel_name>('av_get_channel_name');
    return _av_get_channel_name(
      channel,
    );
  }

  _dart_av_get_channel_name _av_get_channel_name;

  /// Get the description of a given channel.
  ///
  /// @param channel  a channel layout with a single channel
  /// @return  channel description on success, NULL on error
  ffi.Pointer<ffi.Int8> av_get_channel_description(
    int channel,
  ) {
    _av_get_channel_description ??= _dylib.lookupFunction<
        _c_av_get_channel_description,
        _dart_av_get_channel_description>('av_get_channel_description');
    return _av_get_channel_description(
      channel,
    );
  }

  _dart_av_get_channel_description _av_get_channel_description;

  /// Get the value and name of a standard channel layout.
  ///
  /// @param[in]  index   index in an internal list, starting at 0
  /// @param[out] layout  channel layout mask
  /// @param[out] name    name of the layout
  /// @return  0  if the layout exists,
  /// <0 if index is beyond the limits
  int av_get_standard_channel_layout(
    int index,
    ffi.Pointer<ffi.Uint64> layout,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> name,
  ) {
    _av_get_standard_channel_layout ??= _dylib.lookupFunction<
        _c_av_get_standard_channel_layout,
        _dart_av_get_standard_channel_layout>('av_get_standard_channel_layout');
    return _av_get_standard_channel_layout(
      index,
      layout,
      name,
    );
  }

  _dart_av_get_standard_channel_layout _av_get_standard_channel_layout;

  /// Get a dictionary entry with matching key.
  ///
  /// The returned entry key or value must not be changed, or it will
  /// cause undefined behavior.
  ///
  /// To iterate through all the dictionary entries, you can set the matching key
  /// to the null string "" and set the AV_DICT_IGNORE_SUFFIX flag.
  ///
  /// @param prev Set to the previous matching element to find the next.
  /// If set to NULL the first matching element is returned.
  /// @param key matching key
  /// @param flags a collection of AV_DICT_* flags controlling how the entry is retrieved
  /// @return found entry or NULL in case no matching entry was found in the dictionary
  ffi.Pointer<AVDictionaryEntry> av_dict_get(
    ffi.Pointer<AVDictionary> m,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<AVDictionaryEntry> prev,
    int flags,
  ) {
    _av_dict_get ??=
        _dylib.lookupFunction<_c_av_dict_get, _dart_av_dict_get>('av_dict_get');
    return _av_dict_get(
      m,
      key,
      prev,
      flags,
    );
  }

  _dart_av_dict_get _av_dict_get;

  /// Get number of entries in dictionary.
  ///
  /// @param m dictionary
  /// @return  number of entries in dictionary
  int av_dict_count(
    ffi.Pointer<AVDictionary> m,
  ) {
    _av_dict_count ??= _dylib
        .lookupFunction<_c_av_dict_count, _dart_av_dict_count>('av_dict_count');
    return _av_dict_count(
      m,
    );
  }

  _dart_av_dict_count _av_dict_count;

  /// Set the given entry in *pm, overwriting an existing entry.
  ///
  /// Note: If AV_DICT_DONT_STRDUP_KEY or AV_DICT_DONT_STRDUP_VAL is set,
  /// these arguments will be freed on error.
  ///
  /// Warning: Adding a new entry to a dictionary invalidates all existing entries
  /// previously returned with av_dict_get.
  ///
  /// @param pm pointer to a pointer to a dictionary struct. If *pm is NULL
  /// a dictionary struct is allocated and put in *pm.
  /// @param key entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)
  /// @param value entry value to add to *pm (will be av_strduped or added as a new key depending on flags).
  /// Passing a NULL value will cause an existing entry to be deleted.
  /// @return >= 0 on success otherwise an error code <0
  int av_dict_set(
    ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
    ffi.Pointer<ffi.Int8> key,
    ffi.Pointer<ffi.Int8> value,
    int flags,
  ) {
    _av_dict_set ??=
        _dylib.lookupFunction<_c_av_dict_set, _dart_av_dict_set>('av_dict_set');
    return _av_dict_set(
      pm,
      key,
      value,
      flags,
    );
  }

  _dart_av_dict_set _av_dict_set;

  /// Convenience wrapper for av_dict_set that converts the value to a string
  /// and stores it.
  ///
  /// Note: If AV_DICT_DONT_STRDUP_KEY is set, key will be freed on error.
  int av_dict_set_int(
    ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
    ffi.Pointer<ffi.Int8> key,
    int value,
    int flags,
  ) {
    _av_dict_set_int ??=
        _dylib.lookupFunction<_c_av_dict_set_int, _dart_av_dict_set_int>(
            'av_dict_set_int');
    return _av_dict_set_int(
      pm,
      key,
      value,
      flags,
    );
  }

  _dart_av_dict_set_int _av_dict_set_int;

  /// Parse the key/value pairs list and add the parsed entries to a dictionary.
  ///
  /// In case of failure, all the successfully set entries are stored in
  /// *pm. You may need to manually free the created dictionary.
  ///
  /// @param key_val_sep  a 0-terminated list of characters used to separate
  /// key from value
  /// @param pairs_sep    a 0-terminated list of characters used to separate
  /// two pairs from each other
  /// @param flags        flags to use when adding to dictionary.
  /// AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL
  /// are ignored since the key/value tokens will always
  /// be duplicated.
  /// @return             0 on success, negative AVERROR code on failure
  int av_dict_parse_string(
    ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Int8> key_val_sep,
    ffi.Pointer<ffi.Int8> pairs_sep,
    int flags,
  ) {
    _av_dict_parse_string ??= _dylib.lookupFunction<_c_av_dict_parse_string,
        _dart_av_dict_parse_string>('av_dict_parse_string');
    return _av_dict_parse_string(
      pm,
      str,
      key_val_sep,
      pairs_sep,
      flags,
    );
  }

  _dart_av_dict_parse_string _av_dict_parse_string;

  /// Copy entries from one AVDictionary struct into another.
  /// @param dst pointer to a pointer to a AVDictionary struct. If *dst is NULL,
  /// this function will allocate a struct for you and put it in *dst
  /// @param src pointer to source AVDictionary struct
  /// @param flags flags to use when setting entries in *dst
  /// @note metadata is read using the AV_DICT_IGNORE_SUFFIX flag
  /// @return 0 on success, negative AVERROR code on failure. If dst was allocated
  /// by this function, callers should free the associated memory.
  int av_dict_copy(
    ffi.Pointer<ffi.Pointer<AVDictionary>> dst,
    ffi.Pointer<AVDictionary> src,
    int flags,
  ) {
    _av_dict_copy ??= _dylib
        .lookupFunction<_c_av_dict_copy, _dart_av_dict_copy>('av_dict_copy');
    return _av_dict_copy(
      dst,
      src,
      flags,
    );
  }

  _dart_av_dict_copy _av_dict_copy;

  /// Free all the memory allocated for an AVDictionary struct
  /// and all keys and values.
  void av_dict_free(
    ffi.Pointer<ffi.Pointer<AVDictionary>> m,
  ) {
    _av_dict_free ??= _dylib
        .lookupFunction<_c_av_dict_free, _dart_av_dict_free>('av_dict_free');
    return _av_dict_free(
      m,
    );
  }

  _dart_av_dict_free _av_dict_free;

  /// Get dictionary entries as a string.
  ///
  /// Create a string containing dictionary's entries.
  /// Such string may be passed back to av_dict_parse_string().
  /// @note String is escaped with backslashes ('\').
  ///
  /// @param[in]  m             dictionary
  /// @param[out] buffer        Pointer to buffer that will be allocated with string containg entries.
  /// Buffer must be freed by the caller when is no longer needed.
  /// @param[in]  key_val_sep   character used to separate key from value
  /// @param[in]  pairs_sep     character used to separate two pairs from each other
  /// @return                   >= 0 on success, negative on error
  /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
  int av_dict_get_string(
    ffi.Pointer<AVDictionary> m,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> buffer,
    int key_val_sep,
    int pairs_sep,
  ) {
    _av_dict_get_string ??=
        _dylib.lookupFunction<_c_av_dict_get_string, _dart_av_dict_get_string>(
            'av_dict_get_string');
    return _av_dict_get_string(
      m,
      buffer,
      key_val_sep,
      pairs_sep,
    );
  }

  _dart_av_dict_get_string _av_dict_get_string;

  /// Accessors for some AVFrame fields. These used to be provided for ABI
  /// compatibility, and do not need to be used anymore.
  int av_frame_get_best_effort_timestamp(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_best_effort_timestamp ??= _dylib.lookupFunction<
            _c_av_frame_get_best_effort_timestamp,
            _dart_av_frame_get_best_effort_timestamp>(
        'av_frame_get_best_effort_timestamp');
    return _av_frame_get_best_effort_timestamp(
      frame,
    );
  }

  _dart_av_frame_get_best_effort_timestamp _av_frame_get_best_effort_timestamp;

  void av_frame_set_best_effort_timestamp(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_best_effort_timestamp ??= _dylib.lookupFunction<
            _c_av_frame_set_best_effort_timestamp,
            _dart_av_frame_set_best_effort_timestamp>(
        'av_frame_set_best_effort_timestamp');
    return _av_frame_set_best_effort_timestamp(
      frame,
      val,
    );
  }

  _dart_av_frame_set_best_effort_timestamp _av_frame_set_best_effort_timestamp;

  int av_frame_get_pkt_duration(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_pkt_duration ??= _dylib.lookupFunction<
        _c_av_frame_get_pkt_duration,
        _dart_av_frame_get_pkt_duration>('av_frame_get_pkt_duration');
    return _av_frame_get_pkt_duration(
      frame,
    );
  }

  _dart_av_frame_get_pkt_duration _av_frame_get_pkt_duration;

  void av_frame_set_pkt_duration(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_pkt_duration ??= _dylib.lookupFunction<
        _c_av_frame_set_pkt_duration,
        _dart_av_frame_set_pkt_duration>('av_frame_set_pkt_duration');
    return _av_frame_set_pkt_duration(
      frame,
      val,
    );
  }

  _dart_av_frame_set_pkt_duration _av_frame_set_pkt_duration;

  int av_frame_get_pkt_pos(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_pkt_pos ??= _dylib.lookupFunction<_c_av_frame_get_pkt_pos,
        _dart_av_frame_get_pkt_pos>('av_frame_get_pkt_pos');
    return _av_frame_get_pkt_pos(
      frame,
    );
  }

  _dart_av_frame_get_pkt_pos _av_frame_get_pkt_pos;

  void av_frame_set_pkt_pos(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_pkt_pos ??= _dylib.lookupFunction<_c_av_frame_set_pkt_pos,
        _dart_av_frame_set_pkt_pos>('av_frame_set_pkt_pos');
    return _av_frame_set_pkt_pos(
      frame,
      val,
    );
  }

  _dart_av_frame_set_pkt_pos _av_frame_set_pkt_pos;

  int av_frame_get_channel_layout(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_channel_layout ??= _dylib.lookupFunction<
        _c_av_frame_get_channel_layout,
        _dart_av_frame_get_channel_layout>('av_frame_get_channel_layout');
    return _av_frame_get_channel_layout(
      frame,
    );
  }

  _dart_av_frame_get_channel_layout _av_frame_get_channel_layout;

  void av_frame_set_channel_layout(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_channel_layout ??= _dylib.lookupFunction<
        _c_av_frame_set_channel_layout,
        _dart_av_frame_set_channel_layout>('av_frame_set_channel_layout');
    return _av_frame_set_channel_layout(
      frame,
      val,
    );
  }

  _dart_av_frame_set_channel_layout _av_frame_set_channel_layout;

  int av_frame_get_channels(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_channels ??= _dylib.lookupFunction<_c_av_frame_get_channels,
        _dart_av_frame_get_channels>('av_frame_get_channels');
    return _av_frame_get_channels(
      frame,
    );
  }

  _dart_av_frame_get_channels _av_frame_get_channels;

  void av_frame_set_channels(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_channels ??= _dylib.lookupFunction<_c_av_frame_set_channels,
        _dart_av_frame_set_channels>('av_frame_set_channels');
    return _av_frame_set_channels(
      frame,
      val,
    );
  }

  _dart_av_frame_set_channels _av_frame_set_channels;

  int av_frame_get_sample_rate(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_sample_rate ??= _dylib.lookupFunction<
        _c_av_frame_get_sample_rate,
        _dart_av_frame_get_sample_rate>('av_frame_get_sample_rate');
    return _av_frame_get_sample_rate(
      frame,
    );
  }

  _dart_av_frame_get_sample_rate _av_frame_get_sample_rate;

  void av_frame_set_sample_rate(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_sample_rate ??= _dylib.lookupFunction<
        _c_av_frame_set_sample_rate,
        _dart_av_frame_set_sample_rate>('av_frame_set_sample_rate');
    return _av_frame_set_sample_rate(
      frame,
      val,
    );
  }

  _dart_av_frame_set_sample_rate _av_frame_set_sample_rate;

  ffi.Pointer<AVDictionary> av_frame_get_metadata(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_metadata ??= _dylib.lookupFunction<_c_av_frame_get_metadata,
        _dart_av_frame_get_metadata>('av_frame_get_metadata');
    return _av_frame_get_metadata(
      frame,
    );
  }

  _dart_av_frame_get_metadata _av_frame_get_metadata;

  void av_frame_set_metadata(
    ffi.Pointer<AVFrame> frame,
    ffi.Pointer<AVDictionary> val,
  ) {
    _av_frame_set_metadata ??= _dylib.lookupFunction<_c_av_frame_set_metadata,
        _dart_av_frame_set_metadata>('av_frame_set_metadata');
    return _av_frame_set_metadata(
      frame,
      val,
    );
  }

  _dart_av_frame_set_metadata _av_frame_set_metadata;

  int av_frame_get_decode_error_flags(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_decode_error_flags ??= _dylib.lookupFunction<
            _c_av_frame_get_decode_error_flags,
            _dart_av_frame_get_decode_error_flags>(
        'av_frame_get_decode_error_flags');
    return _av_frame_get_decode_error_flags(
      frame,
    );
  }

  _dart_av_frame_get_decode_error_flags _av_frame_get_decode_error_flags;

  void av_frame_set_decode_error_flags(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_decode_error_flags ??= _dylib.lookupFunction<
            _c_av_frame_set_decode_error_flags,
            _dart_av_frame_set_decode_error_flags>(
        'av_frame_set_decode_error_flags');
    return _av_frame_set_decode_error_flags(
      frame,
      val,
    );
  }

  _dart_av_frame_set_decode_error_flags _av_frame_set_decode_error_flags;

  int av_frame_get_pkt_size(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_pkt_size ??= _dylib.lookupFunction<_c_av_frame_get_pkt_size,
        _dart_av_frame_get_pkt_size>('av_frame_get_pkt_size');
    return _av_frame_get_pkt_size(
      frame,
    );
  }

  _dart_av_frame_get_pkt_size _av_frame_get_pkt_size;

  void av_frame_set_pkt_size(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_pkt_size ??= _dylib.lookupFunction<_c_av_frame_set_pkt_size,
        _dart_av_frame_set_pkt_size>('av_frame_set_pkt_size');
    return _av_frame_set_pkt_size(
      frame,
      val,
    );
  }

  _dart_av_frame_set_pkt_size _av_frame_set_pkt_size;

  ffi.Pointer<ffi.Int8> av_frame_get_qp_table(
    ffi.Pointer<AVFrame> f,
    ffi.Pointer<ffi.Int32> stride,
    ffi.Pointer<ffi.Int32> type,
  ) {
    _av_frame_get_qp_table ??= _dylib.lookupFunction<_c_av_frame_get_qp_table,
        _dart_av_frame_get_qp_table>('av_frame_get_qp_table');
    return _av_frame_get_qp_table(
      f,
      stride,
      type,
    );
  }

  _dart_av_frame_get_qp_table _av_frame_get_qp_table;

  int av_frame_set_qp_table(
    ffi.Pointer<AVFrame> f,
    ffi.Pointer<AVBufferRef> buf,
    int stride,
    int type,
  ) {
    _av_frame_set_qp_table ??= _dylib.lookupFunction<_c_av_frame_set_qp_table,
        _dart_av_frame_set_qp_table>('av_frame_set_qp_table');
    return _av_frame_set_qp_table(
      f,
      buf,
      stride,
      type,
    );
  }

  _dart_av_frame_set_qp_table _av_frame_set_qp_table;

  int av_frame_get_colorspace(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_colorspace ??= _dylib.lookupFunction<
        _c_av_frame_get_colorspace,
        _dart_av_frame_get_colorspace>('av_frame_get_colorspace');
    return _av_frame_get_colorspace(
      frame,
    );
  }

  _dart_av_frame_get_colorspace _av_frame_get_colorspace;

  void av_frame_set_colorspace(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_colorspace ??= _dylib.lookupFunction<
        _c_av_frame_set_colorspace,
        _dart_av_frame_set_colorspace>('av_frame_set_colorspace');
    return _av_frame_set_colorspace(
      frame,
      val,
    );
  }

  _dart_av_frame_set_colorspace _av_frame_set_colorspace;

  int av_frame_get_color_range(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_get_color_range ??= _dylib.lookupFunction<
        _c_av_frame_get_color_range,
        _dart_av_frame_get_color_range>('av_frame_get_color_range');
    return _av_frame_get_color_range(
      frame,
    );
  }

  _dart_av_frame_get_color_range _av_frame_get_color_range;

  void av_frame_set_color_range(
    ffi.Pointer<AVFrame> frame,
    int val,
  ) {
    _av_frame_set_color_range ??= _dylib.lookupFunction<
        _c_av_frame_set_color_range,
        _dart_av_frame_set_color_range>('av_frame_set_color_range');
    return _av_frame_set_color_range(
      frame,
      val,
    );
  }

  _dart_av_frame_set_color_range _av_frame_set_color_range;

  /// Get the name of a colorspace.
  /// @return a static string identifying the colorspace; can be NULL.
  ffi.Pointer<ffi.Int8> av_get_colorspace_name(
    int val,
  ) {
    _av_get_colorspace_name ??= _dylib.lookupFunction<_c_av_get_colorspace_name,
        _dart_av_get_colorspace_name>('av_get_colorspace_name');
    return _av_get_colorspace_name(
      val,
    );
  }

  _dart_av_get_colorspace_name _av_get_colorspace_name;

  /// Allocate an AVFrame and set its fields to default values.  The resulting
  /// struct must be freed using av_frame_free().
  ///
  /// @return An AVFrame filled with default values or NULL on failure.
  ///
  /// @note this only allocates the AVFrame itself, not the data buffers. Those
  /// must be allocated through other means, e.g. with av_frame_get_buffer() or
  /// manually.
  ffi.Pointer<AVFrame> av_frame_alloc() {
    _av_frame_alloc ??=
        _dylib.lookupFunction<_c_av_frame_alloc, _dart_av_frame_alloc>(
            'av_frame_alloc');
    return _av_frame_alloc();
  }

  _dart_av_frame_alloc _av_frame_alloc;

  /// Free the frame and any dynamically allocated objects in it,
  /// e.g. extended_data. If the frame is reference counted, it will be
  /// unreferenced first.
  ///
  /// @param frame frame to be freed. The pointer will be set to NULL.
  void av_frame_free(
    ffi.Pointer<ffi.Pointer<AVFrame>> frame,
  ) {
    _av_frame_free ??= _dylib
        .lookupFunction<_c_av_frame_free, _dart_av_frame_free>('av_frame_free');
    return _av_frame_free(
      frame,
    );
  }

  _dart_av_frame_free _av_frame_free;

  /// Set up a new reference to the data described by the source frame.
  ///
  /// Copy frame properties from src to dst and create a new reference for each
  /// AVBufferRef from src.
  ///
  /// If src is not reference counted, new buffers are allocated and the data is
  /// copied.
  ///
  /// @warning: dst MUST have been either unreferenced with av_frame_unref(dst),
  /// or newly allocated with av_frame_alloc() before calling this
  /// function, or undefined behavior will occur.
  ///
  /// @return 0 on success, a negative AVERROR on error
  int av_frame_ref(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    _av_frame_ref ??= _dylib
        .lookupFunction<_c_av_frame_ref, _dart_av_frame_ref>('av_frame_ref');
    return _av_frame_ref(
      dst,
      src,
    );
  }

  _dart_av_frame_ref _av_frame_ref;

  /// Create a new frame that references the same data as src.
  ///
  /// This is a shortcut for av_frame_alloc()+av_frame_ref().
  ///
  /// @return newly created AVFrame on success, NULL on error.
  ffi.Pointer<AVFrame> av_frame_clone(
    ffi.Pointer<AVFrame> src,
  ) {
    _av_frame_clone ??=
        _dylib.lookupFunction<_c_av_frame_clone, _dart_av_frame_clone>(
            'av_frame_clone');
    return _av_frame_clone(
      src,
    );
  }

  _dart_av_frame_clone _av_frame_clone;

  /// Unreference all the buffers referenced by frame and reset the frame fields.
  void av_frame_unref(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_unref ??=
        _dylib.lookupFunction<_c_av_frame_unref, _dart_av_frame_unref>(
            'av_frame_unref');
    return _av_frame_unref(
      frame,
    );
  }

  _dart_av_frame_unref _av_frame_unref;

  /// Move everything contained in src to dst and reset src.
  ///
  /// @warning: dst is not unreferenced, but directly overwritten without reading
  /// or deallocating its contents. Call av_frame_unref(dst) manually
  /// before calling this function to ensure that no memory is leaked.
  void av_frame_move_ref(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    _av_frame_move_ref ??=
        _dylib.lookupFunction<_c_av_frame_move_ref, _dart_av_frame_move_ref>(
            'av_frame_move_ref');
    return _av_frame_move_ref(
      dst,
      src,
    );
  }

  _dart_av_frame_move_ref _av_frame_move_ref;

  /// Allocate new buffer(s) for audio or video data.
  ///
  /// The following fields must be set on frame before calling this function:
  /// - format (pixel format for video, sample format for audio)
  /// - width and height for video
  /// - nb_samples and channel_layout for audio
  ///
  /// This function will fill AVFrame.data and AVFrame.buf arrays and, if
  /// necessary, allocate and fill AVFrame.extended_data and AVFrame.extended_buf.
  /// For planar formats, one buffer will be allocated for each plane.
  ///
  /// @warning: if frame already has been allocated, calling this function will
  /// leak memory. In addition, undefined behavior can occur in certain
  /// cases.
  ///
  /// @param frame frame in which to store the new buffers.
  /// @param align Required buffer size alignment. If equal to 0, alignment will be
  /// chosen automatically for the current CPU. It is highly
  /// recommended to pass 0 here unless you know what you are doing.
  ///
  /// @return 0 on success, a negative AVERROR on error.
  int av_frame_get_buffer(
    ffi.Pointer<AVFrame> frame,
    int align,
  ) {
    _av_frame_get_buffer ??= _dylib.lookupFunction<_c_av_frame_get_buffer,
        _dart_av_frame_get_buffer>('av_frame_get_buffer');
    return _av_frame_get_buffer(
      frame,
      align,
    );
  }

  _dart_av_frame_get_buffer _av_frame_get_buffer;

  /// Check if the frame data is writable.
  ///
  /// @return A positive value if the frame data is writable (which is true if and
  /// only if each of the underlying buffers has only one reference, namely the one
  /// stored in this frame). Return 0 otherwise.
  ///
  /// If 1 is returned the answer is valid until av_buffer_ref() is called on any
  /// of the underlying AVBufferRefs (e.g. through av_frame_ref() or directly).
  ///
  /// @see av_frame_make_writable(), av_buffer_is_writable()
  int av_frame_is_writable(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_is_writable ??= _dylib.lookupFunction<_c_av_frame_is_writable,
        _dart_av_frame_is_writable>('av_frame_is_writable');
    return _av_frame_is_writable(
      frame,
    );
  }

  _dart_av_frame_is_writable _av_frame_is_writable;

  /// Ensure that the frame data is writable, avoiding data copy if possible.
  ///
  /// Do nothing if the frame is writable, allocate new buffers and copy the data
  /// if it is not.
  ///
  /// @return 0 on success, a negative AVERROR on error.
  ///
  /// @see av_frame_is_writable(), av_buffer_is_writable(),
  /// av_buffer_make_writable()
  int av_frame_make_writable(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_frame_make_writable ??= _dylib.lookupFunction<_c_av_frame_make_writable,
        _dart_av_frame_make_writable>('av_frame_make_writable');
    return _av_frame_make_writable(
      frame,
    );
  }

  _dart_av_frame_make_writable _av_frame_make_writable;

  /// Copy the frame data from src to dst.
  ///
  /// This function does not allocate anything, dst must be already initialized and
  /// allocated with the same parameters as src.
  ///
  /// This function only copies the frame data (i.e. the contents of the data /
  /// extended data arrays), not any other properties.
  ///
  /// @return >= 0 on success, a negative AVERROR on error.
  int av_frame_copy(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    _av_frame_copy ??= _dylib
        .lookupFunction<_c_av_frame_copy, _dart_av_frame_copy>('av_frame_copy');
    return _av_frame_copy(
      dst,
      src,
    );
  }

  _dart_av_frame_copy _av_frame_copy;

  /// Copy only "metadata" fields from src to dst.
  ///
  /// Metadata for the purpose of this function are those fields that do not affect
  /// the data layout in the buffers.  E.g. pts, sample rate (for audio) or sample
  /// aspect ratio (for video), but not width/height or channel layout.
  /// Side data is also copied.
  int av_frame_copy_props(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
  ) {
    _av_frame_copy_props ??= _dylib.lookupFunction<_c_av_frame_copy_props,
        _dart_av_frame_copy_props>('av_frame_copy_props');
    return _av_frame_copy_props(
      dst,
      src,
    );
  }

  _dart_av_frame_copy_props _av_frame_copy_props;

  /// Get the buffer reference a given data plane is stored in.
  ///
  /// @param plane index of the data plane of interest in frame->extended_data.
  ///
  /// @return the buffer reference that contains the plane or NULL if the input
  /// frame is not valid.
  ffi.Pointer<AVBufferRef> av_frame_get_plane_buffer(
    ffi.Pointer<AVFrame> frame,
    int plane,
  ) {
    _av_frame_get_plane_buffer ??= _dylib.lookupFunction<
        _c_av_frame_get_plane_buffer,
        _dart_av_frame_get_plane_buffer>('av_frame_get_plane_buffer');
    return _av_frame_get_plane_buffer(
      frame,
      plane,
    );
  }

  _dart_av_frame_get_plane_buffer _av_frame_get_plane_buffer;

  /// Add a new side data to a frame.
  ///
  /// @param frame a frame to which the side data should be added
  /// @param type type of the added side data
  /// @param size size of the side data
  ///
  /// @return newly added side data on success, NULL on error
  ffi.Pointer<AVFrameSideData> av_frame_new_side_data(
    ffi.Pointer<AVFrame> frame,
    int type,
    int size,
  ) {
    _av_frame_new_side_data ??= _dylib.lookupFunction<_c_av_frame_new_side_data,
        _dart_av_frame_new_side_data>('av_frame_new_side_data');
    return _av_frame_new_side_data(
      frame,
      type,
      size,
    );
  }

  _dart_av_frame_new_side_data _av_frame_new_side_data;

  /// Add a new side data to a frame from an existing AVBufferRef
  ///
  /// @param frame a frame to which the side data should be added
  /// @param type  the type of the added side data
  /// @param buf   an AVBufferRef to add as side data. The ownership of
  /// the reference is transferred to the frame.
  ///
  /// @return newly added side data on success, NULL on error. On failure
  /// the frame is unchanged and the AVBufferRef remains owned by
  /// the caller.
  ffi.Pointer<AVFrameSideData> av_frame_new_side_data_from_buf(
    ffi.Pointer<AVFrame> frame,
    int type,
    ffi.Pointer<AVBufferRef> buf,
  ) {
    _av_frame_new_side_data_from_buf ??= _dylib.lookupFunction<
            _c_av_frame_new_side_data_from_buf,
            _dart_av_frame_new_side_data_from_buf>(
        'av_frame_new_side_data_from_buf');
    return _av_frame_new_side_data_from_buf(
      frame,
      type,
      buf,
    );
  }

  _dart_av_frame_new_side_data_from_buf _av_frame_new_side_data_from_buf;

  /// @return a pointer to the side data of a given type on success, NULL if there
  /// is no side data with such type in this frame.
  ffi.Pointer<AVFrameSideData> av_frame_get_side_data(
    ffi.Pointer<AVFrame> frame,
    int type,
  ) {
    _av_frame_get_side_data ??= _dylib.lookupFunction<_c_av_frame_get_side_data,
        _dart_av_frame_get_side_data>('av_frame_get_side_data');
    return _av_frame_get_side_data(
      frame,
      type,
    );
  }

  _dart_av_frame_get_side_data _av_frame_get_side_data;

  /// Remove and free all side data instances of the given type.
  void av_frame_remove_side_data(
    ffi.Pointer<AVFrame> frame,
    int type,
  ) {
    _av_frame_remove_side_data ??= _dylib.lookupFunction<
        _c_av_frame_remove_side_data,
        _dart_av_frame_remove_side_data>('av_frame_remove_side_data');
    return _av_frame_remove_side_data(
      frame,
      type,
    );
  }

  _dart_av_frame_remove_side_data _av_frame_remove_side_data;

  /// Crop the given video AVFrame according to its crop_left/crop_top/crop_right/
  /// crop_bottom fields. If cropping is successful, the function will adjust the
  /// data pointers and the width/height fields, and set the crop fields to 0.
  ///
  /// In all cases, the cropping boundaries will be rounded to the inherent
  /// alignment of the pixel format. In some cases, such as for opaque hwaccel
  /// formats, the left/top cropping is ignored. The crop fields are set to 0 even
  /// if the cropping was rounded or ignored.
  ///
  /// @param frame the frame which should be cropped
  /// @param flags Some combination of AV_FRAME_CROP_* flags, or 0.
  ///
  /// @return >= 0 on success, a negative AVERROR on error. If the cropping fields
  /// were invalid, AVERROR(ERANGE) is returned, and nothing is changed.
  int av_frame_apply_cropping(
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    _av_frame_apply_cropping ??= _dylib.lookupFunction<
        _c_av_frame_apply_cropping,
        _dart_av_frame_apply_cropping>('av_frame_apply_cropping');
    return _av_frame_apply_cropping(
      frame,
      flags,
    );
  }

  _dart_av_frame_apply_cropping _av_frame_apply_cropping;

  /// @return a string identifying the side data type
  ffi.Pointer<ffi.Int8> av_frame_side_data_name(
    int type,
  ) {
    _av_frame_side_data_name ??= _dylib.lookupFunction<
        _c_av_frame_side_data_name,
        _dart_av_frame_side_data_name>('av_frame_side_data_name');
    return _av_frame_side_data_name(
      type,
    );
  }

  _dart_av_frame_side_data_name _av_frame_side_data_name;

  /// Look up an AVHWDeviceType by name.
  ///
  /// @param name String name of the device type (case-insensitive).
  /// @return The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if
  /// not found.
  int av_hwdevice_find_type_by_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_hwdevice_find_type_by_name ??= _dylib.lookupFunction<
        _c_av_hwdevice_find_type_by_name,
        _dart_av_hwdevice_find_type_by_name>('av_hwdevice_find_type_by_name');
    return _av_hwdevice_find_type_by_name(
      name,
    );
  }

  _dart_av_hwdevice_find_type_by_name _av_hwdevice_find_type_by_name;

  /// Get the string name of an AVHWDeviceType.
  ///
  /// @param type Type from enum AVHWDeviceType.
  /// @return Pointer to a static string containing the name, or NULL if the type
  /// is not valid.
  ffi.Pointer<ffi.Int8> av_hwdevice_get_type_name(
    int type,
  ) {
    _av_hwdevice_get_type_name ??= _dylib.lookupFunction<
        _c_av_hwdevice_get_type_name,
        _dart_av_hwdevice_get_type_name>('av_hwdevice_get_type_name');
    return _av_hwdevice_get_type_name(
      type,
    );
  }

  _dart_av_hwdevice_get_type_name _av_hwdevice_get_type_name;

  /// Iterate over supported device types.
  ///
  /// @param type AV_HWDEVICE_TYPE_NONE initially, then the previous type
  /// returned by this function in subsequent iterations.
  /// @return The next usable device type from enum AVHWDeviceType, or
  /// AV_HWDEVICE_TYPE_NONE if there are no more.
  int av_hwdevice_iterate_types(
    int prev,
  ) {
    _av_hwdevice_iterate_types ??= _dylib.lookupFunction<
        _c_av_hwdevice_iterate_types,
        _dart_av_hwdevice_iterate_types>('av_hwdevice_iterate_types');
    return _av_hwdevice_iterate_types(
      prev,
    );
  }

  _dart_av_hwdevice_iterate_types _av_hwdevice_iterate_types;

  /// Allocate an AVHWDeviceContext for a given hardware type.
  ///
  /// @param type the type of the hardware device to allocate.
  /// @return a reference to the newly created AVHWDeviceContext on success or NULL
  /// on failure.
  ffi.Pointer<AVBufferRef> av_hwdevice_ctx_alloc(
    int type,
  ) {
    _av_hwdevice_ctx_alloc ??= _dylib.lookupFunction<_c_av_hwdevice_ctx_alloc,
        _dart_av_hwdevice_ctx_alloc>('av_hwdevice_ctx_alloc');
    return _av_hwdevice_ctx_alloc(
      type,
    );
  }

  _dart_av_hwdevice_ctx_alloc _av_hwdevice_ctx_alloc;

  /// Finalize the device context before use. This function must be called after
  /// the context is filled with all the required information and before it is
  /// used in any way.
  ///
  /// @param ref a reference to the AVHWDeviceContext
  /// @return 0 on success, a negative AVERROR code on failure
  int av_hwdevice_ctx_init(
    ffi.Pointer<AVBufferRef> ref,
  ) {
    _av_hwdevice_ctx_init ??= _dylib.lookupFunction<_c_av_hwdevice_ctx_init,
        _dart_av_hwdevice_ctx_init>('av_hwdevice_ctx_init');
    return _av_hwdevice_ctx_init(
      ref,
    );
  }

  _dart_av_hwdevice_ctx_init _av_hwdevice_ctx_init;

  /// Open a device of the specified type and create an AVHWDeviceContext for it.
  ///
  /// This is a convenience function intended to cover the simple cases. Callers
  /// who need to fine-tune device creation/management should open the device
  /// manually and then wrap it in an AVHWDeviceContext using
  /// av_hwdevice_ctx_alloc()/av_hwdevice_ctx_init().
  ///
  /// The returned context is already initialized and ready for use, the caller
  /// should not call av_hwdevice_ctx_init() on it. The user_opaque/free fields of
  /// the created AVHWDeviceContext are set by this function and should not be
  /// touched by the caller.
  ///
  /// @param device_ctx On success, a reference to the newly-created device context
  /// will be written here. The reference is owned by the caller
  /// and must be released with av_buffer_unref() when no longer
  /// needed. On failure, NULL will be written to this pointer.
  /// @param type The type of the device to create.
  /// @param device A type-specific string identifying the device to open.
  /// @param opts A dictionary of additional (type-specific) options to use in
  /// opening the device. The dictionary remains owned by the caller.
  /// @param flags currently unused
  ///
  /// @return 0 on success, a negative AVERROR code on failure.
  int av_hwdevice_ctx_create(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> device_ctx,
    int type,
    ffi.Pointer<ffi.Int8> device,
    ffi.Pointer<AVDictionary> opts,
    int flags,
  ) {
    _av_hwdevice_ctx_create ??= _dylib.lookupFunction<_c_av_hwdevice_ctx_create,
        _dart_av_hwdevice_ctx_create>('av_hwdevice_ctx_create');
    return _av_hwdevice_ctx_create(
      device_ctx,
      type,
      device,
      opts,
      flags,
    );
  }

  _dart_av_hwdevice_ctx_create _av_hwdevice_ctx_create;

  /// Create a new device of the specified type from an existing device.
  ///
  /// If the source device is a device of the target type or was originally
  /// derived from such a device (possibly through one or more intermediate
  /// devices of other types), then this will return a reference to the
  /// existing device of the same type as is requested.
  ///
  /// Otherwise, it will attempt to derive a new device from the given source
  /// device.  If direct derivation to the new type is not implemented, it will
  /// attempt the same derivation from each ancestor of the source device in
  /// turn looking for an implemented derivation method.
  ///
  /// @param dst_ctx On success, a reference to the newly-created
  /// AVHWDeviceContext.
  /// @param type    The type of the new device to create.
  /// @param src_ctx A reference to an existing AVHWDeviceContext which will be
  /// used to create the new device.
  /// @param flags   Currently unused; should be set to zero.
  /// @return        Zero on success, a negative AVERROR code on failure.
  int av_hwdevice_ctx_create_derived(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
    int type,
    ffi.Pointer<AVBufferRef> src_ctx,
    int flags,
  ) {
    _av_hwdevice_ctx_create_derived ??= _dylib.lookupFunction<
        _c_av_hwdevice_ctx_create_derived,
        _dart_av_hwdevice_ctx_create_derived>('av_hwdevice_ctx_create_derived');
    return _av_hwdevice_ctx_create_derived(
      dst_ctx,
      type,
      src_ctx,
      flags,
    );
  }

  _dart_av_hwdevice_ctx_create_derived _av_hwdevice_ctx_create_derived;

  /// Create a new device of the specified type from an existing device.
  ///
  /// This function performs the same action as av_hwdevice_ctx_create_derived,
  /// however, it is able to set options for the new device to be derived.
  ///
  /// @param dst_ctx On success, a reference to the newly-created
  /// AVHWDeviceContext.
  /// @param type    The type of the new device to create.
  /// @param src_ctx A reference to an existing AVHWDeviceContext which will be
  /// used to create the new device.
  /// @param options Options for the new device to create, same format as in
  /// av_hwdevice_ctx_create.
  /// @param flags   Currently unused; should be set to zero.
  /// @return        Zero on success, a negative AVERROR code on failure.
  int av_hwdevice_ctx_create_derived_opts(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
    int type,
    ffi.Pointer<AVBufferRef> src_ctx,
    ffi.Pointer<AVDictionary> options,
    int flags,
  ) {
    _av_hwdevice_ctx_create_derived_opts ??= _dylib.lookupFunction<
            _c_av_hwdevice_ctx_create_derived_opts,
            _dart_av_hwdevice_ctx_create_derived_opts>(
        'av_hwdevice_ctx_create_derived_opts');
    return _av_hwdevice_ctx_create_derived_opts(
      dst_ctx,
      type,
      src_ctx,
      options,
      flags,
    );
  }

  _dart_av_hwdevice_ctx_create_derived_opts
      _av_hwdevice_ctx_create_derived_opts;

  /// Allocate an AVHWFramesContext tied to a given device context.
  ///
  /// @param device_ctx a reference to a AVHWDeviceContext. This function will make
  /// a new reference for internal use, the one passed to the
  /// function remains owned by the caller.
  /// @return a reference to the newly created AVHWFramesContext on success or NULL
  /// on failure.
  ffi.Pointer<AVBufferRef> av_hwframe_ctx_alloc(
    ffi.Pointer<AVBufferRef> device_ctx,
  ) {
    _av_hwframe_ctx_alloc ??= _dylib.lookupFunction<_c_av_hwframe_ctx_alloc,
        _dart_av_hwframe_ctx_alloc>('av_hwframe_ctx_alloc');
    return _av_hwframe_ctx_alloc(
      device_ctx,
    );
  }

  _dart_av_hwframe_ctx_alloc _av_hwframe_ctx_alloc;

  /// Finalize the context before use. This function must be called after the
  /// context is filled with all the required information and before it is attached
  /// to any frames.
  ///
  /// @param ref a reference to the AVHWFramesContext
  /// @return 0 on success, a negative AVERROR code on failure
  int av_hwframe_ctx_init(
    ffi.Pointer<AVBufferRef> ref,
  ) {
    _av_hwframe_ctx_init ??= _dylib.lookupFunction<_c_av_hwframe_ctx_init,
        _dart_av_hwframe_ctx_init>('av_hwframe_ctx_init');
    return _av_hwframe_ctx_init(
      ref,
    );
  }

  _dart_av_hwframe_ctx_init _av_hwframe_ctx_init;

  /// Allocate a new frame attached to the given AVHWFramesContext.
  ///
  /// @param hwframe_ctx a reference to an AVHWFramesContext
  /// @param frame an empty (freshly allocated or unreffed) frame to be filled with
  /// newly allocated buffers.
  /// @param flags currently unused, should be set to zero
  /// @return 0 on success, a negative AVERROR code on failure
  int av_hwframe_get_buffer(
    ffi.Pointer<AVBufferRef> hwframe_ctx,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    _av_hwframe_get_buffer ??= _dylib.lookupFunction<_c_av_hwframe_get_buffer,
        _dart_av_hwframe_get_buffer>('av_hwframe_get_buffer');
    return _av_hwframe_get_buffer(
      hwframe_ctx,
      frame,
      flags,
    );
  }

  _dart_av_hwframe_get_buffer _av_hwframe_get_buffer;

  /// Copy data to or from a hw surface. At least one of dst/src must have an
  /// AVHWFramesContext attached.
  ///
  /// If src has an AVHWFramesContext attached, then the format of dst (if set)
  /// must use one of the formats returned by av_hwframe_transfer_get_formats(src,
  /// AV_HWFRAME_TRANSFER_DIRECTION_FROM).
  /// If dst has an AVHWFramesContext attached, then the format of src must use one
  /// of the formats returned by av_hwframe_transfer_get_formats(dst,
  /// AV_HWFRAME_TRANSFER_DIRECTION_TO)
  ///
  /// dst may be "clean" (i.e. with data/buf pointers unset), in which case the
  /// data buffers will be allocated by this function using av_frame_get_buffer().
  /// If dst->format is set, then this format will be used, otherwise (when
  /// dst->format is AV_PIX_FMT_NONE) the first acceptable format will be chosen.
  ///
  /// The two frames must have matching allocated dimensions (i.e. equal to
  /// AVHWFramesContext.width/height), since not all device types support
  /// transferring a sub-rectangle of the whole surface. The display dimensions
  /// (i.e. AVFrame.width/height) may be smaller than the allocated dimensions, but
  /// also have to be equal for both frames. When the display dimensions are
  /// smaller than the allocated dimensions, the content of the padding in the
  /// destination frame is unspecified.
  ///
  /// @param dst the destination frame. dst is not touched on failure.
  /// @param src the source frame.
  /// @param flags currently unused, should be set to zero
  /// @return 0 on success, a negative AVERROR error code on failure.
  int av_hwframe_transfer_data(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
    int flags,
  ) {
    _av_hwframe_transfer_data ??= _dylib.lookupFunction<
        _c_av_hwframe_transfer_data,
        _dart_av_hwframe_transfer_data>('av_hwframe_transfer_data');
    return _av_hwframe_transfer_data(
      dst,
      src,
      flags,
    );
  }

  _dart_av_hwframe_transfer_data _av_hwframe_transfer_data;

  /// Get a list of possible source or target formats usable in
  /// av_hwframe_transfer_data().
  ///
  /// @param hwframe_ctx the frame context to obtain the information for
  /// @param dir the direction of the transfer
  /// @param formats the pointer to the output format list will be written here.
  /// The list is terminated with AV_PIX_FMT_NONE and must be freed
  /// by the caller when no longer needed using av_free().
  /// If this function returns successfully, the format list will
  /// have at least one item (not counting the terminator).
  /// On failure, the contents of this pointer are unspecified.
  /// @param flags currently unused, should be set to zero
  /// @return 0 on success, a negative AVERROR code on failure.
  int av_hwframe_transfer_get_formats(
    ffi.Pointer<AVBufferRef> hwframe_ctx,
    int dir,
    ffi.Pointer<ffi.Pointer<ffi.Int32>> formats,
    int flags,
  ) {
    _av_hwframe_transfer_get_formats ??= _dylib.lookupFunction<
            _c_av_hwframe_transfer_get_formats,
            _dart_av_hwframe_transfer_get_formats>(
        'av_hwframe_transfer_get_formats');
    return _av_hwframe_transfer_get_formats(
      hwframe_ctx,
      dir,
      formats,
      flags,
    );
  }

  _dart_av_hwframe_transfer_get_formats _av_hwframe_transfer_get_formats;

  /// Allocate a HW-specific configuration structure for a given HW device.
  /// After use, the user must free all members as required by the specific
  /// hardware structure being used, then free the structure itself with
  /// av_free().
  ///
  /// @param device_ctx a reference to the associated AVHWDeviceContext.
  /// @return The newly created HW-specific configuration structure on
  /// success or NULL on failure.
  ffi.Pointer<ffi.Void> av_hwdevice_hwconfig_alloc(
    ffi.Pointer<AVBufferRef> device_ctx,
  ) {
    _av_hwdevice_hwconfig_alloc ??= _dylib.lookupFunction<
        _c_av_hwdevice_hwconfig_alloc,
        _dart_av_hwdevice_hwconfig_alloc>('av_hwdevice_hwconfig_alloc');
    return _av_hwdevice_hwconfig_alloc(
      device_ctx,
    );
  }

  _dart_av_hwdevice_hwconfig_alloc _av_hwdevice_hwconfig_alloc;

  /// Get the constraints on HW frames given a device and the HW-specific
  /// configuration to be used with that device.  If no HW-specific
  /// configuration is provided, returns the maximum possible capabilities
  /// of the device.
  ///
  /// @param ref a reference to the associated AVHWDeviceContext.
  /// @param hwconfig a filled HW-specific configuration structure, or NULL
  /// to return the maximum possible capabilities of the device.
  /// @return AVHWFramesConstraints structure describing the constraints
  /// on the device, or NULL if not available.
  ffi.Pointer<AVHWFramesConstraints> av_hwdevice_get_hwframe_constraints(
    ffi.Pointer<AVBufferRef> ref,
    ffi.Pointer<ffi.Void> hwconfig,
  ) {
    _av_hwdevice_get_hwframe_constraints ??= _dylib.lookupFunction<
            _c_av_hwdevice_get_hwframe_constraints,
            _dart_av_hwdevice_get_hwframe_constraints>(
        'av_hwdevice_get_hwframe_constraints');
    return _av_hwdevice_get_hwframe_constraints(
      ref,
      hwconfig,
    );
  }

  _dart_av_hwdevice_get_hwframe_constraints
      _av_hwdevice_get_hwframe_constraints;

  /// Free an AVHWFrameConstraints structure.
  ///
  /// @param constraints The (filled or unfilled) AVHWFrameConstraints structure.
  void av_hwframe_constraints_free(
    ffi.Pointer<ffi.Pointer<AVHWFramesConstraints>> constraints,
  ) {
    _av_hwframe_constraints_free ??= _dylib.lookupFunction<
        _c_av_hwframe_constraints_free,
        _dart_av_hwframe_constraints_free>('av_hwframe_constraints_free');
    return _av_hwframe_constraints_free(
      constraints,
    );
  }

  _dart_av_hwframe_constraints_free _av_hwframe_constraints_free;

  /// Map a hardware frame.
  ///
  /// This has a number of different possible effects, depending on the format
  /// and origin of the src and dst frames.  On input, src should be a usable
  /// frame with valid buffers and dst should be blank (typically as just created
  /// by av_frame_alloc()).  src should have an associated hwframe context, and
  /// dst may optionally have a format and associated hwframe context.
  ///
  /// If src was created by mapping a frame from the hwframe context of dst,
  /// then this function undoes the mapping - dst is replaced by a reference to
  /// the frame that src was originally mapped from.
  ///
  /// If both src and dst have an associated hwframe context, then this function
  /// attempts to map the src frame from its hardware context to that of dst and
  /// then fill dst with appropriate data to be usable there.  This will only be
  /// possible if the hwframe contexts and associated devices are compatible -
  /// given compatible devices, av_hwframe_ctx_create_derived() can be used to
  /// create a hwframe context for dst in which mapping should be possible.
  ///
  /// If src has a hwframe context but dst does not, then the src frame is
  /// mapped to normal memory and should thereafter be usable as a normal frame.
  /// If the format is set on dst, then the mapping will attempt to create dst
  /// with that format and fail if it is not possible.  If format is unset (is
  /// AV_PIX_FMT_NONE) then dst will be mapped with whatever the most appropriate
  /// format to use is (probably the sw_format of the src hwframe context).
  ///
  /// A return value of AVERROR(ENOSYS) indicates that the mapping is not
  /// possible with the given arguments and hwframe setup, while other return
  /// values indicate that it failed somehow.
  ///
  /// @param dst Destination frame, to contain the mapping.
  /// @param src Source frame, to be mapped.
  /// @param flags Some combination of AV_HWFRAME_MAP_* flags.
  /// @return Zero on success, negative AVERROR code on failure.
  int av_hwframe_map(
    ffi.Pointer<AVFrame> dst,
    ffi.Pointer<AVFrame> src,
    int flags,
  ) {
    _av_hwframe_map ??=
        _dylib.lookupFunction<_c_av_hwframe_map, _dart_av_hwframe_map>(
            'av_hwframe_map');
    return _av_hwframe_map(
      dst,
      src,
      flags,
    );
  }

  _dart_av_hwframe_map _av_hwframe_map;

  /// Create and initialise an AVHWFramesContext as a mapping of another existing
  /// AVHWFramesContext on a different device.
  ///
  /// av_hwframe_ctx_init() should not be called after this.
  ///
  /// @param derived_frame_ctx  On success, a reference to the newly created
  /// AVHWFramesContext.
  /// @param derived_device_ctx A reference to the device to create the new
  /// AVHWFramesContext on.
  /// @param source_frame_ctx   A reference to an existing AVHWFramesContext
  /// which will be mapped to the derived context.
  /// @param flags  Some combination of AV_HWFRAME_MAP_* flags, defining the
  /// mapping parameters to apply to frames which are allocated
  /// in the derived device.
  /// @return       Zero on success, negative AVERROR code on failure.
  int av_hwframe_ctx_create_derived(
    ffi.Pointer<ffi.Pointer<AVBufferRef>> derived_frame_ctx,
    int format,
    ffi.Pointer<AVBufferRef> derived_device_ctx,
    ffi.Pointer<AVBufferRef> source_frame_ctx,
    int flags,
  ) {
    _av_hwframe_ctx_create_derived ??= _dylib.lookupFunction<
        _c_av_hwframe_ctx_create_derived,
        _dart_av_hwframe_ctx_create_derived>('av_hwframe_ctx_create_derived');
    return _av_hwframe_ctx_create_derived(
      derived_frame_ctx,
      format,
      derived_device_ctx,
      source_frame_ctx,
      flags,
    );
  }

  _dart_av_hwframe_ctx_create_derived _av_hwframe_ctx_create_derived;

  /// Get the type of the given codec.
  int avcodec_get_type(
    int codec_id,
  ) {
    _avcodec_get_type ??=
        _dylib.lookupFunction<_c_avcodec_get_type, _dart_avcodec_get_type>(
            'avcodec_get_type');
    return _avcodec_get_type(
      codec_id,
    );
  }

  _dart_avcodec_get_type _avcodec_get_type;

  /// Get the name of a codec.
  /// @return  a static string identifying the codec; never NULL
  ffi.Pointer<ffi.Int8> avcodec_get_name(
    int id,
  ) {
    _avcodec_get_name ??=
        _dylib.lookupFunction<_c_avcodec_get_name, _dart_avcodec_get_name>(
            'avcodec_get_name');
    return _avcodec_get_name(
      id,
    );
  }

  _dart_avcodec_get_name _avcodec_get_name;

  /// Allocate a new AVCodecParameters and set its fields to default values
  /// (unknown/invalid/0). The returned struct must be freed with
  /// avcodec_parameters_free().
  ffi.Pointer<AVCodecParameters> avcodec_parameters_alloc() {
    _avcodec_parameters_alloc ??= _dylib.lookupFunction<
        _c_avcodec_parameters_alloc,
        _dart_avcodec_parameters_alloc>('avcodec_parameters_alloc');
    return _avcodec_parameters_alloc();
  }

  _dart_avcodec_parameters_alloc _avcodec_parameters_alloc;

  /// Free an AVCodecParameters instance and everything associated with it and
  /// write NULL to the supplied pointer.
  void avcodec_parameters_free(
    ffi.Pointer<ffi.Pointer<AVCodecParameters>> par,
  ) {
    _avcodec_parameters_free ??= _dylib.lookupFunction<
        _c_avcodec_parameters_free,
        _dart_avcodec_parameters_free>('avcodec_parameters_free');
    return _avcodec_parameters_free(
      par,
    );
  }

  _dart_avcodec_parameters_free _avcodec_parameters_free;

  /// Copy the contents of src to dst. Any allocated fields in dst are freed and
  /// replaced with newly allocated duplicates of the corresponding fields in src.
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure.
  int avcodec_parameters_copy(
    ffi.Pointer<AVCodecParameters> dst,
    ffi.Pointer<AVCodecParameters> src,
  ) {
    _avcodec_parameters_copy ??= _dylib.lookupFunction<
        _c_avcodec_parameters_copy,
        _dart_avcodec_parameters_copy>('avcodec_parameters_copy');
    return _avcodec_parameters_copy(
      dst,
      src,
    );
  }

  _dart_avcodec_parameters_copy _avcodec_parameters_copy;

  /// Allocate an AVPacket and set its fields to default values.  The resulting
  /// struct must be freed using av_packet_free().
  ///
  /// @return An AVPacket filled with default values or NULL on failure.
  ///
  /// @note this only allocates the AVPacket itself, not the data buffers. Those
  /// must be allocated through other means such as av_new_packet.
  ///
  /// @see av_new_packet
  ffi.Pointer<AVPacket> av_packet_alloc() {
    _av_packet_alloc ??=
        _dylib.lookupFunction<_c_av_packet_alloc, _dart_av_packet_alloc>(
            'av_packet_alloc');
    return _av_packet_alloc();
  }

  _dart_av_packet_alloc _av_packet_alloc;

  /// Create a new packet that references the same data as src.
  ///
  /// This is a shortcut for av_packet_alloc()+av_packet_ref().
  ///
  /// @return newly created AVPacket on success, NULL on error.
  ///
  /// @see av_packet_alloc
  /// @see av_packet_ref
  ffi.Pointer<AVPacket> av_packet_clone(
    ffi.Pointer<AVPacket> src,
  ) {
    _av_packet_clone ??=
        _dylib.lookupFunction<_c_av_packet_clone, _dart_av_packet_clone>(
            'av_packet_clone');
    return _av_packet_clone(
      src,
    );
  }

  _dart_av_packet_clone _av_packet_clone;

  /// Free the packet, if the packet is reference counted, it will be
  /// unreferenced first.
  ///
  /// @param pkt packet to be freed. The pointer will be set to NULL.
  /// @note passing NULL is a no-op.
  void av_packet_free(
    ffi.Pointer<ffi.Pointer<AVPacket>> pkt,
  ) {
    _av_packet_free ??=
        _dylib.lookupFunction<_c_av_packet_free, _dart_av_packet_free>(
            'av_packet_free');
    return _av_packet_free(
      pkt,
    );
  }

  _dart_av_packet_free _av_packet_free;

  /// Initialize optional fields of a packet with default values.
  ///
  /// Note, this does not touch the data and size members, which have to be
  /// initialized separately.
  ///
  /// @param pkt packet
  void av_init_packet(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_init_packet ??=
        _dylib.lookupFunction<_c_av_init_packet, _dart_av_init_packet>(
            'av_init_packet');
    return _av_init_packet(
      pkt,
    );
  }

  _dart_av_init_packet _av_init_packet;

  /// Allocate the payload of a packet and initialize its fields with
  /// default values.
  ///
  /// @param pkt packet
  /// @param size wanted payload size
  /// @return 0 if OK, AVERROR_xxx otherwise
  int av_new_packet(
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    _av_new_packet ??= _dylib
        .lookupFunction<_c_av_new_packet, _dart_av_new_packet>('av_new_packet');
    return _av_new_packet(
      pkt,
      size,
    );
  }

  _dart_av_new_packet _av_new_packet;

  /// Reduce packet size, correctly zeroing padding
  ///
  /// @param pkt packet
  /// @param size new size
  void av_shrink_packet(
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    _av_shrink_packet ??=
        _dylib.lookupFunction<_c_av_shrink_packet, _dart_av_shrink_packet>(
            'av_shrink_packet');
    return _av_shrink_packet(
      pkt,
      size,
    );
  }

  _dart_av_shrink_packet _av_shrink_packet;

  /// Increase packet size, correctly zeroing padding
  ///
  /// @param pkt packet
  /// @param grow_by number of bytes by which to increase the size of the packet
  int av_grow_packet(
    ffi.Pointer<AVPacket> pkt,
    int grow_by,
  ) {
    _av_grow_packet ??=
        _dylib.lookupFunction<_c_av_grow_packet, _dart_av_grow_packet>(
            'av_grow_packet');
    return _av_grow_packet(
      pkt,
      grow_by,
    );
  }

  _dart_av_grow_packet _av_grow_packet;

  /// Initialize a reference-counted packet from av_malloc()ed data.
  ///
  /// @param pkt packet to be initialized. This function will set the data, size,
  /// and buf fields, all others are left untouched.
  /// @param data Data allocated by av_malloc() to be used as packet data. If this
  /// function returns successfully, the data is owned by the underlying AVBuffer.
  /// The caller may not access the data through other means.
  /// @param size size of data in bytes, without the padding. I.e. the full buffer
  /// size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.
  ///
  /// @return 0 on success, a negative AVERROR on error
  int av_packet_from_data(
    ffi.Pointer<AVPacket> pkt,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    _av_packet_from_data ??= _dylib.lookupFunction<_c_av_packet_from_data,
        _dart_av_packet_from_data>('av_packet_from_data');
    return _av_packet_from_data(
      pkt,
      data,
      size,
    );
  }

  _dart_av_packet_from_data _av_packet_from_data;

  /// @warning This is a hack - the packet memory allocation stuff is broken. The
  /// packet is allocated if it was not really allocated.
  ///
  /// @deprecated Use av_packet_ref or av_packet_make_refcounted
  int av_dup_packet(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_dup_packet ??= _dylib
        .lookupFunction<_c_av_dup_packet, _dart_av_dup_packet>('av_dup_packet');
    return _av_dup_packet(
      pkt,
    );
  }

  _dart_av_dup_packet _av_dup_packet;

  /// Copy packet, including contents
  ///
  /// @return 0 on success, negative AVERROR on fail
  ///
  /// @deprecated Use av_packet_ref
  int av_copy_packet(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    _av_copy_packet ??=
        _dylib.lookupFunction<_c_av_copy_packet, _dart_av_copy_packet>(
            'av_copy_packet');
    return _av_copy_packet(
      dst,
      src,
    );
  }

  _dart_av_copy_packet _av_copy_packet;

  /// Copy packet side data
  ///
  /// @return 0 on success, negative AVERROR on fail
  ///
  /// @deprecated Use av_packet_copy_props
  int av_copy_packet_side_data(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    _av_copy_packet_side_data ??= _dylib.lookupFunction<
        _c_av_copy_packet_side_data,
        _dart_av_copy_packet_side_data>('av_copy_packet_side_data');
    return _av_copy_packet_side_data(
      dst,
      src,
    );
  }

  _dart_av_copy_packet_side_data _av_copy_packet_side_data;

  /// Free a packet.
  ///
  /// @deprecated Use av_packet_unref
  ///
  /// @param pkt packet to free
  void av_free_packet(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_free_packet ??=
        _dylib.lookupFunction<_c_av_free_packet, _dart_av_free_packet>(
            'av_free_packet');
    return _av_free_packet(
      pkt,
    );
  }

  _dart_av_free_packet _av_free_packet;

  /// Allocate new information of a packet.
  ///
  /// @param pkt packet
  /// @param type side information type
  /// @param size side information size
  /// @return pointer to fresh allocated data or NULL otherwise
  ffi.Pointer<ffi.Uint8> av_packet_new_side_data(
    ffi.Pointer<AVPacket> pkt,
    int type,
    int size,
  ) {
    _av_packet_new_side_data ??= _dylib.lookupFunction<
        _c_av_packet_new_side_data,
        _dart_av_packet_new_side_data>('av_packet_new_side_data');
    return _av_packet_new_side_data(
      pkt,
      type,
      size,
    );
  }

  _dart_av_packet_new_side_data _av_packet_new_side_data;

  /// Wrap an existing array as a packet side data.
  ///
  /// @param pkt packet
  /// @param type side information type
  /// @param data the side data array. It must be allocated with the av_malloc()
  /// family of functions. The ownership of the data is transferred to
  /// pkt.
  /// @param size side information size
  /// @return a non-negative number on success, a negative AVERROR code on
  /// failure. On failure, the packet is unchanged and the data remains
  /// owned by the caller.
  int av_packet_add_side_data(
    ffi.Pointer<AVPacket> pkt,
    int type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    _av_packet_add_side_data ??= _dylib.lookupFunction<
        _c_av_packet_add_side_data,
        _dart_av_packet_add_side_data>('av_packet_add_side_data');
    return _av_packet_add_side_data(
      pkt,
      type,
      data,
      size,
    );
  }

  _dart_av_packet_add_side_data _av_packet_add_side_data;

  /// Shrink the already allocated side data buffer
  ///
  /// @param pkt packet
  /// @param type side information type
  /// @param size new side information size
  /// @return 0 on success, < 0 on failure
  int av_packet_shrink_side_data(
    ffi.Pointer<AVPacket> pkt,
    int type,
    int size,
  ) {
    _av_packet_shrink_side_data ??= _dylib.lookupFunction<
        _c_av_packet_shrink_side_data,
        _dart_av_packet_shrink_side_data>('av_packet_shrink_side_data');
    return _av_packet_shrink_side_data(
      pkt,
      type,
      size,
    );
  }

  _dart_av_packet_shrink_side_data _av_packet_shrink_side_data;

  /// Get side information from packet.
  ///
  /// @param pkt packet
  /// @param type desired side information type
  /// @param size If supplied, *size will be set to the size of the side data
  /// or to zero if the desired side data is not present.
  /// @return pointer to data if present or NULL otherwise
  ffi.Pointer<ffi.Uint8> av_packet_get_side_data(
    ffi.Pointer<AVPacket> pkt,
    int type,
    ffi.Pointer<ffi.Int32> size,
  ) {
    _av_packet_get_side_data ??= _dylib.lookupFunction<
        _c_av_packet_get_side_data,
        _dart_av_packet_get_side_data>('av_packet_get_side_data');
    return _av_packet_get_side_data(
      pkt,
      type,
      size,
    );
  }

  _dart_av_packet_get_side_data _av_packet_get_side_data;

  int av_packet_merge_side_data(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_packet_merge_side_data ??= _dylib.lookupFunction<
        _c_av_packet_merge_side_data,
        _dart_av_packet_merge_side_data>('av_packet_merge_side_data');
    return _av_packet_merge_side_data(
      pkt,
    );
  }

  _dart_av_packet_merge_side_data _av_packet_merge_side_data;

  int av_packet_split_side_data(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_packet_split_side_data ??= _dylib.lookupFunction<
        _c_av_packet_split_side_data,
        _dart_av_packet_split_side_data>('av_packet_split_side_data');
    return _av_packet_split_side_data(
      pkt,
    );
  }

  _dart_av_packet_split_side_data _av_packet_split_side_data;

  ffi.Pointer<ffi.Int8> av_packet_side_data_name(
    int type,
  ) {
    _av_packet_side_data_name ??= _dylib.lookupFunction<
        _c_av_packet_side_data_name,
        _dart_av_packet_side_data_name>('av_packet_side_data_name');
    return _av_packet_side_data_name(
      type,
    );
  }

  _dart_av_packet_side_data_name _av_packet_side_data_name;

  /// Pack a dictionary for use in side_data.
  ///
  /// @param dict The dictionary to pack.
  /// @param size pointer to store the size of the returned data
  /// @return pointer to data if successful, NULL otherwise
  ffi.Pointer<ffi.Uint8> av_packet_pack_dictionary(
    ffi.Pointer<AVDictionary> dict,
    ffi.Pointer<ffi.Int32> size,
  ) {
    _av_packet_pack_dictionary ??= _dylib.lookupFunction<
        _c_av_packet_pack_dictionary,
        _dart_av_packet_pack_dictionary>('av_packet_pack_dictionary');
    return _av_packet_pack_dictionary(
      dict,
      size,
    );
  }

  _dart_av_packet_pack_dictionary _av_packet_pack_dictionary;

  /// Unpack a dictionary from side_data.
  ///
  /// @param data data from side_data
  /// @param size size of the data
  /// @param dict the metadata storage dictionary
  /// @return 0 on success, < 0 on failure
  int av_packet_unpack_dictionary(
    ffi.Pointer<ffi.Uint8> data,
    int size,
    ffi.Pointer<ffi.Pointer<AVDictionary>> dict,
  ) {
    _av_packet_unpack_dictionary ??= _dylib.lookupFunction<
        _c_av_packet_unpack_dictionary,
        _dart_av_packet_unpack_dictionary>('av_packet_unpack_dictionary');
    return _av_packet_unpack_dictionary(
      data,
      size,
      dict,
    );
  }

  _dart_av_packet_unpack_dictionary _av_packet_unpack_dictionary;

  /// Convenience function to free all the side data stored.
  /// All the other fields stay untouched.
  ///
  /// @param pkt packet
  void av_packet_free_side_data(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_packet_free_side_data ??= _dylib.lookupFunction<
        _c_av_packet_free_side_data,
        _dart_av_packet_free_side_data>('av_packet_free_side_data');
    return _av_packet_free_side_data(
      pkt,
    );
  }

  _dart_av_packet_free_side_data _av_packet_free_side_data;

  /// Setup a new reference to the data described by a given packet
  ///
  /// If src is reference-counted, setup dst as a new reference to the
  /// buffer in src. Otherwise allocate a new buffer in dst and copy the
  /// data from src into it.
  ///
  /// All the other fields are copied from src.
  ///
  /// @see av_packet_unref
  ///
  /// @param dst Destination packet. Will be completely overwritten.
  /// @param src Source packet
  ///
  /// @return 0 on success, a negative AVERROR on error. On error, dst
  /// will be blank (as if returned by av_packet_alloc()).
  int av_packet_ref(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    _av_packet_ref ??= _dylib
        .lookupFunction<_c_av_packet_ref, _dart_av_packet_ref>('av_packet_ref');
    return _av_packet_ref(
      dst,
      src,
    );
  }

  _dart_av_packet_ref _av_packet_ref;

  /// Wipe the packet.
  ///
  /// Unreference the buffer referenced by the packet and reset the
  /// remaining packet fields to their default values.
  ///
  /// @param pkt The packet to be unreferenced.
  void av_packet_unref(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_packet_unref ??=
        _dylib.lookupFunction<_c_av_packet_unref, _dart_av_packet_unref>(
            'av_packet_unref');
    return _av_packet_unref(
      pkt,
    );
  }

  _dart_av_packet_unref _av_packet_unref;

  /// Move every field in src to dst and reset src.
  ///
  /// @see av_packet_unref
  ///
  /// @param src Source packet, will be reset
  /// @param dst Destination packet
  void av_packet_move_ref(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    _av_packet_move_ref ??=
        _dylib.lookupFunction<_c_av_packet_move_ref, _dart_av_packet_move_ref>(
            'av_packet_move_ref');
    return _av_packet_move_ref(
      dst,
      src,
    );
  }

  _dart_av_packet_move_ref _av_packet_move_ref;

  /// Copy only "properties" fields from src to dst.
  ///
  /// Properties for the purpose of this function are all the fields
  /// beside those related to the packet data (buf, data, size)
  ///
  /// @param dst Destination packet
  /// @param src Source packet
  ///
  /// @return 0 on success AVERROR on failure.
  int av_packet_copy_props(
    ffi.Pointer<AVPacket> dst,
    ffi.Pointer<AVPacket> src,
  ) {
    _av_packet_copy_props ??= _dylib.lookupFunction<_c_av_packet_copy_props,
        _dart_av_packet_copy_props>('av_packet_copy_props');
    return _av_packet_copy_props(
      dst,
      src,
    );
  }

  _dart_av_packet_copy_props _av_packet_copy_props;

  /// Ensure the data described by a given packet is reference counted.
  ///
  /// @note This function does not ensure that the reference will be writable.
  /// Use av_packet_make_writable instead for that purpose.
  ///
  /// @see av_packet_ref
  /// @see av_packet_make_writable
  ///
  /// @param pkt packet whose data should be made reference counted.
  ///
  /// @return 0 on success, a negative AVERROR on error. On failure, the
  /// packet is unchanged.
  int av_packet_make_refcounted(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_packet_make_refcounted ??= _dylib.lookupFunction<
        _c_av_packet_make_refcounted,
        _dart_av_packet_make_refcounted>('av_packet_make_refcounted');
    return _av_packet_make_refcounted(
      pkt,
    );
  }

  _dart_av_packet_make_refcounted _av_packet_make_refcounted;

  /// Create a writable reference for the data described by a given packet,
  /// avoiding data copy if possible.
  ///
  /// @param pkt Packet whose data should be made writable.
  ///
  /// @return 0 on success, a negative AVERROR on failure. On failure, the
  /// packet is unchanged.
  int av_packet_make_writable(
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_packet_make_writable ??= _dylib.lookupFunction<
        _c_av_packet_make_writable,
        _dart_av_packet_make_writable>('av_packet_make_writable');
    return _av_packet_make_writable(
      pkt,
    );
  }

  _dart_av_packet_make_writable _av_packet_make_writable;

  /// @return a bitstream filter with the specified name or NULL if no such
  /// bitstream filter exists.
  ffi.Pointer<AVBitStreamFilter> av_bsf_get_by_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_bsf_get_by_name ??=
        _dylib.lookupFunction<_c_av_bsf_get_by_name, _dart_av_bsf_get_by_name>(
            'av_bsf_get_by_name');
    return _av_bsf_get_by_name(
      name,
    );
  }

  _dart_av_bsf_get_by_name _av_bsf_get_by_name;

  /// Iterate over all registered bitstream filters.
  ///
  /// @param opaque a pointer where libavcodec will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered bitstream filter or NULL when the iteration is
  /// finished
  ffi.Pointer<AVBitStreamFilter> av_bsf_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    _av_bsf_iterate ??=
        _dylib.lookupFunction<_c_av_bsf_iterate, _dart_av_bsf_iterate>(
            'av_bsf_iterate');
    return _av_bsf_iterate(
      opaque,
    );
  }

  _dart_av_bsf_iterate _av_bsf_iterate;

  /// Allocate a context for a given bitstream filter. The caller must fill in the
  /// context parameters as described in the documentation and then call
  /// av_bsf_init() before sending any data to the filter.
  ///
  /// @param filter the filter for which to allocate an instance.
  /// @param ctx a pointer into which the pointer to the newly-allocated context
  /// will be written. It must be freed with av_bsf_free() after the
  /// filtering is done.
  ///
  /// @return 0 on success, a negative AVERROR code on failure
  int av_bsf_alloc(
    ffi.Pointer<AVBitStreamFilter> filter,
    ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
  ) {
    _av_bsf_alloc ??= _dylib
        .lookupFunction<_c_av_bsf_alloc, _dart_av_bsf_alloc>('av_bsf_alloc');
    return _av_bsf_alloc(
      filter,
      ctx,
    );
  }

  _dart_av_bsf_alloc _av_bsf_alloc;

  /// Prepare the filter for use, after all the parameters and options have been
  /// set.
  int av_bsf_init(
    ffi.Pointer<AVBSFContext> ctx,
  ) {
    _av_bsf_init ??=
        _dylib.lookupFunction<_c_av_bsf_init, _dart_av_bsf_init>('av_bsf_init');
    return _av_bsf_init(
      ctx,
    );
  }

  _dart_av_bsf_init _av_bsf_init;

  /// Submit a packet for filtering.
  ///
  /// After sending each packet, the filter must be completely drained by calling
  /// av_bsf_receive_packet() repeatedly until it returns AVERROR(EAGAIN) or
  /// AVERROR_EOF.
  ///
  /// @param pkt the packet to filter. The bitstream filter will take ownership of
  /// the packet and reset the contents of pkt. pkt is not touched if an error occurs.
  /// If pkt is empty (i.e. NULL, or pkt->data is NULL and pkt->side_data_elems zero),
  /// it signals the end of the stream (i.e. no more non-empty packets will be sent;
  /// sending more empty packets does nothing) and will cause the filter to output
  /// any packets it may have buffered internally.
  ///
  /// @return 0 on success. AVERROR(EAGAIN) if packets need to be retrieved from the
  /// filter (using av_bsf_receive_packet()) before new input can be consumed. Another
  /// negative AVERROR value if an error occurs.
  int av_bsf_send_packet(
    ffi.Pointer<AVBSFContext> ctx,
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_bsf_send_packet ??=
        _dylib.lookupFunction<_c_av_bsf_send_packet, _dart_av_bsf_send_packet>(
            'av_bsf_send_packet');
    return _av_bsf_send_packet(
      ctx,
      pkt,
    );
  }

  _dart_av_bsf_send_packet _av_bsf_send_packet;

  /// Retrieve a filtered packet.
  ///
  /// @param[out] pkt this struct will be filled with the contents of the filtered
  /// packet. It is owned by the caller and must be freed using
  /// av_packet_unref() when it is no longer needed.
  /// This parameter should be "clean" (i.e. freshly allocated
  /// with av_packet_alloc() or unreffed with av_packet_unref())
  /// when this function is called. If this function returns
  /// successfully, the contents of pkt will be completely
  /// overwritten by the returned data. On failure, pkt is not
  /// touched.
  ///
  /// @return 0 on success. AVERROR(EAGAIN) if more packets need to be sent to the
  /// filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there
  /// will be no further output from the filter. Another negative AVERROR value if
  /// an error occurs.
  ///
  /// @note one input packet may result in several output packets, so after sending
  /// a packet with av_bsf_send_packet(), this function needs to be called
  /// repeatedly until it stops returning 0. It is also possible for a filter to
  /// output fewer packets than were sent to it, so this function may return
  /// AVERROR(EAGAIN) immediately after a successful av_bsf_send_packet() call.
  int av_bsf_receive_packet(
    ffi.Pointer<AVBSFContext> ctx,
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_bsf_receive_packet ??= _dylib.lookupFunction<_c_av_bsf_receive_packet,
        _dart_av_bsf_receive_packet>('av_bsf_receive_packet');
    return _av_bsf_receive_packet(
      ctx,
      pkt,
    );
  }

  _dart_av_bsf_receive_packet _av_bsf_receive_packet;

  /// Reset the internal bitstream filter state. Should be called e.g. when seeking.
  void av_bsf_flush(
    ffi.Pointer<AVBSFContext> ctx,
  ) {
    _av_bsf_flush ??= _dylib
        .lookupFunction<_c_av_bsf_flush, _dart_av_bsf_flush>('av_bsf_flush');
    return _av_bsf_flush(
      ctx,
    );
  }

  _dart_av_bsf_flush _av_bsf_flush;

  /// Free a bitstream filter context and everything associated with it; write NULL
  /// into the supplied pointer.
  void av_bsf_free(
    ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
  ) {
    _av_bsf_free ??=
        _dylib.lookupFunction<_c_av_bsf_free, _dart_av_bsf_free>('av_bsf_free');
    return _av_bsf_free(
      ctx,
    );
  }

  _dart_av_bsf_free _av_bsf_free;

  /// Get the AVClass for AVBSFContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> av_bsf_get_class() {
    _av_bsf_get_class ??=
        _dylib.lookupFunction<_c_av_bsf_get_class, _dart_av_bsf_get_class>(
            'av_bsf_get_class');
    return _av_bsf_get_class();
  }

  _dart_av_bsf_get_class _av_bsf_get_class;

  /// Allocate empty list of bitstream filters.
  /// The list must be later freed by av_bsf_list_free()
  /// or finalized by av_bsf_list_finalize().
  ///
  /// @return Pointer to @ref AVBSFList on success, NULL in case of failure
  ffi.Pointer<AVBSFList> av_bsf_list_alloc() {
    _av_bsf_list_alloc ??=
        _dylib.lookupFunction<_c_av_bsf_list_alloc, _dart_av_bsf_list_alloc>(
            'av_bsf_list_alloc');
    return _av_bsf_list_alloc();
  }

  _dart_av_bsf_list_alloc _av_bsf_list_alloc;

  /// Free list of bitstream filters.
  ///
  /// @param lst Pointer to pointer returned by av_bsf_list_alloc()
  void av_bsf_list_free(
    ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
  ) {
    _av_bsf_list_free ??=
        _dylib.lookupFunction<_c_av_bsf_list_free, _dart_av_bsf_list_free>(
            'av_bsf_list_free');
    return _av_bsf_list_free(
      lst,
    );
  }

  _dart_av_bsf_list_free _av_bsf_list_free;

  /// Append bitstream filter to the list of bitstream filters.
  ///
  /// @param lst List to append to
  /// @param bsf Filter context to be appended
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_append(
    ffi.Pointer<AVBSFList> lst,
    ffi.Pointer<AVBSFContext> bsf,
  ) {
    _av_bsf_list_append ??=
        _dylib.lookupFunction<_c_av_bsf_list_append, _dart_av_bsf_list_append>(
            'av_bsf_list_append');
    return _av_bsf_list_append(
      lst,
      bsf,
    );
  }

  _dart_av_bsf_list_append _av_bsf_list_append;

  /// Construct new bitstream filter context given it's name and options
  /// and append it to the list of bitstream filters.
  ///
  /// @param lst      List to append to
  /// @param bsf_name Name of the bitstream filter
  /// @param options  Options for the bitstream filter, can be set to NULL
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_append2(
    ffi.Pointer<AVBSFList> lst,
    ffi.Pointer<ffi.Int8> bsf_name,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _av_bsf_list_append2 ??= _dylib.lookupFunction<_c_av_bsf_list_append2,
        _dart_av_bsf_list_append2>('av_bsf_list_append2');
    return _av_bsf_list_append2(
      lst,
      bsf_name,
      options,
    );
  }

  _dart_av_bsf_list_append2 _av_bsf_list_append2;

  /// Finalize list of bitstream filters.
  ///
  /// This function will transform @ref AVBSFList to single @ref AVBSFContext,
  /// so the whole chain of bitstream filters can be treated as single filter
  /// freshly allocated by av_bsf_alloc().
  /// If the call is successful, @ref AVBSFList structure is freed and lst
  /// will be set to NULL. In case of failure, caller is responsible for
  /// freeing the structure by av_bsf_list_free()
  ///
  /// @param      lst Filter list structure to be transformed
  /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
  /// representing the chain of bitstream filters
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_finalize(
    ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
    ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
  ) {
    _av_bsf_list_finalize ??= _dylib.lookupFunction<_c_av_bsf_list_finalize,
        _dart_av_bsf_list_finalize>('av_bsf_list_finalize');
    return _av_bsf_list_finalize(
      lst,
      bsf,
    );
  }

  _dart_av_bsf_list_finalize _av_bsf_list_finalize;

  /// Parse string describing list of bitstream filters and create single
  /// @ref AVBSFContext describing the whole chain of bitstream filters.
  /// Resulting @ref AVBSFContext can be treated as any other @ref AVBSFContext freshly
  /// allocated by av_bsf_alloc().
  ///
  /// @param      str String describing chain of bitstream filters in format
  /// `bsf1[=opt1=val1:opt2=val2][,bsf2]`
  /// @param[out] bsf Pointer to be set to newly created @ref AVBSFContext structure
  /// representing the chain of bitstream filters
  ///
  /// @return >=0 on success, negative AVERROR in case of failure
  int av_bsf_list_parse_str(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
  ) {
    _av_bsf_list_parse_str ??= _dylib.lookupFunction<_c_av_bsf_list_parse_str,
        _dart_av_bsf_list_parse_str>('av_bsf_list_parse_str');
    return _av_bsf_list_parse_str(
      str,
      bsf,
    );
  }

  _dart_av_bsf_list_parse_str _av_bsf_list_parse_str;

  /// Get null/pass-through bitstream filter.
  ///
  /// @param[out] bsf Pointer to be set to new instance of pass-through bitstream filter
  ///
  /// @return
  int av_bsf_get_null_filter(
    ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
  ) {
    _av_bsf_get_null_filter ??= _dylib.lookupFunction<_c_av_bsf_get_null_filter,
        _dart_av_bsf_get_null_filter>('av_bsf_get_null_filter');
    return _av_bsf_get_null_filter(
      bsf,
    );
  }

  _dart_av_bsf_get_null_filter _av_bsf_get_null_filter;

  /// Iterate over all registered codecs.
  ///
  /// @param opaque a pointer where libavcodec will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered codec or NULL when the iteration is
  /// finished
  ffi.Pointer<AVCodec> av_codec_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    _av_codec_iterate ??=
        _dylib.lookupFunction<_c_av_codec_iterate, _dart_av_codec_iterate>(
            'av_codec_iterate');
    return _av_codec_iterate(
      opaque,
    );
  }

  _dart_av_codec_iterate _av_codec_iterate;

  /// Find a registered decoder with a matching codec ID.
  ///
  /// @param id AVCodecID of the requested decoder
  /// @return A decoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_decoder(
    int id,
  ) {
    _avcodec_find_decoder ??= _dylib.lookupFunction<_c_avcodec_find_decoder,
        _dart_avcodec_find_decoder>('avcodec_find_decoder');
    return _avcodec_find_decoder(
      id,
    );
  }

  _dart_avcodec_find_decoder _avcodec_find_decoder;

  /// Find a registered decoder with the specified name.
  ///
  /// @param name name of the requested decoder
  /// @return A decoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_decoder_by_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _avcodec_find_decoder_by_name ??= _dylib.lookupFunction<
        _c_avcodec_find_decoder_by_name,
        _dart_avcodec_find_decoder_by_name>('avcodec_find_decoder_by_name');
    return _avcodec_find_decoder_by_name(
      name,
    );
  }

  _dart_avcodec_find_decoder_by_name _avcodec_find_decoder_by_name;

  /// Find a registered encoder with a matching codec ID.
  ///
  /// @param id AVCodecID of the requested encoder
  /// @return An encoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_encoder(
    int id,
  ) {
    _avcodec_find_encoder ??= _dylib.lookupFunction<_c_avcodec_find_encoder,
        _dart_avcodec_find_encoder>('avcodec_find_encoder');
    return _avcodec_find_encoder(
      id,
    );
  }

  _dart_avcodec_find_encoder _avcodec_find_encoder;

  /// Find a registered encoder with the specified name.
  ///
  /// @param name name of the requested encoder
  /// @return An encoder if one was found, NULL otherwise.
  ffi.Pointer<AVCodec> avcodec_find_encoder_by_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _avcodec_find_encoder_by_name ??= _dylib.lookupFunction<
        _c_avcodec_find_encoder_by_name,
        _dart_avcodec_find_encoder_by_name>('avcodec_find_encoder_by_name');
    return _avcodec_find_encoder_by_name(
      name,
    );
  }

  _dart_avcodec_find_encoder_by_name _avcodec_find_encoder_by_name;

  /// @return a non-zero number if codec is an encoder, zero otherwise
  int av_codec_is_encoder(
    ffi.Pointer<AVCodec> codec,
  ) {
    _av_codec_is_encoder ??= _dylib.lookupFunction<_c_av_codec_is_encoder,
        _dart_av_codec_is_encoder>('av_codec_is_encoder');
    return _av_codec_is_encoder(
      codec,
    );
  }

  _dart_av_codec_is_encoder _av_codec_is_encoder;

  /// @return a non-zero number if codec is a decoder, zero otherwise
  int av_codec_is_decoder(
    ffi.Pointer<AVCodec> codec,
  ) {
    _av_codec_is_decoder ??= _dylib.lookupFunction<_c_av_codec_is_decoder,
        _dart_av_codec_is_decoder>('av_codec_is_decoder');
    return _av_codec_is_decoder(
      codec,
    );
  }

  _dart_av_codec_is_decoder _av_codec_is_decoder;

  /// Retrieve supported hardware configurations for a codec.
  ///
  /// Values of index from zero to some maximum return the indexed configuration
  /// descriptor; all other values return NULL.  If the codec does not support
  /// any hardware configurations then it will always return NULL.
  ffi.Pointer<AVCodecHWConfig> avcodec_get_hw_config(
    ffi.Pointer<AVCodec> codec,
    int index,
  ) {
    _avcodec_get_hw_config ??= _dylib.lookupFunction<_c_avcodec_get_hw_config,
        _dart_avcodec_get_hw_config>('avcodec_get_hw_config');
    return _avcodec_get_hw_config(
      codec,
      index,
    );
  }

  _dart_avcodec_get_hw_config _avcodec_get_hw_config;

  /// @return descriptor for given codec ID or NULL if no descriptor exists.
  ffi.Pointer<AVCodecDescriptor> avcodec_descriptor_get(
    int id,
  ) {
    _avcodec_descriptor_get ??= _dylib.lookupFunction<_c_avcodec_descriptor_get,
        _dart_avcodec_descriptor_get>('avcodec_descriptor_get');
    return _avcodec_descriptor_get(
      id,
    );
  }

  _dart_avcodec_descriptor_get _avcodec_descriptor_get;

  /// Iterate over all codec descriptors known to libavcodec.
  ///
  /// @param prev previous descriptor. NULL to get the first descriptor.
  ///
  /// @return next descriptor or NULL after the last descriptor
  ffi.Pointer<AVCodecDescriptor> avcodec_descriptor_next(
    ffi.Pointer<AVCodecDescriptor> prev,
  ) {
    _avcodec_descriptor_next ??= _dylib.lookupFunction<
        _c_avcodec_descriptor_next,
        _dart_avcodec_descriptor_next>('avcodec_descriptor_next');
    return _avcodec_descriptor_next(
      prev,
    );
  }

  _dart_avcodec_descriptor_next _avcodec_descriptor_next;

  /// @return codec descriptor with the given name or NULL if no such descriptor
  /// exists.
  ffi.Pointer<AVCodecDescriptor> avcodec_descriptor_get_by_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _avcodec_descriptor_get_by_name ??= _dylib.lookupFunction<
        _c_avcodec_descriptor_get_by_name,
        _dart_avcodec_descriptor_get_by_name>('avcodec_descriptor_get_by_name');
    return _avcodec_descriptor_get_by_name(
      name,
    );
  }

  _dart_avcodec_descriptor_get_by_name _avcodec_descriptor_get_by_name;

  ffi.Pointer<AVCodecDescriptor> av_codec_get_codec_descriptor(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_codec_get_codec_descriptor ??= _dylib.lookupFunction<
        _c_av_codec_get_codec_descriptor,
        _dart_av_codec_get_codec_descriptor>('av_codec_get_codec_descriptor');
    return _av_codec_get_codec_descriptor(
      avctx,
    );
  }

  _dart_av_codec_get_codec_descriptor _av_codec_get_codec_descriptor;

  void av_codec_set_codec_descriptor(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVCodecDescriptor> desc,
  ) {
    _av_codec_set_codec_descriptor ??= _dylib.lookupFunction<
        _c_av_codec_set_codec_descriptor,
        _dart_av_codec_set_codec_descriptor>('av_codec_set_codec_descriptor');
    return _av_codec_set_codec_descriptor(
      avctx,
      desc,
    );
  }

  _dart_av_codec_set_codec_descriptor _av_codec_set_codec_descriptor;

  int av_codec_get_codec_properties(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_codec_get_codec_properties ??= _dylib.lookupFunction<
        _c_av_codec_get_codec_properties,
        _dart_av_codec_get_codec_properties>('av_codec_get_codec_properties');
    return _av_codec_get_codec_properties(
      avctx,
    );
  }

  _dart_av_codec_get_codec_properties _av_codec_get_codec_properties;

  int av_codec_get_lowres(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_codec_get_lowres ??= _dylib.lookupFunction<_c_av_codec_get_lowres,
        _dart_av_codec_get_lowres>('av_codec_get_lowres');
    return _av_codec_get_lowres(
      avctx,
    );
  }

  _dart_av_codec_get_lowres _av_codec_get_lowres;

  void av_codec_set_lowres(
    ffi.Pointer<AVCodecContext> avctx,
    int val,
  ) {
    _av_codec_set_lowres ??= _dylib.lookupFunction<_c_av_codec_set_lowres,
        _dart_av_codec_set_lowres>('av_codec_set_lowres');
    return _av_codec_set_lowres(
      avctx,
      val,
    );
  }

  _dart_av_codec_set_lowres _av_codec_set_lowres;

  int av_codec_get_seek_preroll(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_codec_get_seek_preroll ??= _dylib.lookupFunction<
        _c_av_codec_get_seek_preroll,
        _dart_av_codec_get_seek_preroll>('av_codec_get_seek_preroll');
    return _av_codec_get_seek_preroll(
      avctx,
    );
  }

  _dart_av_codec_get_seek_preroll _av_codec_get_seek_preroll;

  void av_codec_set_seek_preroll(
    ffi.Pointer<AVCodecContext> avctx,
    int val,
  ) {
    _av_codec_set_seek_preroll ??= _dylib.lookupFunction<
        _c_av_codec_set_seek_preroll,
        _dart_av_codec_set_seek_preroll>('av_codec_set_seek_preroll');
    return _av_codec_set_seek_preroll(
      avctx,
      val,
    );
  }

  _dart_av_codec_set_seek_preroll _av_codec_set_seek_preroll;

  ffi.Pointer<ffi.Uint16> av_codec_get_chroma_intra_matrix(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_codec_get_chroma_intra_matrix ??= _dylib.lookupFunction<
            _c_av_codec_get_chroma_intra_matrix,
            _dart_av_codec_get_chroma_intra_matrix>(
        'av_codec_get_chroma_intra_matrix');
    return _av_codec_get_chroma_intra_matrix(
      avctx,
    );
  }

  _dart_av_codec_get_chroma_intra_matrix _av_codec_get_chroma_intra_matrix;

  void av_codec_set_chroma_intra_matrix(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Uint16> val,
  ) {
    _av_codec_set_chroma_intra_matrix ??= _dylib.lookupFunction<
            _c_av_codec_set_chroma_intra_matrix,
            _dart_av_codec_set_chroma_intra_matrix>(
        'av_codec_set_chroma_intra_matrix');
    return _av_codec_set_chroma_intra_matrix(
      avctx,
      val,
    );
  }

  _dart_av_codec_set_chroma_intra_matrix _av_codec_set_chroma_intra_matrix;

  int av_codec_get_max_lowres(
    ffi.Pointer<AVCodec> codec,
  ) {
    _av_codec_get_max_lowres ??= _dylib.lookupFunction<
        _c_av_codec_get_max_lowres,
        _dart_av_codec_get_max_lowres>('av_codec_get_max_lowres');
    return _av_codec_get_max_lowres(
      codec,
    );
  }

  _dart_av_codec_get_max_lowres _av_codec_get_max_lowres;

  /// If c is NULL, returns the first registered codec,
  /// if c is non-NULL, returns the next registered codec after c,
  /// or NULL if c is the last one.
  ffi.Pointer<AVCodec> av_codec_next(
    ffi.Pointer<AVCodec> c,
  ) {
    _av_codec_next ??= _dylib
        .lookupFunction<_c_av_codec_next, _dart_av_codec_next>('av_codec_next');
    return _av_codec_next(
      c,
    );
  }

  _dart_av_codec_next _av_codec_next;

  /// Return the LIBAVCODEC_VERSION_INT constant.
  int avcodec_version() {
    _avcodec_version ??=
        _dylib.lookupFunction<_c_avcodec_version, _dart_avcodec_version>(
            'avcodec_version');
    return _avcodec_version();
  }

  _dart_avcodec_version _avcodec_version;

  /// Return the libavcodec build-time configuration.
  ffi.Pointer<ffi.Int8> avcodec_configuration() {
    _avcodec_configuration ??= _dylib.lookupFunction<_c_avcodec_configuration,
        _dart_avcodec_configuration>('avcodec_configuration');
    return _avcodec_configuration();
  }

  _dart_avcodec_configuration _avcodec_configuration;

  /// Return the libavcodec license.
  ffi.Pointer<ffi.Int8> avcodec_license() {
    _avcodec_license ??=
        _dylib.lookupFunction<_c_avcodec_license, _dart_avcodec_license>(
            'avcodec_license');
    return _avcodec_license();
  }

  _dart_avcodec_license _avcodec_license;

  /// Register the codec codec and initialize libavcodec.
  ///
  /// @warning either this function or avcodec_register_all() must be called
  /// before any other libavcodec functions.
  ///
  /// @see avcodec_register_all()
  void avcodec_register(
    ffi.Pointer<AVCodec> codec,
  ) {
    _avcodec_register ??=
        _dylib.lookupFunction<_c_avcodec_register, _dart_avcodec_register>(
            'avcodec_register');
    return _avcodec_register(
      codec,
    );
  }

  _dart_avcodec_register _avcodec_register;

  /// Register all the codecs, parsers and bitstream filters which were enabled at
  /// configuration time. If you do not call this function you can select exactly
  /// which formats you want to support, by using the individual registration
  /// functions.
  ///
  /// @see avcodec_register
  /// @see av_register_codec_parser
  /// @see av_register_bitstream_filter
  void avcodec_register_all() {
    _avcodec_register_all ??= _dylib.lookupFunction<_c_avcodec_register_all,
        _dart_avcodec_register_all>('avcodec_register_all');
    return _avcodec_register_all();
  }

  _dart_avcodec_register_all _avcodec_register_all;

  /// Allocate an AVCodecContext and set its fields to default values. The
  /// resulting struct should be freed with avcodec_free_context().
  ///
  /// @param codec if non-NULL, allocate private data and initialize defaults
  /// for the given codec. It is illegal to then call avcodec_open2()
  /// with a different codec.
  /// If NULL, then the codec-specific defaults won't be initialized,
  /// which may result in suboptimal default settings (this is
  /// important mainly for encoders, e.g. libx264).
  ///
  /// @return An AVCodecContext filled with default values or NULL on failure.
  ffi.Pointer<AVCodecContext> avcodec_alloc_context3(
    ffi.Pointer<AVCodec> codec,
  ) {
    _avcodec_alloc_context3 ??= _dylib.lookupFunction<_c_avcodec_alloc_context3,
        _dart_avcodec_alloc_context3>('avcodec_alloc_context3');
    return _avcodec_alloc_context3(
      codec,
    );
  }

  _dart_avcodec_alloc_context3 _avcodec_alloc_context3;

  /// Free the codec context and everything associated with it and write NULL to
  /// the provided pointer.
  void avcodec_free_context(
    ffi.Pointer<ffi.Pointer<AVCodecContext>> avctx,
  ) {
    _avcodec_free_context ??= _dylib.lookupFunction<_c_avcodec_free_context,
        _dart_avcodec_free_context>('avcodec_free_context');
    return _avcodec_free_context(
      avctx,
    );
  }

  _dart_avcodec_free_context _avcodec_free_context;

  /// @deprecated This function should not be used, as closing and opening a codec
  /// context multiple time is not supported. A new codec context should be
  /// allocated for each new use.
  int avcodec_get_context_defaults3(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<AVCodec> codec,
  ) {
    _avcodec_get_context_defaults3 ??= _dylib.lookupFunction<
        _c_avcodec_get_context_defaults3,
        _dart_avcodec_get_context_defaults3>('avcodec_get_context_defaults3');
    return _avcodec_get_context_defaults3(
      s,
      codec,
    );
  }

  _dart_avcodec_get_context_defaults3 _avcodec_get_context_defaults3;

  /// Get the AVClass for AVCodecContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avcodec_get_class() {
    _avcodec_get_class ??=
        _dylib.lookupFunction<_c_avcodec_get_class, _dart_avcodec_get_class>(
            'avcodec_get_class');
    return _avcodec_get_class();
  }

  _dart_avcodec_get_class _avcodec_get_class;

  /// Get the AVClass for AVFrame. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avcodec_get_frame_class() {
    _avcodec_get_frame_class ??= _dylib.lookupFunction<
        _c_avcodec_get_frame_class,
        _dart_avcodec_get_frame_class>('avcodec_get_frame_class');
    return _avcodec_get_frame_class();
  }

  _dart_avcodec_get_frame_class _avcodec_get_frame_class;

  /// Get the AVClass for AVSubtitleRect. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avcodec_get_subtitle_rect_class() {
    _avcodec_get_subtitle_rect_class ??= _dylib.lookupFunction<
            _c_avcodec_get_subtitle_rect_class,
            _dart_avcodec_get_subtitle_rect_class>(
        'avcodec_get_subtitle_rect_class');
    return _avcodec_get_subtitle_rect_class();
  }

  _dart_avcodec_get_subtitle_rect_class _avcodec_get_subtitle_rect_class;

  /// Copy the settings of the source AVCodecContext into the destination
  /// AVCodecContext. The resulting destination codec context will be
  /// unopened, i.e. you are required to call avcodec_open2() before you
  /// can use this AVCodecContext to decode/encode video/audio data.
  ///
  /// @param dest target codec context, should be initialized with
  /// avcodec_alloc_context3(NULL), but otherwise uninitialized
  /// @param src source codec context
  /// @return AVERROR() on error (e.g. memory allocation error), 0 on success
  ///
  /// @deprecated The semantics of this function are ill-defined and it should not
  /// be used. If you need to transfer the stream parameters from one codec context
  /// to another, use an intermediate AVCodecParameters instance and the
  /// avcodec_parameters_from_context() / avcodec_parameters_to_context()
  /// functions.
  int avcodec_copy_context(
    ffi.Pointer<AVCodecContext> dest,
    ffi.Pointer<AVCodecContext> src,
  ) {
    _avcodec_copy_context ??= _dylib.lookupFunction<_c_avcodec_copy_context,
        _dart_avcodec_copy_context>('avcodec_copy_context');
    return _avcodec_copy_context(
      dest,
      src,
    );
  }

  _dart_avcodec_copy_context _avcodec_copy_context;

  /// Fill the parameters struct based on the values from the supplied codec
  /// context. Any allocated fields in par are freed and replaced with duplicates
  /// of the corresponding fields in codec.
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure
  int avcodec_parameters_from_context(
    ffi.Pointer<AVCodecParameters> par,
    ffi.Pointer<AVCodecContext> codec,
  ) {
    _avcodec_parameters_from_context ??= _dylib.lookupFunction<
            _c_avcodec_parameters_from_context,
            _dart_avcodec_parameters_from_context>(
        'avcodec_parameters_from_context');
    return _avcodec_parameters_from_context(
      par,
      codec,
    );
  }

  _dart_avcodec_parameters_from_context _avcodec_parameters_from_context;

  /// Fill the codec context based on the values from the supplied codec
  /// parameters. Any allocated fields in codec that have a corresponding field in
  /// par are freed and replaced with duplicates of the corresponding field in par.
  /// Fields in codec that do not have a counterpart in par are not touched.
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure.
  int avcodec_parameters_to_context(
    ffi.Pointer<AVCodecContext> codec,
    ffi.Pointer<AVCodecParameters> par,
  ) {
    _avcodec_parameters_to_context ??= _dylib.lookupFunction<
        _c_avcodec_parameters_to_context,
        _dart_avcodec_parameters_to_context>('avcodec_parameters_to_context');
    return _avcodec_parameters_to_context(
      codec,
      par,
    );
  }

  _dart_avcodec_parameters_to_context _avcodec_parameters_to_context;

  /// Initialize the AVCodecContext to use the given AVCodec. Prior to using this
  /// function the context has to be allocated with avcodec_alloc_context3().
  ///
  /// The functions avcodec_find_decoder_by_name(), avcodec_find_encoder_by_name(),
  /// avcodec_find_decoder() and avcodec_find_encoder() provide an easy way for
  /// retrieving a codec.
  ///
  /// @warning This function is not thread safe!
  ///
  /// @note Always call this function before using decoding routines (such as
  /// @ref avcodec_receive_frame()).
  ///
  /// @code
  /// avcodec_register_all();
  /// av_dict_set(&opts, "b", "2.5M", 0);
  /// codec = avcodec_find_decoder(AV_CODEC_ID_H264);
  /// if (!codec)
  /// exit(1);
  ///
  /// context = avcodec_alloc_context3(codec);
  ///
  /// if (avcodec_open2(context, codec, opts) < 0)
  /// exit(1);
  /// @endcode
  ///
  /// @param avctx The context to initialize.
  /// @param codec The codec to open this context for. If a non-NULL codec has been
  /// previously passed to avcodec_alloc_context3() or
  /// for this context, then this parameter MUST be either NULL or
  /// equal to the previously passed codec.
  /// @param options A dictionary filled with AVCodecContext and codec-private options.
  /// On return this object will be filled with options that were not found.
  ///
  /// @return zero on success, a negative value on error
  /// @see avcodec_alloc_context3(), avcodec_find_decoder(), avcodec_find_encoder(),
  /// av_dict_set(), av_opt_find().
  int avcodec_open2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVCodec> codec,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avcodec_open2 ??= _dylib
        .lookupFunction<_c_avcodec_open2, _dart_avcodec_open2>('avcodec_open2');
    return _avcodec_open2(
      avctx,
      codec,
      options,
    );
  }

  _dart_avcodec_open2 _avcodec_open2;

  /// Close a given AVCodecContext and free all the data associated with it
  /// (but not the AVCodecContext itself).
  ///
  /// Calling this function on an AVCodecContext that hasn't been opened will free
  /// the codec-specific data allocated in avcodec_alloc_context3() with a non-NULL
  /// codec. Subsequent calls will do nothing.
  ///
  /// @note Do not use this function. Use avcodec_free_context() to destroy a
  /// codec context (either open or closed). Opening and closing a codec context
  /// multiple times is not supported anymore -- use multiple codec contexts
  /// instead.
  int avcodec_close(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _avcodec_close ??= _dylib
        .lookupFunction<_c_avcodec_close, _dart_avcodec_close>('avcodec_close');
    return _avcodec_close(
      avctx,
    );
  }

  _dart_avcodec_close _avcodec_close;

  /// Free all allocated data in the given subtitle struct.
  ///
  /// @param sub AVSubtitle to free.
  void avsubtitle_free(
    ffi.Pointer<AVSubtitle> sub,
  ) {
    _avsubtitle_free ??=
        _dylib.lookupFunction<_c_avsubtitle_free, _dart_avsubtitle_free>(
            'avsubtitle_free');
    return _avsubtitle_free(
      sub,
    );
  }

  _dart_avsubtitle_free _avsubtitle_free;

  /// The default callback for AVCodecContext.get_buffer2(). It is made public so
  /// it can be called by custom get_buffer2() implementations for decoders without
  /// AV_CODEC_CAP_DR1 set.
  int avcodec_default_get_buffer2(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    _avcodec_default_get_buffer2 ??= _dylib.lookupFunction<
        _c_avcodec_default_get_buffer2,
        _dart_avcodec_default_get_buffer2>('avcodec_default_get_buffer2');
    return _avcodec_default_get_buffer2(
      s,
      frame,
      flags,
    );
  }

  _dart_avcodec_default_get_buffer2 _avcodec_default_get_buffer2;

  /// Modify width and height values so that they will result in a memory
  /// buffer that is acceptable for the codec if you do not use any horizontal
  /// padding.
  ///
  /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
  void avcodec_align_dimensions(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
  ) {
    _avcodec_align_dimensions ??= _dylib.lookupFunction<
        _c_avcodec_align_dimensions,
        _dart_avcodec_align_dimensions>('avcodec_align_dimensions');
    return _avcodec_align_dimensions(
      s,
      width,
      height,
    );
  }

  _dart_avcodec_align_dimensions _avcodec_align_dimensions;

  /// Modify width and height values so that they will result in a memory
  /// buffer that is acceptable for the codec if you also ensure that all
  /// line sizes are a multiple of the respective linesize_align[i].
  ///
  /// May only be used if a codec with AV_CODEC_CAP_DR1 has been opened.
  void avcodec_align_dimensions2(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<ffi.Int32> width,
    ffi.Pointer<ffi.Int32> height,
    ffi.Pointer<ffi.Int32> linesize_align,
  ) {
    _avcodec_align_dimensions2 ??= _dylib.lookupFunction<
        _c_avcodec_align_dimensions2,
        _dart_avcodec_align_dimensions2>('avcodec_align_dimensions2');
    return _avcodec_align_dimensions2(
      s,
      width,
      height,
      linesize_align,
    );
  }

  _dart_avcodec_align_dimensions2 _avcodec_align_dimensions2;

  /// Converts AVChromaLocation to swscale x/y chroma position.
  ///
  /// The positions represent the chroma (0,0) position in a coordinates system
  /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
  ///
  /// @param xpos  horizontal chroma sample position
  /// @param ypos  vertical   chroma sample position
  int avcodec_enum_to_chroma_pos(
    ffi.Pointer<ffi.Int32> xpos,
    ffi.Pointer<ffi.Int32> ypos,
    int pos,
  ) {
    _avcodec_enum_to_chroma_pos ??= _dylib.lookupFunction<
        _c_avcodec_enum_to_chroma_pos,
        _dart_avcodec_enum_to_chroma_pos>('avcodec_enum_to_chroma_pos');
    return _avcodec_enum_to_chroma_pos(
      xpos,
      ypos,
      pos,
    );
  }

  _dart_avcodec_enum_to_chroma_pos _avcodec_enum_to_chroma_pos;

  /// Converts swscale x/y chroma position to AVChromaLocation.
  ///
  /// The positions represent the chroma (0,0) position in a coordinates system
  /// with luma (0,0) representing the origin and luma(1,1) representing 256,256
  ///
  /// @param xpos  horizontal chroma sample position
  /// @param ypos  vertical   chroma sample position
  int avcodec_chroma_pos_to_enum(
    int xpos,
    int ypos,
  ) {
    _avcodec_chroma_pos_to_enum ??= _dylib.lookupFunction<
        _c_avcodec_chroma_pos_to_enum,
        _dart_avcodec_chroma_pos_to_enum>('avcodec_chroma_pos_to_enum');
    return _avcodec_chroma_pos_to_enum(
      xpos,
      ypos,
    );
  }

  _dart_avcodec_chroma_pos_to_enum _avcodec_chroma_pos_to_enum;

  /// Decode the audio frame of size avpkt->size from avpkt->data into frame.
  ///
  /// Some decoders may support multiple frames in a single AVPacket. Such
  /// decoders would then just decode the first frame and the return value would be
  /// less than the packet size. In this case, avcodec_decode_audio4 has to be
  /// called again with an AVPacket containing the remaining data in order to
  /// decode the second frame, etc...  Even if no frames are returned, the packet
  /// needs to be fed to the decoder with remaining data until it is completely
  /// consumed or an error occurs.
  ///
  /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
  /// and output. This means that for some packets they will not immediately
  /// produce decoded output and need to be flushed at the end of decoding to get
  /// all the decoded data. Flushing is done by calling this function with packets
  /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
  /// returning samples. It is safe to flush even those decoders that are not
  /// marked with AV_CODEC_CAP_DELAY, then no samples will be returned.
  ///
  /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
  /// larger than the actual read bytes because some optimized bitstream
  /// readers read 32 or 64 bits at once and could read over the end.
  ///
  /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
  /// before packets may be fed to the decoder.
  ///
  /// @param      avctx the codec context
  /// @param[out] frame The AVFrame in which to store decoded audio samples.
  /// The decoder will allocate a buffer for the decoded frame by
  /// calling the AVCodecContext.get_buffer2() callback.
  /// When AVCodecContext.refcounted_frames is set to 1, the frame is
  /// reference counted and the returned reference belongs to the
  /// caller. The caller must release the frame using av_frame_unref()
  /// when the frame is no longer needed. The caller may safely write
  /// to the frame if av_frame_is_writable() returns 1.
  /// When AVCodecContext.refcounted_frames is set to 0, the returned
  /// reference belongs to the decoder and is valid only until the
  /// next call to this function or until closing or flushing the
  /// decoder. The caller may not write to it.
  /// @param[out] got_frame_ptr Zero if no frame could be decoded, otherwise it is
  /// non-zero. Note that this field being set to zero
  /// does not mean that an error has occurred. For
  /// decoders with AV_CODEC_CAP_DELAY set, no given decode
  /// call is guaranteed to produce a frame.
  /// @param[in]  avpkt The input AVPacket containing the input buffer.
  /// At least avpkt->data and avpkt->size should be set. Some
  /// decoders might also require additional fields to be set.
  /// @return A negative error code is returned if an error occurred during
  /// decoding, otherwise the number of bytes consumed from the input
  /// AVPacket is returned.
  ///
  /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
  int avcodec_decode_audio4(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVFrame> frame,
    ffi.Pointer<ffi.Int32> got_frame_ptr,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    _avcodec_decode_audio4 ??= _dylib.lookupFunction<_c_avcodec_decode_audio4,
        _dart_avcodec_decode_audio4>('avcodec_decode_audio4');
    return _avcodec_decode_audio4(
      avctx,
      frame,
      got_frame_ptr,
      avpkt,
    );
  }

  _dart_avcodec_decode_audio4 _avcodec_decode_audio4;

  /// Decode the video frame of size avpkt->size from avpkt->data into picture.
  /// Some decoders may support multiple frames in a single AVPacket, such
  /// decoders would then just decode the first frame.
  ///
  /// @warning The input buffer must be AV_INPUT_BUFFER_PADDING_SIZE larger than
  /// the actual read bytes because some optimized bitstream readers read 32 or 64
  /// bits at once and could read over the end.
  ///
  /// @warning The end of the input buffer buf should be set to 0 to ensure that
  /// no overreading happens for damaged MPEG streams.
  ///
  /// @note Codecs which have the AV_CODEC_CAP_DELAY capability set have a delay
  /// between input and output, these need to be fed with avpkt->data=NULL,
  /// avpkt->size=0 at the end to return the remaining frames.
  ///
  /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
  /// before packets may be fed to the decoder.
  ///
  /// @param avctx the codec context
  /// @param[out] picture The AVFrame in which the decoded video frame will be stored.
  /// Use av_frame_alloc() to get an AVFrame. The codec will
  /// allocate memory for the actual bitmap by calling the
  /// AVCodecContext.get_buffer2() callback.
  /// When AVCodecContext.refcounted_frames is set to 1, the frame is
  /// reference counted and the returned reference belongs to the
  /// caller. The caller must release the frame using av_frame_unref()
  /// when the frame is no longer needed. The caller may safely write
  /// to the frame if av_frame_is_writable() returns 1.
  /// When AVCodecContext.refcounted_frames is set to 0, the returned
  /// reference belongs to the decoder and is valid only until the
  /// next call to this function or until closing or flushing the
  /// decoder. The caller may not write to it.
  ///
  /// @param[in] avpkt The input AVPacket containing the input buffer.
  /// You can create such packet with av_init_packet() and by then setting
  /// data and size, some decoders might in addition need other fields like
  /// flags&AV_PKT_FLAG_KEY. All decoders are designed to use the least
  /// fields possible.
  /// @param[in,out] got_picture_ptr Zero if no frame could be decompressed, otherwise, it is nonzero.
  /// @return On error a negative value is returned, otherwise the number of bytes
  /// used or zero if no frame could be decompressed.
  ///
  /// @deprecated Use avcodec_send_packet() and avcodec_receive_frame().
  int avcodec_decode_video2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVFrame> picture,
    ffi.Pointer<ffi.Int32> got_picture_ptr,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    _avcodec_decode_video2 ??= _dylib.lookupFunction<_c_avcodec_decode_video2,
        _dart_avcodec_decode_video2>('avcodec_decode_video2');
    return _avcodec_decode_video2(
      avctx,
      picture,
      got_picture_ptr,
      avpkt,
    );
  }

  _dart_avcodec_decode_video2 _avcodec_decode_video2;

  /// Decode a subtitle message.
  /// Return a negative value on error, otherwise return the number of bytes used.
  /// If no subtitle could be decompressed, got_sub_ptr is zero.
  /// Otherwise, the subtitle is stored in *sub.
  /// Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for
  /// simplicity, because the performance difference is expected to be negligible
  /// and reusing a get_buffer written for video codecs would probably perform badly
  /// due to a potentially very different allocation pattern.
  ///
  /// Some decoders (those marked with AV_CODEC_CAP_DELAY) have a delay between input
  /// and output. This means that for some packets they will not immediately
  /// produce decoded output and need to be flushed at the end of decoding to get
  /// all the decoded data. Flushing is done by calling this function with packets
  /// with avpkt->data set to NULL and avpkt->size set to 0 until it stops
  /// returning subtitles. It is safe to flush even those decoders that are not
  /// marked with AV_CODEC_CAP_DELAY, then no subtitles will be returned.
  ///
  /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
  /// before packets may be fed to the decoder.
  ///
  /// @param avctx the codec context
  /// @param[out] sub The preallocated AVSubtitle in which the decoded subtitle will be stored,
  /// must be freed with avsubtitle_free if *got_sub_ptr is set.
  /// @param[in,out] got_sub_ptr Zero if no subtitle could be decompressed, otherwise, it is nonzero.
  /// @param[in] avpkt The input AVPacket containing the input buffer.
  int avcodec_decode_subtitle2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVSubtitle> sub,
    ffi.Pointer<ffi.Int32> got_sub_ptr,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    _avcodec_decode_subtitle2 ??= _dylib.lookupFunction<
        _c_avcodec_decode_subtitle2,
        _dart_avcodec_decode_subtitle2>('avcodec_decode_subtitle2');
    return _avcodec_decode_subtitle2(
      avctx,
      sub,
      got_sub_ptr,
      avpkt,
    );
  }

  _dart_avcodec_decode_subtitle2 _avcodec_decode_subtitle2;

  /// Supply raw packet data as input to a decoder.
  ///
  /// Internally, this call will copy relevant AVCodecContext fields, which can
  /// influence decoding per-packet, and apply them when the packet is actually
  /// decoded. (For example AVCodecContext.skip_frame, which might direct the
  /// decoder to drop the frame contained by the packet sent with this function.)
  ///
  /// @warning The input buffer, avpkt->data must be AV_INPUT_BUFFER_PADDING_SIZE
  /// larger than the actual read bytes because some optimized bitstream
  /// readers read 32 or 64 bits at once and could read over the end.
  ///
  /// @warning Do not mix this API with the legacy API (like avcodec_decode_video2())
  /// on the same AVCodecContext. It will return unexpected results now
  /// or in future libavcodec versions.
  ///
  /// @note The AVCodecContext MUST have been opened with @ref avcodec_open2()
  /// before packets may be fed to the decoder.
  ///
  /// @param avctx codec context
  /// @param[in] avpkt The input AVPacket. Usually, this will be a single video
  /// frame, or several complete audio frames.
  /// Ownership of the packet remains with the caller, and the
  /// decoder will not write to the packet. The decoder may create
  /// a reference to the packet data (or copy it if the packet is
  /// not reference-counted).
  /// Unlike with older APIs, the packet is always fully consumed,
  /// and if it contains multiple frames (e.g. some audio codecs),
  /// will require you to call avcodec_receive_frame() multiple
  /// times afterwards before you can send a new packet.
  /// It can be NULL (or an AVPacket with data set to NULL and
  /// size set to 0); in this case, it is considered a flush
  /// packet, which signals the end of the stream. Sending the
  /// first flush packet will return success. Subsequent ones are
  /// unnecessary and will return AVERROR_EOF. If the decoder
  /// still has frames buffered, it will return them after sending
  /// a flush packet.
  ///
  /// @return 0 on success, otherwise negative error code:
  /// AVERROR(EAGAIN):   input is not accepted in the current state - user
  /// must read output with avcodec_receive_frame() (once
  /// all output is read, the packet should be resent, and
  /// the call will not fail with EAGAIN).
  /// AVERROR_EOF:       the decoder has been flushed, and no new packets can
  /// be sent to it (also returned if more than 1 flush
  /// packet is sent)
  /// AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush
  /// AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
  /// other errors: legitimate decoding errors
  int avcodec_send_packet(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    _avcodec_send_packet ??= _dylib.lookupFunction<_c_avcodec_send_packet,
        _dart_avcodec_send_packet>('avcodec_send_packet');
    return _avcodec_send_packet(
      avctx,
      avpkt,
    );
  }

  _dart_avcodec_send_packet _avcodec_send_packet;

  /// Return decoded output data from a decoder.
  ///
  /// @param avctx codec context
  /// @param frame This will be set to a reference-counted video or audio
  /// frame (depending on the decoder type) allocated by the
  /// decoder. Note that the function will always call
  /// av_frame_unref(frame) before doing anything else.
  ///
  /// @return
  /// 0:                 success, a frame was returned
  /// AVERROR(EAGAIN):   output is not available in this state - user must try
  /// to send new input
  /// AVERROR_EOF:       the decoder has been fully flushed, and there will be
  /// no more output frames
  /// AVERROR(EINVAL):   codec not opened, or it is an encoder
  /// AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters
  /// with respect to first decoded frame. Applicable
  /// when flag AV_CODEC_FLAG_DROPCHANGED is set.
  /// other negative values: legitimate decoding errors
  int avcodec_receive_frame(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    _avcodec_receive_frame ??= _dylib.lookupFunction<_c_avcodec_receive_frame,
        _dart_avcodec_receive_frame>('avcodec_receive_frame');
    return _avcodec_receive_frame(
      avctx,
      frame,
    );
  }

  _dart_avcodec_receive_frame _avcodec_receive_frame;

  /// Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet()
  /// to retrieve buffered output packets.
  ///
  /// @param avctx     codec context
  /// @param[in] frame AVFrame containing the raw audio or video frame to be encoded.
  /// Ownership of the frame remains with the caller, and the
  /// encoder will not write to the frame. The encoder may create
  /// a reference to the frame data (or copy it if the frame is
  /// not reference-counted).
  /// It can be NULL, in which case it is considered a flush
  /// packet.  This signals the end of the stream. If the encoder
  /// still has packets buffered, it will return them after this
  /// call. Once flushing mode has been entered, additional flush
  /// packets are ignored, and sending frames will return
  /// AVERROR_EOF.
  ///
  /// For audio:
  /// If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
  /// can have any number of samples.
  /// If it is not set, frame->nb_samples must be equal to
  /// avctx->frame_size for all frames except the last.
  /// The final frame may be smaller than avctx->frame_size.
  /// @return 0 on success, otherwise negative error code:
  /// AVERROR(EAGAIN):   input is not accepted in the current state - user
  /// must read output with avcodec_receive_packet() (once
  /// all output is read, the packet should be resent, and
  /// the call will not fail with EAGAIN).
  /// AVERROR_EOF:       the encoder has been flushed, and no new frames can
  /// be sent to it
  /// AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a
  /// decoder, or requires flush
  /// AVERROR(ENOMEM):   failed to add packet to internal queue, or similar
  /// other errors: legitimate encoding errors
  int avcodec_send_frame(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    _avcodec_send_frame ??=
        _dylib.lookupFunction<_c_avcodec_send_frame, _dart_avcodec_send_frame>(
            'avcodec_send_frame');
    return _avcodec_send_frame(
      avctx,
      frame,
    );
  }

  _dart_avcodec_send_frame _avcodec_send_frame;

  /// Read encoded data from the encoder.
  ///
  /// @param avctx codec context
  /// @param avpkt This will be set to a reference-counted packet allocated by the
  /// encoder. Note that the function will always call
  /// av_packet_unref(avpkt) before doing anything else.
  /// @return 0 on success, otherwise negative error code:
  /// AVERROR(EAGAIN):   output is not available in the current state - user
  /// must try to send input
  /// AVERROR_EOF:       the encoder has been fully flushed, and there will be
  /// no more output packets
  /// AVERROR(EINVAL):   codec not opened, or it is a decoder
  /// other errors: legitimate encoding errors
  int avcodec_receive_packet(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVPacket> avpkt,
  ) {
    _avcodec_receive_packet ??= _dylib.lookupFunction<_c_avcodec_receive_packet,
        _dart_avcodec_receive_packet>('avcodec_receive_packet');
    return _avcodec_receive_packet(
      avctx,
      avpkt,
    );
  }

  _dart_avcodec_receive_packet _avcodec_receive_packet;

  /// Create and return a AVHWFramesContext with values adequate for hardware
  /// decoding. This is meant to get called from the get_format callback, and is
  /// a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx.
  /// This API is for decoding with certain hardware acceleration modes/APIs only.
  ///
  /// The returned AVHWFramesContext is not initialized. The caller must do this
  /// with av_hwframe_ctx_init().
  ///
  /// Calling this function is not a requirement, but makes it simpler to avoid
  /// codec or hardware API specific details when manually allocating frames.
  ///
  /// Alternatively to this, an API user can set AVCodecContext.hw_device_ctx,
  /// which sets up AVCodecContext.hw_frames_ctx fully automatically, and makes
  /// it unnecessary to call this function or having to care about
  /// AVHWFramesContext initialization at all.
  ///
  /// There are a number of requirements for calling this function:
  ///
  /// - It must be called from get_format with the same avctx parameter that was
  /// passed to get_format. Calling it outside of get_format is not allowed, and
  /// can trigger undefined behavior.
  /// - The function is not always supported (see description of return values).
  /// Even if this function returns successfully, hwaccel initialization could
  /// fail later. (The degree to which implementations check whether the stream
  /// is actually supported varies. Some do this check only after the user's
  /// get_format callback returns.)
  /// - The hw_pix_fmt must be one of the choices suggested by get_format. If the
  /// user decides to use a AVHWFramesContext prepared with this API function,
  /// the user must return the same hw_pix_fmt from get_format.
  /// - The device_ref passed to this function must support the given hw_pix_fmt.
  /// - After calling this API function, it is the user's responsibility to
  /// initialize the AVHWFramesContext (returned by the out_frames_ref parameter),
  /// and to set AVCodecContext.hw_frames_ctx to it. If done, this must be done
  /// before returning from get_format (this is implied by the normal
  /// AVCodecContext.hw_frames_ctx API rules).
  /// - The AVHWFramesContext parameters may change every time time get_format is
  /// called. Also, AVCodecContext.hw_frames_ctx is reset before get_format. So
  /// you are inherently required to go through this process again on every
  /// get_format call.
  /// - It is perfectly possible to call this function without actually using
  /// the resulting AVHWFramesContext. One use-case might be trying to reuse a
  /// previously initialized AVHWFramesContext, and calling this API function
  /// only to test whether the required frame parameters have changed.
  /// - Fields that use dynamically allocated values of any kind must not be set
  /// by the user unless setting them is explicitly allowed by the documentation.
  /// If the user sets AVHWFramesContext.free and AVHWFramesContext.user_opaque,
  /// the new free callback must call the potentially set previous free callback.
  /// This API call may set any dynamically allocated fields, including the free
  /// callback.
  ///
  /// The function will set at least the following fields on AVHWFramesContext
  /// (potentially more, depending on hwaccel API):
  ///
  /// - All fields set by av_hwframe_ctx_alloc().
  /// - Set the format field to hw_pix_fmt.
  /// - Set the sw_format field to the most suited and most versatile format. (An
  /// implication is that this will prefer generic formats over opaque formats
  /// with arbitrary restrictions, if possible.)
  /// - Set the width/height fields to the coded frame size, rounded up to the
  /// API-specific minimum alignment.
  /// - Only _if_ the hwaccel requires a pre-allocated pool: set the initial_pool_size
  /// field to the number of maximum reference surfaces possible with the codec,
  /// plus 1 surface for the user to work (meaning the user can safely reference
  /// at most 1 decoded surface at a time), plus additional buffering introduced
  /// by frame threading. If the hwaccel does not require pre-allocation, the
  /// field is left to 0, and the decoder will allocate new surfaces on demand
  /// during decoding.
  /// - Possibly AVHWFramesContext.hwctx fields, depending on the underlying
  /// hardware API.
  ///
  /// Essentially, out_frames_ref returns the same as av_hwframe_ctx_alloc(), but
  /// with basic frame parameters set.
  ///
  /// The function is stateless, and does not change the AVCodecContext or the
  /// device_ref AVHWDeviceContext.
  ///
  /// @param avctx The context which is currently calling get_format, and which
  /// implicitly contains all state needed for filling the returned
  /// AVHWFramesContext properly.
  /// @param device_ref A reference to the AVHWDeviceContext describing the device
  /// which will be used by the hardware decoder.
  /// @param hw_pix_fmt The hwaccel format you are going to return from get_format.
  /// @param out_frames_ref On success, set to a reference to an _uninitialized_
  /// AVHWFramesContext, created from the given device_ref.
  /// Fields will be set to values required for decoding.
  /// Not changed if an error is returned.
  /// @return zero on success, a negative value on error. The following error codes
  /// have special semantics:
  /// AVERROR(ENOENT): the decoder does not support this functionality. Setup
  /// is always manual, or it is a decoder which does not
  /// support setting AVCodecContext.hw_frames_ctx at all,
  /// or it is a software format.
  /// AVERROR(EINVAL): it is known that hardware decoding is not supported for
  /// this configuration, or the device_ref is not supported
  /// for the hwaccel referenced by hw_pix_fmt.
  int avcodec_get_hw_frames_parameters(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVBufferRef> device_ref,
    int hw_pix_fmt,
    ffi.Pointer<ffi.Pointer<AVBufferRef>> out_frames_ref,
  ) {
    _avcodec_get_hw_frames_parameters ??= _dylib.lookupFunction<
            _c_avcodec_get_hw_frames_parameters,
            _dart_avcodec_get_hw_frames_parameters>(
        'avcodec_get_hw_frames_parameters');
    return _avcodec_get_hw_frames_parameters(
      avctx,
      device_ref,
      hw_pix_fmt,
      out_frames_ref,
    );
  }

  _dart_avcodec_get_hw_frames_parameters _avcodec_get_hw_frames_parameters;

  /// Iterate over all registered codec parsers.
  ///
  /// @param opaque a pointer where libavcodec will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered codec parser or NULL when the iteration is
  /// finished
  ffi.Pointer<AVCodecParser> av_parser_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    _av_parser_iterate ??=
        _dylib.lookupFunction<_c_av_parser_iterate, _dart_av_parser_iterate>(
            'av_parser_iterate');
    return _av_parser_iterate(
      opaque,
    );
  }

  _dart_av_parser_iterate _av_parser_iterate;

  ffi.Pointer<AVCodecParser> av_parser_next(
    ffi.Pointer<AVCodecParser> c,
  ) {
    _av_parser_next ??=
        _dylib.lookupFunction<_c_av_parser_next, _dart_av_parser_next>(
            'av_parser_next');
    return _av_parser_next(
      c,
    );
  }

  _dart_av_parser_next _av_parser_next;

  void av_register_codec_parser(
    ffi.Pointer<AVCodecParser> parser,
  ) {
    _av_register_codec_parser ??= _dylib.lookupFunction<
        _c_av_register_codec_parser,
        _dart_av_register_codec_parser>('av_register_codec_parser');
    return _av_register_codec_parser(
      parser,
    );
  }

  _dart_av_register_codec_parser _av_register_codec_parser;

  ffi.Pointer<AVCodecParserContext> av_parser_init(
    int codec_id,
  ) {
    _av_parser_init ??=
        _dylib.lookupFunction<_c_av_parser_init, _dart_av_parser_init>(
            'av_parser_init');
    return _av_parser_init(
      codec_id,
    );
  }

  _dart_av_parser_init _av_parser_init;

  /// Parse a packet.
  ///
  /// @param s             parser context.
  /// @param avctx         codec context.
  /// @param poutbuf       set to pointer to parsed buffer or NULL if not yet finished.
  /// @param poutbuf_size  set to size of parsed buffer or zero if not yet finished.
  /// @param buf           input buffer.
  /// @param buf_size      buffer size in bytes without the padding. I.e. the full buffer
  /// size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE.
  /// To signal EOF, this should be 0 (so that the last frame
  /// can be output).
  /// @param pts           input presentation timestamp.
  /// @param dts           input decoding timestamp.
  /// @param pos           input byte position in stream.
  /// @return the number of bytes of the input bitstream used.
  ///
  /// Example:
  /// @code
  /// while(in_len){
  /// len = av_parser_parse2(myparser, AVCodecContext, &data, &size,
  /// in_data, in_len,
  /// pts, dts, pos);
  /// in_data += len;
  /// in_len  -= len;
  ///
  /// if(size)
  /// decode_frame(data, size);
  /// }
  /// @endcode
  int av_parser_parse2(
    ffi.Pointer<AVCodecParserContext> s,
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
    ffi.Pointer<ffi.Int32> poutbuf_size,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    int pts,
    int dts,
    int pos,
  ) {
    _av_parser_parse2 ??=
        _dylib.lookupFunction<_c_av_parser_parse2, _dart_av_parser_parse2>(
            'av_parser_parse2');
    return _av_parser_parse2(
      s,
      avctx,
      poutbuf,
      poutbuf_size,
      buf,
      buf_size,
      pts,
      dts,
      pos,
    );
  }

  _dart_av_parser_parse2 _av_parser_parse2;

  /// @return 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed
  /// @deprecated use AVBitStreamFilter
  int av_parser_change(
    ffi.Pointer<AVCodecParserContext> s,
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
    ffi.Pointer<ffi.Int32> poutbuf_size,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    int keyframe,
  ) {
    _av_parser_change ??=
        _dylib.lookupFunction<_c_av_parser_change, _dart_av_parser_change>(
            'av_parser_change');
    return _av_parser_change(
      s,
      avctx,
      poutbuf,
      poutbuf_size,
      buf,
      buf_size,
      keyframe,
    );
  }

  _dart_av_parser_change _av_parser_change;

  void av_parser_close(
    ffi.Pointer<AVCodecParserContext> s,
  ) {
    _av_parser_close ??=
        _dylib.lookupFunction<_c_av_parser_close, _dart_av_parser_close>(
            'av_parser_close');
    return _av_parser_close(
      s,
    );
  }

  _dart_av_parser_close _av_parser_close;

  /// Encode a frame of audio.
  ///
  /// Takes input samples from frame and writes the next output packet, if
  /// available, to avpkt. The output packet does not necessarily contain data for
  /// the most recent frame, as encoders can delay, split, and combine input frames
  /// internally as needed.
  ///
  /// @param avctx     codec context
  /// @param avpkt     output AVPacket.
  /// The user can supply an output buffer by setting
  /// avpkt->data and avpkt->size prior to calling the
  /// function, but if the size of the user-provided data is not
  /// large enough, encoding will fail. If avpkt->data and
  /// avpkt->size are set, avpkt->destruct must also be set. All
  /// other AVPacket fields will be reset by the encoder using
  /// av_init_packet(). If avpkt->data is NULL, the encoder will
  /// allocate it. The encoder will set avpkt->size to the size
  /// of the output packet.
  ///
  /// If this function fails or produces no output, avpkt will be
  /// freed using av_packet_unref().
  /// @param[in] frame AVFrame containing the raw audio data to be encoded.
  /// May be NULL when flushing an encoder that has the
  /// AV_CODEC_CAP_DELAY capability set.
  /// If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame
  /// can have any number of samples.
  /// If it is not set, frame->nb_samples must be equal to
  /// avctx->frame_size for all frames except the last.
  /// The final frame may be smaller than avctx->frame_size.
  /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
  /// output packet is non-empty, and to 0 if it is
  /// empty. If the function returns an error, the
  /// packet can be assumed to be invalid, and the
  /// value of got_packet_ptr is undefined and should
  /// not be used.
  /// @return          0 on success, negative error code on failure
  ///
  /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
  int avcodec_encode_audio2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVPacket> avpkt,
    ffi.Pointer<AVFrame> frame,
    ffi.Pointer<ffi.Int32> got_packet_ptr,
  ) {
    _avcodec_encode_audio2 ??= _dylib.lookupFunction<_c_avcodec_encode_audio2,
        _dart_avcodec_encode_audio2>('avcodec_encode_audio2');
    return _avcodec_encode_audio2(
      avctx,
      avpkt,
      frame,
      got_packet_ptr,
    );
  }

  _dart_avcodec_encode_audio2 _avcodec_encode_audio2;

  /// Encode a frame of video.
  ///
  /// Takes input raw video data from frame and writes the next output packet, if
  /// available, to avpkt. The output packet does not necessarily contain data for
  /// the most recent frame, as encoders can delay and reorder input frames
  /// internally as needed.
  ///
  /// @param avctx     codec context
  /// @param avpkt     output AVPacket.
  /// The user can supply an output buffer by setting
  /// avpkt->data and avpkt->size prior to calling the
  /// function, but if the size of the user-provided data is not
  /// large enough, encoding will fail. All other AVPacket fields
  /// will be reset by the encoder using av_init_packet(). If
  /// avpkt->data is NULL, the encoder will allocate it.
  /// The encoder will set avpkt->size to the size of the
  /// output packet. The returned data (if any) belongs to the
  /// caller, he is responsible for freeing it.
  ///
  /// If this function fails or produces no output, avpkt will be
  /// freed using av_packet_unref().
  /// @param[in] frame AVFrame containing the raw video data to be encoded.
  /// May be NULL when flushing an encoder that has the
  /// AV_CODEC_CAP_DELAY capability set.
  /// @param[out] got_packet_ptr This field is set to 1 by libavcodec if the
  /// output packet is non-empty, and to 0 if it is
  /// empty. If the function returns an error, the
  /// packet can be assumed to be invalid, and the
  /// value of got_packet_ptr is undefined and should
  /// not be used.
  /// @return          0 on success, negative error code on failure
  ///
  /// @deprecated use avcodec_send_frame()/avcodec_receive_packet() instead
  int avcodec_encode_video2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVPacket> avpkt,
    ffi.Pointer<AVFrame> frame,
    ffi.Pointer<ffi.Int32> got_packet_ptr,
  ) {
    _avcodec_encode_video2 ??= _dylib.lookupFunction<_c_avcodec_encode_video2,
        _dart_avcodec_encode_video2>('avcodec_encode_video2');
    return _avcodec_encode_video2(
      avctx,
      avpkt,
      frame,
      got_packet_ptr,
    );
  }

  _dart_avcodec_encode_video2 _avcodec_encode_video2;

  int avcodec_encode_subtitle(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    ffi.Pointer<AVSubtitle> sub,
  ) {
    _avcodec_encode_subtitle ??= _dylib.lookupFunction<
        _c_avcodec_encode_subtitle,
        _dart_avcodec_encode_subtitle>('avcodec_encode_subtitle');
    return _avcodec_encode_subtitle(
      avctx,
      buf,
      buf_size,
      sub,
    );
  }

  _dart_avcodec_encode_subtitle _avcodec_encode_subtitle;

  /// @deprecated unused
  int avpicture_alloc(
    ffi.Pointer<AVPicture> picture,
    int pix_fmt,
    int width,
    int height,
  ) {
    _avpicture_alloc ??=
        _dylib.lookupFunction<_c_avpicture_alloc, _dart_avpicture_alloc>(
            'avpicture_alloc');
    return _avpicture_alloc(
      picture,
      pix_fmt,
      width,
      height,
    );
  }

  _dart_avpicture_alloc _avpicture_alloc;

  /// @deprecated unused
  void avpicture_free(
    ffi.Pointer<AVPicture> picture,
  ) {
    _avpicture_free ??=
        _dylib.lookupFunction<_c_avpicture_free, _dart_avpicture_free>(
            'avpicture_free');
    return _avpicture_free(
      picture,
    );
  }

  _dart_avpicture_free _avpicture_free;

  /// @deprecated use av_image_fill_arrays() instead.
  int avpicture_fill(
    ffi.Pointer<AVPicture> picture,
    ffi.Pointer<ffi.Uint8> ptr,
    int pix_fmt,
    int width,
    int height,
  ) {
    _avpicture_fill ??=
        _dylib.lookupFunction<_c_avpicture_fill, _dart_avpicture_fill>(
            'avpicture_fill');
    return _avpicture_fill(
      picture,
      ptr,
      pix_fmt,
      width,
      height,
    );
  }

  _dart_avpicture_fill _avpicture_fill;

  /// @deprecated use av_image_copy_to_buffer() instead.
  int avpicture_layout(
    ffi.Pointer<AVPicture> src,
    int pix_fmt,
    int width,
    int height,
    ffi.Pointer<ffi.Uint8> dest,
    int dest_size,
  ) {
    _avpicture_layout ??=
        _dylib.lookupFunction<_c_avpicture_layout, _dart_avpicture_layout>(
            'avpicture_layout');
    return _avpicture_layout(
      src,
      pix_fmt,
      width,
      height,
      dest,
      dest_size,
    );
  }

  _dart_avpicture_layout _avpicture_layout;

  /// @deprecated use av_image_get_buffer_size() instead.
  int avpicture_get_size(
    int pix_fmt,
    int width,
    int height,
  ) {
    _avpicture_get_size ??=
        _dylib.lookupFunction<_c_avpicture_get_size, _dart_avpicture_get_size>(
            'avpicture_get_size');
    return _avpicture_get_size(
      pix_fmt,
      width,
      height,
    );
  }

  _dart_avpicture_get_size _avpicture_get_size;

  /// @deprecated av_image_copy() instead.
  void av_picture_copy(
    ffi.Pointer<AVPicture> dst,
    ffi.Pointer<AVPicture> src,
    int pix_fmt,
    int width,
    int height,
  ) {
    _av_picture_copy ??=
        _dylib.lookupFunction<_c_av_picture_copy, _dart_av_picture_copy>(
            'av_picture_copy');
    return _av_picture_copy(
      dst,
      src,
      pix_fmt,
      width,
      height,
    );
  }

  _dart_av_picture_copy _av_picture_copy;

  /// @deprecated unused
  int av_picture_crop(
    ffi.Pointer<AVPicture> dst,
    ffi.Pointer<AVPicture> src,
    int pix_fmt,
    int top_band,
    int left_band,
  ) {
    _av_picture_crop ??=
        _dylib.lookupFunction<_c_av_picture_crop, _dart_av_picture_crop>(
            'av_picture_crop');
    return _av_picture_crop(
      dst,
      src,
      pix_fmt,
      top_band,
      left_band,
    );
  }

  _dart_av_picture_crop _av_picture_crop;

  /// @deprecated unused
  int av_picture_pad(
    ffi.Pointer<AVPicture> dst,
    ffi.Pointer<AVPicture> src,
    int height,
    int width,
    int pix_fmt,
    int padtop,
    int padbottom,
    int padleft,
    int padright,
    ffi.Pointer<ffi.Int32> color,
  ) {
    _av_picture_pad ??=
        _dylib.lookupFunction<_c_av_picture_pad, _dart_av_picture_pad>(
            'av_picture_pad');
    return _av_picture_pad(
      dst,
      src,
      height,
      width,
      pix_fmt,
      padtop,
      padbottom,
      padleft,
      padright,
      color,
    );
  }

  _dart_av_picture_pad _av_picture_pad;

  /// @deprecated Use av_pix_fmt_get_chroma_sub_sample
  void avcodec_get_chroma_sub_sample(
    int pix_fmt,
    ffi.Pointer<ffi.Int32> h_shift,
    ffi.Pointer<ffi.Int32> v_shift,
  ) {
    _avcodec_get_chroma_sub_sample ??= _dylib.lookupFunction<
        _c_avcodec_get_chroma_sub_sample,
        _dart_avcodec_get_chroma_sub_sample>('avcodec_get_chroma_sub_sample');
    return _avcodec_get_chroma_sub_sample(
      pix_fmt,
      h_shift,
      v_shift,
    );
  }

  _dart_avcodec_get_chroma_sub_sample _avcodec_get_chroma_sub_sample;

  /// Return a value representing the fourCC code associated to the
  /// pixel format pix_fmt, or 0 if no associated fourCC code can be
  /// found.
  int avcodec_pix_fmt_to_codec_tag(
    int pix_fmt,
  ) {
    _avcodec_pix_fmt_to_codec_tag ??= _dylib.lookupFunction<
        _c_avcodec_pix_fmt_to_codec_tag,
        _dart_avcodec_pix_fmt_to_codec_tag>('avcodec_pix_fmt_to_codec_tag');
    return _avcodec_pix_fmt_to_codec_tag(
      pix_fmt,
    );
  }

  _dart_avcodec_pix_fmt_to_codec_tag _avcodec_pix_fmt_to_codec_tag;

  /// @deprecated see av_get_pix_fmt_loss()
  int avcodec_get_pix_fmt_loss(
    int dst_pix_fmt,
    int src_pix_fmt,
    int has_alpha,
  ) {
    _avcodec_get_pix_fmt_loss ??= _dylib.lookupFunction<
        _c_avcodec_get_pix_fmt_loss,
        _dart_avcodec_get_pix_fmt_loss>('avcodec_get_pix_fmt_loss');
    return _avcodec_get_pix_fmt_loss(
      dst_pix_fmt,
      src_pix_fmt,
      has_alpha,
    );
  }

  _dart_avcodec_get_pix_fmt_loss _avcodec_get_pix_fmt_loss;

  /// Find the best pixel format to convert to given a certain source pixel
  /// format.  When converting from one pixel format to another, information loss
  /// may occur.  For example, when converting from RGB24 to GRAY, the color
  /// information will be lost. Similarly, other losses occur when converting from
  /// some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of
  /// the given pixel formats should be used to suffer the least amount of loss.
  /// The pixel formats from which it chooses one, are determined by the
  /// pix_fmt_list parameter.
  ///
  ///
  /// @param[in] pix_fmt_list AV_PIX_FMT_NONE terminated array of pixel formats to choose from
  /// @param[in] src_pix_fmt source pixel format
  /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
  /// @param[out] loss_ptr Combination of flags informing you what kind of losses will occur.
  /// @return The best pixel format to convert to or -1 if none was found.
  int avcodec_find_best_pix_fmt_of_list(
    ffi.Pointer<ffi.Int32> pix_fmt_list,
    int src_pix_fmt,
    int has_alpha,
    ffi.Pointer<ffi.Int32> loss_ptr,
  ) {
    _avcodec_find_best_pix_fmt_of_list ??= _dylib.lookupFunction<
            _c_avcodec_find_best_pix_fmt_of_list,
            _dart_avcodec_find_best_pix_fmt_of_list>(
        'avcodec_find_best_pix_fmt_of_list');
    return _avcodec_find_best_pix_fmt_of_list(
      pix_fmt_list,
      src_pix_fmt,
      has_alpha,
      loss_ptr,
    );
  }

  _dart_avcodec_find_best_pix_fmt_of_list _avcodec_find_best_pix_fmt_of_list;

  /// @deprecated see av_find_best_pix_fmt_of_2()
  int avcodec_find_best_pix_fmt_of_2(
    int dst_pix_fmt1,
    int dst_pix_fmt2,
    int src_pix_fmt,
    int has_alpha,
    ffi.Pointer<ffi.Int32> loss_ptr,
  ) {
    _avcodec_find_best_pix_fmt_of_2 ??= _dylib.lookupFunction<
        _c_avcodec_find_best_pix_fmt_of_2,
        _dart_avcodec_find_best_pix_fmt_of_2>('avcodec_find_best_pix_fmt_of_2');
    return _avcodec_find_best_pix_fmt_of_2(
      dst_pix_fmt1,
      dst_pix_fmt2,
      src_pix_fmt,
      has_alpha,
      loss_ptr,
    );
  }

  _dart_avcodec_find_best_pix_fmt_of_2 _avcodec_find_best_pix_fmt_of_2;

  int avcodec_find_best_pix_fmt2(
    int dst_pix_fmt1,
    int dst_pix_fmt2,
    int src_pix_fmt,
    int has_alpha,
    ffi.Pointer<ffi.Int32> loss_ptr,
  ) {
    _avcodec_find_best_pix_fmt2 ??= _dylib.lookupFunction<
        _c_avcodec_find_best_pix_fmt2,
        _dart_avcodec_find_best_pix_fmt2>('avcodec_find_best_pix_fmt2');
    return _avcodec_find_best_pix_fmt2(
      dst_pix_fmt1,
      dst_pix_fmt2,
      src_pix_fmt,
      has_alpha,
      loss_ptr,
    );
  }

  _dart_avcodec_find_best_pix_fmt2 _avcodec_find_best_pix_fmt2;

  int avcodec_default_get_format(
    ffi.Pointer<AVCodecContext> s,
    ffi.Pointer<ffi.Int32> fmt,
  ) {
    _avcodec_default_get_format ??= _dylib.lookupFunction<
        _c_avcodec_default_get_format,
        _dart_avcodec_default_get_format>('avcodec_default_get_format');
    return _avcodec_default_get_format(
      s,
      fmt,
    );
  }

  _dart_avcodec_default_get_format _avcodec_default_get_format;

  /// Put a string representing the codec tag codec_tag in buf.
  ///
  /// @param buf       buffer to place codec tag in
  /// @param buf_size size in bytes of buf
  /// @param codec_tag codec tag to assign
  /// @return the length of the string that would have been generated if
  /// enough space had been available, excluding the trailing null
  ///
  /// @deprecated see av_fourcc_make_string() and av_fourcc2str().
  int av_get_codec_tag_string(
    ffi.Pointer<ffi.Int8> buf,
    int buf_size,
    int codec_tag,
  ) {
    _av_get_codec_tag_string ??= _dylib.lookupFunction<
        _c_av_get_codec_tag_string,
        _dart_av_get_codec_tag_string>('av_get_codec_tag_string');
    return _av_get_codec_tag_string(
      buf,
      buf_size,
      codec_tag,
    );
  }

  _dart_av_get_codec_tag_string _av_get_codec_tag_string;

  void avcodec_string(
    ffi.Pointer<ffi.Int8> buf,
    int buf_size,
    ffi.Pointer<AVCodecContext> enc,
    int encode,
  ) {
    _avcodec_string ??=
        _dylib.lookupFunction<_c_avcodec_string, _dart_avcodec_string>(
            'avcodec_string');
    return _avcodec_string(
      buf,
      buf_size,
      enc,
      encode,
    );
  }

  _dart_avcodec_string _avcodec_string;

  /// Return a name for the specified profile, if available.
  ///
  /// @param codec the codec that is searched for the given profile
  /// @param profile the profile value for which a name is requested
  /// @return A name for the profile if found, NULL otherwise.
  ffi.Pointer<ffi.Int8> av_get_profile_name(
    ffi.Pointer<AVCodec> codec,
    int profile,
  ) {
    _av_get_profile_name ??= _dylib.lookupFunction<_c_av_get_profile_name,
        _dart_av_get_profile_name>('av_get_profile_name');
    return _av_get_profile_name(
      codec,
      profile,
    );
  }

  _dart_av_get_profile_name _av_get_profile_name;

  /// Return a name for the specified profile, if available.
  ///
  /// @param codec_id the ID of the codec to which the requested profile belongs
  /// @param profile the profile value for which a name is requested
  /// @return A name for the profile if found, NULL otherwise.
  ///
  /// @note unlike av_get_profile_name(), which searches a list of profiles
  /// supported by a specific decoder or encoder implementation, this
  /// function searches the list of profiles from the AVCodecDescriptor
  ffi.Pointer<ffi.Int8> avcodec_profile_name(
    int codec_id,
    int profile,
  ) {
    _avcodec_profile_name ??= _dylib.lookupFunction<_c_avcodec_profile_name,
        _dart_avcodec_profile_name>('avcodec_profile_name');
    return _avcodec_profile_name(
      codec_id,
      profile,
    );
  }

  _dart_avcodec_profile_name _avcodec_profile_name;

  int avcodec_default_execute(
    ffi.Pointer<AVCodecContext> c,
    ffi.Pointer<ffi.NativeFunction<_typedefC_41>> func,
    ffi.Pointer<ffi.Void> arg,
    ffi.Pointer<ffi.Int32> ret,
    int count,
    int size,
  ) {
    _avcodec_default_execute ??= _dylib.lookupFunction<
        _c_avcodec_default_execute,
        _dart_avcodec_default_execute>('avcodec_default_execute');
    return _avcodec_default_execute(
      c,
      func,
      arg,
      ret,
      count,
      size,
    );
  }

  _dart_avcodec_default_execute _avcodec_default_execute;

  int avcodec_default_execute2(
    ffi.Pointer<AVCodecContext> c,
    ffi.Pointer<ffi.NativeFunction<_typedefC_42>> func,
    ffi.Pointer<ffi.Void> arg,
    ffi.Pointer<ffi.Int32> ret,
    int count,
  ) {
    _avcodec_default_execute2 ??= _dylib.lookupFunction<
        _c_avcodec_default_execute2,
        _dart_avcodec_default_execute2>('avcodec_default_execute2');
    return _avcodec_default_execute2(
      c,
      func,
      arg,
      ret,
      count,
    );
  }

  _dart_avcodec_default_execute2 _avcodec_default_execute2;

  /// Fill AVFrame audio data and linesize pointers.
  ///
  /// The buffer buf must be a preallocated buffer with a size big enough
  /// to contain the specified samples amount. The filled AVFrame data
  /// pointers will point to this buffer.
  ///
  /// AVFrame extended_data channel pointers are allocated if necessary for
  /// planar audio.
  ///
  /// @param frame       the AVFrame
  /// frame->nb_samples must be set prior to calling the
  /// function. This function fills in frame->data,
  /// frame->extended_data, frame->linesize[0].
  /// @param nb_channels channel count
  /// @param sample_fmt  sample format
  /// @param buf         buffer to use for frame data
  /// @param buf_size    size of buffer
  /// @param align       plane size sample alignment (0 = default)
  /// @return            >=0 on success, negative error code on failure
  /// @todo return the size in bytes required to store the samples in
  /// case of success, at the next libavutil bump
  int avcodec_fill_audio_frame(
    ffi.Pointer<AVFrame> frame,
    int nb_channels,
    int sample_fmt,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    int align,
  ) {
    _avcodec_fill_audio_frame ??= _dylib.lookupFunction<
        _c_avcodec_fill_audio_frame,
        _dart_avcodec_fill_audio_frame>('avcodec_fill_audio_frame');
    return _avcodec_fill_audio_frame(
      frame,
      nb_channels,
      sample_fmt,
      buf,
      buf_size,
      align,
    );
  }

  _dart_avcodec_fill_audio_frame _avcodec_fill_audio_frame;

  /// Reset the internal codec state / flush internal buffers. Should be called
  /// e.g. when seeking or when switching to a different stream.
  ///
  /// @note for decoders, when refcounted frames are not used
  /// (i.e. avctx->refcounted_frames is 0), this invalidates the frames previously
  /// returned from the decoder. When refcounted frames are used, the decoder just
  /// releases any references it might keep internally, but the caller's reference
  /// remains valid.
  ///
  /// @note for encoders, this function will only do something if the encoder
  /// declares support for AV_CODEC_CAP_ENCODER_FLUSH. When called, the encoder
  /// will drain any remaining packets, and can then be re-used for a different
  /// stream (as opposed to sending a null frame which will leave the encoder
  /// in a permanent EOF state after draining). This can be desirable if the
  /// cost of tearing down and replacing the encoder instance is high.
  void avcodec_flush_buffers(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _avcodec_flush_buffers ??= _dylib.lookupFunction<_c_avcodec_flush_buffers,
        _dart_avcodec_flush_buffers>('avcodec_flush_buffers');
    return _avcodec_flush_buffers(
      avctx,
    );
  }

  _dart_avcodec_flush_buffers _avcodec_flush_buffers;

  /// Return codec bits per sample.
  ///
  /// @param[in] codec_id the codec
  /// @return Number of bits per sample or zero if unknown for the given codec.
  int av_get_bits_per_sample(
    int codec_id,
  ) {
    _av_get_bits_per_sample ??= _dylib.lookupFunction<_c_av_get_bits_per_sample,
        _dart_av_get_bits_per_sample>('av_get_bits_per_sample');
    return _av_get_bits_per_sample(
      codec_id,
    );
  }

  _dart_av_get_bits_per_sample _av_get_bits_per_sample;

  /// Return the PCM codec associated with a sample format.
  /// @param be  endianness, 0 for little, 1 for big,
  /// -1 (or anything else) for native
  /// @return  AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE
  int av_get_pcm_codec(
    int fmt,
    int be,
  ) {
    _av_get_pcm_codec ??=
        _dylib.lookupFunction<_c_av_get_pcm_codec, _dart_av_get_pcm_codec>(
            'av_get_pcm_codec');
    return _av_get_pcm_codec(
      fmt,
      be,
    );
  }

  _dart_av_get_pcm_codec _av_get_pcm_codec;

  /// Return codec bits per sample.
  /// Only return non-zero if the bits per sample is exactly correct, not an
  /// approximation.
  ///
  /// @param[in] codec_id the codec
  /// @return Number of bits per sample or zero if unknown for the given codec.
  int av_get_exact_bits_per_sample(
    int codec_id,
  ) {
    _av_get_exact_bits_per_sample ??= _dylib.lookupFunction<
        _c_av_get_exact_bits_per_sample,
        _dart_av_get_exact_bits_per_sample>('av_get_exact_bits_per_sample');
    return _av_get_exact_bits_per_sample(
      codec_id,
    );
  }

  _dart_av_get_exact_bits_per_sample _av_get_exact_bits_per_sample;

  /// Return audio frame duration.
  ///
  /// @param avctx        codec context
  /// @param frame_bytes  size of the frame, or 0 if unknown
  /// @return             frame duration, in samples, if known. 0 if not able to
  /// determine.
  int av_get_audio_frame_duration(
    ffi.Pointer<AVCodecContext> avctx,
    int frame_bytes,
  ) {
    _av_get_audio_frame_duration ??= _dylib.lookupFunction<
        _c_av_get_audio_frame_duration,
        _dart_av_get_audio_frame_duration>('av_get_audio_frame_duration');
    return _av_get_audio_frame_duration(
      avctx,
      frame_bytes,
    );
  }

  _dart_av_get_audio_frame_duration _av_get_audio_frame_duration;

  /// This function is the same as av_get_audio_frame_duration(), except it works
  /// with AVCodecParameters instead of an AVCodecContext.
  int av_get_audio_frame_duration2(
    ffi.Pointer<AVCodecParameters> par,
    int frame_bytes,
  ) {
    _av_get_audio_frame_duration2 ??= _dylib.lookupFunction<
        _c_av_get_audio_frame_duration2,
        _dart_av_get_audio_frame_duration2>('av_get_audio_frame_duration2');
    return _av_get_audio_frame_duration2(
      par,
      frame_bytes,
    );
  }

  _dart_av_get_audio_frame_duration2 _av_get_audio_frame_duration2;

  /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
  /// is deprecated. Use the new bitstream filtering API (using AVBSFContext).
  void av_register_bitstream_filter(
    ffi.Pointer<AVBitStreamFilter> bsf,
  ) {
    _av_register_bitstream_filter ??= _dylib.lookupFunction<
        _c_av_register_bitstream_filter,
        _dart_av_register_bitstream_filter>('av_register_bitstream_filter');
    return _av_register_bitstream_filter(
      bsf,
    );
  }

  _dart_av_register_bitstream_filter _av_register_bitstream_filter;

  /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
  /// is deprecated. Use av_bsf_get_by_name(), av_bsf_alloc(), and av_bsf_init()
  /// from the new bitstream filtering API (using AVBSFContext).
  ffi.Pointer<AVBitStreamFilterContext> av_bitstream_filter_init(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_bitstream_filter_init ??= _dylib.lookupFunction<
        _c_av_bitstream_filter_init,
        _dart_av_bitstream_filter_init>('av_bitstream_filter_init');
    return _av_bitstream_filter_init(
      name,
    );
  }

  _dart_av_bitstream_filter_init _av_bitstream_filter_init;

  /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
  /// is deprecated. Use av_bsf_send_packet() and av_bsf_receive_packet() from the
  /// new bitstream filtering API (using AVBSFContext).
  int av_bitstream_filter_filter(
    ffi.Pointer<AVBitStreamFilterContext> bsfc,
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Int8> args,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
    ffi.Pointer<ffi.Int32> poutbuf_size,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    int keyframe,
  ) {
    _av_bitstream_filter_filter ??= _dylib.lookupFunction<
        _c_av_bitstream_filter_filter,
        _dart_av_bitstream_filter_filter>('av_bitstream_filter_filter');
    return _av_bitstream_filter_filter(
      bsfc,
      avctx,
      args,
      poutbuf,
      poutbuf_size,
      buf,
      buf_size,
      keyframe,
    );
  }

  _dart_av_bitstream_filter_filter _av_bitstream_filter_filter;

  /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
  /// is deprecated. Use av_bsf_free() from the new bitstream filtering API (using
  /// AVBSFContext).
  void av_bitstream_filter_close(
    ffi.Pointer<AVBitStreamFilterContext> bsf,
  ) {
    _av_bitstream_filter_close ??= _dylib.lookupFunction<
        _c_av_bitstream_filter_close,
        _dart_av_bitstream_filter_close>('av_bitstream_filter_close');
    return _av_bitstream_filter_close(
      bsf,
    );
  }

  _dart_av_bitstream_filter_close _av_bitstream_filter_close;

  /// @deprecated the old bitstream filtering API (using AVBitStreamFilterContext)
  /// is deprecated. Use av_bsf_iterate() from the new bitstream filtering API (using
  /// AVBSFContext).
  ffi.Pointer<AVBitStreamFilter> av_bitstream_filter_next(
    ffi.Pointer<AVBitStreamFilter> f,
  ) {
    _av_bitstream_filter_next ??= _dylib.lookupFunction<
        _c_av_bitstream_filter_next,
        _dart_av_bitstream_filter_next>('av_bitstream_filter_next');
    return _av_bitstream_filter_next(
      f,
    );
  }

  _dart_av_bitstream_filter_next _av_bitstream_filter_next;

  ffi.Pointer<AVBitStreamFilter> av_bsf_next(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    _av_bsf_next ??=
        _dylib.lookupFunction<_c_av_bsf_next, _dart_av_bsf_next>('av_bsf_next');
    return _av_bsf_next(
      opaque,
    );
  }

  _dart_av_bsf_next _av_bsf_next;

  /// Same behaviour av_fast_malloc but the buffer has additional
  /// AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.
  ///
  /// In addition the whole buffer will initially and after resizes
  /// be 0-initialized so that no uninitialized data will ever appear.
  void av_fast_padded_malloc(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.Uint32> size,
    int min_size,
  ) {
    _av_fast_padded_malloc ??= _dylib.lookupFunction<_c_av_fast_padded_malloc,
        _dart_av_fast_padded_malloc>('av_fast_padded_malloc');
    return _av_fast_padded_malloc(
      ptr,
      size,
      min_size,
    );
  }

  _dart_av_fast_padded_malloc _av_fast_padded_malloc;

  /// Same behaviour av_fast_padded_malloc except that buffer will always
  /// be 0-initialized after call.
  void av_fast_padded_mallocz(
    ffi.Pointer<ffi.Void> ptr,
    ffi.Pointer<ffi.Uint32> size,
    int min_size,
  ) {
    _av_fast_padded_mallocz ??= _dylib.lookupFunction<_c_av_fast_padded_mallocz,
        _dart_av_fast_padded_mallocz>('av_fast_padded_mallocz');
    return _av_fast_padded_mallocz(
      ptr,
      size,
      min_size,
    );
  }

  _dart_av_fast_padded_mallocz _av_fast_padded_mallocz;

  /// Encode extradata length to a buffer. Used by xiph codecs.
  ///
  /// @param s buffer to write to; must be at least (v/255+1) bytes long
  /// @param v size of extradata in bytes
  /// @return number of bytes written to the buffer.
  int av_xiphlacing(
    ffi.Pointer<ffi.Uint8> s,
    int v,
  ) {
    _av_xiphlacing ??= _dylib
        .lookupFunction<_c_av_xiphlacing, _dart_av_xiphlacing>('av_xiphlacing');
    return _av_xiphlacing(
      s,
      v,
    );
  }

  _dart_av_xiphlacing _av_xiphlacing;

  /// Register the hardware accelerator hwaccel.
  ///
  /// @deprecated  This function doesn't do anything.
  void av_register_hwaccel(
    ffi.Pointer<AVHWAccel> hwaccel,
  ) {
    _av_register_hwaccel ??= _dylib.lookupFunction<_c_av_register_hwaccel,
        _dart_av_register_hwaccel>('av_register_hwaccel');
    return _av_register_hwaccel(
      hwaccel,
    );
  }

  _dart_av_register_hwaccel _av_register_hwaccel;

  /// If hwaccel is NULL, returns the first registered hardware accelerator,
  /// if hwaccel is non-NULL, returns the next registered hardware accelerator
  /// after hwaccel, or NULL if hwaccel is the last one.
  ///
  /// @deprecated  AVHWaccel structures contain no user-serviceable parts, so
  /// this function should not be used.
  ffi.Pointer<AVHWAccel> av_hwaccel_next(
    ffi.Pointer<AVHWAccel> hwaccel,
  ) {
    _av_hwaccel_next ??=
        _dylib.lookupFunction<_c_av_hwaccel_next, _dart_av_hwaccel_next>(
            'av_hwaccel_next');
    return _av_hwaccel_next(
      hwaccel,
    );
  }

  _dart_av_hwaccel_next _av_hwaccel_next;

  /// Register a user provided lock manager supporting the operations
  /// specified by AVLockOp. The "mutex" argument to the function points
  /// to a (void *) where the lockmgr should store/get a pointer to a user
  /// allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the
  /// value left by the last call for all other ops. If the lock manager is
  /// unable to perform the op then it should leave the mutex in the same
  /// state as when it was called and return a non-zero value. However,
  /// when called with AV_LOCK_DESTROY the mutex will always be assumed to
  /// have been successfully destroyed. If av_lockmgr_register succeeds
  /// it will return a non-negative value, if it fails it will return a
  /// negative value and destroy all mutex and unregister all callbacks.
  /// av_lockmgr_register is not thread-safe, it must be called from a
  /// single thread before any calls which make use of locking are used.
  ///
  /// @param cb User defined callback. av_lockmgr_register invokes calls
  /// to this callback and the previously registered callback.
  /// The callback will be used to create more than one mutex
  /// each of which must be backed by its own underlying locking
  /// mechanism (i.e. do not use a single static object to
  /// implement your lock manager). If cb is set to NULL the
  /// lockmgr will be unregistered.
  ///
  /// @deprecated This function does nothing, and always returns 0. Be sure to
  /// build with thread support to get basic thread safety.
  int av_lockmgr_register(
    ffi.Pointer<ffi.NativeFunction<_typedefC_43>> cb,
  ) {
    _av_lockmgr_register ??= _dylib.lookupFunction<_c_av_lockmgr_register,
        _dart_av_lockmgr_register>('av_lockmgr_register');
    return _av_lockmgr_register(
      cb,
    );
  }

  _dart_av_lockmgr_register _av_lockmgr_register;

  /// @return a positive value if s is open (i.e. avcodec_open2() was called on it
  /// with no corresponding avcodec_close()), 0 otherwise.
  int avcodec_is_open(
    ffi.Pointer<AVCodecContext> s,
  ) {
    _avcodec_is_open ??=
        _dylib.lookupFunction<_c_avcodec_is_open, _dart_avcodec_is_open>(
            'avcodec_is_open');
    return _avcodec_is_open(
      s,
    );
  }

  _dart_avcodec_is_open _avcodec_is_open;

  /// Allocate a CPB properties structure and initialize its fields to default
  /// values.
  ///
  /// @param size if non-NULL, the size of the allocated struct will be written
  /// here. This is useful for embedding it in side data.
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVCPBProperties> av_cpb_properties_alloc(
    ffi.Pointer<ffi.Uint64> size,
  ) {
    _av_cpb_properties_alloc ??= _dylib.lookupFunction<
        _c_av_cpb_properties_alloc,
        _dart_av_cpb_properties_alloc>('av_cpb_properties_alloc');
    return _av_cpb_properties_alloc(
      size,
    );
  }

  _dart_av_cpb_properties_alloc _av_cpb_properties_alloc;

  /// Show the obj options.
  ///
  /// @param req_flags requested flags for the options to show. Show only the
  /// options for which it is opt->flags & req_flags.
  /// @param rej_flags rejected flags for the options to show. Show only the
  /// options for which it is !(opt->flags & req_flags).
  /// @param av_log_obj log context to use for showing the options
  int av_opt_show2(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Void> av_log_obj,
    int req_flags,
    int rej_flags,
  ) {
    _av_opt_show2 ??= _dylib
        .lookupFunction<_c_av_opt_show2, _dart_av_opt_show2>('av_opt_show2');
    return _av_opt_show2(
      obj,
      av_log_obj,
      req_flags,
      rej_flags,
    );
  }

  _dart_av_opt_show2 _av_opt_show2;

  /// Set the values of all AVOption fields to their default values.
  ///
  /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
  void av_opt_set_defaults(
    ffi.Pointer<ffi.Void> s,
  ) {
    _av_opt_set_defaults ??= _dylib.lookupFunction<_c_av_opt_set_defaults,
        _dart_av_opt_set_defaults>('av_opt_set_defaults');
    return _av_opt_set_defaults(
      s,
    );
  }

  _dart_av_opt_set_defaults _av_opt_set_defaults;

  /// Set the values of all AVOption fields to their default values. Only these
  /// AVOption fields for which (opt->flags & mask) == flags will have their
  /// default applied to s.
  ///
  /// @param s an AVOption-enabled struct (its first member must be a pointer to AVClass)
  /// @param mask combination of AV_OPT_FLAG_*
  /// @param flags combination of AV_OPT_FLAG_*
  void av_opt_set_defaults2(
    ffi.Pointer<ffi.Void> s,
    int mask,
    int flags,
  ) {
    _av_opt_set_defaults2 ??= _dylib.lookupFunction<_c_av_opt_set_defaults2,
        _dart_av_opt_set_defaults2>('av_opt_set_defaults2');
    return _av_opt_set_defaults2(
      s,
      mask,
      flags,
    );
  }

  _dart_av_opt_set_defaults2 _av_opt_set_defaults2;

  /// Parse the key/value pairs list in opts. For each key/value pair
  /// found, stores the value in the field in ctx that is named like the
  /// key. ctx must be an AVClass context, storing is done using
  /// AVOptions.
  ///
  /// @param opts options string to parse, may be NULL
  /// @param key_val_sep a 0-terminated list of characters used to
  /// separate key from value
  /// @param pairs_sep a 0-terminated list of characters used to separate
  /// two pairs from each other
  /// @return the number of successfully set key/value pairs, or a negative
  /// value corresponding to an AVERROR code in case of error:
  /// AVERROR(EINVAL) if opts cannot be parsed,
  /// the error code issued by av_opt_set() if a key/value pair
  /// cannot be set
  int av_set_options_string(
    ffi.Pointer<ffi.Void> ctx,
    ffi.Pointer<ffi.Int8> opts,
    ffi.Pointer<ffi.Int8> key_val_sep,
    ffi.Pointer<ffi.Int8> pairs_sep,
  ) {
    _av_set_options_string ??= _dylib.lookupFunction<_c_av_set_options_string,
        _dart_av_set_options_string>('av_set_options_string');
    return _av_set_options_string(
      ctx,
      opts,
      key_val_sep,
      pairs_sep,
    );
  }

  _dart_av_set_options_string _av_set_options_string;

  /// Parse the key-value pairs list in opts. For each key=value pair found,
  /// set the value of the corresponding option in ctx.
  ///
  /// @param ctx          the AVClass object to set options on
  /// @param opts         the options string, key-value pairs separated by a
  /// delimiter
  /// @param shorthand    a NULL-terminated array of options names for shorthand
  /// notation: if the first field in opts has no key part,
  /// the key is taken from the first element of shorthand;
  /// then again for the second, etc., until either opts is
  /// finished, shorthand is finished or a named option is
  /// found; after that, all options must be named
  /// @param key_val_sep  a 0-terminated list of characters used to separate
  /// key from value, for example '='
  /// @param pairs_sep    a 0-terminated list of characters used to separate
  /// two pairs from each other, for example ':' or ','
  /// @return  the number of successfully set key=value pairs, or a negative
  /// value corresponding to an AVERROR code in case of error:
  /// AVERROR(EINVAL) if opts cannot be parsed,
  /// the error code issued by av_set_string3() if a key/value pair
  /// cannot be set
  ///
  /// Options names must use only the following characters: a-z A-Z 0-9 - . / _
  /// Separators must use characters distinct from option names and from each
  /// other.
  int av_opt_set_from_string(
    ffi.Pointer<ffi.Void> ctx,
    ffi.Pointer<ffi.Int8> opts,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> shorthand,
    ffi.Pointer<ffi.Int8> key_val_sep,
    ffi.Pointer<ffi.Int8> pairs_sep,
  ) {
    _av_opt_set_from_string ??= _dylib.lookupFunction<_c_av_opt_set_from_string,
        _dart_av_opt_set_from_string>('av_opt_set_from_string');
    return _av_opt_set_from_string(
      ctx,
      opts,
      shorthand,
      key_val_sep,
      pairs_sep,
    );
  }

  _dart_av_opt_set_from_string _av_opt_set_from_string;

  /// Free all allocated objects in obj.
  void av_opt_free(
    ffi.Pointer<ffi.Void> obj,
  ) {
    _av_opt_free ??=
        _dylib.lookupFunction<_c_av_opt_free, _dart_av_opt_free>('av_opt_free');
    return _av_opt_free(
      obj,
    );
  }

  _dart_av_opt_free _av_opt_free;

  /// Check whether a particular flag is set in a flags field.
  ///
  /// @param field_name the name of the flag field option
  /// @param flag_name the name of the flag to check
  /// @return non-zero if the flag is set, zero if the flag isn't set,
  /// isn't of the right type, or the flags field doesn't exist.
  int av_opt_flag_is_set(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> field_name,
    ffi.Pointer<ffi.Int8> flag_name,
  ) {
    _av_opt_flag_is_set ??=
        _dylib.lookupFunction<_c_av_opt_flag_is_set, _dart_av_opt_flag_is_set>(
            'av_opt_flag_is_set');
    return _av_opt_flag_is_set(
      obj,
      field_name,
      flag_name,
    );
  }

  _dart_av_opt_flag_is_set _av_opt_flag_is_set;

  /// Set all the options from a given dictionary on an object.
  ///
  /// @param obj a struct whose first element is a pointer to AVClass
  /// @param options options to process. This dictionary will be freed and replaced
  /// by a new one containing all options not found in obj.
  /// Of course this new dictionary needs to be freed by caller
  /// with av_dict_free().
  ///
  /// @return 0 on success, a negative AVERROR if some option was found in obj,
  /// but could not be set.
  ///
  /// @see av_dict_copy()
  int av_opt_set_dict(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _av_opt_set_dict ??=
        _dylib.lookupFunction<_c_av_opt_set_dict, _dart_av_opt_set_dict>(
            'av_opt_set_dict');
    return _av_opt_set_dict(
      obj,
      options,
    );
  }

  _dart_av_opt_set_dict _av_opt_set_dict;

  /// Set all the options from a given dictionary on an object.
  ///
  /// @param obj a struct whose first element is a pointer to AVClass
  /// @param options options to process. This dictionary will be freed and replaced
  /// by a new one containing all options not found in obj.
  /// Of course this new dictionary needs to be freed by caller
  /// with av_dict_free().
  /// @param search_flags A combination of AV_OPT_SEARCH_*.
  ///
  /// @return 0 on success, a negative AVERROR if some option was found in obj,
  /// but could not be set.
  ///
  /// @see av_dict_copy()
  int av_opt_set_dict2(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
    int search_flags,
  ) {
    _av_opt_set_dict2 ??=
        _dylib.lookupFunction<_c_av_opt_set_dict2, _dart_av_opt_set_dict2>(
            'av_opt_set_dict2');
    return _av_opt_set_dict2(
      obj,
      options,
      search_flags,
    );
  }

  _dart_av_opt_set_dict2 _av_opt_set_dict2;

  /// Extract a key-value pair from the beginning of a string.
  ///
  /// @param ropts        pointer to the options string, will be updated to
  /// point to the rest of the string (one of the pairs_sep
  /// or the final NUL)
  /// @param key_val_sep  a 0-terminated list of characters used to separate
  /// key from value, for example '='
  /// @param pairs_sep    a 0-terminated list of characters used to separate
  /// two pairs from each other, for example ':' or ','
  /// @param flags        flags; see the AV_OPT_FLAG_* values below
  /// @param rkey         parsed key; must be freed using av_free()
  /// @param rval         parsed value; must be freed using av_free()
  ///
  /// @return  >=0 for success, or a negative value corresponding to an
  /// AVERROR code in case of error; in particular:
  /// AVERROR(EINVAL) if no key is present
  int av_opt_get_key_value(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> ropts,
    ffi.Pointer<ffi.Int8> key_val_sep,
    ffi.Pointer<ffi.Int8> pairs_sep,
    int flags,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> rkey,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> rval,
  ) {
    _av_opt_get_key_value ??= _dylib.lookupFunction<_c_av_opt_get_key_value,
        _dart_av_opt_get_key_value>('av_opt_get_key_value');
    return _av_opt_get_key_value(
      ropts,
      key_val_sep,
      pairs_sep,
      flags,
      rkey,
      rval,
    );
  }

  _dart_av_opt_get_key_value _av_opt_get_key_value;

  /// @defgroup opt_eval_funcs Evaluating option strings
  /// @{
  /// This group of functions can be used to evaluate option strings
  /// and get numbers out of them. They do the same thing as av_opt_set(),
  /// except the result is written into the caller-supplied pointer.
  ///
  /// @param obj a struct whose first element is a pointer to AVClass.
  /// @param o an option for which the string is to be evaluated.
  /// @param val string to be evaluated.
  /// @param *_out value of the string will be written here.
  ///
  /// @return 0 on success, a negative number on failure.
  int av_opt_eval_flags(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Int8> val,
    ffi.Pointer<ffi.Int32> flags_out,
  ) {
    _av_opt_eval_flags ??=
        _dylib.lookupFunction<_c_av_opt_eval_flags, _dart_av_opt_eval_flags>(
            'av_opt_eval_flags');
    return _av_opt_eval_flags(
      obj,
      o,
      val,
      flags_out,
    );
  }

  _dart_av_opt_eval_flags _av_opt_eval_flags;

  int av_opt_eval_int(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Int8> val,
    ffi.Pointer<ffi.Int32> int_out,
  ) {
    _av_opt_eval_int ??=
        _dylib.lookupFunction<_c_av_opt_eval_int, _dart_av_opt_eval_int>(
            'av_opt_eval_int');
    return _av_opt_eval_int(
      obj,
      o,
      val,
      int_out,
    );
  }

  _dart_av_opt_eval_int _av_opt_eval_int;

  int av_opt_eval_int64(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Int8> val,
    ffi.Pointer<ffi.Int64> int64_out,
  ) {
    _av_opt_eval_int64 ??=
        _dylib.lookupFunction<_c_av_opt_eval_int64, _dart_av_opt_eval_int64>(
            'av_opt_eval_int64');
    return _av_opt_eval_int64(
      obj,
      o,
      val,
      int64_out,
    );
  }

  _dart_av_opt_eval_int64 _av_opt_eval_int64;

  int av_opt_eval_float(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Int8> val,
    ffi.Pointer<ffi.Float> float_out,
  ) {
    _av_opt_eval_float ??=
        _dylib.lookupFunction<_c_av_opt_eval_float, _dart_av_opt_eval_float>(
            'av_opt_eval_float');
    return _av_opt_eval_float(
      obj,
      o,
      val,
      float_out,
    );
  }

  _dart_av_opt_eval_float _av_opt_eval_float;

  int av_opt_eval_double(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Int8> val,
    ffi.Pointer<ffi.Double> double_out,
  ) {
    _av_opt_eval_double ??=
        _dylib.lookupFunction<_c_av_opt_eval_double, _dart_av_opt_eval_double>(
            'av_opt_eval_double');
    return _av_opt_eval_double(
      obj,
      o,
      val,
      double_out,
    );
  }

  _dart_av_opt_eval_double _av_opt_eval_double;

  int av_opt_eval_q(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
    ffi.Pointer<ffi.Int8> val,
    ffi.Pointer<AVRational> q_out,
  ) {
    _av_opt_eval_q ??= _dylib
        .lookupFunction<_c_av_opt_eval_q, _dart_av_opt_eval_q>('av_opt_eval_q');
    return _av_opt_eval_q(
      obj,
      o,
      val,
      q_out,
    );
  }

  _dart_av_opt_eval_q _av_opt_eval_q;

  /// Look for an option in an object. Consider only options which
  /// have all the specified flags set.
  ///
  /// @param[in] obj A pointer to a struct whose first element is a
  /// pointer to an AVClass.
  /// Alternatively a double pointer to an AVClass, if
  /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
  /// @param[in] name The name of the option to look for.
  /// @param[in] unit When searching for named constants, name of the unit
  /// it belongs to.
  /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
  /// @param search_flags A combination of AV_OPT_SEARCH_*.
  ///
  /// @return A pointer to the option found, or NULL if no option
  /// was found.
  ///
  /// @note Options found with AV_OPT_SEARCH_CHILDREN flag may not be settable
  /// directly with av_opt_set(). Use special calls which take an options
  /// AVDictionary (e.g. avformat_open_input()) to set options found with this
  /// flag.
  ffi.Pointer<AVOption> av_opt_find(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> unit,
    int opt_flags,
    int search_flags,
  ) {
    _av_opt_find ??=
        _dylib.lookupFunction<_c_av_opt_find, _dart_av_opt_find>('av_opt_find');
    return _av_opt_find(
      obj,
      name,
      unit,
      opt_flags,
      search_flags,
    );
  }

  _dart_av_opt_find _av_opt_find;

  /// Look for an option in an object. Consider only options which
  /// have all the specified flags set.
  ///
  /// @param[in] obj A pointer to a struct whose first element is a
  /// pointer to an AVClass.
  /// Alternatively a double pointer to an AVClass, if
  /// AV_OPT_SEARCH_FAKE_OBJ search flag is set.
  /// @param[in] name The name of the option to look for.
  /// @param[in] unit When searching for named constants, name of the unit
  /// it belongs to.
  /// @param opt_flags Find only options with all the specified flags set (AV_OPT_FLAG).
  /// @param search_flags A combination of AV_OPT_SEARCH_*.
  /// @param[out] target_obj if non-NULL, an object to which the option belongs will be
  /// written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present
  /// in search_flags. This parameter is ignored if search_flags contain
  /// AV_OPT_SEARCH_FAKE_OBJ.
  ///
  /// @return A pointer to the option found, or NULL if no option
  /// was found.
  ffi.Pointer<AVOption> av_opt_find2(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> unit,
    int opt_flags,
    int search_flags,
    ffi.Pointer<ffi.Pointer<ffi.Void>> target_obj,
  ) {
    _av_opt_find2 ??= _dylib
        .lookupFunction<_c_av_opt_find2, _dart_av_opt_find2>('av_opt_find2');
    return _av_opt_find2(
      obj,
      name,
      unit,
      opt_flags,
      search_flags,
      target_obj,
    );
  }

  _dart_av_opt_find2 _av_opt_find2;

  /// Iterate over all AVOptions belonging to obj.
  ///
  /// @param obj an AVOptions-enabled struct or a double pointer to an
  /// AVClass describing it.
  /// @param prev result of the previous call to av_opt_next() on this object
  /// or NULL
  /// @return next AVOption or NULL
  ffi.Pointer<AVOption> av_opt_next(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> prev,
  ) {
    _av_opt_next ??=
        _dylib.lookupFunction<_c_av_opt_next, _dart_av_opt_next>('av_opt_next');
    return _av_opt_next(
      obj,
      prev,
    );
  }

  _dart_av_opt_next _av_opt_next;

  /// Iterate over AVOptions-enabled children of obj.
  ///
  /// @param prev result of a previous call to this function or NULL
  /// @return next AVOptions-enabled child or NULL
  ffi.Pointer<ffi.Void> av_opt_child_next(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Void> prev,
  ) {
    _av_opt_child_next ??=
        _dylib.lookupFunction<_c_av_opt_child_next, _dart_av_opt_child_next>(
            'av_opt_child_next');
    return _av_opt_child_next(
      obj,
      prev,
    );
  }

  _dart_av_opt_child_next _av_opt_child_next;

  /// Iterate over potential AVOptions-enabled children of parent.
  ///
  /// @param prev result of a previous call to this function or NULL
  /// @return AVClass corresponding to next potential child or NULL
  ///
  /// @deprecated use av_opt_child_class_iterate
  ffi.Pointer<AVClass> av_opt_child_class_next(
    ffi.Pointer<AVClass> parent,
    ffi.Pointer<AVClass> prev,
  ) {
    _av_opt_child_class_next ??= _dylib.lookupFunction<
        _c_av_opt_child_class_next,
        _dart_av_opt_child_class_next>('av_opt_child_class_next');
    return _av_opt_child_class_next(
      parent,
      prev,
    );
  }

  _dart_av_opt_child_class_next _av_opt_child_class_next;

  /// Iterate over potential AVOptions-enabled children of parent.
  ///
  /// @param iter a pointer where iteration state is stored.
  /// @return AVClass corresponding to next potential child or NULL
  ffi.Pointer<AVClass> av_opt_child_class_iterate(
    ffi.Pointer<AVClass> parent,
    ffi.Pointer<ffi.Pointer<ffi.Void>> iter,
  ) {
    _av_opt_child_class_iterate ??= _dylib.lookupFunction<
        _c_av_opt_child_class_iterate,
        _dart_av_opt_child_class_iterate>('av_opt_child_class_iterate');
    return _av_opt_child_class_iterate(
      parent,
      iter,
    );
  }

  _dart_av_opt_child_class_iterate _av_opt_child_class_iterate;

  /// @defgroup opt_set_funcs Option setting functions
  /// @{
  /// Those functions set the field of obj with the given name to value.
  ///
  /// @param[in] obj A struct whose first element is a pointer to an AVClass.
  /// @param[in] name the name of the field to set
  /// @param[in] val The value to set. In case of av_opt_set() if the field is not
  /// of a string type, then the given string is parsed.
  /// SI postfixes and some named scalars are supported.
  /// If the field is of a numeric type, it has to be a numeric or named
  /// scalar. Behavior with more than one scalar and +- infix operators
  /// is undefined.
  /// If the field is of a flags type, it has to be a sequence of numeric
  /// scalars or named flags separated by '+' or '-'. Prefixing a flag
  /// with '+' causes it to be set without affecting the other flags;
  /// similarly, '-' unsets a flag.
  /// If the field is of a dictionary type, it has to be a ':' separated list of
  /// key=value parameters. Values containing ':' special characters must be
  /// escaped.
  /// @param search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
  /// is passed here, then the option may be set on a child of obj.
  ///
  /// @return 0 if the value has been set, or an AVERROR code in case of
  /// error:
  /// AVERROR_OPTION_NOT_FOUND if no matching option exists
  /// AVERROR(ERANGE) if the value is out of range
  /// AVERROR(EINVAL) if the value is not valid
  int av_opt_set(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> val,
    int search_flags,
  ) {
    _av_opt_set ??=
        _dylib.lookupFunction<_c_av_opt_set, _dart_av_opt_set>('av_opt_set');
    return _av_opt_set(
      obj,
      name,
      val,
      search_flags,
    );
  }

  _dart_av_opt_set _av_opt_set;

  int av_opt_set_int(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int val,
    int search_flags,
  ) {
    _av_opt_set_int ??=
        _dylib.lookupFunction<_c_av_opt_set_int, _dart_av_opt_set_int>(
            'av_opt_set_int');
    return _av_opt_set_int(
      obj,
      name,
      val,
      search_flags,
    );
  }

  _dart_av_opt_set_int _av_opt_set_int;

  int av_opt_set_double(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    double val,
    int search_flags,
  ) {
    _av_opt_set_double ??=
        _dylib.lookupFunction<_c_av_opt_set_double, _dart_av_opt_set_double>(
            'av_opt_set_double');
    return _av_opt_set_double(
      obj,
      name,
      val,
      search_flags,
    );
  }

  _dart_av_opt_set_double _av_opt_set_double;

  int av_opt_set_bin(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Uint8> val,
    int size,
    int search_flags,
  ) {
    _av_opt_set_bin ??=
        _dylib.lookupFunction<_c_av_opt_set_bin, _dart_av_opt_set_bin>(
            'av_opt_set_bin');
    return _av_opt_set_bin(
      obj,
      name,
      val,
      size,
      search_flags,
    );
  }

  _dart_av_opt_set_bin _av_opt_set_bin;

  int av_opt_set_image_size(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int w,
    int h,
    int search_flags,
  ) {
    _av_opt_set_image_size ??= _dylib.lookupFunction<_c_av_opt_set_image_size,
        _dart_av_opt_set_image_size>('av_opt_set_image_size');
    return _av_opt_set_image_size(
      obj,
      name,
      w,
      h,
      search_flags,
    );
  }

  _dart_av_opt_set_image_size _av_opt_set_image_size;

  int av_opt_set_pixel_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int fmt,
    int search_flags,
  ) {
    _av_opt_set_pixel_fmt ??= _dylib.lookupFunction<_c_av_opt_set_pixel_fmt,
        _dart_av_opt_set_pixel_fmt>('av_opt_set_pixel_fmt');
    return _av_opt_set_pixel_fmt(
      obj,
      name,
      fmt,
      search_flags,
    );
  }

  _dart_av_opt_set_pixel_fmt _av_opt_set_pixel_fmt;

  int av_opt_set_sample_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int fmt,
    int search_flags,
  ) {
    _av_opt_set_sample_fmt ??= _dylib.lookupFunction<_c_av_opt_set_sample_fmt,
        _dart_av_opt_set_sample_fmt>('av_opt_set_sample_fmt');
    return _av_opt_set_sample_fmt(
      obj,
      name,
      fmt,
      search_flags,
    );
  }

  _dart_av_opt_set_sample_fmt _av_opt_set_sample_fmt;

  int av_opt_set_channel_layout(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int ch_layout,
    int search_flags,
  ) {
    _av_opt_set_channel_layout ??= _dylib.lookupFunction<
        _c_av_opt_set_channel_layout,
        _dart_av_opt_set_channel_layout>('av_opt_set_channel_layout');
    return _av_opt_set_channel_layout(
      obj,
      name,
      ch_layout,
      search_flags,
    );
  }

  _dart_av_opt_set_channel_layout _av_opt_set_channel_layout;

  /// @note Any old dictionary present is discarded and replaced with a copy of the new one. The
  /// caller still owns val is and responsible for freeing it.
  int av_opt_set_dict_val(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<AVDictionary> val,
    int search_flags,
  ) {
    _av_opt_set_dict_val ??= _dylib.lookupFunction<_c_av_opt_set_dict_val,
        _dart_av_opt_set_dict_val>('av_opt_set_dict_val');
    return _av_opt_set_dict_val(
      obj,
      name,
      val,
      search_flags,
    );
  }

  _dart_av_opt_set_dict_val _av_opt_set_dict_val;

  /// @defgroup opt_get_funcs Option getting functions
  /// @{
  /// Those functions get a value of the option with the given name from an object.
  ///
  /// @param[in] obj a struct whose first element is a pointer to an AVClass.
  /// @param[in] name name of the option to get.
  /// @param[in] search_flags flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN
  /// is passed here, then the option may be found in a child of obj.
  /// @param[out] out_val value of the option will be written here
  /// @return >=0 on success, a negative error code otherwise
  ///
  ///
  /// @note the returned string will be av_malloc()ed and must be av_free()ed by the caller
  ///
  /// @note if AV_OPT_ALLOW_NULL is set in search_flags in av_opt_get, and the
  /// option is of type AV_OPT_TYPE_STRING, AV_OPT_TYPE_BINARY or AV_OPT_TYPE_DICT
  /// and is set to NULL, *out_val will be set to NULL instead of an allocated
  /// empty string.
  int av_opt_get(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> out_val,
  ) {
    _av_opt_get ??=
        _dylib.lookupFunction<_c_av_opt_get, _dart_av_opt_get>('av_opt_get');
    return _av_opt_get(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  _dart_av_opt_get _av_opt_get;

  int av_opt_get_int(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Int64> out_val,
  ) {
    _av_opt_get_int ??=
        _dylib.lookupFunction<_c_av_opt_get_int, _dart_av_opt_get_int>(
            'av_opt_get_int');
    return _av_opt_get_int(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  _dart_av_opt_get_int _av_opt_get_int;

  int av_opt_get_double(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Double> out_val,
  ) {
    _av_opt_get_double ??=
        _dylib.lookupFunction<_c_av_opt_get_double, _dart_av_opt_get_double>(
            'av_opt_get_double');
    return _av_opt_get_double(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  _dart_av_opt_get_double _av_opt_get_double;

  int av_opt_get_q(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<AVRational> out_val,
  ) {
    _av_opt_get_q ??= _dylib
        .lookupFunction<_c_av_opt_get_q, _dart_av_opt_get_q>('av_opt_get_q');
    return _av_opt_get_q(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  _dart_av_opt_get_q _av_opt_get_q;

  int av_opt_get_image_size(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Int32> w_out,
    ffi.Pointer<ffi.Int32> h_out,
  ) {
    _av_opt_get_image_size ??= _dylib.lookupFunction<_c_av_opt_get_image_size,
        _dart_av_opt_get_image_size>('av_opt_get_image_size');
    return _av_opt_get_image_size(
      obj,
      name,
      search_flags,
      w_out,
      h_out,
    );
  }

  _dart_av_opt_get_image_size _av_opt_get_image_size;

  int av_opt_get_pixel_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Int32> out_fmt,
  ) {
    _av_opt_get_pixel_fmt ??= _dylib.lookupFunction<_c_av_opt_get_pixel_fmt,
        _dart_av_opt_get_pixel_fmt>('av_opt_get_pixel_fmt');
    return _av_opt_get_pixel_fmt(
      obj,
      name,
      search_flags,
      out_fmt,
    );
  }

  _dart_av_opt_get_pixel_fmt _av_opt_get_pixel_fmt;

  int av_opt_get_sample_fmt(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Int32> out_fmt,
  ) {
    _av_opt_get_sample_fmt ??= _dylib.lookupFunction<_c_av_opt_get_sample_fmt,
        _dart_av_opt_get_sample_fmt>('av_opt_get_sample_fmt');
    return _av_opt_get_sample_fmt(
      obj,
      name,
      search_flags,
      out_fmt,
    );
  }

  _dart_av_opt_get_sample_fmt _av_opt_get_sample_fmt;

  int av_opt_get_video_rate(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<AVRational> out_val,
  ) {
    _av_opt_get_video_rate ??= _dylib.lookupFunction<_c_av_opt_get_video_rate,
        _dart_av_opt_get_video_rate>('av_opt_get_video_rate');
    return _av_opt_get_video_rate(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  _dart_av_opt_get_video_rate _av_opt_get_video_rate;

  int av_opt_get_channel_layout(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Int64> ch_layout,
  ) {
    _av_opt_get_channel_layout ??= _dylib.lookupFunction<
        _c_av_opt_get_channel_layout,
        _dart_av_opt_get_channel_layout>('av_opt_get_channel_layout');
    return _av_opt_get_channel_layout(
      obj,
      name,
      search_flags,
      ch_layout,
    );
  }

  _dart_av_opt_get_channel_layout _av_opt_get_channel_layout;

  /// @param[out] out_val The returned dictionary is a copy of the actual value and must
  /// be freed with av_dict_free() by the caller
  int av_opt_get_dict_val(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
    ffi.Pointer<ffi.Pointer<AVDictionary>> out_val,
  ) {
    _av_opt_get_dict_val ??= _dylib.lookupFunction<_c_av_opt_get_dict_val,
        _dart_av_opt_get_dict_val>('av_opt_get_dict_val');
    return _av_opt_get_dict_val(
      obj,
      name,
      search_flags,
      out_val,
    );
  }

  _dart_av_opt_get_dict_val _av_opt_get_dict_val;

  /// @}
  ///
  ///
  /// Gets a pointer to the requested field in a struct.
  /// This function allows accessing a struct even when its fields are moved or
  /// renamed since the application making the access has been compiled,
  ///
  /// @returns a pointer to the field, it can be cast to the correct type and read
  /// or written to.
  ffi.Pointer<ffi.Void> av_opt_ptr(
    ffi.Pointer<AVClass> avclass,
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_opt_ptr ??=
        _dylib.lookupFunction<_c_av_opt_ptr, _dart_av_opt_ptr>('av_opt_ptr');
    return _av_opt_ptr(
      avclass,
      obj,
      name,
    );
  }

  _dart_av_opt_ptr _av_opt_ptr;

  /// Free an AVOptionRanges struct and set it to NULL.
  void av_opt_freep_ranges(
    ffi.Pointer<ffi.Pointer<AVOptionRanges>> ranges,
  ) {
    _av_opt_freep_ranges ??= _dylib.lookupFunction<_c_av_opt_freep_ranges,
        _dart_av_opt_freep_ranges>('av_opt_freep_ranges');
    return _av_opt_freep_ranges(
      ranges,
    );
  }

  _dart_av_opt_freep_ranges _av_opt_freep_ranges;

  /// Get a list of allowed ranges for the given option.
  ///
  /// The returned list may depend on other fields in obj like for example profile.
  ///
  /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
  /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
  /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
  ///
  /// The result must be freed with av_opt_freep_ranges.
  ///
  /// @return number of compontents returned on success, a negative errro code otherwise
  int av_opt_query_ranges(
    ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> key,
    int flags,
  ) {
    _av_opt_query_ranges ??= _dylib.lookupFunction<_c_av_opt_query_ranges,
        _dart_av_opt_query_ranges>('av_opt_query_ranges');
    return _av_opt_query_ranges(
      arg0,
      obj,
      key,
      flags,
    );
  }

  _dart_av_opt_query_ranges _av_opt_query_ranges;

  /// Copy options from src object into dest object.
  ///
  /// Options that require memory allocation (e.g. string or binary) are malloc'ed in dest object.
  /// Original memory allocated for such options is freed unless both src and dest options points to the same memory.
  ///
  /// @param dest Object to copy from
  /// @param src  Object to copy into
  /// @return 0 on success, negative on error
  int av_opt_copy(
    ffi.Pointer<ffi.Void> dest,
    ffi.Pointer<ffi.Void> src,
  ) {
    _av_opt_copy ??=
        _dylib.lookupFunction<_c_av_opt_copy, _dart_av_opt_copy>('av_opt_copy');
    return _av_opt_copy(
      dest,
      src,
    );
  }

  _dart_av_opt_copy _av_opt_copy;

  /// Get a default list of allowed ranges for the given option.
  ///
  /// This list is constructed without using the AVClass.query_ranges() callback
  /// and can be used as fallback from within the callback.
  ///
  /// @param flags is a bitmask of flags, undefined flags should not be set and should be ignored
  /// AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance
  /// AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component, @see AVOptionRanges
  ///
  /// The result must be freed with av_opt_free_ranges.
  ///
  /// @return number of compontents returned on success, a negative errro code otherwise
  int av_opt_query_ranges_default(
    ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> key,
    int flags,
  ) {
    _av_opt_query_ranges_default ??= _dylib.lookupFunction<
        _c_av_opt_query_ranges_default,
        _dart_av_opt_query_ranges_default>('av_opt_query_ranges_default');
    return _av_opt_query_ranges_default(
      arg0,
      obj,
      key,
      flags,
    );
  }

  _dart_av_opt_query_ranges_default _av_opt_query_ranges_default;

  /// Check if given option is set to its default value.
  ///
  /// Options o must belong to the obj. This function must not be called to check child's options state.
  /// @see av_opt_is_set_to_default_by_name().
  ///
  /// @param obj  AVClass object to check option on
  /// @param o    option to be checked
  /// @return     >0 when option is set to its default,
  /// 0 when option is not set its default,
  /// <0 on error
  int av_opt_is_set_to_default(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<AVOption> o,
  ) {
    _av_opt_is_set_to_default ??= _dylib.lookupFunction<
        _c_av_opt_is_set_to_default,
        _dart_av_opt_is_set_to_default>('av_opt_is_set_to_default');
    return _av_opt_is_set_to_default(
      obj,
      o,
    );
  }

  _dart_av_opt_is_set_to_default _av_opt_is_set_to_default;

  /// Check if given option is set to its default value.
  ///
  /// @param obj          AVClass object to check option on
  /// @param name         option name
  /// @param search_flags combination of AV_OPT_SEARCH_*
  /// @return             >0 when option is set to its default,
  /// 0 when option is not set its default,
  /// <0 on error
  int av_opt_is_set_to_default_by_name(
    ffi.Pointer<ffi.Void> obj,
    ffi.Pointer<ffi.Int8> name,
    int search_flags,
  ) {
    _av_opt_is_set_to_default_by_name ??= _dylib.lookupFunction<
            _c_av_opt_is_set_to_default_by_name,
            _dart_av_opt_is_set_to_default_by_name>(
        'av_opt_is_set_to_default_by_name');
    return _av_opt_is_set_to_default_by_name(
      obj,
      name,
      search_flags,
    );
  }

  _dart_av_opt_is_set_to_default_by_name _av_opt_is_set_to_default_by_name;

  /// Serialize object's options.
  ///
  /// Create a string containing object's serialized options.
  /// Such string may be passed back to av_opt_set_from_string() in order to restore option values.
  /// A key/value or pairs separator occurring in the serialized value or
  /// name string are escaped through the av_escape() function.
  ///
  /// @param[in]  obj           AVClass object to serialize
  /// @param[in]  opt_flags     serialize options with all the specified flags set (AV_OPT_FLAG)
  /// @param[in]  flags         combination of AV_OPT_SERIALIZE_* flags
  /// @param[out] buffer        Pointer to buffer that will be allocated with string containg serialized options.
  /// Buffer must be freed by the caller when is no longer needed.
  /// @param[in]  key_val_sep   character used to separate key from value
  /// @param[in]  pairs_sep     character used to separate two pairs from each other
  /// @return                   >= 0 on success, negative on error
  /// @warning Separators cannot be neither '\\' nor '\0'. They also cannot be the same.
  int av_opt_serialize(
    ffi.Pointer<ffi.Void> obj,
    int opt_flags,
    int flags,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> buffer,
    int key_val_sep,
    int pairs_sep,
  ) {
    _av_opt_serialize ??=
        _dylib.lookupFunction<_c_av_opt_serialize, _dart_av_opt_serialize>(
            'av_opt_serialize');
    return _av_opt_serialize(
      obj,
      opt_flags,
      flags,
      buffer,
      key_val_sep,
      pairs_sep,
    );
  }

  _dart_av_opt_serialize _av_opt_serialize;

  /// Allocates a AVDCT context.
  /// This needs to be initialized with avcodec_dct_init() after optionally
  /// configuring it with AVOptions.
  ///
  /// To free it use av_free()
  ffi.Pointer<AVDCT> avcodec_dct_alloc() {
    _avcodec_dct_alloc ??=
        _dylib.lookupFunction<_c_avcodec_dct_alloc, _dart_avcodec_dct_alloc>(
            'avcodec_dct_alloc');
    return _avcodec_dct_alloc();
  }

  _dart_avcodec_dct_alloc _avcodec_dct_alloc;

  int avcodec_dct_init(
    ffi.Pointer<AVDCT> arg0,
  ) {
    _avcodec_dct_init ??=
        _dylib.lookupFunction<_c_avcodec_dct_init, _dart_avcodec_dct_init>(
            'avcodec_dct_init');
    return _avcodec_dct_init(
      arg0,
    );
  }

  _dart_avcodec_dct_init _avcodec_dct_init;

  ffi.Pointer<AVClass> avcodec_dct_get_class() {
    _avcodec_dct_get_class ??= _dylib.lookupFunction<_c_avcodec_dct_get_class,
        _dart_avcodec_dct_get_class>('avcodec_dct_get_class');
    return _avcodec_dct_get_class();
  }

  _dart_avcodec_dct_get_class _avcodec_dct_get_class;

  /// Set up a complex FFT.
  /// @param nbits           log2 of the length of the input array
  /// @param inverse         if 0 perform the forward transform, if 1 perform the inverse
  ffi.Pointer<FFTContext> av_fft_init(
    int nbits,
    int inverse,
  ) {
    _av_fft_init ??=
        _dylib.lookupFunction<_c_av_fft_init, _dart_av_fft_init>('av_fft_init');
    return _av_fft_init(
      nbits,
      inverse,
    );
  }

  _dart_av_fft_init _av_fft_init;

  /// Do the permutation needed BEFORE calling ff_fft_calc().
  void av_fft_permute(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<FFTComplex> z,
  ) {
    _av_fft_permute ??=
        _dylib.lookupFunction<_c_av_fft_permute, _dart_av_fft_permute>(
            'av_fft_permute');
    return _av_fft_permute(
      s,
      z,
    );
  }

  _dart_av_fft_permute _av_fft_permute;

  /// Do a complex FFT with the parameters defined in av_fft_init(). The
  /// input data must be permuted before. No 1.0/sqrt(n) normalization is done.
  void av_fft_calc(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<FFTComplex> z,
  ) {
    _av_fft_calc ??=
        _dylib.lookupFunction<_c_av_fft_calc, _dart_av_fft_calc>('av_fft_calc');
    return _av_fft_calc(
      s,
      z,
    );
  }

  _dart_av_fft_calc _av_fft_calc;

  void av_fft_end(
    ffi.Pointer<FFTContext> s,
  ) {
    _av_fft_end ??=
        _dylib.lookupFunction<_c_av_fft_end, _dart_av_fft_end>('av_fft_end');
    return _av_fft_end(
      s,
    );
  }

  _dart_av_fft_end _av_fft_end;

  ffi.Pointer<FFTContext> av_mdct_init(
    int nbits,
    int inverse,
    double scale,
  ) {
    _av_mdct_init ??= _dylib
        .lookupFunction<_c_av_mdct_init, _dart_av_mdct_init>('av_mdct_init');
    return _av_mdct_init(
      nbits,
      inverse,
      scale,
    );
  }

  _dart_av_mdct_init _av_mdct_init;

  void av_imdct_calc(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<ffi.Float> output,
    ffi.Pointer<ffi.Float> input,
  ) {
    _av_imdct_calc ??= _dylib
        .lookupFunction<_c_av_imdct_calc, _dart_av_imdct_calc>('av_imdct_calc');
    return _av_imdct_calc(
      s,
      output,
      input,
    );
  }

  _dart_av_imdct_calc _av_imdct_calc;

  void av_imdct_half(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<ffi.Float> output,
    ffi.Pointer<ffi.Float> input,
  ) {
    _av_imdct_half ??= _dylib
        .lookupFunction<_c_av_imdct_half, _dart_av_imdct_half>('av_imdct_half');
    return _av_imdct_half(
      s,
      output,
      input,
    );
  }

  _dart_av_imdct_half _av_imdct_half;

  void av_mdct_calc(
    ffi.Pointer<FFTContext> s,
    ffi.Pointer<ffi.Float> output,
    ffi.Pointer<ffi.Float> input,
  ) {
    _av_mdct_calc ??= _dylib
        .lookupFunction<_c_av_mdct_calc, _dart_av_mdct_calc>('av_mdct_calc');
    return _av_mdct_calc(
      s,
      output,
      input,
    );
  }

  _dart_av_mdct_calc _av_mdct_calc;

  void av_mdct_end(
    ffi.Pointer<FFTContext> s,
  ) {
    _av_mdct_end ??=
        _dylib.lookupFunction<_c_av_mdct_end, _dart_av_mdct_end>('av_mdct_end');
    return _av_mdct_end(
      s,
    );
  }

  _dart_av_mdct_end _av_mdct_end;

  /// Set up a real FFT.
  /// @param nbits           log2 of the length of the input array
  /// @param trans           the type of transform
  ffi.Pointer<RDFTContext> av_rdft_init(
    int nbits,
    int trans,
  ) {
    _av_rdft_init ??= _dylib
        .lookupFunction<_c_av_rdft_init, _dart_av_rdft_init>('av_rdft_init');
    return _av_rdft_init(
      nbits,
      trans,
    );
  }

  _dart_av_rdft_init _av_rdft_init;

  void av_rdft_calc(
    ffi.Pointer<RDFTContext> s,
    ffi.Pointer<ffi.Float> data,
  ) {
    _av_rdft_calc ??= _dylib
        .lookupFunction<_c_av_rdft_calc, _dart_av_rdft_calc>('av_rdft_calc');
    return _av_rdft_calc(
      s,
      data,
    );
  }

  _dart_av_rdft_calc _av_rdft_calc;

  void av_rdft_end(
    ffi.Pointer<RDFTContext> s,
  ) {
    _av_rdft_end ??=
        _dylib.lookupFunction<_c_av_rdft_end, _dart_av_rdft_end>('av_rdft_end');
    return _av_rdft_end(
      s,
    );
  }

  _dart_av_rdft_end _av_rdft_end;

  /// Set up DCT.
  ///
  /// @param nbits           size of the input array:
  /// (1 << nbits)     for DCT-II, DCT-III and DST-I
  /// (1 << nbits) + 1 for DCT-I
  /// @param type            the type of transform
  ///
  /// @note the first element of the input of DST-I is ignored
  ffi.Pointer<DCTContext> av_dct_init(
    int nbits,
    int type,
  ) {
    _av_dct_init ??=
        _dylib.lookupFunction<_c_av_dct_init, _dart_av_dct_init>('av_dct_init');
    return _av_dct_init(
      nbits,
      type,
    );
  }

  _dart_av_dct_init _av_dct_init;

  void av_dct_calc(
    ffi.Pointer<DCTContext> s,
    ffi.Pointer<ffi.Float> data,
  ) {
    _av_dct_calc ??=
        _dylib.lookupFunction<_c_av_dct_calc, _dart_av_dct_calc>('av_dct_calc');
    return _av_dct_calc(
      s,
      data,
    );
  }

  _dart_av_dct_calc _av_dct_calc;

  void av_dct_end(
    ffi.Pointer<DCTContext> s,
  ) {
    _av_dct_end ??=
        _dylib.lookupFunction<_c_av_dct_end, _dart_av_dct_end>('av_dct_end');
    return _av_dct_end(
      s,
    );
  }

  _dart_av_dct_end _av_dct_end;

  /// Allocate an AVD3D11VAContext.
  ///
  /// @return Newly-allocated AVD3D11VAContext or NULL on failure.
  ffi.Pointer<AVD3D11VAContext> av_d3d11va_alloc_context() {
    _av_d3d11va_alloc_context ??= _dylib.lookupFunction<
        _c_av_d3d11va_alloc_context,
        _dart_av_d3d11va_alloc_context>('av_d3d11va_alloc_context');
    return _av_d3d11va_alloc_context();
  }

  _dart_av_d3d11va_alloc_context _av_d3d11va_alloc_context;

  /// Parse a Dirac sequence header.
  ///
  /// @param dsh this function will allocate and fill an AVDiracSeqHeader struct
  /// and write it into this pointer. The caller must free it with
  /// av_free().
  /// @param buf the data buffer
  /// @param buf_size the size of the data buffer in bytes
  /// @param log_ctx if non-NULL, this function will log errors here
  /// @return 0 on success, a negative AVERROR code on failure
  int av_dirac_parse_sequence_header(
    ffi.Pointer<ffi.Pointer<AVDiracSeqHeader>> dsh,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_dirac_parse_sequence_header ??= _dylib.lookupFunction<
        _c_av_dirac_parse_sequence_header,
        _dart_av_dirac_parse_sequence_header>('av_dirac_parse_sequence_header');
    return _av_dirac_parse_sequence_header(
      dsh,
      buf,
      buf_size,
      log_ctx,
    );
  }

  _dart_av_dirac_parse_sequence_header _av_dirac_parse_sequence_header;

  /// Get a DV profile for the provided compressed frame.
  ///
  /// @param sys the profile used for the previous frame, may be NULL
  /// @param frame the compressed data buffer
  /// @param buf_size size of the buffer in bytes
  /// @return the DV profile for the supplied data or NULL on failure
  ffi.Pointer<AVDVProfile> av_dv_frame_profile(
    ffi.Pointer<AVDVProfile> sys,
    ffi.Pointer<ffi.Uint8> frame,
    int buf_size,
  ) {
    _av_dv_frame_profile ??= _dylib.lookupFunction<_c_av_dv_frame_profile,
        _dart_av_dv_frame_profile>('av_dv_frame_profile');
    return _av_dv_frame_profile(
      sys,
      frame,
      buf_size,
    );
  }

  _dart_av_dv_frame_profile _av_dv_frame_profile;

  /// Get a DV profile for the provided stream parameters.
  ffi.Pointer<AVDVProfile> av_dv_codec_profile(
    int width,
    int height,
    int pix_fmt,
  ) {
    _av_dv_codec_profile ??= _dylib.lookupFunction<_c_av_dv_codec_profile,
        _dart_av_dv_codec_profile>('av_dv_codec_profile');
    return _av_dv_codec_profile(
      width,
      height,
      pix_fmt,
    );
  }

  _dart_av_dv_codec_profile _av_dv_codec_profile;

  int av_jni_set_java_vm(
    ffi.Pointer<ffi.Void> vm,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_jni_set_java_vm ??=
        _dylib.lookupFunction<_c_av_jni_set_java_vm, _dart_av_jni_set_java_vm>(
            'av_jni_set_java_vm');
    return _av_jni_set_java_vm(
      vm,
      log_ctx,
    );
  }

  _dart_av_jni_set_java_vm _av_jni_set_java_vm;

  ffi.Pointer<ffi.Void> av_jni_get_java_vm(
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_jni_get_java_vm ??=
        _dylib.lookupFunction<_c_av_jni_get_java_vm, _dart_av_jni_get_java_vm>(
            'av_jni_get_java_vm');
    return _av_jni_get_java_vm(
      log_ctx,
    );
  }

  _dart_av_jni_get_java_vm _av_jni_get_java_vm;

  /// Allocate and initialize a MediaCodec context.
  ///
  /// When decoding with MediaCodec is finished, the caller must free the
  /// MediaCodec context with av_mediacodec_default_free.
  ///
  /// @return a pointer to a newly allocated AVMediaCodecContext on success, NULL otherwise
  ffi.Pointer<AVMediaCodecContext> av_mediacodec_alloc_context() {
    _av_mediacodec_alloc_context ??= _dylib.lookupFunction<
        _c_av_mediacodec_alloc_context,
        _dart_av_mediacodec_alloc_context>('av_mediacodec_alloc_context');
    return _av_mediacodec_alloc_context();
  }

  _dart_av_mediacodec_alloc_context _av_mediacodec_alloc_context;

  /// Convenience function that sets up the MediaCodec context.
  ///
  /// @param avctx codec context
  /// @param ctx MediaCodec context to initialize
  /// @param surface reference to an android/view/Surface
  /// @return 0 on success, < 0 otherwise
  int av_mediacodec_default_init(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVMediaCodecContext> ctx,
    ffi.Pointer<ffi.Void> surface,
  ) {
    _av_mediacodec_default_init ??= _dylib.lookupFunction<
        _c_av_mediacodec_default_init,
        _dart_av_mediacodec_default_init>('av_mediacodec_default_init');
    return _av_mediacodec_default_init(
      avctx,
      ctx,
      surface,
    );
  }

  _dart_av_mediacodec_default_init _av_mediacodec_default_init;

  /// This function must be called to free the MediaCodec context initialized with
  /// av_mediacodec_default_init().
  ///
  /// @param avctx codec context
  void av_mediacodec_default_free(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_mediacodec_default_free ??= _dylib.lookupFunction<
        _c_av_mediacodec_default_free,
        _dart_av_mediacodec_default_free>('av_mediacodec_default_free');
    return _av_mediacodec_default_free(
      avctx,
    );
  }

  _dart_av_mediacodec_default_free _av_mediacodec_default_free;

  /// Release a MediaCodec buffer and render it to the surface that is associated
  /// with the decoder. This function should only be called once on a given
  /// buffer, once released the underlying buffer returns to the codec, thus
  /// subsequent calls to this function will have no effect.
  ///
  /// @param buffer the buffer to render
  /// @param render 1 to release and render the buffer to the surface or 0 to
  /// discard the buffer
  /// @return 0 on success, < 0 otherwise
  int av_mediacodec_release_buffer(
    ffi.Pointer<MediaCodecBuffer> buffer,
    int render,
  ) {
    _av_mediacodec_release_buffer ??= _dylib.lookupFunction<
        _c_av_mediacodec_release_buffer,
        _dart_av_mediacodec_release_buffer>('av_mediacodec_release_buffer');
    return _av_mediacodec_release_buffer(
      buffer,
      render,
    );
  }

  _dart_av_mediacodec_release_buffer _av_mediacodec_release_buffer;

  /// Release a MediaCodec buffer and render it at the given time to the surface
  /// that is associated with the decoder. The timestamp must be within one second
  /// of the current java/lang/System#nanoTime() (which is implemented using
  /// CLOCK_MONOTONIC on Android). See the Android MediaCodec documentation
  /// of android/media/MediaCodec#releaseOutputBuffer(int,long) for more details.
  ///
  /// @param buffer the buffer to render
  /// @param time timestamp in nanoseconds of when to render the buffer
  /// @return 0 on success, < 0 otherwise
  int av_mediacodec_render_buffer_at_time(
    ffi.Pointer<MediaCodecBuffer> buffer,
    int time,
  ) {
    _av_mediacodec_render_buffer_at_time ??= _dylib.lookupFunction<
            _c_av_mediacodec_render_buffer_at_time,
            _dart_av_mediacodec_render_buffer_at_time>(
        'av_mediacodec_render_buffer_at_time');
    return _av_mediacodec_render_buffer_at_time(
      buffer,
      time,
    );
  }

  _dart_av_mediacodec_render_buffer_at_time
      _av_mediacodec_render_buffer_at_time;

  /// Allocate a new context.
  ///
  /// It must be freed by the caller with av_free().
  ffi.Pointer<AVQSVContext> av_qsv_alloc_context() {
    _av_qsv_alloc_context ??= _dylib.lookupFunction<_c_av_qsv_alloc_context,
        _dart_av_qsv_alloc_context>('av_qsv_alloc_context');
    return _av_qsv_alloc_context();
  }

  _dart_av_qsv_alloc_context _av_qsv_alloc_context;

  /// @brief allocation function for AVVDPAUContext
  ///
  /// Allows extending the struct without breaking API/ABI
  ffi.Pointer<AVVDPAUContext> av_alloc_vdpaucontext() {
    _av_alloc_vdpaucontext ??= _dylib.lookupFunction<_c_av_alloc_vdpaucontext,
        _dart_av_alloc_vdpaucontext>('av_alloc_vdpaucontext');
    return _av_alloc_vdpaucontext();
  }

  _dart_av_alloc_vdpaucontext _av_alloc_vdpaucontext;

  ffi.Pointer<ffi.NativeFunction<AVVDPAU_Render2>> av_vdpau_hwaccel_get_render2(
    ffi.Pointer<AVVDPAUContext> arg0,
  ) {
    _av_vdpau_hwaccel_get_render2 ??= _dylib.lookupFunction<
        _c_av_vdpau_hwaccel_get_render2,
        _dart_av_vdpau_hwaccel_get_render2>('av_vdpau_hwaccel_get_render2');
    return _av_vdpau_hwaccel_get_render2(
      arg0,
    );
  }

  _dart_av_vdpau_hwaccel_get_render2 _av_vdpau_hwaccel_get_render2;

  void av_vdpau_hwaccel_set_render2(
    ffi.Pointer<AVVDPAUContext> arg0,
    ffi.Pointer<ffi.NativeFunction<AVVDPAU_Render2>> arg1,
  ) {
    _av_vdpau_hwaccel_set_render2 ??= _dylib.lookupFunction<
        _c_av_vdpau_hwaccel_set_render2,
        _dart_av_vdpau_hwaccel_set_render2>('av_vdpau_hwaccel_set_render2');
    return _av_vdpau_hwaccel_set_render2(
      arg0,
      arg1,
    );
  }

  _dart_av_vdpau_hwaccel_set_render2 _av_vdpau_hwaccel_set_render2;

  /// Associate a VDPAU device with a codec context for hardware acceleration.
  /// This function is meant to be called from the get_format() codec callback,
  /// or earlier. It can also be called after avcodec_flush_buffers() to change
  /// the underlying VDPAU device mid-stream (e.g. to recover from non-transparent
  /// display preemption).
  ///
  /// @note get_format() must return AV_PIX_FMT_VDPAU if this function completes
  /// successfully.
  ///
  /// @param avctx decoding context whose get_format() callback is invoked
  /// @param device VDPAU device handle to use for hardware acceleration
  /// @param get_proc_address VDPAU device driver
  /// @param flags zero of more OR'd AV_HWACCEL_FLAG_* flags
  ///
  /// @return 0 on success, an AVERROR code on failure.
  int av_vdpau_bind_context(
    ffi.Pointer<AVCodecContext> avctx,
    int device,
    ffi.Pointer<ffi.Int32> get_proc_address,
    int flags,
  ) {
    _av_vdpau_bind_context ??= _dylib.lookupFunction<_c_av_vdpau_bind_context,
        _dart_av_vdpau_bind_context>('av_vdpau_bind_context');
    return _av_vdpau_bind_context(
      avctx,
      device,
      get_proc_address,
      flags,
    );
  }

  _dart_av_vdpau_bind_context _av_vdpau_bind_context;

  /// Gets the parameters to create an adequate VDPAU video surface for the codec
  /// context using VDPAU hardware decoding acceleration.
  ///
  /// @note Behavior is undefined if the context was not successfully bound to a
  /// VDPAU device using av_vdpau_bind_context().
  ///
  /// @param avctx the codec context being used for decoding the stream
  /// @param type storage space for the VDPAU video surface chroma type
  /// (or NULL to ignore)
  /// @param width storage space for the VDPAU video surface pixel width
  /// (or NULL to ignore)
  /// @param height storage space for the VDPAU video surface pixel height
  /// (or NULL to ignore)
  ///
  /// @return 0 on success, a negative AVERROR code on failure.
  int av_vdpau_get_surface_parameters(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Int32> type,
    ffi.Pointer<ffi.Uint32> width,
    ffi.Pointer<ffi.Uint32> height,
  ) {
    _av_vdpau_get_surface_parameters ??= _dylib.lookupFunction<
            _c_av_vdpau_get_surface_parameters,
            _dart_av_vdpau_get_surface_parameters>(
        'av_vdpau_get_surface_parameters');
    return _av_vdpau_get_surface_parameters(
      avctx,
      type,
      width,
      height,
    );
  }

  _dart_av_vdpau_get_surface_parameters _av_vdpau_get_surface_parameters;

  /// Allocate an AVVDPAUContext.
  ///
  /// @return Newly-allocated AVVDPAUContext or NULL on failure.
  ffi.Pointer<AVVDPAUContext> av_vdpau_alloc_context() {
    _av_vdpau_alloc_context ??= _dylib.lookupFunction<_c_av_vdpau_alloc_context,
        _dart_av_vdpau_alloc_context>('av_vdpau_alloc_context');
    return _av_vdpau_alloc_context();
  }

  _dart_av_vdpau_alloc_context _av_vdpau_alloc_context;

  /// Get a decoder profile that should be used for initializing a VDPAU decoder.
  /// Should be called from the AVCodecContext.get_format() callback.
  ///
  /// @deprecated Use av_vdpau_bind_context() instead.
  ///
  /// @param avctx the codec context being used for decoding the stream
  /// @param profile a pointer into which the result will be written on success.
  /// The contents of profile are undefined if this function returns
  /// an error.
  ///
  /// @return 0 on success (non-negative), a negative AVERROR on failure.
  int av_vdpau_get_profile(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<ffi.Int32> profile,
  ) {
    _av_vdpau_get_profile ??= _dylib.lookupFunction<_c_av_vdpau_get_profile,
        _dart_av_vdpau_get_profile>('av_vdpau_get_profile');
    return _av_vdpau_get_profile(
      avctx,
      profile,
    );
  }

  _dart_av_vdpau_get_profile _av_vdpau_get_profile;

  /// Allocate and initialize a Videotoolbox context.
  ///
  /// This function should be called from the get_format() callback when the caller
  /// selects the AV_PIX_FMT_VIDETOOLBOX format. The caller must then create
  /// the decoder object (using the output callback provided by libavcodec) that
  /// will be used for Videotoolbox-accelerated decoding.
  ///
  /// When decoding with Videotoolbox is finished, the caller must destroy the decoder
  /// object and free the Videotoolbox context using av_free().
  ///
  /// @return the newly allocated context or NULL on failure
  ffi.Pointer<AVVideotoolboxContext> av_videotoolbox_alloc_context() {
    _av_videotoolbox_alloc_context ??= _dylib.lookupFunction<
        _c_av_videotoolbox_alloc_context,
        _dart_av_videotoolbox_alloc_context>('av_videotoolbox_alloc_context');
    return _av_videotoolbox_alloc_context();
  }

  _dart_av_videotoolbox_alloc_context _av_videotoolbox_alloc_context;

  /// This is a convenience function that creates and sets up the Videotoolbox context using
  /// an internal implementation.
  ///
  /// @param avctx the corresponding codec context
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure
  int av_videotoolbox_default_init(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_videotoolbox_default_init ??= _dylib.lookupFunction<
        _c_av_videotoolbox_default_init,
        _dart_av_videotoolbox_default_init>('av_videotoolbox_default_init');
    return _av_videotoolbox_default_init(
      avctx,
    );
  }

  _dart_av_videotoolbox_default_init _av_videotoolbox_default_init;

  /// This is a convenience function that creates and sets up the Videotoolbox context using
  /// an internal implementation.
  ///
  /// @param avctx the corresponding codec context
  /// @param vtctx the Videotoolbox context to use
  ///
  /// @return >= 0 on success, a negative AVERROR code on failure
  int av_videotoolbox_default_init2(
    ffi.Pointer<AVCodecContext> avctx,
    ffi.Pointer<AVVideotoolboxContext> vtctx,
  ) {
    _av_videotoolbox_default_init2 ??= _dylib.lookupFunction<
        _c_av_videotoolbox_default_init2,
        _dart_av_videotoolbox_default_init2>('av_videotoolbox_default_init2');
    return _av_videotoolbox_default_init2(
      avctx,
      vtctx,
    );
  }

  _dart_av_videotoolbox_default_init2 _av_videotoolbox_default_init2;

  /// This function must be called to free the Videotoolbox context initialized with
  /// av_videotoolbox_default_init().
  ///
  /// @param avctx the corresponding codec context
  void av_videotoolbox_default_free(
    ffi.Pointer<AVCodecContext> avctx,
  ) {
    _av_videotoolbox_default_free ??= _dylib.lookupFunction<
        _c_av_videotoolbox_default_free,
        _dart_av_videotoolbox_default_free>('av_videotoolbox_default_free');
    return _av_videotoolbox_default_free(
      avctx,
    );
  }

  _dart_av_videotoolbox_default_free _av_videotoolbox_default_free;

  /// Allocate and initialize the Vorbis parser using headers in the extradata.
  ffi.Pointer<AVVorbisParseContext> av_vorbis_parse_init(
    ffi.Pointer<ffi.Uint8> extradata,
    int extradata_size,
  ) {
    _av_vorbis_parse_init ??= _dylib.lookupFunction<_c_av_vorbis_parse_init,
        _dart_av_vorbis_parse_init>('av_vorbis_parse_init');
    return _av_vorbis_parse_init(
      extradata,
      extradata_size,
    );
  }

  _dart_av_vorbis_parse_init _av_vorbis_parse_init;

  /// Free the parser and everything associated with it.
  void av_vorbis_parse_free(
    ffi.Pointer<ffi.Pointer<AVVorbisParseContext>> s,
  ) {
    _av_vorbis_parse_free ??= _dylib.lookupFunction<_c_av_vorbis_parse_free,
        _dart_av_vorbis_parse_free>('av_vorbis_parse_free');
    return _av_vorbis_parse_free(
      s,
    );
  }

  _dart_av_vorbis_parse_free _av_vorbis_parse_free;

  /// Get the duration for a Vorbis packet.
  ///
  /// If @p flags is @c NULL,
  /// special frames are considered invalid.
  ///
  /// @param s        Vorbis parser context
  /// @param buf      buffer containing a Vorbis frame
  /// @param buf_size size of the buffer
  /// @param flags    flags for special frames
  int av_vorbis_parse_frame_flags(
    ffi.Pointer<AVVorbisParseContext> s,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
    ffi.Pointer<ffi.Int32> flags,
  ) {
    _av_vorbis_parse_frame_flags ??= _dylib.lookupFunction<
        _c_av_vorbis_parse_frame_flags,
        _dart_av_vorbis_parse_frame_flags>('av_vorbis_parse_frame_flags');
    return _av_vorbis_parse_frame_flags(
      s,
      buf,
      buf_size,
      flags,
    );
  }

  _dart_av_vorbis_parse_frame_flags _av_vorbis_parse_frame_flags;

  /// Get the duration for a Vorbis packet.
  ///
  /// @param s        Vorbis parser context
  /// @param buf      buffer containing a Vorbis frame
  /// @param buf_size size of the buffer
  int av_vorbis_parse_frame(
    ffi.Pointer<AVVorbisParseContext> s,
    ffi.Pointer<ffi.Uint8> buf,
    int buf_size,
  ) {
    _av_vorbis_parse_frame ??= _dylib.lookupFunction<_c_av_vorbis_parse_frame,
        _dart_av_vorbis_parse_frame>('av_vorbis_parse_frame');
    return _av_vorbis_parse_frame(
      s,
      buf,
      buf_size,
    );
  }

  _dart_av_vorbis_parse_frame _av_vorbis_parse_frame;

  void av_vorbis_parse_reset(
    ffi.Pointer<AVVorbisParseContext> s,
  ) {
    _av_vorbis_parse_reset ??= _dylib.lookupFunction<_c_av_vorbis_parse_reset,
        _dart_av_vorbis_parse_reset>('av_vorbis_parse_reset');
    return _av_vorbis_parse_reset(
      s,
    );
  }

  _dart_av_vorbis_parse_reset _av_vorbis_parse_reset;

  /// Return the name of the protocol that will handle the passed URL.
  ///
  /// NULL is returned if no protocol could be found for the given URL.
  ///
  /// @return Name of the protocol or NULL.
  ffi.Pointer<ffi.Int8> avio_find_protocol_name(
    ffi.Pointer<ffi.Int8> url,
  ) {
    _avio_find_protocol_name ??= _dylib.lookupFunction<
        _c_avio_find_protocol_name,
        _dart_avio_find_protocol_name>('avio_find_protocol_name');
    return _avio_find_protocol_name(
      url,
    );
  }

  _dart_avio_find_protocol_name _avio_find_protocol_name;

  /// Return AVIO_FLAG_* access flags corresponding to the access permissions
  /// of the resource in url, or a negative value corresponding to an
  /// AVERROR code in case of failure. The returned access flags are
  /// masked by the value in flags.
  ///
  /// @note This function is intrinsically unsafe, in the sense that the
  /// checked resource may change its existence or permission status from
  /// one call to another. Thus you should not trust the returned value,
  /// unless you are sure that no other processes are accessing the
  /// checked resource.
  int avio_check(
    ffi.Pointer<ffi.Int8> url,
    int flags,
  ) {
    _avio_check ??=
        _dylib.lookupFunction<_c_avio_check, _dart_avio_check>('avio_check');
    return _avio_check(
      url,
      flags,
    );
  }

  _dart_avio_check _avio_check;

  /// Move or rename a resource.
  ///
  /// @note url_src and url_dst should share the same protocol and authority.
  ///
  /// @param url_src url to resource to be moved
  /// @param url_dst new url to resource if the operation succeeded
  /// @return >=0 on success or negative on error.
  int avpriv_io_move(
    ffi.Pointer<ffi.Int8> url_src,
    ffi.Pointer<ffi.Int8> url_dst,
  ) {
    _avpriv_io_move ??=
        _dylib.lookupFunction<_c_avpriv_io_move, _dart_avpriv_io_move>(
            'avpriv_io_move');
    return _avpriv_io_move(
      url_src,
      url_dst,
    );
  }

  _dart_avpriv_io_move _avpriv_io_move;

  /// Delete a resource.
  ///
  /// @param url resource to be deleted.
  /// @return >=0 on success or negative on error.
  int avpriv_io_delete(
    ffi.Pointer<ffi.Int8> url,
  ) {
    _avpriv_io_delete ??=
        _dylib.lookupFunction<_c_avpriv_io_delete, _dart_avpriv_io_delete>(
            'avpriv_io_delete');
    return _avpriv_io_delete(
      url,
    );
  }

  _dart_avpriv_io_delete _avpriv_io_delete;

  /// Open directory for reading.
  ///
  /// @param s       directory read context. Pointer to a NULL pointer must be passed.
  /// @param url     directory to be listed.
  /// @param options A dictionary filled with protocol-private options. On return
  /// this parameter will be destroyed and replaced with a dictionary
  /// containing options that were not found. May be NULL.
  /// @return >=0 on success or negative on error.
  int avio_open_dir(
    ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avio_open_dir ??= _dylib
        .lookupFunction<_c_avio_open_dir, _dart_avio_open_dir>('avio_open_dir');
    return _avio_open_dir(
      s,
      url,
      options,
    );
  }

  _dart_avio_open_dir _avio_open_dir;

  /// Get next directory entry.
  ///
  /// Returned entry must be freed with avio_free_directory_entry(). In particular
  /// it may outlive AVIODirContext.
  ///
  /// @param s         directory read context.
  /// @param[out] next next entry or NULL when no more entries.
  /// @return >=0 on success or negative on error. End of list is not considered an
  /// error.
  int avio_read_dir(
    ffi.Pointer<AVIODirContext> s,
    ffi.Pointer<ffi.Pointer<AVIODirEntry>> next,
  ) {
    _avio_read_dir ??= _dylib
        .lookupFunction<_c_avio_read_dir, _dart_avio_read_dir>('avio_read_dir');
    return _avio_read_dir(
      s,
      next,
    );
  }

  _dart_avio_read_dir _avio_read_dir;

  /// Close directory.
  ///
  /// @note Entries created using avio_read_dir() are not deleted and must be
  /// freeded with avio_free_directory_entry().
  ///
  /// @param s         directory read context.
  /// @return >=0 on success or negative on error.
  int avio_close_dir(
    ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
  ) {
    _avio_close_dir ??=
        _dylib.lookupFunction<_c_avio_close_dir, _dart_avio_close_dir>(
            'avio_close_dir');
    return _avio_close_dir(
      s,
    );
  }

  _dart_avio_close_dir _avio_close_dir;

  /// Free entry allocated by avio_read_dir().
  ///
  /// @param entry entry to be freed.
  void avio_free_directory_entry(
    ffi.Pointer<ffi.Pointer<AVIODirEntry>> entry,
  ) {
    _avio_free_directory_entry ??= _dylib.lookupFunction<
        _c_avio_free_directory_entry,
        _dart_avio_free_directory_entry>('avio_free_directory_entry');
    return _avio_free_directory_entry(
      entry,
    );
  }

  _dart_avio_free_directory_entry _avio_free_directory_entry;

  /// Allocate and initialize an AVIOContext for buffered I/O. It must be later
  /// freed with avio_context_free().
  ///
  /// @param buffer Memory block for input/output operations via AVIOContext.
  /// The buffer must be allocated with av_malloc() and friends.
  /// It may be freed and replaced with a new buffer by libavformat.
  /// AVIOContext.buffer holds the buffer currently in use,
  /// which must be later freed with av_free().
  /// @param buffer_size The buffer size is very important for performance.
  /// For protocols with fixed blocksize it should be set to this blocksize.
  /// For others a typical size is a cache page, e.g. 4kb.
  /// @param write_flag Set to 1 if the buffer should be writable, 0 otherwise.
  /// @param opaque An opaque pointer to user-specific data.
  /// @param read_packet  A function for refilling the buffer, may be NULL.
  /// For stream protocols, must never return 0 but rather
  /// a proper AVERROR code.
  /// @param write_packet A function for writing the buffer contents, may be NULL.
  /// The function may not change the input buffers content.
  /// @param seek A function for seeking to specified byte position, may be NULL.
  ///
  /// @return Allocated AVIOContext or NULL on failure.
  ffi.Pointer<AVIOContext> avio_alloc_context(
    ffi.Pointer<ffi.Uint8> buffer,
    int buffer_size,
    int write_flag,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.NativeFunction<_typedefC_57>> read_packet,
    ffi.Pointer<ffi.NativeFunction<_typedefC_58>> write_packet,
    ffi.Pointer<ffi.NativeFunction<_typedefC_59>> seek,
  ) {
    _avio_alloc_context ??=
        _dylib.lookupFunction<_c_avio_alloc_context, _dart_avio_alloc_context>(
            'avio_alloc_context');
    return _avio_alloc_context(
      buffer,
      buffer_size,
      write_flag,
      opaque,
      read_packet,
      write_packet,
      seek,
    );
  }

  _dart_avio_alloc_context _avio_alloc_context;

  /// Free the supplied IO context and everything associated with it.
  ///
  /// @param s Double pointer to the IO context. This function will write NULL
  /// into s.
  void avio_context_free(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ) {
    _avio_context_free ??=
        _dylib.lookupFunction<_c_avio_context_free, _dart_avio_context_free>(
            'avio_context_free');
    return _avio_context_free(
      s,
    );
  }

  _dart_avio_context_free _avio_context_free;

  void avio_w8(
    ffi.Pointer<AVIOContext> s,
    int b,
  ) {
    _avio_w8 ??= _dylib.lookupFunction<_c_avio_w8, _dart_avio_w8>('avio_w8');
    return _avio_w8(
      s,
      b,
    );
  }

  _dart_avio_w8 _avio_w8;

  void avio_write(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Uint8> buf,
    int size,
  ) {
    _avio_write ??=
        _dylib.lookupFunction<_c_avio_write, _dart_avio_write>('avio_write');
    return _avio_write(
      s,
      buf,
      size,
    );
  }

  _dart_avio_write _avio_write;

  void avio_wl64(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wl64 ??=
        _dylib.lookupFunction<_c_avio_wl64, _dart_avio_wl64>('avio_wl64');
    return _avio_wl64(
      s,
      val,
    );
  }

  _dart_avio_wl64 _avio_wl64;

  void avio_wb64(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wb64 ??=
        _dylib.lookupFunction<_c_avio_wb64, _dart_avio_wb64>('avio_wb64');
    return _avio_wb64(
      s,
      val,
    );
  }

  _dart_avio_wb64 _avio_wb64;

  void avio_wl32(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wl32 ??=
        _dylib.lookupFunction<_c_avio_wl32, _dart_avio_wl32>('avio_wl32');
    return _avio_wl32(
      s,
      val,
    );
  }

  _dart_avio_wl32 _avio_wl32;

  void avio_wb32(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wb32 ??=
        _dylib.lookupFunction<_c_avio_wb32, _dart_avio_wb32>('avio_wb32');
    return _avio_wb32(
      s,
      val,
    );
  }

  _dart_avio_wb32 _avio_wb32;

  void avio_wl24(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wl24 ??=
        _dylib.lookupFunction<_c_avio_wl24, _dart_avio_wl24>('avio_wl24');
    return _avio_wl24(
      s,
      val,
    );
  }

  _dart_avio_wl24 _avio_wl24;

  void avio_wb24(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wb24 ??=
        _dylib.lookupFunction<_c_avio_wb24, _dart_avio_wb24>('avio_wb24');
    return _avio_wb24(
      s,
      val,
    );
  }

  _dart_avio_wb24 _avio_wb24;

  void avio_wl16(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wl16 ??=
        _dylib.lookupFunction<_c_avio_wl16, _dart_avio_wl16>('avio_wl16');
    return _avio_wl16(
      s,
      val,
    );
  }

  _dart_avio_wl16 _avio_wl16;

  void avio_wb16(
    ffi.Pointer<AVIOContext> s,
    int val,
  ) {
    _avio_wb16 ??=
        _dylib.lookupFunction<_c_avio_wb16, _dart_avio_wb16>('avio_wb16');
    return _avio_wb16(
      s,
      val,
    );
  }

  _dart_avio_wb16 _avio_wb16;

  /// Write a NULL-terminated string.
  /// @return number of bytes written.
  int avio_put_str(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Int8> str,
  ) {
    _avio_put_str ??= _dylib
        .lookupFunction<_c_avio_put_str, _dart_avio_put_str>('avio_put_str');
    return _avio_put_str(
      s,
      str,
    );
  }

  _dart_avio_put_str _avio_put_str;

  /// Convert an UTF-8 string to UTF-16LE and write it.
  /// @param s the AVIOContext
  /// @param str NULL-terminated UTF-8 string
  ///
  /// @return number of bytes written.
  int avio_put_str16le(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Int8> str,
  ) {
    _avio_put_str16le ??=
        _dylib.lookupFunction<_c_avio_put_str16le, _dart_avio_put_str16le>(
            'avio_put_str16le');
    return _avio_put_str16le(
      s,
      str,
    );
  }

  _dart_avio_put_str16le _avio_put_str16le;

  /// Convert an UTF-8 string to UTF-16BE and write it.
  /// @param s the AVIOContext
  /// @param str NULL-terminated UTF-8 string
  ///
  /// @return number of bytes written.
  int avio_put_str16be(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Int8> str,
  ) {
    _avio_put_str16be ??=
        _dylib.lookupFunction<_c_avio_put_str16be, _dart_avio_put_str16be>(
            'avio_put_str16be');
    return _avio_put_str16be(
      s,
      str,
    );
  }

  _dart_avio_put_str16be _avio_put_str16be;

  /// Mark the written bytestream as a specific type.
  ///
  /// Zero-length ranges are omitted from the output.
  ///
  /// @param time the stream time the current bytestream pos corresponds to
  /// (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not
  /// applicable
  /// @param type the kind of data written starting at the current pos
  void avio_write_marker(
    ffi.Pointer<AVIOContext> s,
    int time,
    int type,
  ) {
    _avio_write_marker ??=
        _dylib.lookupFunction<_c_avio_write_marker, _dart_avio_write_marker>(
            'avio_write_marker');
    return _avio_write_marker(
      s,
      time,
      type,
    );
  }

  _dart_avio_write_marker _avio_write_marker;

  /// fseek() equivalent for AVIOContext.
  /// @return new position or AVERROR.
  int avio_seek(
    ffi.Pointer<AVIOContext> s,
    int offset,
    int whence,
  ) {
    _avio_seek ??=
        _dylib.lookupFunction<_c_avio_seek, _dart_avio_seek>('avio_seek');
    return _avio_seek(
      s,
      offset,
      whence,
    );
  }

  _dart_avio_seek _avio_seek;

  /// Skip given number of bytes forward
  /// @return new position or AVERROR.
  int avio_skip(
    ffi.Pointer<AVIOContext> s,
    int offset,
  ) {
    _avio_skip ??=
        _dylib.lookupFunction<_c_avio_skip, _dart_avio_skip>('avio_skip');
    return _avio_skip(
      s,
      offset,
    );
  }

  _dart_avio_skip _avio_skip;

  /// ftell() equivalent for AVIOContext.
  /// @return position or AVERROR.
  int avio_tell(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_tell ??=
        _dylib.lookupFunction<_c_avio_tell, _dart_avio_tell>('avio_tell');
    return _avio_tell(
      s,
    );
  }

  _dart_avio_tell _avio_tell;

  /// Get the filesize.
  /// @return filesize or AVERROR
  int avio_size(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_size ??=
        _dylib.lookupFunction<_c_avio_size, _dart_avio_size>('avio_size');
    return _avio_size(
      s,
    );
  }

  _dart_avio_size _avio_size;

  /// Similar to feof() but also returns nonzero on read errors.
  /// @return non zero if and only if at end of file or a read error happened when reading.
  int avio_feof(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_feof ??=
        _dylib.lookupFunction<_c_avio_feof, _dart_avio_feof>('avio_feof');
    return _avio_feof(
      s,
    );
  }

  _dart_avio_feof _avio_feof;

  /// Writes a formatted string to the context.
  /// @return number of bytes written, < 0 on error.
  int avio_printf(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    _avio_printf ??=
        _dylib.lookupFunction<_c_avio_printf, _dart_avio_printf>('avio_printf');
    return _avio_printf(
      s,
      fmt,
    );
  }

  _dart_avio_printf _avio_printf;

  /// Write a NULL terminated array of strings to the context.
  /// Usually you don't need to use this function directly but its macro wrapper,
  /// avio_print.
  void avio_print_string_array(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> strings,
  ) {
    _avio_print_string_array ??= _dylib.lookupFunction<
        _c_avio_print_string_array,
        _dart_avio_print_string_array>('avio_print_string_array');
    return _avio_print_string_array(
      s,
      strings,
    );
  }

  _dart_avio_print_string_array _avio_print_string_array;

  /// Force flushing of buffered data.
  ///
  /// For write streams, force the buffered data to be immediately written to the output,
  /// without to wait to fill the internal buffer.
  ///
  /// For read streams, discard all currently buffered data, and advance the
  /// reported file position to that of the underlying stream. This does not
  /// read new data, and does not perform any seeks.
  void avio_flush(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_flush ??=
        _dylib.lookupFunction<_c_avio_flush, _dart_avio_flush>('avio_flush');
    return _avio_flush(
      s,
    );
  }

  _dart_avio_flush _avio_flush;

  /// Read size bytes from AVIOContext into buf.
  /// @return number of bytes read or AVERROR
  int avio_read(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Uint8> buf,
    int size,
  ) {
    _avio_read ??=
        _dylib.lookupFunction<_c_avio_read, _dart_avio_read>('avio_read');
    return _avio_read(
      s,
      buf,
      size,
    );
  }

  _dart_avio_read _avio_read;

  /// Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed
  /// to read fewer bytes than requested. The missing bytes can be read in the next
  /// call. This always tries to read at least 1 byte.
  /// Useful to reduce latency in certain cases.
  /// @return number of bytes read or AVERROR
  int avio_read_partial(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Uint8> buf,
    int size,
  ) {
    _avio_read_partial ??=
        _dylib.lookupFunction<_c_avio_read_partial, _dart_avio_read_partial>(
            'avio_read_partial');
    return _avio_read_partial(
      s,
      buf,
      size,
    );
  }

  _dart_avio_read_partial _avio_read_partial;

  /// @name Functions for reading from AVIOContext
  /// @{
  ///
  /// @note return 0 if EOF, so you cannot use it if EOF handling is
  /// necessary
  int avio_r8(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_r8 ??= _dylib.lookupFunction<_c_avio_r8, _dart_avio_r8>('avio_r8');
    return _avio_r8(
      s,
    );
  }

  _dart_avio_r8 _avio_r8;

  int avio_rl16(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rl16 ??=
        _dylib.lookupFunction<_c_avio_rl16, _dart_avio_rl16>('avio_rl16');
    return _avio_rl16(
      s,
    );
  }

  _dart_avio_rl16 _avio_rl16;

  int avio_rl24(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rl24 ??=
        _dylib.lookupFunction<_c_avio_rl24, _dart_avio_rl24>('avio_rl24');
    return _avio_rl24(
      s,
    );
  }

  _dart_avio_rl24 _avio_rl24;

  int avio_rl32(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rl32 ??=
        _dylib.lookupFunction<_c_avio_rl32, _dart_avio_rl32>('avio_rl32');
    return _avio_rl32(
      s,
    );
  }

  _dart_avio_rl32 _avio_rl32;

  int avio_rl64(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rl64 ??=
        _dylib.lookupFunction<_c_avio_rl64, _dart_avio_rl64>('avio_rl64');
    return _avio_rl64(
      s,
    );
  }

  _dart_avio_rl64 _avio_rl64;

  int avio_rb16(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rb16 ??=
        _dylib.lookupFunction<_c_avio_rb16, _dart_avio_rb16>('avio_rb16');
    return _avio_rb16(
      s,
    );
  }

  _dart_avio_rb16 _avio_rb16;

  int avio_rb24(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rb24 ??=
        _dylib.lookupFunction<_c_avio_rb24, _dart_avio_rb24>('avio_rb24');
    return _avio_rb24(
      s,
    );
  }

  _dart_avio_rb24 _avio_rb24;

  int avio_rb32(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rb32 ??=
        _dylib.lookupFunction<_c_avio_rb32, _dart_avio_rb32>('avio_rb32');
    return _avio_rb32(
      s,
    );
  }

  _dart_avio_rb32 _avio_rb32;

  int avio_rb64(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_rb64 ??=
        _dylib.lookupFunction<_c_avio_rb64, _dart_avio_rb64>('avio_rb64');
    return _avio_rb64(
      s,
    );
  }

  _dart_avio_rb64 _avio_rb64;

  /// Read a string from pb into buf. The reading will terminate when either
  /// a NULL character was encountered, maxlen bytes have been read, or nothing
  /// more can be read from pb. The result is guaranteed to be NULL-terminated, it
  /// will be truncated if buf is too small.
  /// Note that the string is not interpreted or validated in any way, it
  /// might get truncated in the middle of a sequence for multi-byte encodings.
  ///
  /// @return number of bytes read (is always <= maxlen).
  /// If reading ends on EOF or error, the return value will be one more than
  /// bytes actually read.
  int avio_get_str(
    ffi.Pointer<AVIOContext> pb,
    int maxlen,
    ffi.Pointer<ffi.Int8> buf,
    int buflen,
  ) {
    _avio_get_str ??= _dylib
        .lookupFunction<_c_avio_get_str, _dart_avio_get_str>('avio_get_str');
    return _avio_get_str(
      pb,
      maxlen,
      buf,
      buflen,
    );
  }

  _dart_avio_get_str _avio_get_str;

  /// Read a UTF-16 string from pb and convert it to UTF-8.
  /// The reading will terminate when either a null or invalid character was
  /// encountered or maxlen bytes have been read.
  /// @return number of bytes read (is always <= maxlen)
  int avio_get_str16le(
    ffi.Pointer<AVIOContext> pb,
    int maxlen,
    ffi.Pointer<ffi.Int8> buf,
    int buflen,
  ) {
    _avio_get_str16le ??=
        _dylib.lookupFunction<_c_avio_get_str16le, _dart_avio_get_str16le>(
            'avio_get_str16le');
    return _avio_get_str16le(
      pb,
      maxlen,
      buf,
      buflen,
    );
  }

  _dart_avio_get_str16le _avio_get_str16le;

  int avio_get_str16be(
    ffi.Pointer<AVIOContext> pb,
    int maxlen,
    ffi.Pointer<ffi.Int8> buf,
    int buflen,
  ) {
    _avio_get_str16be ??=
        _dylib.lookupFunction<_c_avio_get_str16be, _dart_avio_get_str16be>(
            'avio_get_str16be');
    return _avio_get_str16be(
      pb,
      maxlen,
      buf,
      buflen,
    );
  }

  _dart_avio_get_str16be _avio_get_str16be;

  /// Create and initialize a AVIOContext for accessing the
  /// resource indicated by url.
  /// @note When the resource indicated by url has been opened in
  /// read+write mode, the AVIOContext can be used only for writing.
  ///
  /// @param s Used to return the pointer to the created AVIOContext.
  /// In case of failure the pointed to value is set to NULL.
  /// @param url resource to access
  /// @param flags flags which control how the resource indicated by url
  /// is to be opened
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code in case of failure
  int avio_open(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
    ffi.Pointer<ffi.Int8> url,
    int flags,
  ) {
    _avio_open ??=
        _dylib.lookupFunction<_c_avio_open, _dart_avio_open>('avio_open');
    return _avio_open(
      s,
      url,
      flags,
    );
  }

  _dart_avio_open _avio_open;

  /// Create and initialize a AVIOContext for accessing the
  /// resource indicated by url.
  /// @note When the resource indicated by url has been opened in
  /// read+write mode, the AVIOContext can be used only for writing.
  ///
  /// @param s Used to return the pointer to the created AVIOContext.
  /// In case of failure the pointed to value is set to NULL.
  /// @param url resource to access
  /// @param flags flags which control how the resource indicated by url
  /// is to be opened
  /// @param int_cb an interrupt callback to be used at the protocols level
  /// @param options  A dictionary filled with protocol-private options. On return
  /// this parameter will be destroyed and replaced with a dict containing options
  /// that were not found. May be NULL.
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code in case of failure
  int avio_open2(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
    ffi.Pointer<ffi.Int8> url,
    int flags,
    ffi.Pointer<AVIOInterruptCB> int_cb,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avio_open2 ??=
        _dylib.lookupFunction<_c_avio_open2, _dart_avio_open2>('avio_open2');
    return _avio_open2(
      s,
      url,
      flags,
      int_cb,
      options,
    );
  }

  _dart_avio_open2 _avio_open2;

  /// Close the resource accessed by the AVIOContext s and free it.
  /// This function can only be used if s was opened by avio_open().
  ///
  /// The internal buffer is automatically flushed before closing the
  /// resource.
  ///
  /// @return 0 on success, an AVERROR < 0 on error.
  /// @see avio_closep
  int avio_close(
    ffi.Pointer<AVIOContext> s,
  ) {
    _avio_close ??=
        _dylib.lookupFunction<_c_avio_close, _dart_avio_close>('avio_close');
    return _avio_close(
      s,
    );
  }

  _dart_avio_close _avio_close;

  /// Close the resource accessed by the AVIOContext *s, free it
  /// and set the pointer pointing to it to NULL.
  /// This function can only be used if s was opened by avio_open().
  ///
  /// The internal buffer is automatically flushed before closing the
  /// resource.
  ///
  /// @return 0 on success, an AVERROR < 0 on error.
  /// @see avio_close
  int avio_closep(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ) {
    _avio_closep ??=
        _dylib.lookupFunction<_c_avio_closep, _dart_avio_closep>('avio_closep');
    return _avio_closep(
      s,
    );
  }

  _dart_avio_closep _avio_closep;

  /// Open a write only memory stream.
  ///
  /// @param s new IO context
  /// @return zero if no error.
  int avio_open_dyn_buf(
    ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ) {
    _avio_open_dyn_buf ??=
        _dylib.lookupFunction<_c_avio_open_dyn_buf, _dart_avio_open_dyn_buf>(
            'avio_open_dyn_buf');
    return _avio_open_dyn_buf(
      s,
    );
  }

  _dart_avio_open_dyn_buf _avio_open_dyn_buf;

  /// Return the written size and a pointer to the buffer.
  /// The AVIOContext stream is left intact.
  /// The buffer must NOT be freed.
  /// No padding is added to the buffer.
  ///
  /// @param s IO context
  /// @param pbuffer pointer to a byte buffer
  /// @return the length of the byte buffer
  int avio_get_dyn_buf(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
  ) {
    _avio_get_dyn_buf ??=
        _dylib.lookupFunction<_c_avio_get_dyn_buf, _dart_avio_get_dyn_buf>(
            'avio_get_dyn_buf');
    return _avio_get_dyn_buf(
      s,
      pbuffer,
    );
  }

  _dart_avio_get_dyn_buf _avio_get_dyn_buf;

  /// Return the written size and a pointer to the buffer. The buffer
  /// must be freed with av_free().
  /// Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.
  ///
  /// @param s IO context
  /// @param pbuffer pointer to a byte buffer
  /// @return the length of the byte buffer
  int avio_close_dyn_buf(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
  ) {
    _avio_close_dyn_buf ??=
        _dylib.lookupFunction<_c_avio_close_dyn_buf, _dart_avio_close_dyn_buf>(
            'avio_close_dyn_buf');
    return _avio_close_dyn_buf(
      s,
      pbuffer,
    );
  }

  _dart_avio_close_dyn_buf _avio_close_dyn_buf;

  /// Iterate through names of available protocols.
  ///
  /// @param opaque A private pointer representing current protocol.
  /// It must be a pointer to NULL on first iteration and will
  /// be updated by successive calls to avio_enum_protocols.
  /// @param output If set to 1, iterate over output protocols,
  /// otherwise over input protocols.
  ///
  /// @return A static string containing the name of current protocol or NULL
  ffi.Pointer<ffi.Int8> avio_enum_protocols(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
    int output,
  ) {
    _avio_enum_protocols ??= _dylib.lookupFunction<_c_avio_enum_protocols,
        _dart_avio_enum_protocols>('avio_enum_protocols');
    return _avio_enum_protocols(
      opaque,
      output,
    );
  }

  _dart_avio_enum_protocols _avio_enum_protocols;

  /// Get AVClass by names of available protocols.
  ///
  /// @return A AVClass of input protocol name or NULL
  ffi.Pointer<AVClass> avio_protocol_get_class(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _avio_protocol_get_class ??= _dylib.lookupFunction<
        _c_avio_protocol_get_class,
        _dart_avio_protocol_get_class>('avio_protocol_get_class');
    return _avio_protocol_get_class(
      name,
    );
  }

  _dart_avio_protocol_get_class _avio_protocol_get_class;

  /// Pause and resume playing - only meaningful if using a network streaming
  /// protocol (e.g. MMS).
  ///
  /// @param h     IO context from which to call the read_pause function pointer
  /// @param pause 1 for pause, 0 for resume
  int avio_pause(
    ffi.Pointer<AVIOContext> h,
    int pause,
  ) {
    _avio_pause ??=
        _dylib.lookupFunction<_c_avio_pause, _dart_avio_pause>('avio_pause');
    return _avio_pause(
      h,
      pause,
    );
  }

  _dart_avio_pause _avio_pause;

  /// Seek to a given timestamp relative to some component stream.
  /// Only meaningful if using a network streaming protocol (e.g. MMS.).
  ///
  /// @param h IO context from which to call the seek function pointers
  /// @param stream_index The stream index that the timestamp is relative to.
  /// If stream_index is (-1) the timestamp should be in AV_TIME_BASE
  /// units from the beginning of the presentation.
  /// If a stream_index >= 0 is used and the protocol does not support
  /// seeking based on component streams, the call will fail.
  /// @param timestamp timestamp in AVStream.time_base units
  /// or if there is no stream specified then in AV_TIME_BASE units.
  /// @param flags Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE
  /// and AVSEEK_FLAG_ANY. The protocol may silently ignore
  /// AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will
  /// fail if used and not supported.
  /// @return >= 0 on success
  /// @see AVInputFormat::read_seek
  int avio_seek_time(
    ffi.Pointer<AVIOContext> h,
    int stream_index,
    int timestamp,
    int flags,
  ) {
    _avio_seek_time ??=
        _dylib.lookupFunction<_c_avio_seek_time, _dart_avio_seek_time>(
            'avio_seek_time');
    return _avio_seek_time(
      h,
      stream_index,
      timestamp,
      flags,
    );
  }

  _dart_avio_seek_time _avio_seek_time;

  /// Read contents of h into print buffer, up to max_size bytes, or up to EOF.
  ///
  /// @return 0 for success (max_size bytes read or EOF reached), negative error
  /// code otherwise
  int avio_read_to_bprint(
    ffi.Pointer<AVIOContext> h,
    ffi.Pointer<AVBPrint> pb,
    int max_size,
  ) {
    _avio_read_to_bprint ??= _dylib.lookupFunction<_c_avio_read_to_bprint,
        _dart_avio_read_to_bprint>('avio_read_to_bprint');
    return _avio_read_to_bprint(
      h,
      pb,
      max_size,
    );
  }

  _dart_avio_read_to_bprint _avio_read_to_bprint;

  /// Accept and allocate a client context on a server context.
  /// @param  s the server context
  /// @param  c the client context, must be unallocated
  /// @return   >= 0 on success or a negative value corresponding
  /// to an AVERROR on failure
  int avio_accept(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<ffi.Pointer<AVIOContext>> c,
  ) {
    _avio_accept ??=
        _dylib.lookupFunction<_c_avio_accept, _dart_avio_accept>('avio_accept');
    return _avio_accept(
      s,
      c,
    );
  }

  _dart_avio_accept _avio_accept;

  /// Perform one step of the protocol handshake to accept a new client.
  /// This function must be called on a client returned by avio_accept() before
  /// using it as a read/write context.
  /// It is separate from avio_accept() because it may block.
  /// A step of the handshake is defined by places where the application may
  /// decide to change the proceedings.
  /// For example, on a protocol with a request header and a reply header, each
  /// one can constitute a step because the application may use the parameters
  /// from the request to change parameters in the reply; or each individual
  /// chunk of the request can constitute a step.
  /// If the handshake is already finished, avio_handshake() does nothing and
  /// returns 0 immediately.
  ///
  /// @param  c the client context to perform the handshake on
  /// @return   0   on a complete and successful handshake
  /// > 0 if the handshake progressed, but is not complete
  /// < 0 for an AVERROR code
  int avio_handshake(
    ffi.Pointer<AVIOContext> c,
  ) {
    _avio_handshake ??=
        _dylib.lookupFunction<_c_avio_handshake, _dart_avio_handshake>(
            'avio_handshake');
    return _avio_handshake(
      c,
    );
  }

  _dart_avio_handshake _avio_handshake;

  /// Allocate and read the payload of a packet and initialize its
  /// fields with default values.
  ///
  /// @param s    associated IO context
  /// @param pkt packet
  /// @param size desired payload size
  /// @return >0 (read size) if OK, AVERROR_xxx otherwise
  int av_get_packet(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    _av_get_packet ??= _dylib
        .lookupFunction<_c_av_get_packet, _dart_av_get_packet>('av_get_packet');
    return _av_get_packet(
      s,
      pkt,
      size,
    );
  }

  _dart_av_get_packet _av_get_packet;

  /// Read data and append it to the current content of the AVPacket.
  /// If pkt->size is 0 this is identical to av_get_packet.
  /// Note that this uses av_grow_packet and thus involves a realloc
  /// which is inefficient. Thus this function should only be used
  /// when there is no reasonable way to know (an upper bound of)
  /// the final size.
  ///
  /// @param s    associated IO context
  /// @param pkt packet
  /// @param size amount of data to read
  /// @return >0 (read size) if OK, AVERROR_xxx otherwise, previous data
  /// will not be lost even if an error occurs.
  int av_append_packet(
    ffi.Pointer<AVIOContext> s,
    ffi.Pointer<AVPacket> pkt,
    int size,
  ) {
    _av_append_packet ??=
        _dylib.lookupFunction<_c_av_append_packet, _dart_av_append_packet>(
            'av_append_packet');
    return _av_append_packet(
      s,
      pkt,
      size,
    );
  }

  _dart_av_append_packet _av_append_packet;

  ffi.Pointer<ffi.Int8> av_stream_get_recommended_encoder_configuration(
    ffi.Pointer<AVStream> s,
  ) {
    _av_stream_get_recommended_encoder_configuration ??= _dylib.lookupFunction<
            _c_av_stream_get_recommended_encoder_configuration,
            _dart_av_stream_get_recommended_encoder_configuration>(
        'av_stream_get_recommended_encoder_configuration');
    return _av_stream_get_recommended_encoder_configuration(
      s,
    );
  }

  _dart_av_stream_get_recommended_encoder_configuration
      _av_stream_get_recommended_encoder_configuration;

  void av_stream_set_recommended_encoder_configuration(
    ffi.Pointer<AVStream> s,
    ffi.Pointer<ffi.Int8> configuration,
  ) {
    _av_stream_set_recommended_encoder_configuration ??= _dylib.lookupFunction<
            _c_av_stream_set_recommended_encoder_configuration,
            _dart_av_stream_set_recommended_encoder_configuration>(
        'av_stream_set_recommended_encoder_configuration');
    return _av_stream_set_recommended_encoder_configuration(
      s,
      configuration,
    );
  }

  _dart_av_stream_set_recommended_encoder_configuration
      _av_stream_set_recommended_encoder_configuration;

  ffi.Pointer<AVCodecParserContext> av_stream_get_parser(
    ffi.Pointer<AVStream> s,
  ) {
    _av_stream_get_parser ??= _dylib.lookupFunction<_c_av_stream_get_parser,
        _dart_av_stream_get_parser>('av_stream_get_parser');
    return _av_stream_get_parser(
      s,
    );
  }

  _dart_av_stream_get_parser _av_stream_get_parser;

  /// Returns the pts of the last muxed packet + its duration
  ///
  /// the retuned value is undefined when used with a demuxer.
  int av_stream_get_end_pts(
    ffi.Pointer<AVStream> st,
  ) {
    _av_stream_get_end_pts ??= _dylib.lookupFunction<_c_av_stream_get_end_pts,
        _dart_av_stream_get_end_pts>('av_stream_get_end_pts');
    return _av_stream_get_end_pts(
      st,
    );
  }

  _dart_av_stream_get_end_pts _av_stream_get_end_pts;

  /// Accessors for some AVFormatContext fields. These used to be provided for ABI
  /// compatibility, and do not need to be used anymore.
  int av_format_get_probe_score(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_probe_score ??= _dylib.lookupFunction<
        _c_av_format_get_probe_score,
        _dart_av_format_get_probe_score>('av_format_get_probe_score');
    return _av_format_get_probe_score(
      s,
    );
  }

  _dart_av_format_get_probe_score _av_format_get_probe_score;

  ffi.Pointer<AVCodec> av_format_get_video_codec(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_video_codec ??= _dylib.lookupFunction<
        _c_av_format_get_video_codec,
        _dart_av_format_get_video_codec>('av_format_get_video_codec');
    return _av_format_get_video_codec(
      s,
    );
  }

  _dart_av_format_get_video_codec _av_format_get_video_codec;

  void av_format_set_video_codec(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVCodec> c,
  ) {
    _av_format_set_video_codec ??= _dylib.lookupFunction<
        _c_av_format_set_video_codec,
        _dart_av_format_set_video_codec>('av_format_set_video_codec');
    return _av_format_set_video_codec(
      s,
      c,
    );
  }

  _dart_av_format_set_video_codec _av_format_set_video_codec;

  ffi.Pointer<AVCodec> av_format_get_audio_codec(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_audio_codec ??= _dylib.lookupFunction<
        _c_av_format_get_audio_codec,
        _dart_av_format_get_audio_codec>('av_format_get_audio_codec');
    return _av_format_get_audio_codec(
      s,
    );
  }

  _dart_av_format_get_audio_codec _av_format_get_audio_codec;

  void av_format_set_audio_codec(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVCodec> c,
  ) {
    _av_format_set_audio_codec ??= _dylib.lookupFunction<
        _c_av_format_set_audio_codec,
        _dart_av_format_set_audio_codec>('av_format_set_audio_codec');
    return _av_format_set_audio_codec(
      s,
      c,
    );
  }

  _dart_av_format_set_audio_codec _av_format_set_audio_codec;

  ffi.Pointer<AVCodec> av_format_get_subtitle_codec(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_subtitle_codec ??= _dylib.lookupFunction<
        _c_av_format_get_subtitle_codec,
        _dart_av_format_get_subtitle_codec>('av_format_get_subtitle_codec');
    return _av_format_get_subtitle_codec(
      s,
    );
  }

  _dart_av_format_get_subtitle_codec _av_format_get_subtitle_codec;

  void av_format_set_subtitle_codec(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVCodec> c,
  ) {
    _av_format_set_subtitle_codec ??= _dylib.lookupFunction<
        _c_av_format_set_subtitle_codec,
        _dart_av_format_set_subtitle_codec>('av_format_set_subtitle_codec');
    return _av_format_set_subtitle_codec(
      s,
      c,
    );
  }

  _dart_av_format_set_subtitle_codec _av_format_set_subtitle_codec;

  ffi.Pointer<AVCodec> av_format_get_data_codec(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_data_codec ??= _dylib.lookupFunction<
        _c_av_format_get_data_codec,
        _dart_av_format_get_data_codec>('av_format_get_data_codec');
    return _av_format_get_data_codec(
      s,
    );
  }

  _dart_av_format_get_data_codec _av_format_get_data_codec;

  void av_format_set_data_codec(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVCodec> c,
  ) {
    _av_format_set_data_codec ??= _dylib.lookupFunction<
        _c_av_format_set_data_codec,
        _dart_av_format_set_data_codec>('av_format_set_data_codec');
    return _av_format_set_data_codec(
      s,
      c,
    );
  }

  _dart_av_format_set_data_codec _av_format_set_data_codec;

  int av_format_get_metadata_header_padding(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_metadata_header_padding ??= _dylib.lookupFunction<
            _c_av_format_get_metadata_header_padding,
            _dart_av_format_get_metadata_header_padding>(
        'av_format_get_metadata_header_padding');
    return _av_format_get_metadata_header_padding(
      s,
    );
  }

  _dart_av_format_get_metadata_header_padding
      _av_format_get_metadata_header_padding;

  void av_format_set_metadata_header_padding(
    ffi.Pointer<AVFormatContext> s,
    int c,
  ) {
    _av_format_set_metadata_header_padding ??= _dylib.lookupFunction<
            _c_av_format_set_metadata_header_padding,
            _dart_av_format_set_metadata_header_padding>(
        'av_format_set_metadata_header_padding');
    return _av_format_set_metadata_header_padding(
      s,
      c,
    );
  }

  _dart_av_format_set_metadata_header_padding
      _av_format_set_metadata_header_padding;

  ffi.Pointer<ffi.Void> av_format_get_opaque(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_opaque ??= _dylib.lookupFunction<_c_av_format_get_opaque,
        _dart_av_format_get_opaque>('av_format_get_opaque');
    return _av_format_get_opaque(
      s,
    );
  }

  _dart_av_format_get_opaque _av_format_get_opaque;

  void av_format_set_opaque(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Void> opaque,
  ) {
    _av_format_set_opaque ??= _dylib.lookupFunction<_c_av_format_set_opaque,
        _dart_av_format_set_opaque>('av_format_set_opaque');
    return _av_format_set_opaque(
      s,
      opaque,
    );
  }

  _dart_av_format_set_opaque _av_format_set_opaque;

  ffi.Pointer<ffi.NativeFunction<av_format_control_message>>
      av_format_get_control_message_cb(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_control_message_cb ??= _dylib.lookupFunction<
            _c_av_format_get_control_message_cb,
            _dart_av_format_get_control_message_cb>(
        'av_format_get_control_message_cb');
    return _av_format_get_control_message_cb(
      s,
    );
  }

  _dart_av_format_get_control_message_cb _av_format_get_control_message_cb;

  void av_format_set_control_message_cb(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.NativeFunction<av_format_control_message>> callback,
  ) {
    _av_format_set_control_message_cb ??= _dylib.lookupFunction<
            _c_av_format_set_control_message_cb,
            _dart_av_format_set_control_message_cb>(
        'av_format_set_control_message_cb');
    return _av_format_set_control_message_cb(
      s,
      callback,
    );
  }

  _dart_av_format_set_control_message_cb _av_format_set_control_message_cb;

  ffi.Pointer<ffi.NativeFunction<AVOpenCallback>> av_format_get_open_cb(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_get_open_cb ??= _dylib.lookupFunction<_c_av_format_get_open_cb,
        _dart_av_format_get_open_cb>('av_format_get_open_cb');
    return _av_format_get_open_cb(
      s,
    );
  }

  _dart_av_format_get_open_cb _av_format_get_open_cb;

  void av_format_set_open_cb(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.NativeFunction<AVOpenCallback>> callback,
  ) {
    _av_format_set_open_cb ??= _dylib.lookupFunction<_c_av_format_set_open_cb,
        _dart_av_format_set_open_cb>('av_format_set_open_cb');
    return _av_format_set_open_cb(
      s,
      callback,
    );
  }

  _dart_av_format_set_open_cb _av_format_set_open_cb;

  /// This function will cause global side data to be injected in the next packet
  /// of each stream as well as after any subsequent seek.
  void av_format_inject_global_side_data(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_format_inject_global_side_data ??= _dylib.lookupFunction<
            _c_av_format_inject_global_side_data,
            _dart_av_format_inject_global_side_data>(
        'av_format_inject_global_side_data');
    return _av_format_inject_global_side_data(
      s,
    );
  }

  _dart_av_format_inject_global_side_data _av_format_inject_global_side_data;

  /// Returns the method used to set ctx->duration.
  ///
  /// @return AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.
  int av_fmt_ctx_get_duration_estimation_method(
    ffi.Pointer<AVFormatContext> ctx,
  ) {
    _av_fmt_ctx_get_duration_estimation_method ??= _dylib.lookupFunction<
            _c_av_fmt_ctx_get_duration_estimation_method,
            _dart_av_fmt_ctx_get_duration_estimation_method>(
        'av_fmt_ctx_get_duration_estimation_method');
    return _av_fmt_ctx_get_duration_estimation_method(
      ctx,
    );
  }

  _dart_av_fmt_ctx_get_duration_estimation_method
      _av_fmt_ctx_get_duration_estimation_method;

  /// Return the LIBAVFORMAT_VERSION_INT constant.
  int avformat_version() {
    _avformat_version ??=
        _dylib.lookupFunction<_c_avformat_version, _dart_avformat_version>(
            'avformat_version');
    return _avformat_version();
  }

  _dart_avformat_version _avformat_version;

  /// Return the libavformat build-time configuration.
  ffi.Pointer<ffi.Int8> avformat_configuration() {
    _avformat_configuration ??= _dylib.lookupFunction<_c_avformat_configuration,
        _dart_avformat_configuration>('avformat_configuration');
    return _avformat_configuration();
  }

  _dart_avformat_configuration _avformat_configuration;

  /// Return the libavformat license.
  ffi.Pointer<ffi.Int8> avformat_license() {
    _avformat_license ??=
        _dylib.lookupFunction<_c_avformat_license, _dart_avformat_license>(
            'avformat_license');
    return _avformat_license();
  }

  _dart_avformat_license _avformat_license;

  /// Initialize libavformat and register all the muxers, demuxers and
  /// protocols. If you do not call this function, then you can select
  /// exactly which formats you want to support.
  ///
  /// @see av_register_input_format()
  /// @see av_register_output_format()
  void av_register_all() {
    _av_register_all ??=
        _dylib.lookupFunction<_c_av_register_all, _dart_av_register_all>(
            'av_register_all');
    return _av_register_all();
  }

  _dart_av_register_all _av_register_all;

  void av_register_input_format(
    ffi.Pointer<AVInputFormat> format,
  ) {
    _av_register_input_format ??= _dylib.lookupFunction<
        _c_av_register_input_format,
        _dart_av_register_input_format>('av_register_input_format');
    return _av_register_input_format(
      format,
    );
  }

  _dart_av_register_input_format _av_register_input_format;

  void av_register_output_format(
    ffi.Pointer<AVOutputFormat> format,
  ) {
    _av_register_output_format ??= _dylib.lookupFunction<
        _c_av_register_output_format,
        _dart_av_register_output_format>('av_register_output_format');
    return _av_register_output_format(
      format,
    );
  }

  _dart_av_register_output_format _av_register_output_format;

  /// Do global initialization of network libraries. This is optional,
  /// and not recommended anymore.
  ///
  /// This functions only exists to work around thread-safety issues
  /// with older GnuTLS or OpenSSL libraries. If libavformat is linked
  /// to newer versions of those libraries, or if you do not use them,
  /// calling this function is unnecessary. Otherwise, you need to call
  /// this function before any other threads using them are started.
  ///
  /// This function will be deprecated once support for older GnuTLS and
  /// OpenSSL libraries is removed, and this function has no purpose
  /// anymore.
  int avformat_network_init() {
    _avformat_network_init ??= _dylib.lookupFunction<_c_avformat_network_init,
        _dart_avformat_network_init>('avformat_network_init');
    return _avformat_network_init();
  }

  _dart_avformat_network_init _avformat_network_init;

  /// Undo the initialization done by avformat_network_init. Call it only
  /// once for each time you called avformat_network_init.
  int avformat_network_deinit() {
    _avformat_network_deinit ??= _dylib.lookupFunction<
        _c_avformat_network_deinit,
        _dart_avformat_network_deinit>('avformat_network_deinit');
    return _avformat_network_deinit();
  }

  _dart_avformat_network_deinit _avformat_network_deinit;

  /// If f is NULL, returns the first registered input format,
  /// if f is non-NULL, returns the next registered input format after f
  /// or NULL if f is the last one.
  ffi.Pointer<AVInputFormat> av_iformat_next(
    ffi.Pointer<AVInputFormat> f,
  ) {
    _av_iformat_next ??=
        _dylib.lookupFunction<_c_av_iformat_next, _dart_av_iformat_next>(
            'av_iformat_next');
    return _av_iformat_next(
      f,
    );
  }

  _dart_av_iformat_next _av_iformat_next;

  /// If f is NULL, returns the first registered output format,
  /// if f is non-NULL, returns the next registered output format after f
  /// or NULL if f is the last one.
  ffi.Pointer<AVOutputFormat> av_oformat_next(
    ffi.Pointer<AVOutputFormat> f,
  ) {
    _av_oformat_next ??=
        _dylib.lookupFunction<_c_av_oformat_next, _dart_av_oformat_next>(
            'av_oformat_next');
    return _av_oformat_next(
      f,
    );
  }

  _dart_av_oformat_next _av_oformat_next;

  /// Iterate over all registered muxers.
  ///
  /// @param opaque a pointer where libavformat will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered muxer or NULL when the iteration is
  /// finished
  ffi.Pointer<AVOutputFormat> av_muxer_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    _av_muxer_iterate ??=
        _dylib.lookupFunction<_c_av_muxer_iterate, _dart_av_muxer_iterate>(
            'av_muxer_iterate');
    return _av_muxer_iterate(
      opaque,
    );
  }

  _dart_av_muxer_iterate _av_muxer_iterate;

  /// Iterate over all registered demuxers.
  ///
  /// @param opaque a pointer where libavformat will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered demuxer or NULL when the iteration is
  /// finished
  ffi.Pointer<AVInputFormat> av_demuxer_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    _av_demuxer_iterate ??=
        _dylib.lookupFunction<_c_av_demuxer_iterate, _dart_av_demuxer_iterate>(
            'av_demuxer_iterate');
    return _av_demuxer_iterate(
      opaque,
    );
  }

  _dart_av_demuxer_iterate _av_demuxer_iterate;

  /// Allocate an AVFormatContext.
  /// avformat_free_context() can be used to free the context and everything
  /// allocated by the framework within it.
  ffi.Pointer<AVFormatContext> avformat_alloc_context() {
    _avformat_alloc_context ??= _dylib.lookupFunction<_c_avformat_alloc_context,
        _dart_avformat_alloc_context>('avformat_alloc_context');
    return _avformat_alloc_context();
  }

  _dart_avformat_alloc_context _avformat_alloc_context;

  /// Free an AVFormatContext and all its streams.
  /// @param s context to free
  void avformat_free_context(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _avformat_free_context ??= _dylib.lookupFunction<_c_avformat_free_context,
        _dart_avformat_free_context>('avformat_free_context');
    return _avformat_free_context(
      s,
    );
  }

  _dart_avformat_free_context _avformat_free_context;

  /// Get the AVClass for AVFormatContext. It can be used in combination with
  /// AV_OPT_SEARCH_FAKE_OBJ for examining options.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avformat_get_class() {
    _avformat_get_class ??=
        _dylib.lookupFunction<_c_avformat_get_class, _dart_avformat_get_class>(
            'avformat_get_class');
    return _avformat_get_class();
  }

  _dart_avformat_get_class _avformat_get_class;

  /// Add a new stream to a media file.
  ///
  /// When demuxing, it is called by the demuxer in read_header(). If the
  /// flag AVFMTCTX_NOHEADER is set in s.ctx_flags, then it may also
  /// be called in read_packet().
  ///
  /// When muxing, should be called by the user before avformat_write_header().
  ///
  /// User is required to call avcodec_close() and avformat_free_context() to
  /// clean up the allocation by avformat_new_stream().
  ///
  /// @param s media file handle
  /// @param c If non-NULL, the AVCodecContext corresponding to the new stream
  /// will be initialized to use this codec. This is needed for e.g. codec-specific
  /// defaults to be set, so codec should be provided if it is known.
  ///
  /// @return newly created stream or NULL on error.
  ffi.Pointer<AVStream> avformat_new_stream(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVCodec> c,
  ) {
    _avformat_new_stream ??= _dylib.lookupFunction<_c_avformat_new_stream,
        _dart_avformat_new_stream>('avformat_new_stream');
    return _avformat_new_stream(
      s,
      c,
    );
  }

  _dart_avformat_new_stream _avformat_new_stream;

  /// Wrap an existing array as stream side data.
  ///
  /// @param st stream
  /// @param type side information type
  /// @param data the side data array. It must be allocated with the av_malloc()
  /// family of functions. The ownership of the data is transferred to
  /// st.
  /// @param size side information size
  /// @return zero on success, a negative AVERROR code on failure. On failure,
  /// the stream is unchanged and the data remains owned by the caller.
  int av_stream_add_side_data(
    ffi.Pointer<AVStream> st,
    int type,
    ffi.Pointer<ffi.Uint8> data,
    int size,
  ) {
    _av_stream_add_side_data ??= _dylib.lookupFunction<
        _c_av_stream_add_side_data,
        _dart_av_stream_add_side_data>('av_stream_add_side_data');
    return _av_stream_add_side_data(
      st,
      type,
      data,
      size,
    );
  }

  _dart_av_stream_add_side_data _av_stream_add_side_data;

  /// Allocate new information from stream.
  ///
  /// @param stream stream
  /// @param type desired side information type
  /// @param size side information size
  /// @return pointer to fresh allocated data or NULL otherwise
  ffi.Pointer<ffi.Uint8> av_stream_new_side_data(
    ffi.Pointer<AVStream> stream,
    int type,
    int size,
  ) {
    _av_stream_new_side_data ??= _dylib.lookupFunction<
        _c_av_stream_new_side_data,
        _dart_av_stream_new_side_data>('av_stream_new_side_data');
    return _av_stream_new_side_data(
      stream,
      type,
      size,
    );
  }

  _dart_av_stream_new_side_data _av_stream_new_side_data;

  /// Get side information from stream.
  ///
  /// @param stream stream
  /// @param type desired side information type
  /// @param size If supplied, *size will be set to the size of the side data
  /// or to zero if the desired side data is not present.
  /// @return pointer to data if present or NULL otherwise
  ffi.Pointer<ffi.Uint8> av_stream_get_side_data(
    ffi.Pointer<AVStream> stream,
    int type,
    ffi.Pointer<ffi.Int32> size,
  ) {
    _av_stream_get_side_data ??= _dylib.lookupFunction<
        _c_av_stream_get_side_data,
        _dart_av_stream_get_side_data>('av_stream_get_side_data');
    return _av_stream_get_side_data(
      stream,
      type,
      size,
    );
  }

  _dart_av_stream_get_side_data _av_stream_get_side_data;

  ffi.Pointer<AVProgram> av_new_program(
    ffi.Pointer<AVFormatContext> s,
    int id,
  ) {
    _av_new_program ??=
        _dylib.lookupFunction<_c_av_new_program, _dart_av_new_program>(
            'av_new_program');
    return _av_new_program(
      s,
      id,
    );
  }

  _dart_av_new_program _av_new_program;

  /// Allocate an AVFormatContext for an output format.
  /// avformat_free_context() can be used to free the context and
  /// everything allocated by the framework within it.
  ///
  /// @param *ctx is set to the created format context, or to NULL in
  /// case of failure
  /// @param oformat format to use for allocating the context, if NULL
  /// format_name and filename are used instead
  /// @param format_name the name of output format to use for allocating the
  /// context, if NULL filename is used instead
  /// @param filename the name of the filename to use for allocating the
  /// context, may be NULL
  /// @return >= 0 in case of success, a negative AVERROR code in case of
  /// failure
  int avformat_alloc_output_context2(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> ctx,
    ffi.Pointer<AVOutputFormat> oformat,
    ffi.Pointer<ffi.Int8> format_name,
    ffi.Pointer<ffi.Int8> filename,
  ) {
    _avformat_alloc_output_context2 ??= _dylib.lookupFunction<
        _c_avformat_alloc_output_context2,
        _dart_avformat_alloc_output_context2>('avformat_alloc_output_context2');
    return _avformat_alloc_output_context2(
      ctx,
      oformat,
      format_name,
      filename,
    );
  }

  _dart_avformat_alloc_output_context2 _avformat_alloc_output_context2;

  /// Find AVInputFormat based on the short name of the input format.
  ffi.Pointer<AVInputFormat> av_find_input_format(
    ffi.Pointer<ffi.Int8> short_name,
  ) {
    _av_find_input_format ??= _dylib.lookupFunction<_c_av_find_input_format,
        _dart_av_find_input_format>('av_find_input_format');
    return _av_find_input_format(
      short_name,
    );
  }

  _dart_av_find_input_format _av_find_input_format;

  /// Guess the file format.
  ///
  /// @param pd        data to be probed
  /// @param is_opened Whether the file is already opened; determines whether
  /// demuxers with or without AVFMT_NOFILE are probed.
  ffi.Pointer<AVInputFormat> av_probe_input_format(
    ffi.Pointer<AVProbeData> pd,
    int is_opened,
  ) {
    _av_probe_input_format ??= _dylib.lookupFunction<_c_av_probe_input_format,
        _dart_av_probe_input_format>('av_probe_input_format');
    return _av_probe_input_format(
      pd,
      is_opened,
    );
  }

  _dart_av_probe_input_format _av_probe_input_format;

  /// Guess the file format.
  ///
  /// @param pd        data to be probed
  /// @param is_opened Whether the file is already opened; determines whether
  /// demuxers with or without AVFMT_NOFILE are probed.
  /// @param score_max A probe score larger that this is required to accept a
  /// detection, the variable is set to the actual detection
  /// score afterwards.
  /// If the score is <= AVPROBE_SCORE_MAX / 4 it is recommended
  /// to retry with a larger probe buffer.
  ffi.Pointer<AVInputFormat> av_probe_input_format2(
    ffi.Pointer<AVProbeData> pd,
    int is_opened,
    ffi.Pointer<ffi.Int32> score_max,
  ) {
    _av_probe_input_format2 ??= _dylib.lookupFunction<_c_av_probe_input_format2,
        _dart_av_probe_input_format2>('av_probe_input_format2');
    return _av_probe_input_format2(
      pd,
      is_opened,
      score_max,
    );
  }

  _dart_av_probe_input_format2 _av_probe_input_format2;

  /// Guess the file format.
  ///
  /// @param is_opened Whether the file is already opened; determines whether
  /// demuxers with or without AVFMT_NOFILE are probed.
  /// @param score_ret The score of the best detection.
  ffi.Pointer<AVInputFormat> av_probe_input_format3(
    ffi.Pointer<AVProbeData> pd,
    int is_opened,
    ffi.Pointer<ffi.Int32> score_ret,
  ) {
    _av_probe_input_format3 ??= _dylib.lookupFunction<_c_av_probe_input_format3,
        _dart_av_probe_input_format3>('av_probe_input_format3');
    return _av_probe_input_format3(
      pd,
      is_opened,
      score_ret,
    );
  }

  _dart_av_probe_input_format3 _av_probe_input_format3;

  /// Probe a bytestream to determine the input format. Each time a probe returns
  /// with a score that is too low, the probe buffer size is increased and another
  /// attempt is made. When the maximum probe size is reached, the input format
  /// with the highest score is returned.
  ///
  /// @param pb the bytestream to probe
  /// @param fmt the input format is put here
  /// @param url the url of the stream
  /// @param logctx the log context
  /// @param offset the offset within the bytestream to probe from
  /// @param max_probe_size the maximum probe buffer size (zero for default)
  /// @return the score in case of success, a negative value corresponding to an
  /// the maximal score is AVPROBE_SCORE_MAX
  /// AVERROR code otherwise
  int av_probe_input_buffer2(
    ffi.Pointer<AVIOContext> pb,
    ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Void> logctx,
    int offset,
    int max_probe_size,
  ) {
    _av_probe_input_buffer2 ??= _dylib.lookupFunction<_c_av_probe_input_buffer2,
        _dart_av_probe_input_buffer2>('av_probe_input_buffer2');
    return _av_probe_input_buffer2(
      pb,
      fmt,
      url,
      logctx,
      offset,
      max_probe_size,
    );
  }

  _dart_av_probe_input_buffer2 _av_probe_input_buffer2;

  /// Like av_probe_input_buffer2() but returns 0 on success
  int av_probe_input_buffer(
    ffi.Pointer<AVIOContext> pb,
    ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<ffi.Void> logctx,
    int offset,
    int max_probe_size,
  ) {
    _av_probe_input_buffer ??= _dylib.lookupFunction<_c_av_probe_input_buffer,
        _dart_av_probe_input_buffer>('av_probe_input_buffer');
    return _av_probe_input_buffer(
      pb,
      fmt,
      url,
      logctx,
      offset,
      max_probe_size,
    );
  }

  _dart_av_probe_input_buffer _av_probe_input_buffer;

  /// Open an input stream and read the header. The codecs are not opened.
  /// The stream must be closed with avformat_close_input().
  ///
  /// @param ps Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context).
  /// May be a pointer to NULL, in which case an AVFormatContext is allocated by this
  /// function and written into ps.
  /// Note that a user-supplied AVFormatContext will be freed on failure.
  /// @param url URL of the stream to open.
  /// @param fmt If non-NULL, this parameter forces a specific input format.
  /// Otherwise the format is autodetected.
  /// @param options  A dictionary filled with AVFormatContext and demuxer-private options.
  /// On return this parameter will be destroyed and replaced with a dict containing
  /// options that were not found. May be NULL.
  ///
  /// @return 0 on success, a negative AVERROR on failure.
  ///
  /// @note If you want to use custom IO, preallocate the format context and set its pb field.
  int avformat_open_input(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> ps,
    ffi.Pointer<ffi.Int8> url,
    ffi.Pointer<AVInputFormat> fmt,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avformat_open_input ??= _dylib.lookupFunction<_c_avformat_open_input,
        _dart_avformat_open_input>('avformat_open_input');
    return _avformat_open_input(
      ps,
      url,
      fmt,
      options,
    );
  }

  _dart_avformat_open_input _avformat_open_input;

  int av_demuxer_open(
    ffi.Pointer<AVFormatContext> ic,
  ) {
    _av_demuxer_open ??=
        _dylib.lookupFunction<_c_av_demuxer_open, _dart_av_demuxer_open>(
            'av_demuxer_open');
    return _av_demuxer_open(
      ic,
    );
  }

  _dart_av_demuxer_open _av_demuxer_open;

  /// Read packets of a media file to get stream information. This
  /// is useful for file formats with no headers such as MPEG. This
  /// function also computes the real framerate in case of MPEG-2 repeat
  /// frame mode.
  /// The logical file position is not changed by this function;
  /// examined packets may be buffered for later processing.
  ///
  /// @param ic media file handle
  /// @param options  If non-NULL, an ic.nb_streams long array of pointers to
  /// dictionaries, where i-th member contains options for
  /// codec corresponding to i-th stream.
  /// On return each dictionary will be filled with options that were not found.
  /// @return >=0 if OK, AVERROR_xxx on error
  ///
  /// @note this function isn't guaranteed to open all the codecs, so
  /// options being non-empty at return is a perfectly normal behavior.
  ///
  /// @todo Let the user decide somehow what information is needed so that
  /// we do not waste time getting stuff the user does not need.
  int avformat_find_stream_info(
    ffi.Pointer<AVFormatContext> ic,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avformat_find_stream_info ??= _dylib.lookupFunction<
        _c_avformat_find_stream_info,
        _dart_avformat_find_stream_info>('avformat_find_stream_info');
    return _avformat_find_stream_info(
      ic,
      options,
    );
  }

  _dart_avformat_find_stream_info _avformat_find_stream_info;

  /// Find the programs which belong to a given stream.
  ///
  /// @param ic    media file handle
  /// @param last  the last found program, the search will start after this
  /// program, or from the beginning if it is NULL
  /// @param s     stream index
  /// @return the next program which belongs to s, NULL if no program is found or
  /// the last program is not among the programs of ic.
  ffi.Pointer<AVProgram> av_find_program_from_stream(
    ffi.Pointer<AVFormatContext> ic,
    ffi.Pointer<AVProgram> last,
    int s,
  ) {
    _av_find_program_from_stream ??= _dylib.lookupFunction<
        _c_av_find_program_from_stream,
        _dart_av_find_program_from_stream>('av_find_program_from_stream');
    return _av_find_program_from_stream(
      ic,
      last,
      s,
    );
  }

  _dart_av_find_program_from_stream _av_find_program_from_stream;

  void av_program_add_stream_index(
    ffi.Pointer<AVFormatContext> ac,
    int progid,
    int idx,
  ) {
    _av_program_add_stream_index ??= _dylib.lookupFunction<
        _c_av_program_add_stream_index,
        _dart_av_program_add_stream_index>('av_program_add_stream_index');
    return _av_program_add_stream_index(
      ac,
      progid,
      idx,
    );
  }

  _dart_av_program_add_stream_index _av_program_add_stream_index;

  /// Find the "best" stream in the file.
  /// The best stream is determined according to various heuristics as the most
  /// likely to be what the user expects.
  /// If the decoder parameter is non-NULL, av_find_best_stream will find the
  /// default decoder for the stream's codec; streams for which no decoder can
  /// be found are ignored.
  ///
  /// @param ic                media file handle
  /// @param type              stream type: video, audio, subtitles, etc.
  /// @param wanted_stream_nb  user-requested stream number,
  /// or -1 for automatic selection
  /// @param related_stream    try to find a stream related (eg. in the same
  /// program) to this one, or -1 if none
  /// @param decoder_ret       if non-NULL, returns the decoder for the
  /// selected stream
  /// @param flags             flags; none are currently defined
  /// @return  the non-negative stream number in case of success,
  /// AVERROR_STREAM_NOT_FOUND if no stream with the requested type
  /// could be found,
  /// AVERROR_DECODER_NOT_FOUND if streams were found but no decoder
  /// @note  If av_find_best_stream returns successfully and decoder_ret is not
  /// NULL, then *decoder_ret is guaranteed to be set to a valid AVCodec.
  int av_find_best_stream(
    ffi.Pointer<AVFormatContext> ic,
    int type,
    int wanted_stream_nb,
    int related_stream,
    ffi.Pointer<ffi.Pointer<AVCodec>> decoder_ret,
    int flags,
  ) {
    _av_find_best_stream ??= _dylib.lookupFunction<_c_av_find_best_stream,
        _dart_av_find_best_stream>('av_find_best_stream');
    return _av_find_best_stream(
      ic,
      type,
      wanted_stream_nb,
      related_stream,
      decoder_ret,
      flags,
    );
  }

  _dart_av_find_best_stream _av_find_best_stream;

  /// Return the next frame of a stream.
  /// This function returns what is stored in the file, and does not validate
  /// that what is there are valid frames for the decoder. It will split what is
  /// stored in the file into frames and return one for each call. It will not
  /// omit invalid data between valid frames so as to give the decoder the maximum
  /// information possible for decoding.
  ///
  /// On success, the returned packet is reference-counted (pkt->buf is set) and
  /// valid indefinitely. The packet must be freed with av_packet_unref() when
  /// it is no longer needed. For video, the packet contains exactly one frame.
  /// For audio, it contains an integer number of frames if each frame has
  /// a known fixed size (e.g. PCM or ADPCM data). If the audio frames have
  /// a variable size (e.g. MPEG audio), then it contains one frame.
  ///
  /// pkt->pts, pkt->dts and pkt->duration are always set to correct
  /// values in AVStream.time_base units (and guessed if the format cannot
  /// provide them). pkt->pts can be AV_NOPTS_VALUE if the video format
  /// has B-frames, so it is better to rely on pkt->dts if you do not
  /// decompress the payload.
  ///
  /// @return 0 if OK, < 0 on error or end of file. On error, pkt will be blank
  /// (as if it came from av_packet_alloc()).
  ///
  /// @note pkt will be initialized, so it may be uninitialized, but it must not
  /// contain data that needs to be freed.
  int av_read_frame(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_read_frame ??= _dylib
        .lookupFunction<_c_av_read_frame, _dart_av_read_frame>('av_read_frame');
    return _av_read_frame(
      s,
      pkt,
    );
  }

  _dart_av_read_frame _av_read_frame;

  /// Seek to the keyframe at timestamp.
  /// 'timestamp' in 'stream_index'.
  ///
  /// @param s media file handle
  /// @param stream_index If stream_index is (-1), a default
  /// stream is selected, and timestamp is automatically converted
  /// from AV_TIME_BASE units to the stream specific time_base.
  /// @param timestamp Timestamp in AVStream.time_base units
  /// or, if no stream is specified, in AV_TIME_BASE units.
  /// @param flags flags which select direction and seeking mode
  /// @return >= 0 on success
  int av_seek_frame(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    int timestamp,
    int flags,
  ) {
    _av_seek_frame ??= _dylib
        .lookupFunction<_c_av_seek_frame, _dart_av_seek_frame>('av_seek_frame');
    return _av_seek_frame(
      s,
      stream_index,
      timestamp,
      flags,
    );
  }

  _dart_av_seek_frame _av_seek_frame;

  /// Seek to timestamp ts.
  /// Seeking will be done so that the point from which all active streams
  /// can be presented successfully will be closest to ts and within min/max_ts.
  /// Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
  ///
  /// If flags contain AVSEEK_FLAG_BYTE, then all timestamps are in bytes and
  /// are the file position (this may not be supported by all demuxers).
  /// If flags contain AVSEEK_FLAG_FRAME, then all timestamps are in frames
  /// in the stream with stream_index (this may not be supported by all demuxers).
  /// Otherwise all timestamps are in units of the stream selected by stream_index
  /// or if stream_index is -1, in AV_TIME_BASE units.
  /// If flags contain AVSEEK_FLAG_ANY, then non-keyframes are treated as
  /// keyframes (this may not be supported by all demuxers).
  /// If flags contain AVSEEK_FLAG_BACKWARD, it is ignored.
  ///
  /// @param s media file handle
  /// @param stream_index index of the stream which is used as time base reference
  /// @param min_ts smallest acceptable timestamp
  /// @param ts target timestamp
  /// @param max_ts largest acceptable timestamp
  /// @param flags flags
  /// @return >=0 on success, error code otherwise
  ///
  /// @note This is part of the new seek API which is still under construction.
  int avformat_seek_file(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    int min_ts,
    int ts,
    int max_ts,
    int flags,
  ) {
    _avformat_seek_file ??=
        _dylib.lookupFunction<_c_avformat_seek_file, _dart_avformat_seek_file>(
            'avformat_seek_file');
    return _avformat_seek_file(
      s,
      stream_index,
      min_ts,
      ts,
      max_ts,
      flags,
    );
  }

  _dart_avformat_seek_file _avformat_seek_file;

  /// Discard all internally buffered data. This can be useful when dealing with
  /// discontinuities in the byte stream. Generally works only with formats that
  /// can resync. This includes headerless formats like MPEG-TS/TS but should also
  /// work with NUT, Ogg and in a limited way AVI for example.
  ///
  /// The set of streams, the detected duration, stream parameters and codecs do
  /// not change when calling this function. If you want a complete reset, it's
  /// better to open a new AVFormatContext.
  ///
  /// This does not flush the AVIOContext (s->pb). If necessary, call
  /// avio_flush(s->pb) before calling this function.
  ///
  /// @param s media file handle
  /// @return >=0 on success, error code otherwise
  int avformat_flush(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _avformat_flush ??=
        _dylib.lookupFunction<_c_avformat_flush, _dart_avformat_flush>(
            'avformat_flush');
    return _avformat_flush(
      s,
    );
  }

  _dart_avformat_flush _avformat_flush;

  /// Start playing a network-based stream (e.g. RTSP stream) at the
  /// current position.
  int av_read_play(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_read_play ??= _dylib
        .lookupFunction<_c_av_read_play, _dart_av_read_play>('av_read_play');
    return _av_read_play(
      s,
    );
  }

  _dart_av_read_play _av_read_play;

  /// Pause a network-based stream (e.g. RTSP stream).
  ///
  /// Use av_read_play() to resume it.
  int av_read_pause(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_read_pause ??= _dylib
        .lookupFunction<_c_av_read_pause, _dart_av_read_pause>('av_read_pause');
    return _av_read_pause(
      s,
    );
  }

  _dart_av_read_pause _av_read_pause;

  /// Close an opened input AVFormatContext. Free it and all its contents
  /// and set *s to NULL.
  void avformat_close_input(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> s,
  ) {
    _avformat_close_input ??= _dylib.lookupFunction<_c_avformat_close_input,
        _dart_avformat_close_input>('avformat_close_input');
    return _avformat_close_input(
      s,
    );
  }

  _dart_avformat_close_input _avformat_close_input;

  /// Allocate the stream private data and write the stream header to
  /// an output media file.
  ///
  /// @param s Media file handle, must be allocated with avformat_alloc_context().
  /// Its oformat field must be set to the desired output format;
  /// Its pb field must be set to an already opened AVIOContext.
  /// @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
  /// On return this parameter will be destroyed and replaced with a dict containing
  /// options that were not found. May be NULL.
  ///
  /// @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init,
  /// AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init,
  /// negative AVERROR on failure.
  ///
  /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_init_output.
  int avformat_write_header(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avformat_write_header ??= _dylib.lookupFunction<_c_avformat_write_header,
        _dart_avformat_write_header>('avformat_write_header');
    return _avformat_write_header(
      s,
      options,
    );
  }

  _dart_avformat_write_header _avformat_write_header;

  /// Allocate the stream private data and initialize the codec, but do not write the header.
  /// May optionally be used before avformat_write_header to initialize stream parameters
  /// before actually writing the header.
  /// If using this function, do not pass the same options to avformat_write_header.
  ///
  /// @param s Media file handle, must be allocated with avformat_alloc_context().
  /// Its oformat field must be set to the desired output format;
  /// Its pb field must be set to an already opened AVIOContext.
  /// @param options  An AVDictionary filled with AVFormatContext and muxer-private options.
  /// On return this parameter will be destroyed and replaced with a dict containing
  /// options that were not found. May be NULL.
  ///
  /// @return AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize,
  /// AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized,
  /// negative AVERROR on failure.
  ///
  /// @see av_opt_find, av_dict_set, avio_open, av_oformat_next, avformat_write_header.
  int avformat_init_output(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avformat_init_output ??= _dylib.lookupFunction<_c_avformat_init_output,
        _dart_avformat_init_output>('avformat_init_output');
    return _avformat_init_output(
      s,
      options,
    );
  }

  _dart_avformat_init_output _avformat_init_output;

  /// Write a packet to an output media file.
  ///
  /// This function passes the packet directly to the muxer, without any buffering
  /// or reordering. The caller is responsible for correctly interleaving the
  /// packets if the format requires it. Callers that want libavformat to handle
  /// the interleaving should call av_interleaved_write_frame() instead of this
  /// function.
  ///
  /// @param s media file handle
  /// @param pkt The packet containing the data to be written. Note that unlike
  /// av_interleaved_write_frame(), this function does not take
  /// ownership of the packet passed to it (though some muxers may make
  /// an internal reference to the input packet).
  /// <br>
  /// This parameter can be NULL (at any time, not just at the end), in
  /// order to immediately flush data buffered within the muxer, for
  /// muxers that buffer up data internally before writing it to the
  /// output.
  /// <br>
  /// Packet's @ref AVPacket.stream_index "stream_index" field must be
  /// set to the index of the corresponding stream in @ref
  /// AVFormatContext.streams "s->streams".
  /// <br>
  /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
  /// must be set to correct values in the stream's timebase (unless the
  /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
  /// they can be set to AV_NOPTS_VALUE).
  /// The dts for subsequent packets passed to this function must be strictly
  /// increasing when compared in their respective timebases (unless the
  /// output format is flagged with the AVFMT_TS_NONSTRICT, then they
  /// merely have to be nondecreasing).  @ref AVPacket.duration
  /// "duration") should also be set if known.
  /// @return < 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush
  ///
  /// @see av_interleaved_write_frame()
  int av_write_frame(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_write_frame ??=
        _dylib.lookupFunction<_c_av_write_frame, _dart_av_write_frame>(
            'av_write_frame');
    return _av_write_frame(
      s,
      pkt,
    );
  }

  _dart_av_write_frame _av_write_frame;

  /// Write a packet to an output media file ensuring correct interleaving.
  ///
  /// This function will buffer the packets internally as needed to make sure the
  /// packets in the output file are properly interleaved in the order of
  /// increasing dts. Callers doing their own interleaving should call
  /// av_write_frame() instead of this function.
  ///
  /// Using this function instead of av_write_frame() can give muxers advance
  /// knowledge of future packets, improving e.g. the behaviour of the mp4
  /// muxer for VFR content in fragmenting mode.
  ///
  /// @param s media file handle
  /// @param pkt The packet containing the data to be written.
  /// <br>
  /// If the packet is reference-counted, this function will take
  /// ownership of this reference and unreference it later when it sees
  /// fit.
  /// The caller must not access the data through this reference after
  /// this function returns. If the packet is not reference-counted,
  /// libavformat will make a copy.
  /// <br>
  /// This parameter can be NULL (at any time, not just at the end), to
  /// flush the interleaving queues.
  /// <br>
  /// Packet's @ref AVPacket.stream_index "stream_index" field must be
  /// set to the index of the corresponding stream in @ref
  /// AVFormatContext.streams "s->streams".
  /// <br>
  /// The timestamps (@ref AVPacket.pts "pts", @ref AVPacket.dts "dts")
  /// must be set to correct values in the stream's timebase (unless the
  /// output format is flagged with the AVFMT_NOTIMESTAMPS flag, then
  /// they can be set to AV_NOPTS_VALUE).
  /// The dts for subsequent packets in one stream must be strictly
  /// increasing (unless the output format is flagged with the
  /// AVFMT_TS_NONSTRICT, then they merely have to be nondecreasing).
  /// @ref AVPacket.duration "duration") should also be set if known.
  ///
  /// @return 0 on success, a negative AVERROR on error. Libavformat will always
  /// take care of freeing the packet, even if this function fails.
  ///
  /// @see av_write_frame(), AVFormatContext.max_interleave_delta
  int av_interleaved_write_frame(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVPacket> pkt,
  ) {
    _av_interleaved_write_frame ??= _dylib.lookupFunction<
        _c_av_interleaved_write_frame,
        _dart_av_interleaved_write_frame>('av_interleaved_write_frame');
    return _av_interleaved_write_frame(
      s,
      pkt,
    );
  }

  _dart_av_interleaved_write_frame _av_interleaved_write_frame;

  /// Write an uncoded frame to an output media file.
  ///
  /// The frame must be correctly interleaved according to the container
  /// specification; if not, av_interleaved_write_uncoded_frame() must be used.
  ///
  /// See av_interleaved_write_uncoded_frame() for details.
  int av_write_uncoded_frame(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_write_uncoded_frame ??= _dylib.lookupFunction<_c_av_write_uncoded_frame,
        _dart_av_write_uncoded_frame>('av_write_uncoded_frame');
    return _av_write_uncoded_frame(
      s,
      stream_index,
      frame,
    );
  }

  _dart_av_write_uncoded_frame _av_write_uncoded_frame;

  /// Write an uncoded frame to an output media file.
  ///
  /// If the muxer supports it, this function makes it possible to write an AVFrame
  /// structure directly, without encoding it into a packet.
  /// It is mostly useful for devices and similar special muxers that use raw
  /// video or PCM data and will not serialize it into a byte stream.
  ///
  /// To test whether it is possible to use it with a given muxer and stream,
  /// use av_write_uncoded_frame_query().
  ///
  /// The caller gives up ownership of the frame and must not access it
  /// afterwards.
  ///
  /// @return  >=0 for success, a negative code on error
  int av_interleaved_write_uncoded_frame(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_interleaved_write_uncoded_frame ??= _dylib.lookupFunction<
            _c_av_interleaved_write_uncoded_frame,
            _dart_av_interleaved_write_uncoded_frame>(
        'av_interleaved_write_uncoded_frame');
    return _av_interleaved_write_uncoded_frame(
      s,
      stream_index,
      frame,
    );
  }

  _dart_av_interleaved_write_uncoded_frame _av_interleaved_write_uncoded_frame;

  /// Test whether a muxer supports uncoded frame.
  ///
  /// @return  >=0 if an uncoded frame can be written to that muxer and stream,
  /// <0 if not
  int av_write_uncoded_frame_query(
    ffi.Pointer<AVFormatContext> s,
    int stream_index,
  ) {
    _av_write_uncoded_frame_query ??= _dylib.lookupFunction<
        _c_av_write_uncoded_frame_query,
        _dart_av_write_uncoded_frame_query>('av_write_uncoded_frame_query');
    return _av_write_uncoded_frame_query(
      s,
      stream_index,
    );
  }

  _dart_av_write_uncoded_frame_query _av_write_uncoded_frame_query;

  /// Write the stream trailer to an output media file and free the
  /// file private data.
  ///
  /// May only be called after a successful call to avformat_write_header.
  ///
  /// @param s media file handle
  /// @return 0 if OK, AVERROR_xxx on error
  int av_write_trailer(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_write_trailer ??=
        _dylib.lookupFunction<_c_av_write_trailer, _dart_av_write_trailer>(
            'av_write_trailer');
    return _av_write_trailer(
      s,
    );
  }

  _dart_av_write_trailer _av_write_trailer;

  /// Return the output format in the list of registered output formats
  /// which best matches the provided parameters, or return NULL if
  /// there is no match.
  ///
  /// @param short_name if non-NULL checks if short_name matches with the
  /// names of the registered formats
  /// @param filename if non-NULL checks if filename terminates with the
  /// extensions of the registered formats
  /// @param mime_type if non-NULL checks if mime_type matches with the
  /// MIME type of the registered formats
  ffi.Pointer<AVOutputFormat> av_guess_format(
    ffi.Pointer<ffi.Int8> short_name,
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Int8> mime_type,
  ) {
    _av_guess_format ??=
        _dylib.lookupFunction<_c_av_guess_format, _dart_av_guess_format>(
            'av_guess_format');
    return _av_guess_format(
      short_name,
      filename,
      mime_type,
    );
  }

  _dart_av_guess_format _av_guess_format;

  /// Guess the codec ID based upon muxer and filename.
  int av_guess_codec(
    ffi.Pointer<AVOutputFormat> fmt,
    ffi.Pointer<ffi.Int8> short_name,
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Int8> mime_type,
    int type,
  ) {
    _av_guess_codec ??=
        _dylib.lookupFunction<_c_av_guess_codec, _dart_av_guess_codec>(
            'av_guess_codec');
    return _av_guess_codec(
      fmt,
      short_name,
      filename,
      mime_type,
      type,
    );
  }

  _dart_av_guess_codec _av_guess_codec;

  /// Get timing information for the data currently output.
  /// The exact meaning of "currently output" depends on the format.
  /// It is mostly relevant for devices that have an internal buffer and/or
  /// work in real time.
  /// @param s          media file handle
  /// @param stream     stream in the media file
  /// @param[out] dts   DTS of the last packet output for the stream, in stream
  /// time_base units
  /// @param[out] wall  absolute time when that packet whas output,
  /// in microsecond
  /// @return  0 if OK, AVERROR(ENOSYS) if the format does not support it
  /// Note: some formats or devices may not allow to measure dts and wall
  /// atomically.
  int av_get_output_timestamp(
    ffi.Pointer<AVFormatContext> s,
    int stream,
    ffi.Pointer<ffi.Int64> dts,
    ffi.Pointer<ffi.Int64> wall,
  ) {
    _av_get_output_timestamp ??= _dylib.lookupFunction<
        _c_av_get_output_timestamp,
        _dart_av_get_output_timestamp>('av_get_output_timestamp');
    return _av_get_output_timestamp(
      s,
      stream,
      dts,
      wall,
    );
  }

  _dart_av_get_output_timestamp _av_get_output_timestamp;

  /// Send a nice hexadecimal dump of a buffer to the specified file stream.
  ///
  /// @param f The file stream pointer where the dump should be sent to.
  /// @param buf buffer
  /// @param size buffer size
  ///
  /// @see av_hex_dump_log, av_pkt_dump2, av_pkt_dump_log2
  void av_hex_dump(
    ffi.Pointer<_IO_FILE> f,
    ffi.Pointer<ffi.Uint8> buf,
    int size,
  ) {
    _av_hex_dump ??=
        _dylib.lookupFunction<_c_av_hex_dump, _dart_av_hex_dump>('av_hex_dump');
    return _av_hex_dump(
      f,
      buf,
      size,
    );
  }

  _dart_av_hex_dump _av_hex_dump;

  /// Send a nice hexadecimal dump of a buffer to the log.
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message, lower values signifying
  /// higher importance.
  /// @param buf buffer
  /// @param size buffer size
  ///
  /// @see av_hex_dump, av_pkt_dump2, av_pkt_dump_log2
  void av_hex_dump_log(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<ffi.Uint8> buf,
    int size,
  ) {
    _av_hex_dump_log ??=
        _dylib.lookupFunction<_c_av_hex_dump_log, _dart_av_hex_dump_log>(
            'av_hex_dump_log');
    return _av_hex_dump_log(
      avcl,
      level,
      buf,
      size,
    );
  }

  _dart_av_hex_dump_log _av_hex_dump_log;

  /// Send a nice dump of a packet to the specified file stream.
  ///
  /// @param f The file stream pointer where the dump should be sent to.
  /// @param pkt packet to dump
  /// @param dump_payload True if the payload must be displayed, too.
  /// @param st AVStream that the packet belongs to
  void av_pkt_dump2(
    ffi.Pointer<_IO_FILE> f,
    ffi.Pointer<AVPacket> pkt,
    int dump_payload,
    ffi.Pointer<AVStream> st,
  ) {
    _av_pkt_dump2 ??= _dylib
        .lookupFunction<_c_av_pkt_dump2, _dart_av_pkt_dump2>('av_pkt_dump2');
    return _av_pkt_dump2(
      f,
      pkt,
      dump_payload,
      st,
    );
  }

  _dart_av_pkt_dump2 _av_pkt_dump2;

  /// Send a nice dump of a packet to the log.
  ///
  /// @param avcl A pointer to an arbitrary struct of which the first field is a
  /// pointer to an AVClass struct.
  /// @param level The importance level of the message, lower values signifying
  /// higher importance.
  /// @param pkt packet to dump
  /// @param dump_payload True if the payload must be displayed, too.
  /// @param st AVStream that the packet belongs to
  void av_pkt_dump_log2(
    ffi.Pointer<ffi.Void> avcl,
    int level,
    ffi.Pointer<AVPacket> pkt,
    int dump_payload,
    ffi.Pointer<AVStream> st,
  ) {
    _av_pkt_dump_log2 ??=
        _dylib.lookupFunction<_c_av_pkt_dump_log2, _dart_av_pkt_dump_log2>(
            'av_pkt_dump_log2');
    return _av_pkt_dump_log2(
      avcl,
      level,
      pkt,
      dump_payload,
      st,
    );
  }

  _dart_av_pkt_dump_log2 _av_pkt_dump_log2;

  /// Get the AVCodecID for the given codec tag tag.
  /// If no codec id is found returns AV_CODEC_ID_NONE.
  ///
  /// @param tags list of supported codec_id-codec_tag pairs, as stored
  /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
  /// @param tag  codec tag to match to a codec ID
  int av_codec_get_id(
    ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
    int tag,
  ) {
    _av_codec_get_id ??=
        _dylib.lookupFunction<_c_av_codec_get_id, _dart_av_codec_get_id>(
            'av_codec_get_id');
    return _av_codec_get_id(
      tags,
      tag,
    );
  }

  _dart_av_codec_get_id _av_codec_get_id;

  /// Get the codec tag for the given codec id id.
  /// If no codec tag is found returns 0.
  ///
  /// @param tags list of supported codec_id-codec_tag pairs, as stored
  /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
  /// @param id   codec ID to match to a codec tag
  int av_codec_get_tag(
    ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
    int id,
  ) {
    _av_codec_get_tag ??=
        _dylib.lookupFunction<_c_av_codec_get_tag, _dart_av_codec_get_tag>(
            'av_codec_get_tag');
    return _av_codec_get_tag(
      tags,
      id,
    );
  }

  _dart_av_codec_get_tag _av_codec_get_tag;

  /// Get the codec tag for the given codec id.
  ///
  /// @param tags list of supported codec_id - codec_tag pairs, as stored
  /// in AVInputFormat.codec_tag and AVOutputFormat.codec_tag
  /// @param id codec id that should be searched for in the list
  /// @param tag A pointer to the found tag
  /// @return 0 if id was not found in tags, > 0 if it was found
  int av_codec_get_tag2(
    ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
    int id,
    ffi.Pointer<ffi.Uint32> tag,
  ) {
    _av_codec_get_tag2 ??=
        _dylib.lookupFunction<_c_av_codec_get_tag2, _dart_av_codec_get_tag2>(
            'av_codec_get_tag2');
    return _av_codec_get_tag2(
      tags,
      id,
      tag,
    );
  }

  _dart_av_codec_get_tag2 _av_codec_get_tag2;

  int av_find_default_stream_index(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _av_find_default_stream_index ??= _dylib.lookupFunction<
        _c_av_find_default_stream_index,
        _dart_av_find_default_stream_index>('av_find_default_stream_index');
    return _av_find_default_stream_index(
      s,
    );
  }

  _dart_av_find_default_stream_index _av_find_default_stream_index;

  /// Get the index for a specific timestamp.
  ///
  /// @param st        stream that the timestamp belongs to
  /// @param timestamp timestamp to retrieve the index for
  /// @param flags if AVSEEK_FLAG_BACKWARD then the returned index will correspond
  /// to the timestamp which is <= the requested one, if backward
  /// is 0, then it will be >=
  /// if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise
  /// @return < 0 if no such timestamp could be found
  int av_index_search_timestamp(
    ffi.Pointer<AVStream> st,
    int timestamp,
    int flags,
  ) {
    _av_index_search_timestamp ??= _dylib.lookupFunction<
        _c_av_index_search_timestamp,
        _dart_av_index_search_timestamp>('av_index_search_timestamp');
    return _av_index_search_timestamp(
      st,
      timestamp,
      flags,
    );
  }

  _dart_av_index_search_timestamp _av_index_search_timestamp;

  /// Add an index entry into a sorted list. Update the entry if the list
  /// already contains it.
  ///
  /// @param timestamp timestamp in the time base of the given stream
  int av_add_index_entry(
    ffi.Pointer<AVStream> st,
    int pos,
    int timestamp,
    int size,
    int distance,
    int flags,
  ) {
    _av_add_index_entry ??=
        _dylib.lookupFunction<_c_av_add_index_entry, _dart_av_add_index_entry>(
            'av_add_index_entry');
    return _av_add_index_entry(
      st,
      pos,
      timestamp,
      size,
      distance,
      flags,
    );
  }

  _dart_av_add_index_entry _av_add_index_entry;

  /// Split a URL string into components.
  ///
  /// The pointers to buffers for storing individual components may be null,
  /// in order to ignore that component. Buffers for components not found are
  /// set to empty strings. If the port is not found, it is set to a negative
  /// value.
  ///
  /// @param proto the buffer for the protocol
  /// @param proto_size the size of the proto buffer
  /// @param authorization the buffer for the authorization
  /// @param authorization_size the size of the authorization buffer
  /// @param hostname the buffer for the host name
  /// @param hostname_size the size of the hostname buffer
  /// @param port_ptr a pointer to store the port number in
  /// @param path the buffer for the path
  /// @param path_size the size of the path buffer
  /// @param url the URL to split
  void av_url_split(
    ffi.Pointer<ffi.Int8> proto,
    int proto_size,
    ffi.Pointer<ffi.Int8> authorization,
    int authorization_size,
    ffi.Pointer<ffi.Int8> hostname,
    int hostname_size,
    ffi.Pointer<ffi.Int32> port_ptr,
    ffi.Pointer<ffi.Int8> path,
    int path_size,
    ffi.Pointer<ffi.Int8> url,
  ) {
    _av_url_split ??= _dylib
        .lookupFunction<_c_av_url_split, _dart_av_url_split>('av_url_split');
    return _av_url_split(
      proto,
      proto_size,
      authorization,
      authorization_size,
      hostname,
      hostname_size,
      port_ptr,
      path,
      path_size,
      url,
    );
  }

  _dart_av_url_split _av_url_split;

  /// Print detailed information about the input or output format, such as
  /// duration, bitrate, streams, container, programs, metadata, side data,
  /// codec and time base.
  ///
  /// @param ic        the context to analyze
  /// @param index     index of the stream to dump information about
  /// @param url       the URL to print, such as source or destination file
  /// @param is_output Select whether the specified context is an input(0) or output(1)
  void av_dump_format(
    ffi.Pointer<AVFormatContext> ic,
    int index,
    ffi.Pointer<ffi.Int8> url,
    int is_output,
  ) {
    _av_dump_format ??=
        _dylib.lookupFunction<_c_av_dump_format, _dart_av_dump_format>(
            'av_dump_format');
    return _av_dump_format(
      ic,
      index,
      url,
      is_output,
    );
  }

  _dart_av_dump_format _av_dump_format;

  /// Return in 'buf' the path with '%d' replaced by a number.
  ///
  /// Also handles the '%0nd' format where 'n' is the total number
  /// of digits and '%%'.
  ///
  /// @param buf destination buffer
  /// @param buf_size destination buffer size
  /// @param path numbered sequence string
  /// @param number frame number
  /// @param flags AV_FRAME_FILENAME_FLAGS_*
  /// @return 0 if OK, -1 on format error
  int av_get_frame_filename2(
    ffi.Pointer<ffi.Int8> buf,
    int buf_size,
    ffi.Pointer<ffi.Int8> path,
    int number,
    int flags,
  ) {
    _av_get_frame_filename2 ??= _dylib.lookupFunction<_c_av_get_frame_filename2,
        _dart_av_get_frame_filename2>('av_get_frame_filename2');
    return _av_get_frame_filename2(
      buf,
      buf_size,
      path,
      number,
      flags,
    );
  }

  _dart_av_get_frame_filename2 _av_get_frame_filename2;

  int av_get_frame_filename(
    ffi.Pointer<ffi.Int8> buf,
    int buf_size,
    ffi.Pointer<ffi.Int8> path,
    int number,
  ) {
    _av_get_frame_filename ??= _dylib.lookupFunction<_c_av_get_frame_filename,
        _dart_av_get_frame_filename>('av_get_frame_filename');
    return _av_get_frame_filename(
      buf,
      buf_size,
      path,
      number,
    );
  }

  _dart_av_get_frame_filename _av_get_frame_filename;

  /// Check whether filename actually is a numbered sequence generator.
  ///
  /// @param filename possible numbered sequence string
  /// @return 1 if a valid numbered sequence string, 0 otherwise
  int av_filename_number_test(
    ffi.Pointer<ffi.Int8> filename,
  ) {
    _av_filename_number_test ??= _dylib.lookupFunction<
        _c_av_filename_number_test,
        _dart_av_filename_number_test>('av_filename_number_test');
    return _av_filename_number_test(
      filename,
    );
  }

  _dart_av_filename_number_test _av_filename_number_test;

  /// Generate an SDP for an RTP session.
  ///
  /// Note, this overwrites the id values of AVStreams in the muxer contexts
  /// for getting unique dynamic payload types.
  ///
  /// @param ac array of AVFormatContexts describing the RTP streams. If the
  /// array is composed by only one context, such context can contain
  /// multiple AVStreams (one AVStream per RTP stream). Otherwise,
  /// all the contexts in the array (an AVCodecContext per RTP stream)
  /// must contain only one AVStream.
  /// @param n_files number of AVCodecContexts contained in ac
  /// @param buf buffer where the SDP will be stored (must be allocated by
  /// the caller)
  /// @param size the size of the buffer
  /// @return 0 if OK, AVERROR_xxx on error
  int av_sdp_create(
    ffi.Pointer<ffi.Pointer<AVFormatContext>> ac,
    int n_files,
    ffi.Pointer<ffi.Int8> buf,
    int size,
  ) {
    _av_sdp_create ??= _dylib
        .lookupFunction<_c_av_sdp_create, _dart_av_sdp_create>('av_sdp_create');
    return _av_sdp_create(
      ac,
      n_files,
      buf,
      size,
    );
  }

  _dart_av_sdp_create _av_sdp_create;

  /// Return a positive value if the given filename has one of the given
  /// extensions, 0 otherwise.
  ///
  /// @param filename   file name to check against the given extensions
  /// @param extensions a comma-separated list of filename extensions
  int av_match_ext(
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Int8> extensions,
  ) {
    _av_match_ext ??= _dylib
        .lookupFunction<_c_av_match_ext, _dart_av_match_ext>('av_match_ext');
    return _av_match_ext(
      filename,
      extensions,
    );
  }

  _dart_av_match_ext _av_match_ext;

  /// Test if the given container can store a codec.
  ///
  /// @param ofmt           container to check for compatibility
  /// @param codec_id       codec to potentially store in container
  /// @param std_compliance standards compliance level, one of FF_COMPLIANCE_*
  ///
  /// @return 1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot.
  /// A negative number if this information is not available.
  int avformat_query_codec(
    ffi.Pointer<AVOutputFormat> ofmt,
    int codec_id,
    int std_compliance,
  ) {
    _avformat_query_codec ??= _dylib.lookupFunction<_c_avformat_query_codec,
        _dart_avformat_query_codec>('avformat_query_codec');
    return _avformat_query_codec(
      ofmt,
      codec_id,
      std_compliance,
    );
  }

  _dart_avformat_query_codec _avformat_query_codec;

  /// @defgroup riff_fourcc RIFF FourCCs
  /// @{
  /// Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are
  /// meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the
  /// following code:
  /// @code
  /// uint32_t tag = MKTAG('H', '2', '6', '4');
  /// const struct AVCodecTag *table[] = { avformat_get_riff_video_tags(), 0 };
  /// enum AVCodecID id = av_codec_get_id(table, tag);
  /// @endcode
  ///
  ///
  /// @return the table mapping RIFF FourCCs for video to libavcodec AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_riff_video_tags() {
    _avformat_get_riff_video_tags ??= _dylib.lookupFunction<
        _c_avformat_get_riff_video_tags,
        _dart_avformat_get_riff_video_tags>('avformat_get_riff_video_tags');
    return _avformat_get_riff_video_tags();
  }

  _dart_avformat_get_riff_video_tags _avformat_get_riff_video_tags;

  /// @return the table mapping RIFF FourCCs for audio to AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_riff_audio_tags() {
    _avformat_get_riff_audio_tags ??= _dylib.lookupFunction<
        _c_avformat_get_riff_audio_tags,
        _dart_avformat_get_riff_audio_tags>('avformat_get_riff_audio_tags');
    return _avformat_get_riff_audio_tags();
  }

  _dart_avformat_get_riff_audio_tags _avformat_get_riff_audio_tags;

  /// @return the table mapping MOV FourCCs for video to libavcodec AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_mov_video_tags() {
    _avformat_get_mov_video_tags ??= _dylib.lookupFunction<
        _c_avformat_get_mov_video_tags,
        _dart_avformat_get_mov_video_tags>('avformat_get_mov_video_tags');
    return _avformat_get_mov_video_tags();
  }

  _dart_avformat_get_mov_video_tags _avformat_get_mov_video_tags;

  /// @return the table mapping MOV FourCCs for audio to AVCodecID.
  ffi.Pointer<AVCodecTag> avformat_get_mov_audio_tags() {
    _avformat_get_mov_audio_tags ??= _dylib.lookupFunction<
        _c_avformat_get_mov_audio_tags,
        _dart_avformat_get_mov_audio_tags>('avformat_get_mov_audio_tags');
    return _avformat_get_mov_audio_tags();
  }

  _dart_avformat_get_mov_audio_tags _avformat_get_mov_audio_tags;

  /// Check if the stream st contained in s is matched by the stream specifier
  /// spec.
  ///
  /// See the "stream specifiers" chapter in the documentation for the syntax
  /// of spec.
  ///
  /// @return  >0 if st is matched by spec;
  /// 0  if st is not matched by spec;
  /// AVERROR code if spec is invalid
  ///
  /// @note  A stream specifier can match several streams in the format.
  int avformat_match_stream_specifier(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<AVStream> st,
    ffi.Pointer<ffi.Int8> spec,
  ) {
    _avformat_match_stream_specifier ??= _dylib.lookupFunction<
            _c_avformat_match_stream_specifier,
            _dart_avformat_match_stream_specifier>(
        'avformat_match_stream_specifier');
    return _avformat_match_stream_specifier(
      s,
      st,
      spec,
    );
  }

  _dart_avformat_match_stream_specifier _avformat_match_stream_specifier;

  int avformat_queue_attached_pictures(
    ffi.Pointer<AVFormatContext> s,
  ) {
    _avformat_queue_attached_pictures ??= _dylib.lookupFunction<
            _c_avformat_queue_attached_pictures,
            _dart_avformat_queue_attached_pictures>(
        'avformat_queue_attached_pictures');
    return _avformat_queue_attached_pictures(
      s,
    );
  }

  _dart_avformat_queue_attached_pictures _avformat_queue_attached_pictures;

  /// Apply a list of bitstream filters to a packet.
  ///
  /// @param codec AVCodecContext, usually from an AVStream
  /// @param pkt the packet to apply filters to. If, on success, the returned
  /// packet has size == 0 and side_data_elems == 0, it indicates that
  /// the packet should be dropped
  /// @param bsfc a NULL-terminated list of filters to apply
  /// @return  >=0 on success;
  /// AVERROR code on failure
  int av_apply_bitstream_filters(
    ffi.Pointer<AVCodecContext> codec,
    ffi.Pointer<AVPacket> pkt,
    ffi.Pointer<AVBitStreamFilterContext> bsfc,
  ) {
    _av_apply_bitstream_filters ??= _dylib.lookupFunction<
        _c_av_apply_bitstream_filters,
        _dart_av_apply_bitstream_filters>('av_apply_bitstream_filters');
    return _av_apply_bitstream_filters(
      codec,
      pkt,
      bsfc,
    );
  }

  _dart_av_apply_bitstream_filters _av_apply_bitstream_filters;

  /// Transfer internal timing information from one stream to another.
  ///
  /// This function is useful when doing stream copy.
  ///
  /// @param ofmt     target output format for ost
  /// @param ost      output stream which needs timings copy and adjustments
  /// @param ist      reference input stream to copy timings from
  /// @param copy_tb  define from where the stream codec timebase needs to be imported
  int avformat_transfer_internal_stream_timing_info(
    ffi.Pointer<AVOutputFormat> ofmt,
    ffi.Pointer<AVStream> ost,
    ffi.Pointer<AVStream> ist,
    int copy_tb,
  ) {
    _avformat_transfer_internal_stream_timing_info ??= _dylib.lookupFunction<
            _c_avformat_transfer_internal_stream_timing_info,
            _dart_avformat_transfer_internal_stream_timing_info>(
        'avformat_transfer_internal_stream_timing_info');
    return _avformat_transfer_internal_stream_timing_info(
      ofmt,
      ost,
      ist,
      copy_tb,
    );
  }

  _dart_avformat_transfer_internal_stream_timing_info
      _avformat_transfer_internal_stream_timing_info;

  /// Return the LIBAVDEVICE_VERSION_INT constant.
  int avdevice_version() {
    _avdevice_version ??=
        _dylib.lookupFunction<_c_avdevice_version, _dart_avdevice_version>(
            'avdevice_version');
    return _avdevice_version();
  }

  _dart_avdevice_version _avdevice_version;

  /// Return the libavdevice build-time configuration.
  ffi.Pointer<ffi.Int8> avdevice_configuration() {
    _avdevice_configuration ??= _dylib.lookupFunction<_c_avdevice_configuration,
        _dart_avdevice_configuration>('avdevice_configuration');
    return _avdevice_configuration();
  }

  _dart_avdevice_configuration _avdevice_configuration;

  /// Return the libavdevice license.
  ffi.Pointer<ffi.Int8> avdevice_license() {
    _avdevice_license ??=
        _dylib.lookupFunction<_c_avdevice_license, _dart_avdevice_license>(
            'avdevice_license');
    return _avdevice_license();
  }

  _dart_avdevice_license _avdevice_license;

  /// Initialize libavdevice and register all the input and output devices.
  void avdevice_register_all() {
    _avdevice_register_all ??= _dylib.lookupFunction<_c_avdevice_register_all,
        _dart_avdevice_register_all>('avdevice_register_all');
    return _avdevice_register_all();
  }

  _dart_avdevice_register_all _avdevice_register_all;

  /// Audio input devices iterator.
  ///
  /// If d is NULL, returns the first registered input audio/video device,
  /// if d is non-NULL, returns the next registered input audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVInputFormat> av_input_audio_device_next(
    ffi.Pointer<AVInputFormat> d,
  ) {
    _av_input_audio_device_next ??= _dylib.lookupFunction<
        _c_av_input_audio_device_next,
        _dart_av_input_audio_device_next>('av_input_audio_device_next');
    return _av_input_audio_device_next(
      d,
    );
  }

  _dart_av_input_audio_device_next _av_input_audio_device_next;

  /// Video input devices iterator.
  ///
  /// If d is NULL, returns the first registered input audio/video device,
  /// if d is non-NULL, returns the next registered input audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVInputFormat> av_input_video_device_next(
    ffi.Pointer<AVInputFormat> d,
  ) {
    _av_input_video_device_next ??= _dylib.lookupFunction<
        _c_av_input_video_device_next,
        _dart_av_input_video_device_next>('av_input_video_device_next');
    return _av_input_video_device_next(
      d,
    );
  }

  _dart_av_input_video_device_next _av_input_video_device_next;

  /// Audio output devices iterator.
  ///
  /// If d is NULL, returns the first registered output audio/video device,
  /// if d is non-NULL, returns the next registered output audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVOutputFormat> av_output_audio_device_next(
    ffi.Pointer<AVOutputFormat> d,
  ) {
    _av_output_audio_device_next ??= _dylib.lookupFunction<
        _c_av_output_audio_device_next,
        _dart_av_output_audio_device_next>('av_output_audio_device_next');
    return _av_output_audio_device_next(
      d,
    );
  }

  _dart_av_output_audio_device_next _av_output_audio_device_next;

  /// Video output devices iterator.
  ///
  /// If d is NULL, returns the first registered output audio/video device,
  /// if d is non-NULL, returns the next registered output audio/video device after d
  /// or NULL if d is the last one.
  ffi.Pointer<AVOutputFormat> av_output_video_device_next(
    ffi.Pointer<AVOutputFormat> d,
  ) {
    _av_output_video_device_next ??= _dylib.lookupFunction<
        _c_av_output_video_device_next,
        _dart_av_output_video_device_next>('av_output_video_device_next');
    return _av_output_video_device_next(
      d,
    );
  }

  _dart_av_output_video_device_next _av_output_video_device_next;

  /// Send control message from application to device.
  ///
  /// @param s         device context.
  /// @param type      message type.
  /// @param data      message data. Exact type depends on message type.
  /// @param data_size size of message data.
  /// @return >= 0 on success, negative on error.
  /// AVERROR(ENOSYS) when device doesn't implement handler of the message.
  int avdevice_app_to_dev_control_message(
    ffi.Pointer<AVFormatContext> s,
    int type,
    ffi.Pointer<ffi.Void> data,
    int data_size,
  ) {
    _avdevice_app_to_dev_control_message ??= _dylib.lookupFunction<
            _c_avdevice_app_to_dev_control_message,
            _dart_avdevice_app_to_dev_control_message>(
        'avdevice_app_to_dev_control_message');
    return _avdevice_app_to_dev_control_message(
      s,
      type,
      data,
      data_size,
    );
  }

  _dart_avdevice_app_to_dev_control_message
      _avdevice_app_to_dev_control_message;

  /// Send control message from device to application.
  ///
  /// @param s         device context.
  /// @param type      message type.
  /// @param data      message data. Can be NULL.
  /// @param data_size size of message data.
  /// @return >= 0 on success, negative on error.
  /// AVERROR(ENOSYS) when application doesn't implement handler of the message.
  int avdevice_dev_to_app_control_message(
    ffi.Pointer<AVFormatContext> s,
    int type,
    ffi.Pointer<ffi.Void> data,
    int data_size,
  ) {
    _avdevice_dev_to_app_control_message ??= _dylib.lookupFunction<
            _c_avdevice_dev_to_app_control_message,
            _dart_avdevice_dev_to_app_control_message>(
        'avdevice_dev_to_app_control_message');
    return _avdevice_dev_to_app_control_message(
      s,
      type,
      data,
      data_size,
    );
  }

  _dart_avdevice_dev_to_app_control_message
      _avdevice_dev_to_app_control_message;

  /// Initialize capabilities probing API based on AVOption API.
  ///
  /// avdevice_capabilities_free() must be called when query capabilities API is
  /// not used anymore.
  ///
  /// @param[out] caps      Device capabilities data. Pointer to a NULL pointer must be passed.
  /// @param s              Context of the device.
  /// @param device_options An AVDictionary filled with device-private options.
  /// On return this parameter will be destroyed and replaced with a dict
  /// containing options that were not found. May be NULL.
  /// The same options must be passed later to avformat_write_header() for output
  /// devices or avformat_open_input() for input devices, or at any other place
  /// that affects device-private options.
  ///
  /// @return >= 0 on success, negative otherwise.
  int avdevice_capabilities_create(
    ffi.Pointer<ffi.Pointer<AVDeviceCapabilitiesQuery>> caps,
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Pointer<AVDictionary>> device_options,
  ) {
    _avdevice_capabilities_create ??= _dylib.lookupFunction<
        _c_avdevice_capabilities_create,
        _dart_avdevice_capabilities_create>('avdevice_capabilities_create');
    return _avdevice_capabilities_create(
      caps,
      s,
      device_options,
    );
  }

  _dart_avdevice_capabilities_create _avdevice_capabilities_create;

  /// Free resources created by avdevice_capabilities_create()
  ///
  /// @param caps Device capabilities data to be freed.
  /// @param s    Context of the device.
  void avdevice_capabilities_free(
    ffi.Pointer<ffi.Pointer<AVDeviceCapabilitiesQuery>> caps,
    ffi.Pointer<AVFormatContext> s,
  ) {
    _avdevice_capabilities_free ??= _dylib.lookupFunction<
        _c_avdevice_capabilities_free,
        _dart_avdevice_capabilities_free>('avdevice_capabilities_free');
    return _avdevice_capabilities_free(
      caps,
      s,
    );
  }

  _dart_avdevice_capabilities_free _avdevice_capabilities_free;

  /// List devices.
  ///
  /// Returns available device names and their parameters.
  ///
  /// @note: Some devices may accept system-dependent device names that cannot be
  /// autodetected. The list returned by this function cannot be assumed to
  /// be always completed.
  ///
  /// @param s                device context.
  /// @param[out] device_list list of autodetected devices.
  /// @return count of autodetected devices, negative on error.
  int avdevice_list_devices(
    ffi.Pointer<AVFormatContext> s,
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    _avdevice_list_devices ??= _dylib.lookupFunction<_c_avdevice_list_devices,
        _dart_avdevice_list_devices>('avdevice_list_devices');
    return _avdevice_list_devices(
      s,
      device_list,
    );
  }

  _dart_avdevice_list_devices _avdevice_list_devices;

  /// Convenient function to free result of avdevice_list_devices().
  ///
  /// @param devices device list to be freed.
  void avdevice_free_list_devices(
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    _avdevice_free_list_devices ??= _dylib.lookupFunction<
        _c_avdevice_free_list_devices,
        _dart_avdevice_free_list_devices>('avdevice_free_list_devices');
    return _avdevice_free_list_devices(
      device_list,
    );
  }

  _dart_avdevice_free_list_devices _avdevice_free_list_devices;

  /// List devices.
  ///
  /// Returns available device names and their parameters.
  /// These are convinient wrappers for avdevice_list_devices().
  /// Device context is allocated and deallocated internally.
  ///
  /// @param device           device format. May be NULL if device name is set.
  /// @param device_name      device name. May be NULL if device format is set.
  /// @param device_options   An AVDictionary filled with device-private options. May be NULL.
  /// The same options must be passed later to avformat_write_header() for output
  /// devices or avformat_open_input() for input devices, or at any other place
  /// that affects device-private options.
  /// @param[out] device_list list of autodetected devices
  /// @return count of autodetected devices, negative on error.
  /// @note device argument takes precedence over device_name when both are set.
  int avdevice_list_input_sources(
    ffi.Pointer<AVInputFormat> device,
    ffi.Pointer<ffi.Int8> device_name,
    ffi.Pointer<AVDictionary> device_options,
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    _avdevice_list_input_sources ??= _dylib.lookupFunction<
        _c_avdevice_list_input_sources,
        _dart_avdevice_list_input_sources>('avdevice_list_input_sources');
    return _avdevice_list_input_sources(
      device,
      device_name,
      device_options,
      device_list,
    );
  }

  _dart_avdevice_list_input_sources _avdevice_list_input_sources;

  int avdevice_list_output_sinks(
    ffi.Pointer<AVOutputFormat> device,
    ffi.Pointer<ffi.Int8> device_name,
    ffi.Pointer<AVDictionary> device_options,
    ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
  ) {
    _avdevice_list_output_sinks ??= _dylib.lookupFunction<
        _c_avdevice_list_output_sinks,
        _dart_avdevice_list_output_sinks>('avdevice_list_output_sinks');
    return _avdevice_list_output_sinks(
      device,
      device_name,
      device_options,
      device_list,
    );
  }

  _dart_avdevice_list_output_sinks _avdevice_list_output_sinks;

  /// Return the LIBAVFILTER_VERSION_INT constant.
  int avfilter_version() {
    _avfilter_version ??=
        _dylib.lookupFunction<_c_avfilter_version, _dart_avfilter_version>(
            'avfilter_version');
    return _avfilter_version();
  }

  _dart_avfilter_version _avfilter_version;

  /// Return the libavfilter build-time configuration.
  ffi.Pointer<ffi.Int8> avfilter_configuration() {
    _avfilter_configuration ??= _dylib.lookupFunction<_c_avfilter_configuration,
        _dart_avfilter_configuration>('avfilter_configuration');
    return _avfilter_configuration();
  }

  _dart_avfilter_configuration _avfilter_configuration;

  /// Return the libavfilter license.
  ffi.Pointer<ffi.Int8> avfilter_license() {
    _avfilter_license ??=
        _dylib.lookupFunction<_c_avfilter_license, _dart_avfilter_license>(
            'avfilter_license');
    return _avfilter_license();
  }

  _dart_avfilter_license _avfilter_license;

  /// Get the number of elements in a NULL-terminated array of AVFilterPads (e.g.
  /// AVFilter.inputs/outputs).
  int avfilter_pad_count(
    ffi.Pointer<AVFilterPad> pads,
  ) {
    _avfilter_pad_count ??=
        _dylib.lookupFunction<_c_avfilter_pad_count, _dart_avfilter_pad_count>(
            'avfilter_pad_count');
    return _avfilter_pad_count(
      pads,
    );
  }

  _dart_avfilter_pad_count _avfilter_pad_count;

  /// Get the name of an AVFilterPad.
  ///
  /// @param pads an array of AVFilterPads
  /// @param pad_idx index of the pad in the array; it is the caller's
  /// responsibility to ensure the index is valid
  ///
  /// @return name of the pad_idx'th pad in pads
  ffi.Pointer<ffi.Int8> avfilter_pad_get_name(
    ffi.Pointer<AVFilterPad> pads,
    int pad_idx,
  ) {
    _avfilter_pad_get_name ??= _dylib.lookupFunction<_c_avfilter_pad_get_name,
        _dart_avfilter_pad_get_name>('avfilter_pad_get_name');
    return _avfilter_pad_get_name(
      pads,
      pad_idx,
    );
  }

  _dart_avfilter_pad_get_name _avfilter_pad_get_name;

  /// Get the type of an AVFilterPad.
  ///
  /// @param pads an array of AVFilterPads
  /// @param pad_idx index of the pad in the array; it is the caller's
  /// responsibility to ensure the index is valid
  ///
  /// @return type of the pad_idx'th pad in pads
  int avfilter_pad_get_type(
    ffi.Pointer<AVFilterPad> pads,
    int pad_idx,
  ) {
    _avfilter_pad_get_type ??= _dylib.lookupFunction<_c_avfilter_pad_get_type,
        _dart_avfilter_pad_get_type>('avfilter_pad_get_type');
    return _avfilter_pad_get_type(
      pads,
      pad_idx,
    );
  }

  _dart_avfilter_pad_get_type _avfilter_pad_get_type;

  /// Link two filters together.
  ///
  /// @param src    the source filter
  /// @param srcpad index of the output pad on the source filter
  /// @param dst    the destination filter
  /// @param dstpad index of the input pad on the destination filter
  /// @return       zero on success
  int avfilter_link(
    ffi.Pointer<AVFilterContext> src,
    int srcpad,
    ffi.Pointer<AVFilterContext> dst,
    int dstpad,
  ) {
    _avfilter_link ??= _dylib
        .lookupFunction<_c_avfilter_link, _dart_avfilter_link>('avfilter_link');
    return _avfilter_link(
      src,
      srcpad,
      dst,
      dstpad,
    );
  }

  _dart_avfilter_link _avfilter_link;

  /// Free the link in *link, and set its pointer to NULL.
  void avfilter_link_free(
    ffi.Pointer<ffi.Pointer<AVFilterLink>> link,
  ) {
    _avfilter_link_free ??=
        _dylib.lookupFunction<_c_avfilter_link_free, _dart_avfilter_link_free>(
            'avfilter_link_free');
    return _avfilter_link_free(
      link,
    );
  }

  _dart_avfilter_link_free _avfilter_link_free;

  /// Get the number of channels of a link.
  /// @deprecated Use av_buffersink_get_channels()
  int avfilter_link_get_channels(
    ffi.Pointer<AVFilterLink> link,
  ) {
    _avfilter_link_get_channels ??= _dylib.lookupFunction<
        _c_avfilter_link_get_channels,
        _dart_avfilter_link_get_channels>('avfilter_link_get_channels');
    return _avfilter_link_get_channels(
      link,
    );
  }

  _dart_avfilter_link_get_channels _avfilter_link_get_channels;

  /// Set the closed field of a link.
  /// @deprecated applications are not supposed to mess with links, they should
  /// close the sinks.
  void avfilter_link_set_closed(
    ffi.Pointer<AVFilterLink> link,
    int closed,
  ) {
    _avfilter_link_set_closed ??= _dylib.lookupFunction<
        _c_avfilter_link_set_closed,
        _dart_avfilter_link_set_closed>('avfilter_link_set_closed');
    return _avfilter_link_set_closed(
      link,
      closed,
    );
  }

  _dart_avfilter_link_set_closed _avfilter_link_set_closed;

  /// Negotiate the media format, dimensions, etc of all inputs to a filter.
  ///
  /// @param filter the filter to negotiate the properties for its inputs
  /// @return       zero on successful negotiation
  int avfilter_config_links(
    ffi.Pointer<AVFilterContext> filter,
  ) {
    _avfilter_config_links ??= _dylib.lookupFunction<_c_avfilter_config_links,
        _dart_avfilter_config_links>('avfilter_config_links');
    return _avfilter_config_links(
      filter,
    );
  }

  _dart_avfilter_config_links _avfilter_config_links;

  /// Make the filter instance process a command.
  /// It is recommended to use avfilter_graph_send_command().
  int avfilter_process_command(
    ffi.Pointer<AVFilterContext> filter,
    ffi.Pointer<ffi.Int8> cmd,
    ffi.Pointer<ffi.Int8> arg,
    ffi.Pointer<ffi.Int8> res,
    int res_len,
    int flags,
  ) {
    _avfilter_process_command ??= _dylib.lookupFunction<
        _c_avfilter_process_command,
        _dart_avfilter_process_command>('avfilter_process_command');
    return _avfilter_process_command(
      filter,
      cmd,
      arg,
      res,
      res_len,
      flags,
    );
  }

  _dart_avfilter_process_command _avfilter_process_command;

  /// Iterate over all registered filters.
  ///
  /// @param opaque a pointer where libavfilter will store the iteration state. Must
  /// point to NULL to start the iteration.
  ///
  /// @return the next registered filter or NULL when the iteration is
  /// finished
  ffi.Pointer<AVFilter> av_filter_iterate(
    ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ) {
    _av_filter_iterate ??=
        _dylib.lookupFunction<_c_av_filter_iterate, _dart_av_filter_iterate>(
            'av_filter_iterate');
    return _av_filter_iterate(
      opaque,
    );
  }

  _dart_av_filter_iterate _av_filter_iterate;

  /// Initialize the filter system. Register all builtin filters.
  void avfilter_register_all() {
    _avfilter_register_all ??= _dylib.lookupFunction<_c_avfilter_register_all,
        _dart_avfilter_register_all>('avfilter_register_all');
    return _avfilter_register_all();
  }

  _dart_avfilter_register_all _avfilter_register_all;

  /// Register a filter. This is only needed if you plan to use
  /// avfilter_get_by_name later to lookup the AVFilter structure by name. A
  /// filter can still by instantiated with avfilter_graph_alloc_filter even if it
  /// is not registered.
  ///
  /// @param filter the filter to register
  /// @return 0 if the registration was successful, a negative value
  /// otherwise
  int avfilter_register(
    ffi.Pointer<AVFilter> filter,
  ) {
    _avfilter_register ??=
        _dylib.lookupFunction<_c_avfilter_register, _dart_avfilter_register>(
            'avfilter_register');
    return _avfilter_register(
      filter,
    );
  }

  _dart_avfilter_register _avfilter_register;

  /// Iterate over all registered filters.
  /// @return If prev is non-NULL, next registered filter after prev or NULL if
  /// prev is the last filter. If prev is NULL, return the first registered filter.
  ffi.Pointer<AVFilter> avfilter_next(
    ffi.Pointer<AVFilter> prev,
  ) {
    _avfilter_next ??= _dylib
        .lookupFunction<_c_avfilter_next, _dart_avfilter_next>('avfilter_next');
    return _avfilter_next(
      prev,
    );
  }

  _dart_avfilter_next _avfilter_next;

  /// Get a filter definition matching the given name.
  ///
  /// @param name the filter name to find
  /// @return     the filter definition, if any matching one is registered.
  /// NULL if none found.
  ffi.Pointer<AVFilter> avfilter_get_by_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _avfilter_get_by_name ??= _dylib.lookupFunction<_c_avfilter_get_by_name,
        _dart_avfilter_get_by_name>('avfilter_get_by_name');
    return _avfilter_get_by_name(
      name,
    );
  }

  _dart_avfilter_get_by_name _avfilter_get_by_name;

  /// Initialize a filter with the supplied parameters.
  ///
  /// @param ctx  uninitialized filter context to initialize
  /// @param args Options to initialize the filter with. This must be a
  /// ':'-separated list of options in the 'key=value' form.
  /// May be NULL if the options have been set directly using the
  /// AVOptions API or there are no options that need to be set.
  /// @return 0 on success, a negative AVERROR on failure
  int avfilter_init_str(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<ffi.Int8> args,
  ) {
    _avfilter_init_str ??=
        _dylib.lookupFunction<_c_avfilter_init_str, _dart_avfilter_init_str>(
            'avfilter_init_str');
    return _avfilter_init_str(
      ctx,
      args,
    );
  }

  _dart_avfilter_init_str _avfilter_init_str;

  /// Initialize a filter with the supplied dictionary of options.
  ///
  /// @param ctx     uninitialized filter context to initialize
  /// @param options An AVDictionary filled with options for this filter. On
  /// return this parameter will be destroyed and replaced with
  /// a dict containing options that were not found. This dictionary
  /// must be freed by the caller.
  /// May be NULL, then this function is equivalent to
  /// avfilter_init_str() with the second parameter set to NULL.
  /// @return 0 on success, a negative AVERROR on failure
  ///
  /// @note This function and avfilter_init_str() do essentially the same thing,
  /// the difference is in manner in which the options are passed. It is up to the
  /// calling code to choose whichever is more preferable. The two functions also
  /// behave differently when some of the provided options are not declared as
  /// supported by the filter. In such a case, avfilter_init_str() will fail, but
  /// this function will leave those extra options in the options AVDictionary and
  /// continue as usual.
  int avfilter_init_dict(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ) {
    _avfilter_init_dict ??=
        _dylib.lookupFunction<_c_avfilter_init_dict, _dart_avfilter_init_dict>(
            'avfilter_init_dict');
    return _avfilter_init_dict(
      ctx,
      options,
    );
  }

  _dart_avfilter_init_dict _avfilter_init_dict;

  /// Free a filter context. This will also remove the filter from its
  /// filtergraph's list of filters.
  ///
  /// @param filter the filter to free
  void avfilter_free(
    ffi.Pointer<AVFilterContext> filter,
  ) {
    _avfilter_free ??= _dylib
        .lookupFunction<_c_avfilter_free, _dart_avfilter_free>('avfilter_free');
    return _avfilter_free(
      filter,
    );
  }

  _dart_avfilter_free _avfilter_free;

  /// Insert a filter in the middle of an existing link.
  ///
  /// @param link the link into which the filter should be inserted
  /// @param filt the filter to be inserted
  /// @param filt_srcpad_idx the input pad on the filter to connect
  /// @param filt_dstpad_idx the output pad on the filter to connect
  /// @return     zero on success
  int avfilter_insert_filter(
    ffi.Pointer<AVFilterLink> link,
    ffi.Pointer<AVFilterContext> filt,
    int filt_srcpad_idx,
    int filt_dstpad_idx,
  ) {
    _avfilter_insert_filter ??= _dylib.lookupFunction<_c_avfilter_insert_filter,
        _dart_avfilter_insert_filter>('avfilter_insert_filter');
    return _avfilter_insert_filter(
      link,
      filt,
      filt_srcpad_idx,
      filt_dstpad_idx,
    );
  }

  _dart_avfilter_insert_filter _avfilter_insert_filter;

  /// @return AVClass for AVFilterContext.
  ///
  /// @see av_opt_find().
  ffi.Pointer<AVClass> avfilter_get_class() {
    _avfilter_get_class ??=
        _dylib.lookupFunction<_c_avfilter_get_class, _dart_avfilter_get_class>(
            'avfilter_get_class');
    return _avfilter_get_class();
  }

  _dart_avfilter_get_class _avfilter_get_class;

  /// Allocate a filter graph.
  ///
  /// @return the allocated filter graph on success or NULL.
  ffi.Pointer<AVFilterGraph> avfilter_graph_alloc() {
    _avfilter_graph_alloc ??= _dylib.lookupFunction<_c_avfilter_graph_alloc,
        _dart_avfilter_graph_alloc>('avfilter_graph_alloc');
    return _avfilter_graph_alloc();
  }

  _dart_avfilter_graph_alloc _avfilter_graph_alloc;

  /// Create a new filter instance in a filter graph.
  ///
  /// @param graph graph in which the new filter will be used
  /// @param filter the filter to create an instance of
  /// @param name Name to give to the new instance (will be copied to
  /// AVFilterContext.name). This may be used by the caller to identify
  /// different filters, libavfilter itself assigns no semantics to
  /// this parameter. May be NULL.
  ///
  /// @return the context of the newly created filter instance (note that it is
  /// also retrievable directly through AVFilterGraph.filters or with
  /// avfilter_graph_get_filter()) on success or NULL on failure.
  ffi.Pointer<AVFilterContext> avfilter_graph_alloc_filter(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<AVFilter> filter,
    ffi.Pointer<ffi.Int8> name,
  ) {
    _avfilter_graph_alloc_filter ??= _dylib.lookupFunction<
        _c_avfilter_graph_alloc_filter,
        _dart_avfilter_graph_alloc_filter>('avfilter_graph_alloc_filter');
    return _avfilter_graph_alloc_filter(
      graph,
      filter,
      name,
    );
  }

  _dart_avfilter_graph_alloc_filter _avfilter_graph_alloc_filter;

  /// Get a filter instance identified by instance name from graph.
  ///
  /// @param graph filter graph to search through.
  /// @param name filter instance name (should be unique in the graph).
  /// @return the pointer to the found filter instance or NULL if it
  /// cannot be found.
  ffi.Pointer<AVFilterContext> avfilter_graph_get_filter(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Int8> name,
  ) {
    _avfilter_graph_get_filter ??= _dylib.lookupFunction<
        _c_avfilter_graph_get_filter,
        _dart_avfilter_graph_get_filter>('avfilter_graph_get_filter');
    return _avfilter_graph_get_filter(
      graph,
      name,
    );
  }

  _dart_avfilter_graph_get_filter _avfilter_graph_get_filter;

  /// Create and add a filter instance into an existing graph.
  /// The filter instance is created from the filter filt and inited
  /// with the parameter args. opaque is currently ignored.
  ///
  /// In case of success put in *filt_ctx the pointer to the created
  /// filter instance, otherwise set *filt_ctx to NULL.
  ///
  /// @param name the instance name to give to the created filter instance
  /// @param graph_ctx the filter graph
  /// @return a negative AVERROR error code in case of failure, a non
  /// negative value otherwise
  int avfilter_graph_create_filter(
    ffi.Pointer<ffi.Pointer<AVFilterContext>> filt_ctx,
    ffi.Pointer<AVFilter> filt,
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> args,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<AVFilterGraph> graph_ctx,
  ) {
    _avfilter_graph_create_filter ??= _dylib.lookupFunction<
        _c_avfilter_graph_create_filter,
        _dart_avfilter_graph_create_filter>('avfilter_graph_create_filter');
    return _avfilter_graph_create_filter(
      filt_ctx,
      filt,
      name,
      args,
      opaque,
      graph_ctx,
    );
  }

  _dart_avfilter_graph_create_filter _avfilter_graph_create_filter;

  /// Enable or disable automatic format conversion inside the graph.
  ///
  /// Note that format conversion can still happen inside explicitly inserted
  /// scale and aresample filters.
  ///
  /// @param flags  any of the AVFILTER_AUTO_CONVERT_* constants
  void avfilter_graph_set_auto_convert(
    ffi.Pointer<AVFilterGraph> graph,
    int flags,
  ) {
    _avfilter_graph_set_auto_convert ??= _dylib.lookupFunction<
            _c_avfilter_graph_set_auto_convert,
            _dart_avfilter_graph_set_auto_convert>(
        'avfilter_graph_set_auto_convert');
    return _avfilter_graph_set_auto_convert(
      graph,
      flags,
    );
  }

  _dart_avfilter_graph_set_auto_convert _avfilter_graph_set_auto_convert;

  /// Check validity and configure all the links and formats in the graph.
  ///
  /// @param graphctx the filter graph
  /// @param log_ctx context used for logging
  /// @return >= 0 in case of success, a negative AVERROR code otherwise
  int avfilter_graph_config(
    ffi.Pointer<AVFilterGraph> graphctx,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _avfilter_graph_config ??= _dylib.lookupFunction<_c_avfilter_graph_config,
        _dart_avfilter_graph_config>('avfilter_graph_config');
    return _avfilter_graph_config(
      graphctx,
      log_ctx,
    );
  }

  _dart_avfilter_graph_config _avfilter_graph_config;

  /// Free a graph, destroy its links, and set *graph to NULL.
  /// If *graph is NULL, do nothing.
  void avfilter_graph_free(
    ffi.Pointer<ffi.Pointer<AVFilterGraph>> graph,
  ) {
    _avfilter_graph_free ??= _dylib.lookupFunction<_c_avfilter_graph_free,
        _dart_avfilter_graph_free>('avfilter_graph_free');
    return _avfilter_graph_free(
      graph,
    );
  }

  _dart_avfilter_graph_free _avfilter_graph_free;

  /// Allocate a single AVFilterInOut entry.
  /// Must be freed with avfilter_inout_free().
  /// @return allocated AVFilterInOut on success, NULL on failure.
  ffi.Pointer<AVFilterInOut> avfilter_inout_alloc() {
    _avfilter_inout_alloc ??= _dylib.lookupFunction<_c_avfilter_inout_alloc,
        _dart_avfilter_inout_alloc>('avfilter_inout_alloc');
    return _avfilter_inout_alloc();
  }

  _dart_avfilter_inout_alloc _avfilter_inout_alloc;

  /// Free the supplied list of AVFilterInOut and set *inout to NULL.
  /// If *inout is NULL, do nothing.
  void avfilter_inout_free(
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inout,
  ) {
    _avfilter_inout_free ??= _dylib.lookupFunction<_c_avfilter_inout_free,
        _dart_avfilter_inout_free>('avfilter_inout_free');
    return _avfilter_inout_free(
      inout,
    );
  }

  _dart_avfilter_inout_free _avfilter_inout_free;

  /// Add a graph described by a string to a graph.
  ///
  /// @note The caller must provide the lists of inputs and outputs,
  /// which therefore must be known before calling the function.
  ///
  /// @note The inputs parameter describes inputs of the already existing
  /// part of the graph; i.e. from the point of view of the newly created
  /// part, they are outputs. Similarly the outputs parameter describes
  /// outputs of the already existing filters, which are provided as
  /// inputs to the parsed filters.
  ///
  /// @param graph   the filter graph where to link the parsed graph context
  /// @param filters string to be parsed
  /// @param inputs  linked list to the inputs of the graph
  /// @param outputs linked list to the outputs of the graph
  /// @return zero on success, a negative AVERROR code on error
  int avfilter_graph_parse(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Int8> filters,
    ffi.Pointer<AVFilterInOut> inputs,
    ffi.Pointer<AVFilterInOut> outputs,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _avfilter_graph_parse ??= _dylib.lookupFunction<_c_avfilter_graph_parse,
        _dart_avfilter_graph_parse>('avfilter_graph_parse');
    return _avfilter_graph_parse(
      graph,
      filters,
      inputs,
      outputs,
      log_ctx,
    );
  }

  _dart_avfilter_graph_parse _avfilter_graph_parse;

  /// Add a graph described by a string to a graph.
  ///
  /// In the graph filters description, if the input label of the first
  /// filter is not specified, "in" is assumed; if the output label of
  /// the last filter is not specified, "out" is assumed.
  ///
  /// @param graph   the filter graph where to link the parsed graph context
  /// @param filters string to be parsed
  /// @param inputs  pointer to a linked list to the inputs of the graph, may be NULL.
  /// If non-NULL, *inputs is updated to contain the list of open inputs
  /// after the parsing, should be freed with avfilter_inout_free().
  /// @param outputs pointer to a linked list to the outputs of the graph, may be NULL.
  /// If non-NULL, *outputs is updated to contain the list of open outputs
  /// after the parsing, should be freed with avfilter_inout_free().
  /// @return non negative on success, a negative AVERROR code on error
  int avfilter_graph_parse_ptr(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Int8> filters,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _avfilter_graph_parse_ptr ??= _dylib.lookupFunction<
        _c_avfilter_graph_parse_ptr,
        _dart_avfilter_graph_parse_ptr>('avfilter_graph_parse_ptr');
    return _avfilter_graph_parse_ptr(
      graph,
      filters,
      inputs,
      outputs,
      log_ctx,
    );
  }

  _dart_avfilter_graph_parse_ptr _avfilter_graph_parse_ptr;

  /// Add a graph described by a string to a graph.
  ///
  /// @param[in]  graph   the filter graph where to link the parsed graph context
  /// @param[in]  filters string to be parsed
  /// @param[out] inputs  a linked list of all free (unlinked) inputs of the
  /// parsed graph will be returned here. It is to be freed
  /// by the caller using avfilter_inout_free().
  /// @param[out] outputs a linked list of all free (unlinked) outputs of the
  /// parsed graph will be returned here. It is to be freed by the
  /// caller using avfilter_inout_free().
  /// @return zero on success, a negative AVERROR code on error
  ///
  /// @note This function returns the inputs and outputs that are left
  /// unlinked after parsing the graph and the caller then deals with
  /// them.
  /// @note This function makes no reference whatsoever to already
  /// existing parts of the graph and the inputs parameter will on return
  /// contain inputs of the newly parsed part of the graph.  Analogously
  /// the outputs parameter will contain outputs of the newly created
  /// filters.
  int avfilter_graph_parse2(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Int8> filters,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
    ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
  ) {
    _avfilter_graph_parse2 ??= _dylib.lookupFunction<_c_avfilter_graph_parse2,
        _dart_avfilter_graph_parse2>('avfilter_graph_parse2');
    return _avfilter_graph_parse2(
      graph,
      filters,
      inputs,
      outputs,
    );
  }

  _dart_avfilter_graph_parse2 _avfilter_graph_parse2;

  /// Send a command to one or more filter instances.
  ///
  /// @param graph  the filter graph
  /// @param target the filter(s) to which the command should be sent
  /// "all" sends to all filters
  /// otherwise it can be a filter or filter instance name
  /// which will send the command to all matching filters.
  /// @param cmd    the command to send, for handling simplicity all commands must be alphanumeric only
  /// @param arg    the argument for the command
  /// @param res    a buffer with size res_size where the filter(s) can return a response.
  ///
  /// @returns >=0 on success otherwise an error code.
  /// AVERROR(ENOSYS) on unsupported commands
  int avfilter_graph_send_command(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Int8> target,
    ffi.Pointer<ffi.Int8> cmd,
    ffi.Pointer<ffi.Int8> arg,
    ffi.Pointer<ffi.Int8> res,
    int res_len,
    int flags,
  ) {
    _avfilter_graph_send_command ??= _dylib.lookupFunction<
        _c_avfilter_graph_send_command,
        _dart_avfilter_graph_send_command>('avfilter_graph_send_command');
    return _avfilter_graph_send_command(
      graph,
      target,
      cmd,
      arg,
      res,
      res_len,
      flags,
    );
  }

  _dart_avfilter_graph_send_command _avfilter_graph_send_command;

  /// Queue a command for one or more filter instances.
  ///
  /// @param graph  the filter graph
  /// @param target the filter(s) to which the command should be sent
  /// "all" sends to all filters
  /// otherwise it can be a filter or filter instance name
  /// which will send the command to all matching filters.
  /// @param cmd    the command to sent, for handling simplicity all commands must be alphanumeric only
  /// @param arg    the argument for the command
  /// @param ts     time at which the command should be sent to the filter
  ///
  /// @note As this executes commands after this function returns, no return code
  /// from the filter is provided, also AVFILTER_CMD_FLAG_ONE is not supported.
  int avfilter_graph_queue_command(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Int8> target,
    ffi.Pointer<ffi.Int8> cmd,
    ffi.Pointer<ffi.Int8> arg,
    int flags,
    double ts,
  ) {
    _avfilter_graph_queue_command ??= _dylib.lookupFunction<
        _c_avfilter_graph_queue_command,
        _dart_avfilter_graph_queue_command>('avfilter_graph_queue_command');
    return _avfilter_graph_queue_command(
      graph,
      target,
      cmd,
      arg,
      flags,
      ts,
    );
  }

  _dart_avfilter_graph_queue_command _avfilter_graph_queue_command;

  /// Dump a graph into a human-readable string representation.
  ///
  /// @param graph    the graph to dump
  /// @param options  formatting options; currently ignored
  /// @return  a string, or NULL in case of memory allocation failure;
  /// the string must be freed using av_free
  ffi.Pointer<ffi.Int8> avfilter_graph_dump(
    ffi.Pointer<AVFilterGraph> graph,
    ffi.Pointer<ffi.Int8> options,
  ) {
    _avfilter_graph_dump ??= _dylib.lookupFunction<_c_avfilter_graph_dump,
        _dart_avfilter_graph_dump>('avfilter_graph_dump');
    return _avfilter_graph_dump(
      graph,
      options,
    );
  }

  _dart_avfilter_graph_dump _avfilter_graph_dump;

  /// Request a frame on the oldest sink link.
  ///
  /// If the request returns AVERROR_EOF, try the next.
  ///
  /// Note that this function is not meant to be the sole scheduling mechanism
  /// of a filtergraph, only a convenience function to help drain a filtergraph
  /// in a balanced way under normal circumstances.
  ///
  /// Also note that AVERROR_EOF does not mean that frames did not arrive on
  /// some of the sinks during the process.
  /// When there are multiple sink links, in case the requested link
  /// returns an EOF, this may cause a filter to flush pending frames
  /// which are sent to another sink link, although unrequested.
  ///
  /// @return  the return value of ff_request_frame(),
  /// or AVERROR_EOF if all links returned AVERROR_EOF
  int avfilter_graph_request_oldest(
    ffi.Pointer<AVFilterGraph> graph,
  ) {
    _avfilter_graph_request_oldest ??= _dylib.lookupFunction<
        _c_avfilter_graph_request_oldest,
        _dart_avfilter_graph_request_oldest>('avfilter_graph_request_oldest');
    return _avfilter_graph_request_oldest(
      graph,
    );
  }

  _dart_avfilter_graph_request_oldest _avfilter_graph_request_oldest;

  /// Get a frame with filtered data from sink and put it in frame.
  ///
  /// @param ctx    pointer to a buffersink or abuffersink filter context.
  /// @param frame  pointer to an allocated frame that will be filled with data.
  /// The data must be freed using av_frame_unref() / av_frame_free()
  /// @param flags  a combination of AV_BUFFERSINK_FLAG_* flags
  ///
  /// @return  >= 0 in for success, a negative AVERROR code for failure.
  int av_buffersink_get_frame_flags(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    _av_buffersink_get_frame_flags ??= _dylib.lookupFunction<
        _c_av_buffersink_get_frame_flags,
        _dart_av_buffersink_get_frame_flags>('av_buffersink_get_frame_flags');
    return _av_buffersink_get_frame_flags(
      ctx,
      frame,
      flags,
    );
  }

  _dart_av_buffersink_get_frame_flags _av_buffersink_get_frame_flags;

  /// Create an AVBufferSinkParams structure.
  ///
  /// Must be freed with av_free().
  ffi.Pointer<AVBufferSinkParams> av_buffersink_params_alloc() {
    _av_buffersink_params_alloc ??= _dylib.lookupFunction<
        _c_av_buffersink_params_alloc,
        _dart_av_buffersink_params_alloc>('av_buffersink_params_alloc');
    return _av_buffersink_params_alloc();
  }

  _dart_av_buffersink_params_alloc _av_buffersink_params_alloc;

  /// Create an AVABufferSinkParams structure.
  ///
  /// Must be freed with av_free().
  ffi.Pointer<AVABufferSinkParams> av_abuffersink_params_alloc() {
    _av_abuffersink_params_alloc ??= _dylib.lookupFunction<
        _c_av_abuffersink_params_alloc,
        _dart_av_abuffersink_params_alloc>('av_abuffersink_params_alloc');
    return _av_abuffersink_params_alloc();
  }

  _dart_av_abuffersink_params_alloc _av_abuffersink_params_alloc;

  /// Set the frame size for an audio buffer sink.
  ///
  /// All calls to av_buffersink_get_buffer_ref will return a buffer with
  /// exactly the specified number of samples, or AVERROR(EAGAIN) if there is
  /// not enough. The last buffer at EOF will be padded with 0.
  void av_buffersink_set_frame_size(
    ffi.Pointer<AVFilterContext> ctx,
    int frame_size,
  ) {
    _av_buffersink_set_frame_size ??= _dylib.lookupFunction<
        _c_av_buffersink_set_frame_size,
        _dart_av_buffersink_set_frame_size>('av_buffersink_set_frame_size');
    return _av_buffersink_set_frame_size(
      ctx,
      frame_size,
    );
  }

  _dart_av_buffersink_set_frame_size _av_buffersink_set_frame_size;

  /// @defgroup lavfi_buffersink_accessors Buffer sink accessors
  /// Get the properties of the stream
  /// @{
  int av_buffersink_get_type(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_type ??= _dylib.lookupFunction<_c_av_buffersink_get_type,
        _dart_av_buffersink_get_type>('av_buffersink_get_type');
    return _av_buffersink_get_type(
      ctx,
    );
  }

  _dart_av_buffersink_get_type _av_buffersink_get_type;

  int av_buffersink_get_format(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_format ??= _dylib.lookupFunction<
        _c_av_buffersink_get_format,
        _dart_av_buffersink_get_format>('av_buffersink_get_format');
    return _av_buffersink_get_format(
      ctx,
    );
  }

  _dart_av_buffersink_get_format _av_buffersink_get_format;

  int av_buffersink_get_w(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_w ??= _dylib.lookupFunction<_c_av_buffersink_get_w,
        _dart_av_buffersink_get_w>('av_buffersink_get_w');
    return _av_buffersink_get_w(
      ctx,
    );
  }

  _dart_av_buffersink_get_w _av_buffersink_get_w;

  int av_buffersink_get_h(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_h ??= _dylib.lookupFunction<_c_av_buffersink_get_h,
        _dart_av_buffersink_get_h>('av_buffersink_get_h');
    return _av_buffersink_get_h(
      ctx,
    );
  }

  _dart_av_buffersink_get_h _av_buffersink_get_h;

  int av_buffersink_get_channels(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_channels ??= _dylib.lookupFunction<
        _c_av_buffersink_get_channels,
        _dart_av_buffersink_get_channels>('av_buffersink_get_channels');
    return _av_buffersink_get_channels(
      ctx,
    );
  }

  _dart_av_buffersink_get_channels _av_buffersink_get_channels;

  int av_buffersink_get_channel_layout(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_channel_layout ??= _dylib.lookupFunction<
            _c_av_buffersink_get_channel_layout,
            _dart_av_buffersink_get_channel_layout>(
        'av_buffersink_get_channel_layout');
    return _av_buffersink_get_channel_layout(
      ctx,
    );
  }

  _dart_av_buffersink_get_channel_layout _av_buffersink_get_channel_layout;

  int av_buffersink_get_sample_rate(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_sample_rate ??= _dylib.lookupFunction<
        _c_av_buffersink_get_sample_rate,
        _dart_av_buffersink_get_sample_rate>('av_buffersink_get_sample_rate');
    return _av_buffersink_get_sample_rate(
      ctx,
    );
  }

  _dart_av_buffersink_get_sample_rate _av_buffersink_get_sample_rate;

  ffi.Pointer<AVBufferRef> av_buffersink_get_hw_frames_ctx(
    ffi.Pointer<AVFilterContext> ctx,
  ) {
    _av_buffersink_get_hw_frames_ctx ??= _dylib.lookupFunction<
            _c_av_buffersink_get_hw_frames_ctx,
            _dart_av_buffersink_get_hw_frames_ctx>(
        'av_buffersink_get_hw_frames_ctx');
    return _av_buffersink_get_hw_frames_ctx(
      ctx,
    );
  }

  _dart_av_buffersink_get_hw_frames_ctx _av_buffersink_get_hw_frames_ctx;

  /// Get a frame with filtered data from sink and put it in frame.
  ///
  /// @param ctx pointer to a context of a buffersink or abuffersink AVFilter.
  /// @param frame pointer to an allocated frame that will be filled with data.
  /// The data must be freed using av_frame_unref() / av_frame_free()
  ///
  /// @return
  /// - >= 0 if a frame was successfully returned.
  /// - AVERROR(EAGAIN) if no frames are available at this point; more
  /// input frames must be added to the filtergraph to get more output.
  /// - AVERROR_EOF if there will be no more output frames on this sink.
  /// - A different negative AVERROR code in other failure cases.
  int av_buffersink_get_frame(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_buffersink_get_frame ??= _dylib.lookupFunction<
        _c_av_buffersink_get_frame,
        _dart_av_buffersink_get_frame>('av_buffersink_get_frame');
    return _av_buffersink_get_frame(
      ctx,
      frame,
    );
  }

  _dart_av_buffersink_get_frame _av_buffersink_get_frame;

  /// Same as av_buffersink_get_frame(), but with the ability to specify the number
  /// of samples read. This function is less efficient than
  /// av_buffersink_get_frame(), because it copies the data around.
  ///
  /// @param ctx pointer to a context of the abuffersink AVFilter.
  /// @param frame pointer to an allocated frame that will be filled with data.
  /// The data must be freed using av_frame_unref() / av_frame_free()
  /// frame will contain exactly nb_samples audio samples, except at
  /// the end of stream, when it can contain less than nb_samples.
  ///
  /// @return The return codes have the same meaning as for
  /// av_buffersink_get_frame().
  ///
  /// @warning do not mix this function with av_buffersink_get_frame(). Use only one or
  /// the other with a single sink, not both.
  int av_buffersink_get_samples(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
    int nb_samples,
  ) {
    _av_buffersink_get_samples ??= _dylib.lookupFunction<
        _c_av_buffersink_get_samples,
        _dart_av_buffersink_get_samples>('av_buffersink_get_samples');
    return _av_buffersink_get_samples(
      ctx,
      frame,
      nb_samples,
    );
  }

  _dart_av_buffersink_get_samples _av_buffersink_get_samples;

  /// Get the number of failed requests.
  ///
  /// A failed request is when the request_frame method is called while no
  /// frame is present in the buffer.
  /// The number is reset when a frame is added.
  int av_buffersrc_get_nb_failed_requests(
    ffi.Pointer<AVFilterContext> buffer_src,
  ) {
    _av_buffersrc_get_nb_failed_requests ??= _dylib.lookupFunction<
            _c_av_buffersrc_get_nb_failed_requests,
            _dart_av_buffersrc_get_nb_failed_requests>(
        'av_buffersrc_get_nb_failed_requests');
    return _av_buffersrc_get_nb_failed_requests(
      buffer_src,
    );
  }

  _dart_av_buffersrc_get_nb_failed_requests
      _av_buffersrc_get_nb_failed_requests;

  /// Allocate a new AVBufferSrcParameters instance. It should be freed by the
  /// caller with av_free().
  ffi.Pointer<AVBufferSrcParameters> av_buffersrc_parameters_alloc() {
    _av_buffersrc_parameters_alloc ??= _dylib.lookupFunction<
        _c_av_buffersrc_parameters_alloc,
        _dart_av_buffersrc_parameters_alloc>('av_buffersrc_parameters_alloc');
    return _av_buffersrc_parameters_alloc();
  }

  _dart_av_buffersrc_parameters_alloc _av_buffersrc_parameters_alloc;

  /// Initialize the buffersrc or abuffersrc filter with the provided parameters.
  /// This function may be called multiple times, the later calls override the
  /// previous ones. Some of the parameters may also be set through AVOptions, then
  /// whatever method is used last takes precedence.
  ///
  /// @param ctx an instance of the buffersrc or abuffersrc filter
  /// @param param the stream parameters. The frames later passed to this filter
  /// must conform to those parameters. All the allocated fields in
  /// param remain owned by the caller, libavfilter will make internal
  /// copies or references when necessary.
  /// @return 0 on success, a negative AVERROR code on failure.
  int av_buffersrc_parameters_set(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVBufferSrcParameters> param,
  ) {
    _av_buffersrc_parameters_set ??= _dylib.lookupFunction<
        _c_av_buffersrc_parameters_set,
        _dart_av_buffersrc_parameters_set>('av_buffersrc_parameters_set');
    return _av_buffersrc_parameters_set(
      ctx,
      param,
    );
  }

  _dart_av_buffersrc_parameters_set _av_buffersrc_parameters_set;

  /// Add a frame to the buffer source.
  ///
  /// @param ctx   an instance of the buffersrc filter
  /// @param frame frame to be added. If the frame is reference counted, this
  /// function will make a new reference to it. Otherwise the frame data will be
  /// copied.
  ///
  /// @return 0 on success, a negative AVERROR on error
  ///
  /// This function is equivalent to av_buffersrc_add_frame_flags() with the
  /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
  int av_buffersrc_write_frame(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_buffersrc_write_frame ??= _dylib.lookupFunction<
        _c_av_buffersrc_write_frame,
        _dart_av_buffersrc_write_frame>('av_buffersrc_write_frame');
    return _av_buffersrc_write_frame(
      ctx,
      frame,
    );
  }

  _dart_av_buffersrc_write_frame _av_buffersrc_write_frame;

  /// Add a frame to the buffer source.
  ///
  /// @param ctx   an instance of the buffersrc filter
  /// @param frame frame to be added. If the frame is reference counted, this
  /// function will take ownership of the reference(s) and reset the frame.
  /// Otherwise the frame data will be copied. If this function returns an error,
  /// the input frame is not touched.
  ///
  /// @return 0 on success, a negative AVERROR on error.
  ///
  /// @note the difference between this function and av_buffersrc_write_frame() is
  /// that av_buffersrc_write_frame() creates a new reference to the input frame,
  /// while this function takes ownership of the reference passed to it.
  ///
  /// This function is equivalent to av_buffersrc_add_frame_flags() without the
  /// AV_BUFFERSRC_FLAG_KEEP_REF flag.
  int av_buffersrc_add_frame(
    ffi.Pointer<AVFilterContext> ctx,
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_buffersrc_add_frame ??= _dylib.lookupFunction<_c_av_buffersrc_add_frame,
        _dart_av_buffersrc_add_frame>('av_buffersrc_add_frame');
    return _av_buffersrc_add_frame(
      ctx,
      frame,
    );
  }

  _dart_av_buffersrc_add_frame _av_buffersrc_add_frame;

  /// Add a frame to the buffer source.
  ///
  /// By default, if the frame is reference-counted, this function will take
  /// ownership of the reference(s) and reset the frame. This can be controlled
  /// using the flags.
  ///
  /// If this function returns an error, the input frame is not touched.
  ///
  /// @param buffer_src  pointer to a buffer source context
  /// @param frame       a frame, or NULL to mark EOF
  /// @param flags       a combination of AV_BUFFERSRC_FLAG_*
  /// @return            >= 0 in case of success, a negative AVERROR code
  /// in case of failure
  int av_buffersrc_add_frame_flags(
    ffi.Pointer<AVFilterContext> buffer_src,
    ffi.Pointer<AVFrame> frame,
    int flags,
  ) {
    _av_buffersrc_add_frame_flags ??= _dylib.lookupFunction<
        _c_av_buffersrc_add_frame_flags,
        _dart_av_buffersrc_add_frame_flags>('av_buffersrc_add_frame_flags');
    return _av_buffersrc_add_frame_flags(
      buffer_src,
      frame,
      flags,
    );
  }

  _dart_av_buffersrc_add_frame_flags _av_buffersrc_add_frame_flags;

  /// Close the buffer source after EOF.
  ///
  /// This is similar to passing NULL to av_buffersrc_add_frame_flags()
  /// except it takes the timestamp of the EOF, i.e. the timestamp of the end
  /// of the last frame.
  int av_buffersrc_close(
    ffi.Pointer<AVFilterContext> ctx,
    int pts,
    int flags,
  ) {
    _av_buffersrc_close ??=
        _dylib.lookupFunction<_c_av_buffersrc_close, _dart_av_buffersrc_close>(
            'av_buffersrc_close');
    return _av_buffersrc_close(
      ctx,
      pts,
      flags,
    );
  }

  _dart_av_buffersrc_close _av_buffersrc_close;

  /// Calculate the Adler32 checksum of a buffer.
  ///
  /// Passing the return value to a subsequent av_adler32_update() call
  /// allows the checksum of multiple buffers to be calculated as though
  /// they were concatenated.
  ///
  /// @param adler initial checksum value
  /// @param buf   pointer to input buffer
  /// @param len   size of input buffer
  /// @return      updated checksum
  int av_adler32_update(
    int adler,
    ffi.Pointer<ffi.Uint8> buf,
    int len,
  ) {
    _av_adler32_update ??=
        _dylib.lookupFunction<_c_av_adler32_update, _dart_av_adler32_update>(
            'av_adler32_update');
    return _av_adler32_update(
      adler,
      buf,
      len,
    );
  }

  _dart_av_adler32_update _av_adler32_update;

  /// Allocate an AVAES context.
  ffi.Pointer<AVAES> av_aes_alloc() {
    _av_aes_alloc ??= _dylib
        .lookupFunction<_c_av_aes_alloc, _dart_av_aes_alloc>('av_aes_alloc');
    return _av_aes_alloc();
  }

  _dart_av_aes_alloc _av_aes_alloc;

  /// Initialize an AVAES context.
  /// @param key_bits 128, 192 or 256
  /// @param decrypt 0 for encryption, 1 for decryption
  int av_aes_init(
    ffi.Pointer<AVAES> a,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
    int decrypt,
  ) {
    _av_aes_init ??=
        _dylib.lookupFunction<_c_av_aes_init, _dart_av_aes_init>('av_aes_init');
    return _av_aes_init(
      a,
      key,
      key_bits,
      decrypt,
    );
  }

  _dart_av_aes_init _av_aes_init;

  /// Encrypt or decrypt a buffer using a previously initialized context.
  /// @param count number of 16 byte blocks
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_aes_crypt(
    ffi.Pointer<AVAES> a,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_aes_crypt ??= _dylib
        .lookupFunction<_c_av_aes_crypt, _dart_av_aes_crypt>('av_aes_crypt');
    return _av_aes_crypt(
      a,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_aes_crypt _av_aes_crypt;

  /// Allocate an AVAESCTR context.
  ffi.Pointer<AVAESCTR> av_aes_ctr_alloc() {
    _av_aes_ctr_alloc ??=
        _dylib.lookupFunction<_c_av_aes_ctr_alloc, _dart_av_aes_ctr_alloc>(
            'av_aes_ctr_alloc');
    return _av_aes_ctr_alloc();
  }

  _dart_av_aes_ctr_alloc _av_aes_ctr_alloc;

  /// Initialize an AVAESCTR context.
  /// @param key encryption key, must have a length of AES_CTR_KEY_SIZE
  int av_aes_ctr_init(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> key,
  ) {
    _av_aes_ctr_init ??=
        _dylib.lookupFunction<_c_av_aes_ctr_init, _dart_av_aes_ctr_init>(
            'av_aes_ctr_init');
    return _av_aes_ctr_init(
      a,
      key,
    );
  }

  _dart_av_aes_ctr_init _av_aes_ctr_init;

  /// Release an AVAESCTR context.
  void av_aes_ctr_free(
    ffi.Pointer<AVAESCTR> a,
  ) {
    _av_aes_ctr_free ??=
        _dylib.lookupFunction<_c_av_aes_ctr_free, _dart_av_aes_ctr_free>(
            'av_aes_ctr_free');
    return _av_aes_ctr_free(
      a,
    );
  }

  _dart_av_aes_ctr_free _av_aes_ctr_free;

  /// Process a buffer using a previously initialized context.
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param size the size of src and dst
  void av_aes_ctr_crypt(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int size,
  ) {
    _av_aes_ctr_crypt ??=
        _dylib.lookupFunction<_c_av_aes_ctr_crypt, _dart_av_aes_ctr_crypt>(
            'av_aes_ctr_crypt');
    return _av_aes_ctr_crypt(
      a,
      dst,
      src,
      size,
    );
  }

  _dart_av_aes_ctr_crypt _av_aes_ctr_crypt;

  /// Get the current iv
  ffi.Pointer<ffi.Uint8> av_aes_ctr_get_iv(
    ffi.Pointer<AVAESCTR> a,
  ) {
    _av_aes_ctr_get_iv ??=
        _dylib.lookupFunction<_c_av_aes_ctr_get_iv, _dart_av_aes_ctr_get_iv>(
            'av_aes_ctr_get_iv');
    return _av_aes_ctr_get_iv(
      a,
    );
  }

  _dart_av_aes_ctr_get_iv _av_aes_ctr_get_iv;

  /// Generate a random iv
  void av_aes_ctr_set_random_iv(
    ffi.Pointer<AVAESCTR> a,
  ) {
    _av_aes_ctr_set_random_iv ??= _dylib.lookupFunction<
        _c_av_aes_ctr_set_random_iv,
        _dart_av_aes_ctr_set_random_iv>('av_aes_ctr_set_random_iv');
    return _av_aes_ctr_set_random_iv(
      a,
    );
  }

  _dart_av_aes_ctr_set_random_iv _av_aes_ctr_set_random_iv;

  /// Forcefully change the 8-byte iv
  void av_aes_ctr_set_iv(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> iv,
  ) {
    _av_aes_ctr_set_iv ??=
        _dylib.lookupFunction<_c_av_aes_ctr_set_iv, _dart_av_aes_ctr_set_iv>(
            'av_aes_ctr_set_iv');
    return _av_aes_ctr_set_iv(
      a,
      iv,
    );
  }

  _dart_av_aes_ctr_set_iv _av_aes_ctr_set_iv;

  /// Forcefully change the "full" 16-byte iv, including the counter
  void av_aes_ctr_set_full_iv(
    ffi.Pointer<AVAESCTR> a,
    ffi.Pointer<ffi.Uint8> iv,
  ) {
    _av_aes_ctr_set_full_iv ??= _dylib.lookupFunction<_c_av_aes_ctr_set_full_iv,
        _dart_av_aes_ctr_set_full_iv>('av_aes_ctr_set_full_iv');
    return _av_aes_ctr_set_full_iv(
      a,
      iv,
    );
  }

  _dart_av_aes_ctr_set_full_iv _av_aes_ctr_set_full_iv;

  /// Increment the top 64 bit of the iv (performed after each frame)
  void av_aes_ctr_increment_iv(
    ffi.Pointer<AVAESCTR> a,
  ) {
    _av_aes_ctr_increment_iv ??= _dylib.lookupFunction<
        _c_av_aes_ctr_increment_iv,
        _dart_av_aes_ctr_increment_iv>('av_aes_ctr_increment_iv');
    return _av_aes_ctr_increment_iv(
      a,
    );
  }

  _dart_av_aes_ctr_increment_iv _av_aes_ctr_increment_iv;

  /// Initialize an AVFifoBuffer.
  /// @param size of FIFO
  /// @return AVFifoBuffer or NULL in case of memory allocation failure
  ffi.Pointer<AVFifoBuffer> av_fifo_alloc(
    int size,
  ) {
    _av_fifo_alloc ??= _dylib
        .lookupFunction<_c_av_fifo_alloc, _dart_av_fifo_alloc>('av_fifo_alloc');
    return _av_fifo_alloc(
      size,
    );
  }

  _dart_av_fifo_alloc _av_fifo_alloc;

  /// Initialize an AVFifoBuffer.
  /// @param nmemb number of elements
  /// @param size  size of the single element
  /// @return AVFifoBuffer or NULL in case of memory allocation failure
  ffi.Pointer<AVFifoBuffer> av_fifo_alloc_array(
    int nmemb,
    int size,
  ) {
    _av_fifo_alloc_array ??= _dylib.lookupFunction<_c_av_fifo_alloc_array,
        _dart_av_fifo_alloc_array>('av_fifo_alloc_array');
    return _av_fifo_alloc_array(
      nmemb,
      size,
    );
  }

  _dart_av_fifo_alloc_array _av_fifo_alloc_array;

  /// Free an AVFifoBuffer.
  /// @param f AVFifoBuffer to free
  void av_fifo_free(
    ffi.Pointer<AVFifoBuffer> f,
  ) {
    _av_fifo_free ??= _dylib
        .lookupFunction<_c_av_fifo_free, _dart_av_fifo_free>('av_fifo_free');
    return _av_fifo_free(
      f,
    );
  }

  _dart_av_fifo_free _av_fifo_free;

  /// Free an AVFifoBuffer and reset pointer to NULL.
  /// @param f AVFifoBuffer to free
  void av_fifo_freep(
    ffi.Pointer<ffi.Pointer<AVFifoBuffer>> f,
  ) {
    _av_fifo_freep ??= _dylib
        .lookupFunction<_c_av_fifo_freep, _dart_av_fifo_freep>('av_fifo_freep');
    return _av_fifo_freep(
      f,
    );
  }

  _dart_av_fifo_freep _av_fifo_freep;

  /// Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.
  /// @param f AVFifoBuffer to reset
  void av_fifo_reset(
    ffi.Pointer<AVFifoBuffer> f,
  ) {
    _av_fifo_reset ??= _dylib
        .lookupFunction<_c_av_fifo_reset, _dart_av_fifo_reset>('av_fifo_reset');
    return _av_fifo_reset(
      f,
    );
  }

  _dart_av_fifo_reset _av_fifo_reset;

  /// Return the amount of data in bytes in the AVFifoBuffer, that is the
  /// amount of data you can read from it.
  /// @param f AVFifoBuffer to read from
  /// @return size
  int av_fifo_size(
    ffi.Pointer<AVFifoBuffer> f,
  ) {
    _av_fifo_size ??= _dylib
        .lookupFunction<_c_av_fifo_size, _dart_av_fifo_size>('av_fifo_size');
    return _av_fifo_size(
      f,
    );
  }

  _dart_av_fifo_size _av_fifo_size;

  /// Return the amount of space in bytes in the AVFifoBuffer, that is the
  /// amount of data you can write into it.
  /// @param f AVFifoBuffer to write into
  /// @return size
  int av_fifo_space(
    ffi.Pointer<AVFifoBuffer> f,
  ) {
    _av_fifo_space ??= _dylib
        .lookupFunction<_c_av_fifo_space, _dart_av_fifo_space>('av_fifo_space');
    return _av_fifo_space(
      f,
    );
  }

  _dart_av_fifo_space _av_fifo_space;

  /// Feed data at specific position from an AVFifoBuffer to a user-supplied callback.
  /// Similar as av_fifo_gereric_read but without discarding data.
  /// @param f AVFifoBuffer to read from
  /// @param offset offset from current read position
  /// @param buf_size number of bytes to read
  /// @param func generic read function
  /// @param dest data destination
  int av_fifo_generic_peek_at(
    ffi.Pointer<AVFifoBuffer> f,
    ffi.Pointer<ffi.Void> dest,
    int offset,
    int buf_size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_94>> func,
  ) {
    _av_fifo_generic_peek_at ??= _dylib.lookupFunction<
        _c_av_fifo_generic_peek_at,
        _dart_av_fifo_generic_peek_at>('av_fifo_generic_peek_at');
    return _av_fifo_generic_peek_at(
      f,
      dest,
      offset,
      buf_size,
      func,
    );
  }

  _dart_av_fifo_generic_peek_at _av_fifo_generic_peek_at;

  /// Feed data from an AVFifoBuffer to a user-supplied callback.
  /// Similar as av_fifo_gereric_read but without discarding data.
  /// @param f AVFifoBuffer to read from
  /// @param buf_size number of bytes to read
  /// @param func generic read function
  /// @param dest data destination
  int av_fifo_generic_peek(
    ffi.Pointer<AVFifoBuffer> f,
    ffi.Pointer<ffi.Void> dest,
    int buf_size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_95>> func,
  ) {
    _av_fifo_generic_peek ??= _dylib.lookupFunction<_c_av_fifo_generic_peek,
        _dart_av_fifo_generic_peek>('av_fifo_generic_peek');
    return _av_fifo_generic_peek(
      f,
      dest,
      buf_size,
      func,
    );
  }

  _dart_av_fifo_generic_peek _av_fifo_generic_peek;

  /// Feed data from an AVFifoBuffer to a user-supplied callback.
  /// @param f AVFifoBuffer to read from
  /// @param buf_size number of bytes to read
  /// @param func generic read function
  /// @param dest data destination
  int av_fifo_generic_read(
    ffi.Pointer<AVFifoBuffer> f,
    ffi.Pointer<ffi.Void> dest,
    int buf_size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_96>> func,
  ) {
    _av_fifo_generic_read ??= _dylib.lookupFunction<_c_av_fifo_generic_read,
        _dart_av_fifo_generic_read>('av_fifo_generic_read');
    return _av_fifo_generic_read(
      f,
      dest,
      buf_size,
      func,
    );
  }

  _dart_av_fifo_generic_read _av_fifo_generic_read;

  /// Feed data from a user-supplied callback to an AVFifoBuffer.
  /// @param f AVFifoBuffer to write to
  /// @param src data source; non-const since it may be used as a
  /// modifiable context by the function defined in func
  /// @param size number of bytes to write
  /// @param func generic write function; the first parameter is src,
  /// the second is dest_buf, the third is dest_buf_size.
  /// func must return the number of bytes written to dest_buf, or <= 0 to
  /// indicate no more data available to write.
  /// If func is NULL, src is interpreted as a simple byte array for source data.
  /// @return the number of bytes written to the FIFO
  int av_fifo_generic_write(
    ffi.Pointer<AVFifoBuffer> f,
    ffi.Pointer<ffi.Void> src,
    int size,
    ffi.Pointer<ffi.NativeFunction<_typedefC_97>> func,
  ) {
    _av_fifo_generic_write ??= _dylib.lookupFunction<_c_av_fifo_generic_write,
        _dart_av_fifo_generic_write>('av_fifo_generic_write');
    return _av_fifo_generic_write(
      f,
      src,
      size,
      func,
    );
  }

  _dart_av_fifo_generic_write _av_fifo_generic_write;

  /// Resize an AVFifoBuffer.
  /// In case of reallocation failure, the old FIFO is kept unchanged.
  ///
  /// @param f AVFifoBuffer to resize
  /// @param size new AVFifoBuffer size in bytes
  /// @return <0 for failure, >=0 otherwise
  int av_fifo_realloc2(
    ffi.Pointer<AVFifoBuffer> f,
    int size,
  ) {
    _av_fifo_realloc2 ??=
        _dylib.lookupFunction<_c_av_fifo_realloc2, _dart_av_fifo_realloc2>(
            'av_fifo_realloc2');
    return _av_fifo_realloc2(
      f,
      size,
    );
  }

  _dart_av_fifo_realloc2 _av_fifo_realloc2;

  /// Enlarge an AVFifoBuffer.
  /// In case of reallocation failure, the old FIFO is kept unchanged.
  /// The new fifo size may be larger than the requested size.
  ///
  /// @param f AVFifoBuffer to resize
  /// @param additional_space the amount of space in bytes to allocate in addition to av_fifo_size()
  /// @return <0 for failure, >=0 otherwise
  int av_fifo_grow(
    ffi.Pointer<AVFifoBuffer> f,
    int additional_space,
  ) {
    _av_fifo_grow ??= _dylib
        .lookupFunction<_c_av_fifo_grow, _dart_av_fifo_grow>('av_fifo_grow');
    return _av_fifo_grow(
      f,
      additional_space,
    );
  }

  _dart_av_fifo_grow _av_fifo_grow;

  /// Read and discard the specified amount of data from an AVFifoBuffer.
  /// @param f AVFifoBuffer to read from
  /// @param size amount of data to read in bytes
  void av_fifo_drain(
    ffi.Pointer<AVFifoBuffer> f,
    int size,
  ) {
    _av_fifo_drain ??= _dylib
        .lookupFunction<_c_av_fifo_drain, _dart_av_fifo_drain>('av_fifo_drain');
    return _av_fifo_drain(
      f,
      size,
    );
  }

  _dart_av_fifo_drain _av_fifo_drain;

  /// Return a pointer to the data stored in a FIFO buffer at a certain offset.
  /// The FIFO buffer is not modified.
  ///
  /// @param f    AVFifoBuffer to peek at, f must be non-NULL
  /// @param offs an offset in bytes, its absolute value must be less
  /// than the used buffer size or the returned pointer will
  /// point outside to the buffer data.
  /// The used buffer size can be checked with av_fifo_size().
  ffi.Pointer<ffi.Uint8> av_fifo_peek2(
    ffi.Pointer<AVFifoBuffer> f,
    int offs,
  ) {
    _av_fifo_peek2 ??= _dylib
        .lookupFunction<_c_av_fifo_peek2, _dart_av_fifo_peek2>('av_fifo_peek2');
    return _av_fifo_peek2(
      f,
      offs,
    );
  }

  _dart_av_fifo_peek2 _av_fifo_peek2;

  /// Free an AVAudioFifo.
  ///
  /// @param af  AVAudioFifo to free
  void av_audio_fifo_free(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    _av_audio_fifo_free ??=
        _dylib.lookupFunction<_c_av_audio_fifo_free, _dart_av_audio_fifo_free>(
            'av_audio_fifo_free');
    return _av_audio_fifo_free(
      af,
    );
  }

  _dart_av_audio_fifo_free _av_audio_fifo_free;

  /// Allocate an AVAudioFifo.
  ///
  /// @param sample_fmt  sample format
  /// @param channels    number of channels
  /// @param nb_samples  initial allocation size, in samples
  /// @return            newly allocated AVAudioFifo, or NULL on error
  ffi.Pointer<AVAudioFifo> av_audio_fifo_alloc(
    int sample_fmt,
    int channels,
    int nb_samples,
  ) {
    _av_audio_fifo_alloc ??= _dylib.lookupFunction<_c_av_audio_fifo_alloc,
        _dart_av_audio_fifo_alloc>('av_audio_fifo_alloc');
    return _av_audio_fifo_alloc(
      sample_fmt,
      channels,
      nb_samples,
    );
  }

  _dart_av_audio_fifo_alloc _av_audio_fifo_alloc;

  /// Reallocate an AVAudioFifo.
  ///
  /// @param af          AVAudioFifo to reallocate
  /// @param nb_samples  new allocation size, in samples
  /// @return            0 if OK, or negative AVERROR code on failure
  int av_audio_fifo_realloc(
    ffi.Pointer<AVAudioFifo> af,
    int nb_samples,
  ) {
    _av_audio_fifo_realloc ??= _dylib.lookupFunction<_c_av_audio_fifo_realloc,
        _dart_av_audio_fifo_realloc>('av_audio_fifo_realloc');
    return _av_audio_fifo_realloc(
      af,
      nb_samples,
    );
  }

  _dart_av_audio_fifo_realloc _av_audio_fifo_realloc;

  /// Write data to an AVAudioFifo.
  ///
  /// The AVAudioFifo will be reallocated automatically if the available space
  /// is less than nb_samples.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to write to
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to write
  /// @return            number of samples actually written, or negative AVERROR
  /// code on failure. If successful, the number of samples
  /// actually written will always be nb_samples.
  int av_audio_fifo_write(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
  ) {
    _av_audio_fifo_write ??= _dylib.lookupFunction<_c_av_audio_fifo_write,
        _dart_av_audio_fifo_write>('av_audio_fifo_write');
    return _av_audio_fifo_write(
      af,
      data,
      nb_samples,
    );
  }

  _dart_av_audio_fifo_write _av_audio_fifo_write;

  /// Peek data from an AVAudioFifo.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to read from
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to peek
  /// @return            number of samples actually peek, or negative AVERROR code
  /// on failure. The number of samples actually peek will not
  /// be greater than nb_samples, and will only be less than
  /// nb_samples if av_audio_fifo_size is less than nb_samples.
  int av_audio_fifo_peek(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
  ) {
    _av_audio_fifo_peek ??=
        _dylib.lookupFunction<_c_av_audio_fifo_peek, _dart_av_audio_fifo_peek>(
            'av_audio_fifo_peek');
    return _av_audio_fifo_peek(
      af,
      data,
      nb_samples,
    );
  }

  _dart_av_audio_fifo_peek _av_audio_fifo_peek;

  /// Peek data from an AVAudioFifo.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to read from
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to peek
  /// @param offset      offset from current read position
  /// @return            number of samples actually peek, or negative AVERROR code
  /// on failure. The number of samples actually peek will not
  /// be greater than nb_samples, and will only be less than
  /// nb_samples if av_audio_fifo_size is less than nb_samples.
  int av_audio_fifo_peek_at(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
    int offset,
  ) {
    _av_audio_fifo_peek_at ??= _dylib.lookupFunction<_c_av_audio_fifo_peek_at,
        _dart_av_audio_fifo_peek_at>('av_audio_fifo_peek_at');
    return _av_audio_fifo_peek_at(
      af,
      data,
      nb_samples,
      offset,
    );
  }

  _dart_av_audio_fifo_peek_at _av_audio_fifo_peek_at;

  /// Read data from an AVAudioFifo.
  ///
  /// @see enum AVSampleFormat
  /// The documentation for AVSampleFormat describes the data layout.
  ///
  /// @param af          AVAudioFifo to read from
  /// @param data        audio data plane pointers
  /// @param nb_samples  number of samples to read
  /// @return            number of samples actually read, or negative AVERROR code
  /// on failure. The number of samples actually read will not
  /// be greater than nb_samples, and will only be less than
  /// nb_samples if av_audio_fifo_size is less than nb_samples.
  int av_audio_fifo_read(
    ffi.Pointer<AVAudioFifo> af,
    ffi.Pointer<ffi.Pointer<ffi.Void>> data,
    int nb_samples,
  ) {
    _av_audio_fifo_read ??=
        _dylib.lookupFunction<_c_av_audio_fifo_read, _dart_av_audio_fifo_read>(
            'av_audio_fifo_read');
    return _av_audio_fifo_read(
      af,
      data,
      nb_samples,
    );
  }

  _dart_av_audio_fifo_read _av_audio_fifo_read;

  /// Drain data from an AVAudioFifo.
  ///
  /// Removes the data without reading it.
  ///
  /// @param af          AVAudioFifo to drain
  /// @param nb_samples  number of samples to drain
  /// @return            0 if OK, or negative AVERROR code on failure
  int av_audio_fifo_drain(
    ffi.Pointer<AVAudioFifo> af,
    int nb_samples,
  ) {
    _av_audio_fifo_drain ??= _dylib.lookupFunction<_c_av_audio_fifo_drain,
        _dart_av_audio_fifo_drain>('av_audio_fifo_drain');
    return _av_audio_fifo_drain(
      af,
      nb_samples,
    );
  }

  _dart_av_audio_fifo_drain _av_audio_fifo_drain;

  /// Reset the AVAudioFifo buffer.
  ///
  /// This empties all data in the buffer.
  ///
  /// @param af  AVAudioFifo to reset
  void av_audio_fifo_reset(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    _av_audio_fifo_reset ??= _dylib.lookupFunction<_c_av_audio_fifo_reset,
        _dart_av_audio_fifo_reset>('av_audio_fifo_reset');
    return _av_audio_fifo_reset(
      af,
    );
  }

  _dart_av_audio_fifo_reset _av_audio_fifo_reset;

  /// Get the current number of samples in the AVAudioFifo available for reading.
  ///
  /// @param af  the AVAudioFifo to query
  /// @return    number of samples available for reading
  int av_audio_fifo_size(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    _av_audio_fifo_size ??=
        _dylib.lookupFunction<_c_av_audio_fifo_size, _dart_av_audio_fifo_size>(
            'av_audio_fifo_size');
    return _av_audio_fifo_size(
      af,
    );
  }

  _dart_av_audio_fifo_size _av_audio_fifo_size;

  /// Get the current number of samples in the AVAudioFifo available for writing.
  ///
  /// @param af  the AVAudioFifo to query
  /// @return    number of samples available for writing
  int av_audio_fifo_space(
    ffi.Pointer<AVAudioFifo> af,
  ) {
    _av_audio_fifo_space ??= _dylib.lookupFunction<_c_av_audio_fifo_space,
        _dart_av_audio_fifo_space>('av_audio_fifo_space');
    return _av_audio_fifo_space(
      af,
    );
  }

  _dart_av_audio_fifo_space _av_audio_fifo_space;

  /// Assert that floating point operations can be executed.
  ///
  /// This will av_assert0() that the cpu is not in MMX state on X86
  void av_assert0_fpu() {
    _av_assert0_fpu ??=
        _dylib.lookupFunction<_c_av_assert0_fpu, _dart_av_assert0_fpu>(
            'av_assert0_fpu');
    return _av_assert0_fpu();
  }

  _dart_av_assert0_fpu _av_assert0_fpu;

  /// Return non-zero if pfx is a prefix of str. If it is, *ptr is set to
  /// the address of the first character in str after the prefix.
  ///
  /// @param str input string
  /// @param pfx prefix to test
  /// @param ptr updated if the prefix is matched inside str
  /// @return non-zero if the prefix matches, zero otherwise
  int av_strstart(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Int8> pfx,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> ptr,
  ) {
    _av_strstart ??=
        _dylib.lookupFunction<_c_av_strstart, _dart_av_strstart>('av_strstart');
    return _av_strstart(
      str,
      pfx,
      ptr,
    );
  }

  _dart_av_strstart _av_strstart;

  /// Return non-zero if pfx is a prefix of str independent of case. If
  /// it is, *ptr is set to the address of the first character in str
  /// after the prefix.
  ///
  /// @param str input string
  /// @param pfx prefix to test
  /// @param ptr updated if the prefix is matched inside str
  /// @return non-zero if the prefix matches, zero otherwise
  int av_stristart(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Int8> pfx,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> ptr,
  ) {
    _av_stristart ??= _dylib
        .lookupFunction<_c_av_stristart, _dart_av_stristart>('av_stristart');
    return _av_stristart(
      str,
      pfx,
      ptr,
    );
  }

  _dart_av_stristart _av_stristart;

  /// Locate the first case-independent occurrence in the string haystack
  /// of the string needle.  A zero-length string needle is considered to
  /// match at the start of haystack.
  ///
  /// This function is a case-insensitive version of the standard strstr().
  ///
  /// @param haystack string to search in
  /// @param needle   string to search for
  /// @return         pointer to the located match within haystack
  /// or a null pointer if no match
  ffi.Pointer<ffi.Int8> av_stristr(
    ffi.Pointer<ffi.Int8> haystack,
    ffi.Pointer<ffi.Int8> needle,
  ) {
    _av_stristr ??=
        _dylib.lookupFunction<_c_av_stristr, _dart_av_stristr>('av_stristr');
    return _av_stristr(
      haystack,
      needle,
    );
  }

  _dart_av_stristr _av_stristr;

  /// Locate the first occurrence of the string needle in the string haystack
  /// where not more than hay_length characters are searched. A zero-length
  /// string needle is considered to match at the start of haystack.
  ///
  /// This function is a length-limited version of the standard strstr().
  ///
  /// @param haystack   string to search in
  /// @param needle     string to search for
  /// @param hay_length length of string to search in
  /// @return           pointer to the located match within haystack
  /// or a null pointer if no match
  ffi.Pointer<ffi.Int8> av_strnstr(
    ffi.Pointer<ffi.Int8> haystack,
    ffi.Pointer<ffi.Int8> needle,
    int hay_length,
  ) {
    _av_strnstr ??=
        _dylib.lookupFunction<_c_av_strnstr, _dart_av_strnstr>('av_strnstr');
    return _av_strnstr(
      haystack,
      needle,
      hay_length,
    );
  }

  _dart_av_strnstr _av_strnstr;

  /// Copy the string src to dst, but no more than size - 1 bytes, and
  /// null-terminate dst.
  ///
  /// This function is the same as BSD strlcpy().
  ///
  /// @param dst destination buffer
  /// @param src source string
  /// @param size size of destination buffer
  /// @return the length of src
  ///
  /// @warning since the return value is the length of src, src absolutely
  /// _must_ be a properly 0-terminated string, otherwise this will read beyond
  /// the end of the buffer and possibly crash.
  int av_strlcpy(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int size,
  ) {
    _av_strlcpy ??=
        _dylib.lookupFunction<_c_av_strlcpy, _dart_av_strlcpy>('av_strlcpy');
    return _av_strlcpy(
      dst,
      src,
      size,
    );
  }

  _dart_av_strlcpy _av_strlcpy;

  /// Append the string src to the string dst, but to a total length of
  /// no more than size - 1 bytes, and null-terminate dst.
  ///
  /// This function is similar to BSD strlcat(), but differs when
  /// size <= strlen(dst).
  ///
  /// @param dst destination buffer
  /// @param src source string
  /// @param size size of destination buffer
  /// @return the total length of src and dst
  ///
  /// @warning since the return value use the length of src and dst, these
  /// absolutely _must_ be a properly 0-terminated strings, otherwise this
  /// will read beyond the end of the buffer and possibly crash.
  int av_strlcat(
    ffi.Pointer<ffi.Int8> dst,
    ffi.Pointer<ffi.Int8> src,
    int size,
  ) {
    _av_strlcat ??=
        _dylib.lookupFunction<_c_av_strlcat, _dart_av_strlcat>('av_strlcat');
    return _av_strlcat(
      dst,
      src,
      size,
    );
  }

  _dart_av_strlcat _av_strlcat;

  /// Append output to a string, according to a format. Never write out of
  /// the destination buffer, and always put a terminating 0 within
  /// the buffer.
  /// @param dst destination buffer (string to which the output is
  /// appended)
  /// @param size total size of the destination buffer
  /// @param fmt printf-compatible format string, specifying how the
  /// following parameters are used
  /// @return the length of the string that would have been generated
  /// if enough space had been available
  int av_strlcatf(
    ffi.Pointer<ffi.Int8> dst,
    int size,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    _av_strlcatf ??=
        _dylib.lookupFunction<_c_av_strlcatf, _dart_av_strlcatf>('av_strlcatf');
    return _av_strlcatf(
      dst,
      size,
      fmt,
    );
  }

  _dart_av_strlcatf _av_strlcatf;

  /// Get the count of continuous non zero chars starting from the beginning.
  ///
  /// @param len maximum number of characters to check in the string, that
  /// is the maximum value which is returned by the function
  int av_strnlen(
    ffi.Pointer<ffi.Int8> s,
    int len,
  ) {
    _av_strnlen ??=
        _dylib.lookupFunction<_c_av_strnlen, _dart_av_strnlen>('av_strnlen');
    return _av_strnlen(
      s,
      len,
    );
  }

  _dart_av_strnlen _av_strnlen;

  /// Print arguments following specified format into a large enough auto
  /// allocated buffer. It is similar to GNU asprintf().
  /// @param fmt printf-compatible format string, specifying how the
  /// following parameters are used.
  /// @return the allocated string
  /// @note You have to free the string yourself with av_free().
  ffi.Pointer<ffi.Int8> av_asprintf(
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    _av_asprintf ??=
        _dylib.lookupFunction<_c_av_asprintf, _dart_av_asprintf>('av_asprintf');
    return _av_asprintf(
      fmt,
    );
  }

  _dart_av_asprintf _av_asprintf;

  /// Convert a number to an av_malloced string.
  /// @deprecated  use av_asprintf() with "%f" or a more specific format
  ffi.Pointer<ffi.Int8> av_d2str(
    double d,
  ) {
    _av_d2str ??=
        _dylib.lookupFunction<_c_av_d2str, _dart_av_d2str>('av_d2str');
    return _av_d2str(
      d,
    );
  }

  _dart_av_d2str _av_d2str;

  /// Unescape the given string until a non escaped terminating char,
  /// and return the token corresponding to the unescaped string.
  ///
  /// The normal \ and ' escaping is supported. Leading and trailing
  /// whitespaces are removed, unless they are escaped with '\' or are
  /// enclosed between ''.
  ///
  /// @param buf the buffer to parse, buf will be updated to point to the
  /// terminating char
  /// @param term a 0-terminated list of terminating chars
  /// @return the malloced unescaped string, which must be av_freed by
  /// the user, NULL in case of allocation failure
  ffi.Pointer<ffi.Int8> av_get_token(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> buf,
    ffi.Pointer<ffi.Int8> term,
  ) {
    _av_get_token ??= _dylib
        .lookupFunction<_c_av_get_token, _dart_av_get_token>('av_get_token');
    return _av_get_token(
      buf,
      term,
    );
  }

  _dart_av_get_token _av_get_token;

  /// Split the string into several tokens which can be accessed by
  /// successive calls to av_strtok().
  ///
  /// A token is defined as a sequence of characters not belonging to the
  /// set specified in delim.
  ///
  /// On the first call to av_strtok(), s should point to the string to
  /// parse, and the value of saveptr is ignored. In subsequent calls, s
  /// should be NULL, and saveptr should be unchanged since the previous
  /// call.
  ///
  /// This function is similar to strtok_r() defined in POSIX.1.
  ///
  /// @param s the string to parse, may be NULL
  /// @param delim 0-terminated list of token delimiters, must be non-NULL
  /// @param saveptr user-provided pointer which points to stored
  /// information necessary for av_strtok() to continue scanning the same
  /// string. saveptr is updated to point to the next character after the
  /// first delimiter found, or to NULL if the string was terminated
  /// @return the found token, or NULL when no token is found
  ffi.Pointer<ffi.Int8> av_strtok(
    ffi.Pointer<ffi.Int8> s,
    ffi.Pointer<ffi.Int8> delim,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> saveptr,
  ) {
    _av_strtok ??=
        _dylib.lookupFunction<_c_av_strtok, _dart_av_strtok>('av_strtok');
    return _av_strtok(
      s,
      delim,
      saveptr,
    );
  }

  _dart_av_strtok _av_strtok;

  /// Locale-independent conversion of ASCII isdigit.
  int av_isdigit(
    int c,
  ) {
    _av_isdigit ??=
        _dylib.lookupFunction<_c_av_isdigit, _dart_av_isdigit>('av_isdigit');
    return _av_isdigit(
      c,
    );
  }

  _dart_av_isdigit _av_isdigit;

  /// Locale-independent conversion of ASCII isgraph.
  int av_isgraph(
    int c,
  ) {
    _av_isgraph ??=
        _dylib.lookupFunction<_c_av_isgraph, _dart_av_isgraph>('av_isgraph');
    return _av_isgraph(
      c,
    );
  }

  _dart_av_isgraph _av_isgraph;

  /// Locale-independent conversion of ASCII isspace.
  int av_isspace(
    int c,
  ) {
    _av_isspace ??=
        _dylib.lookupFunction<_c_av_isspace, _dart_av_isspace>('av_isspace');
    return _av_isspace(
      c,
    );
  }

  _dart_av_isspace _av_isspace;

  /// Locale-independent conversion of ASCII characters to uppercase.
  int av_toupper(
    int c,
  ) {
    _av_toupper ??=
        _dylib.lookupFunction<_c_av_toupper, _dart_av_toupper>('av_toupper');
    return _av_toupper(
      c,
    );
  }

  _dart_av_toupper _av_toupper;

  /// Locale-independent conversion of ASCII characters to lowercase.
  int av_tolower(
    int c,
  ) {
    _av_tolower ??=
        _dylib.lookupFunction<_c_av_tolower, _dart_av_tolower>('av_tolower');
    return _av_tolower(
      c,
    );
  }

  _dart_av_tolower _av_tolower;

  /// Locale-independent conversion of ASCII isxdigit.
  int av_isxdigit(
    int c,
  ) {
    _av_isxdigit ??=
        _dylib.lookupFunction<_c_av_isxdigit, _dart_av_isxdigit>('av_isxdigit');
    return _av_isxdigit(
      c,
    );
  }

  _dart_av_isxdigit _av_isxdigit;

  /// Locale-independent case-insensitive compare.
  /// @note This means only ASCII-range characters are case-insensitive
  int av_strcasecmp(
    ffi.Pointer<ffi.Int8> a,
    ffi.Pointer<ffi.Int8> b,
  ) {
    _av_strcasecmp ??= _dylib
        .lookupFunction<_c_av_strcasecmp, _dart_av_strcasecmp>('av_strcasecmp');
    return _av_strcasecmp(
      a,
      b,
    );
  }

  _dart_av_strcasecmp _av_strcasecmp;

  /// Locale-independent case-insensitive compare.
  /// @note This means only ASCII-range characters are case-insensitive
  int av_strncasecmp(
    ffi.Pointer<ffi.Int8> a,
    ffi.Pointer<ffi.Int8> b,
    int n,
  ) {
    _av_strncasecmp ??=
        _dylib.lookupFunction<_c_av_strncasecmp, _dart_av_strncasecmp>(
            'av_strncasecmp');
    return _av_strncasecmp(
      a,
      b,
      n,
    );
  }

  _dart_av_strncasecmp _av_strncasecmp;

  /// Locale-independent strings replace.
  /// @note This means only ASCII-range characters are replace
  ffi.Pointer<ffi.Int8> av_strireplace(
    ffi.Pointer<ffi.Int8> str,
    ffi.Pointer<ffi.Int8> from,
    ffi.Pointer<ffi.Int8> to,
  ) {
    _av_strireplace ??=
        _dylib.lookupFunction<_c_av_strireplace, _dart_av_strireplace>(
            'av_strireplace');
    return _av_strireplace(
      str,
      from,
      to,
    );
  }

  _dart_av_strireplace _av_strireplace;

  /// Thread safe basename.
  /// @param path the string to parse, on DOS both \ and / are considered separators.
  /// @return pointer to the basename substring.
  /// If path does not contain a slash, the function returns a copy of path.
  /// If path is a NULL pointer or points to an empty string, a pointer
  /// to a string "." is returned.
  ffi.Pointer<ffi.Int8> av_basename(
    ffi.Pointer<ffi.Int8> path,
  ) {
    _av_basename ??=
        _dylib.lookupFunction<_c_av_basename, _dart_av_basename>('av_basename');
    return _av_basename(
      path,
    );
  }

  _dart_av_basename _av_basename;

  /// Thread safe dirname.
  /// @param path the string to parse, on DOS both \ and / are considered separators.
  /// @return A pointer to a string that's the parent directory of path.
  /// If path is a NULL pointer or points to an empty string, a pointer
  /// to a string "." is returned.
  /// @note the function may modify the contents of the path, so copies should be passed.
  ffi.Pointer<ffi.Int8> av_dirname(
    ffi.Pointer<ffi.Int8> path,
  ) {
    _av_dirname ??=
        _dylib.lookupFunction<_c_av_dirname, _dart_av_dirname>('av_dirname');
    return _av_dirname(
      path,
    );
  }

  _dart_av_dirname _av_dirname;

  /// Match instances of a name in a comma-separated list of names.
  /// List entries are checked from the start to the end of the names list,
  /// the first match ends further processing. If an entry prefixed with '-'
  /// matches, then 0 is returned. The "ALL" list entry is considered to
  /// match all names.
  ///
  /// @param name  Name to look for.
  /// @param names List of names.
  /// @return 1 on match, 0 otherwise.
  int av_match_name(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> names,
  ) {
    _av_match_name ??= _dylib
        .lookupFunction<_c_av_match_name, _dart_av_match_name>('av_match_name');
    return _av_match_name(
      name,
      names,
    );
  }

  _dart_av_match_name _av_match_name;

  /// Append path component to the existing path.
  /// Path separator '/' is placed between when needed.
  /// Resulting string have to be freed with av_free().
  /// @param path      base path
  /// @param component component to be appended
  /// @return new path or NULL on error.
  ffi.Pointer<ffi.Int8> av_append_path_component(
    ffi.Pointer<ffi.Int8> path,
    ffi.Pointer<ffi.Int8> component,
  ) {
    _av_append_path_component ??= _dylib.lookupFunction<
        _c_av_append_path_component,
        _dart_av_append_path_component>('av_append_path_component');
    return _av_append_path_component(
      path,
      component,
    );
  }

  _dart_av_append_path_component _av_append_path_component;

  /// Escape string in src, and put the escaped string in an allocated
  /// string in *dst, which must be freed with av_free().
  ///
  /// @param dst           pointer where an allocated string is put
  /// @param src           string to escape, must be non-NULL
  /// @param special_chars string containing the special characters which
  /// need to be escaped, can be NULL
  /// @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
  /// Any unknown value for mode will be considered equivalent to
  /// AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
  /// notice.
  /// @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_ macros
  /// @return the length of the allocated string, or a negative error code in case of error
  /// @see av_bprint_escape()
  int av_escape(
    ffi.Pointer<ffi.Pointer<ffi.Int8>> dst,
    ffi.Pointer<ffi.Int8> src,
    ffi.Pointer<ffi.Int8> special_chars,
    int mode,
    int flags,
  ) {
    _av_escape ??=
        _dylib.lookupFunction<_c_av_escape, _dart_av_escape>('av_escape');
    return _av_escape(
      dst,
      src,
      special_chars,
      mode,
      flags,
    );
  }

  _dart_av_escape _av_escape;

  /// Read and decode a single UTF-8 code point (character) from the
  /// buffer in *buf, and update *buf to point to the next byte to
  /// decode.
  ///
  /// In case of an invalid byte sequence, the pointer will be updated to
  /// the next byte after the invalid sequence and the function will
  /// return an error code.
  ///
  /// Depending on the specified flags, the function will also fail in
  /// case the decoded code point does not belong to a valid range.
  ///
  /// @note For speed-relevant code a carefully implemented use of
  /// GET_UTF8() may be preferred.
  ///
  /// @param codep   pointer used to return the parsed code in case of success.
  /// The value in *codep is set even in case the range check fails.
  /// @param bufp    pointer to the address the first byte of the sequence
  /// to decode, updated by the function to point to the
  /// byte next after the decoded sequence
  /// @param buf_end pointer to the end of the buffer, points to the next
  /// byte past the last in the buffer. This is used to
  /// avoid buffer overreads (in case of an unfinished
  /// UTF-8 sequence towards the end of the buffer).
  /// @param flags   a collection of AV_UTF8_FLAG_* flags
  /// @return >= 0 in case a sequence was successfully read, a negative
  /// value in case of invalid sequence
  int av_utf8_decode(
    ffi.Pointer<ffi.Int32> codep,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufp,
    ffi.Pointer<ffi.Uint8> buf_end,
    int flags,
  ) {
    _av_utf8_decode ??=
        _dylib.lookupFunction<_c_av_utf8_decode, _dart_av_utf8_decode>(
            'av_utf8_decode');
    return _av_utf8_decode(
      codep,
      bufp,
      buf_end,
      flags,
    );
  }

  _dart_av_utf8_decode _av_utf8_decode;

  /// Check if a name is in a list.
  /// @returns 0 if not found, or the 1 based index where it has been found in the
  /// list.
  int av_match_list(
    ffi.Pointer<ffi.Int8> name,
    ffi.Pointer<ffi.Int8> list,
    int separator,
  ) {
    _av_match_list ??= _dylib
        .lookupFunction<_c_av_match_list, _dart_av_match_list>('av_match_list');
    return _av_match_list(
      name,
      list,
      separator,
    );
  }

  _dart_av_match_list _av_match_list;

  /// See libc sscanf manual for more information.
  /// Locale-independent sscanf implementation.
  int av_sscanf(
    ffi.Pointer<ffi.Int8> string,
    ffi.Pointer<ffi.Int8> format,
  ) {
    _av_sscanf ??=
        _dylib.lookupFunction<_c_av_sscanf, _dart_av_sscanf>('av_sscanf');
    return _av_sscanf(
      string,
      format,
    );
  }

  _dart_av_sscanf _av_sscanf;

  /// Decode a base64-encoded string.
  ///
  /// @param out      buffer for decoded data
  /// @param in       null-terminated input string
  /// @param out_size size in bytes of the out buffer, must be at
  /// least 3/4 of the length of in, that is AV_BASE64_DECODE_SIZE(strlen(in))
  /// @return         number of bytes written, or a negative value in case of
  /// invalid input
  int av_base64_decode(
    ffi.Pointer<ffi.Uint8> out,
    ffi.Pointer<ffi.Int8> in_1,
    int out_size,
  ) {
    _av_base64_decode ??=
        _dylib.lookupFunction<_c_av_base64_decode, _dart_av_base64_decode>(
            'av_base64_decode');
    return _av_base64_decode(
      out,
      in_1,
      out_size,
    );
  }

  _dart_av_base64_decode _av_base64_decode;

  /// Encode data to base64 and null-terminate.
  ///
  /// @param out      buffer for encoded data
  /// @param out_size size in bytes of the out buffer (including the
  /// null terminator), must be at least AV_BASE64_SIZE(in_size)
  /// @param in       input buffer containing the data to encode
  /// @param in_size  size in bytes of the in buffer
  /// @return         out or NULL in case of error
  ffi.Pointer<ffi.Int8> av_base64_encode(
    ffi.Pointer<ffi.Int8> out,
    int out_size,
    ffi.Pointer<ffi.Uint8> in_1,
    int in_size,
  ) {
    _av_base64_encode ??=
        _dylib.lookupFunction<_c_av_base64_encode, _dart_av_base64_encode>(
            'av_base64_encode');
    return _av_base64_encode(
      out,
      out_size,
      in_1,
      in_size,
    );
  }

  _dart_av_base64_encode _av_base64_encode;

  /// Allocate an AVBlowfish context.
  ffi.Pointer<AVBlowfish> av_blowfish_alloc() {
    _av_blowfish_alloc ??=
        _dylib.lookupFunction<_c_av_blowfish_alloc, _dart_av_blowfish_alloc>(
            'av_blowfish_alloc');
    return _av_blowfish_alloc();
  }

  _dart_av_blowfish_alloc _av_blowfish_alloc;

  /// Initialize an AVBlowfish context.
  ///
  /// @param ctx an AVBlowfish context
  /// @param key a key
  /// @param key_len length of the key
  void av_blowfish_init(
    ffi.Pointer<AVBlowfish> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_len,
  ) {
    _av_blowfish_init ??=
        _dylib.lookupFunction<_c_av_blowfish_init, _dart_av_blowfish_init>(
            'av_blowfish_init');
    return _av_blowfish_init(
      ctx,
      key,
      key_len,
    );
  }

  _dart_av_blowfish_init _av_blowfish_init;

  /// Encrypt or decrypt a buffer using a previously initialized context.
  ///
  /// @param ctx an AVBlowfish context
  /// @param xl left four bytes halves of input to be encrypted
  /// @param xr right four bytes halves of input to be encrypted
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_blowfish_crypt_ecb(
    ffi.Pointer<AVBlowfish> ctx,
    ffi.Pointer<ffi.Uint32> xl,
    ffi.Pointer<ffi.Uint32> xr,
    int decrypt,
  ) {
    _av_blowfish_crypt_ecb ??= _dylib.lookupFunction<_c_av_blowfish_crypt_ecb,
        _dart_av_blowfish_crypt_ecb>('av_blowfish_crypt_ecb');
    return _av_blowfish_crypt_ecb(
      ctx,
      xl,
      xr,
      decrypt,
    );
  }

  _dart_av_blowfish_crypt_ecb _av_blowfish_crypt_ecb;

  /// Encrypt or decrypt a buffer using a previously initialized context.
  ///
  /// @param ctx an AVBlowfish context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_blowfish_crypt(
    ffi.Pointer<AVBlowfish> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_blowfish_crypt ??=
        _dylib.lookupFunction<_c_av_blowfish_crypt, _dart_av_blowfish_crypt>(
            'av_blowfish_crypt');
    return _av_blowfish_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_blowfish_crypt _av_blowfish_crypt;

  /// Init a print buffer.
  ///
  /// @param buf        buffer to init
  /// @param size_init  initial size (including the final 0)
  /// @param size_max   maximum size;
  /// 0 means do not write anything, just count the length;
  /// 1 is replaced by the maximum value for automatic storage;
  /// any large value means that the internal buffer will be
  /// reallocated as needed up to that limit; -1 is converted to
  /// UINT_MAX, the largest limit possible.
  /// Check also AV_BPRINT_SIZE_* macros.
  void av_bprint_init(
    ffi.Pointer<AVBPrint> buf,
    int size_init,
    int size_max,
  ) {
    _av_bprint_init ??=
        _dylib.lookupFunction<_c_av_bprint_init, _dart_av_bprint_init>(
            'av_bprint_init');
    return _av_bprint_init(
      buf,
      size_init,
      size_max,
    );
  }

  _dart_av_bprint_init _av_bprint_init;

  /// Init a print buffer using a pre-existing buffer.
  ///
  /// The buffer will not be reallocated.
  ///
  /// @param buf     buffer structure to init
  /// @param buffer  byte buffer to use for the string data
  /// @param size    size of buffer
  void av_bprint_init_for_buffer(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Int8> buffer,
    int size,
  ) {
    _av_bprint_init_for_buffer ??= _dylib.lookupFunction<
        _c_av_bprint_init_for_buffer,
        _dart_av_bprint_init_for_buffer>('av_bprint_init_for_buffer');
    return _av_bprint_init_for_buffer(
      buf,
      buffer,
      size,
    );
  }

  _dart_av_bprint_init_for_buffer _av_bprint_init_for_buffer;

  /// Append a formatted string to a print buffer.
  void av_bprintf(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Int8> fmt,
  ) {
    _av_bprintf ??=
        _dylib.lookupFunction<_c_av_bprintf, _dart_av_bprintf>('av_bprintf');
    return _av_bprintf(
      buf,
      fmt,
    );
  }

  _dart_av_bprintf _av_bprintf;

  /// Append a formatted string to a print buffer.
  void av_vbprintf(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<__va_list_tag> vl_arg,
  ) {
    _av_vbprintf ??=
        _dylib.lookupFunction<_c_av_vbprintf, _dart_av_vbprintf>('av_vbprintf');
    return _av_vbprintf(
      buf,
      fmt,
      vl_arg,
    );
  }

  _dart_av_vbprintf _av_vbprintf;

  /// Append char c n times to a print buffer.
  void av_bprint_chars(
    ffi.Pointer<AVBPrint> buf,
    int c,
    int n,
  ) {
    _av_bprint_chars ??=
        _dylib.lookupFunction<_c_av_bprint_chars, _dart_av_bprint_chars>(
            'av_bprint_chars');
    return _av_bprint_chars(
      buf,
      c,
      n,
    );
  }

  _dart_av_bprint_chars _av_bprint_chars;

  /// Append data to a print buffer.
  ///
  /// param buf  bprint buffer to use
  /// param data pointer to data
  /// param size size of data
  void av_bprint_append_data(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Int8> data,
    int size,
  ) {
    _av_bprint_append_data ??= _dylib.lookupFunction<_c_av_bprint_append_data,
        _dart_av_bprint_append_data>('av_bprint_append_data');
    return _av_bprint_append_data(
      buf,
      data,
      size,
    );
  }

  _dart_av_bprint_append_data _av_bprint_append_data;

  /// Append a formatted date and time to a print buffer.
  ///
  /// param buf  bprint buffer to use
  /// param fmt  date and time format string, see strftime()
  /// param tm   broken-down time structure to translate
  ///
  /// @note due to poor design of the standard strftime function, it may
  /// produce poor results if the format string expands to a very long text and
  /// the bprint buffer is near the limit stated by the size_max option.
  void av_bprint_strftime(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<tm> tm,
  ) {
    _av_bprint_strftime ??=
        _dylib.lookupFunction<_c_av_bprint_strftime, _dart_av_bprint_strftime>(
            'av_bprint_strftime');
    return _av_bprint_strftime(
      buf,
      fmt,
      tm,
    );
  }

  _dart_av_bprint_strftime _av_bprint_strftime;

  /// Allocate bytes in the buffer for external use.
  ///
  /// @param[in]  buf          buffer structure
  /// @param[in]  size         required size
  /// @param[out] mem          pointer to the memory area
  /// @param[out] actual_size  size of the memory area after allocation;
  /// can be larger or smaller than size
  void av_bprint_get_buffer(
    ffi.Pointer<AVBPrint> buf,
    int size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> mem,
    ffi.Pointer<ffi.Uint32> actual_size,
  ) {
    _av_bprint_get_buffer ??= _dylib.lookupFunction<_c_av_bprint_get_buffer,
        _dart_av_bprint_get_buffer>('av_bprint_get_buffer');
    return _av_bprint_get_buffer(
      buf,
      size,
      mem,
      actual_size,
    );
  }

  _dart_av_bprint_get_buffer _av_bprint_get_buffer;

  /// Reset the string to "" but keep internal allocated data.
  void av_bprint_clear(
    ffi.Pointer<AVBPrint> buf,
  ) {
    _av_bprint_clear ??=
        _dylib.lookupFunction<_c_av_bprint_clear, _dart_av_bprint_clear>(
            'av_bprint_clear');
    return _av_bprint_clear(
      buf,
    );
  }

  _dart_av_bprint_clear _av_bprint_clear;

  /// Test if the print buffer is complete (not truncated).
  ///
  /// It may have been truncated due to a memory allocation failure
  /// or the size_max limit (compare size and size_max if necessary).
  int av_bprint_is_complete(
    ffi.Pointer<AVBPrint> buf,
  ) {
    _av_bprint_is_complete ??= _dylib.lookupFunction<_c_av_bprint_is_complete,
        _dart_av_bprint_is_complete>('av_bprint_is_complete');
    return _av_bprint_is_complete(
      buf,
    );
  }

  _dart_av_bprint_is_complete _av_bprint_is_complete;

  /// Finalize a print buffer.
  ///
  /// The print buffer can no longer be used afterwards,
  /// but the len and size fields are still valid.
  ///
  /// @arg[out] ret_str  if not NULL, used to return a permanent copy of the
  /// buffer contents, or NULL if memory allocation fails;
  /// if NULL, the buffer is discarded and freed
  /// @return  0 for success or error code (probably AVERROR(ENOMEM))
  int av_bprint_finalize(
    ffi.Pointer<AVBPrint> buf,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> ret_str,
  ) {
    _av_bprint_finalize ??=
        _dylib.lookupFunction<_c_av_bprint_finalize, _dart_av_bprint_finalize>(
            'av_bprint_finalize');
    return _av_bprint_finalize(
      buf,
      ret_str,
    );
  }

  _dart_av_bprint_finalize _av_bprint_finalize;

  /// Escape the content in src and append it to dstbuf.
  ///
  /// @param dstbuf        already inited destination bprint buffer
  /// @param src           string containing the text to escape
  /// @param special_chars string containing the special characters which
  /// need to be escaped, can be NULL
  /// @param mode          escape mode to employ, see AV_ESCAPE_MODE_* macros.
  /// Any unknown value for mode will be considered equivalent to
  /// AV_ESCAPE_MODE_BACKSLASH, but this behaviour can change without
  /// notice.
  /// @param flags         flags which control how to escape, see AV_ESCAPE_FLAG_* macros
  void av_bprint_escape(
    ffi.Pointer<AVBPrint> dstbuf,
    ffi.Pointer<ffi.Int8> src,
    ffi.Pointer<ffi.Int8> special_chars,
    int mode,
    int flags,
  ) {
    _av_bprint_escape ??=
        _dylib.lookupFunction<_c_av_bprint_escape, _dart_av_bprint_escape>(
            'av_bprint_escape');
    return _av_bprint_escape(
      dstbuf,
      src,
      special_chars,
      mode,
      flags,
    );
  }

  _dart_av_bprint_escape _av_bprint_escape;

  int av_bswap16(
    int x,
  ) {
    _av_bswap16 ??=
        _dylib.lookupFunction<_c_av_bswap16, _dart_av_bswap16>('av_bswap16');
    return _av_bswap16(
      x,
    );
  }

  _dart_av_bswap16 _av_bswap16;

  int av_bswap32(
    int x,
  ) {
    _av_bswap32 ??=
        _dylib.lookupFunction<_c_av_bswap32, _dart_av_bswap32>('av_bswap32');
    return _av_bswap32(
      x,
    );
  }

  _dart_av_bswap32 _av_bswap32;

  int av_bswap64(
    int x,
  ) {
    _av_bswap64 ??=
        _dylib.lookupFunction<_c_av_bswap64, _dart_av_bswap64>('av_bswap64');
    return _av_bswap64(
      x,
    );
  }

  _dart_av_bswap64 _av_bswap64;

  /// Allocate an AVCAMELLIA context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVCAMELLIA> av_camellia_alloc() {
    _av_camellia_alloc ??=
        _dylib.lookupFunction<_c_av_camellia_alloc, _dart_av_camellia_alloc>(
            'av_camellia_alloc');
    return _av_camellia_alloc();
  }

  _dart_av_camellia_alloc _av_camellia_alloc;

  /// Initialize an AVCAMELLIA context.
  ///
  /// @param ctx an AVCAMELLIA context
  /// @param key a key of 16, 24, 32 bytes used for encryption/decryption
  /// @param key_bits number of keybits: possible are 128, 192, 256
  int av_camellia_init(
    ffi.Pointer<AVCAMELLIA> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
  ) {
    _av_camellia_init ??=
        _dylib.lookupFunction<_c_av_camellia_init, _dart_av_camellia_init>(
            'av_camellia_init');
    return _av_camellia_init(
      ctx,
      key,
      key_bits,
    );
  }

  _dart_av_camellia_init _av_camellia_init;

  /// Encrypt or decrypt a buffer using a previously initialized context
  ///
  /// @param ctx an AVCAMELLIA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 16 byte blocks
  /// @paran iv initialization vector for CBC mode, NULL for ECB mode
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_camellia_crypt(
    ffi.Pointer<AVCAMELLIA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_camellia_crypt ??=
        _dylib.lookupFunction<_c_av_camellia_crypt, _dart_av_camellia_crypt>(
            'av_camellia_crypt');
    return _av_camellia_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_camellia_crypt _av_camellia_crypt;

  /// Allocate an AVCAST5 context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVCAST5> av_cast5_alloc() {
    _av_cast5_alloc ??=
        _dylib.lookupFunction<_c_av_cast5_alloc, _dart_av_cast5_alloc>(
            'av_cast5_alloc');
    return _av_cast5_alloc();
  }

  _dart_av_cast5_alloc _av_cast5_alloc;

  /// Initialize an AVCAST5 context.
  ///
  /// @param ctx an AVCAST5 context
  /// @param key a key of 5,6,...16 bytes used for encryption/decryption
  /// @param key_bits number of keybits: possible are 40,48,...,128
  /// @return 0 on success, less than 0 on failure
  int av_cast5_init(
    ffi.Pointer<AVCAST5> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
  ) {
    _av_cast5_init ??= _dylib
        .lookupFunction<_c_av_cast5_init, _dart_av_cast5_init>('av_cast5_init');
    return _av_cast5_init(
      ctx,
      key,
      key_bits,
    );
  }

  _dart_av_cast5_init _av_cast5_init;

  /// Encrypt or decrypt a buffer using a previously initialized context, ECB mode only
  ///
  /// @param ctx an AVCAST5 context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_cast5_crypt(
    ffi.Pointer<AVCAST5> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    int decrypt,
  ) {
    _av_cast5_crypt ??=
        _dylib.lookupFunction<_c_av_cast5_crypt, _dart_av_cast5_crypt>(
            'av_cast5_crypt');
    return _av_cast5_crypt(
      ctx,
      dst,
      src,
      count,
      decrypt,
    );
  }

  _dart_av_cast5_crypt _av_cast5_crypt;

  /// Encrypt or decrypt a buffer using a previously initialized context
  ///
  /// @param ctx an AVCAST5 context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, NULL for ECB mode
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_cast5_crypt2(
    ffi.Pointer<AVCAST5> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_cast5_crypt2 ??=
        _dylib.lookupFunction<_c_av_cast5_crypt2, _dart_av_cast5_crypt2>(
            'av_cast5_crypt2');
    return _av_cast5_crypt2(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_cast5_crypt2 _av_cast5_crypt2;

  /// Initialize a CRC table.
  /// @param ctx must be an array of size sizeof(AVCRC)*257 or sizeof(AVCRC)*1024
  /// @param le If 1, the lowest bit represents the coefficient for the highest
  /// exponent of the corresponding polynomial (both for poly and
  /// actual CRC).
  /// If 0, you must swap the CRC parameter and the result of av_crc
  /// if you need the standard representation (can be simplified in
  /// most cases to e.g. bswap16):
  /// av_bswap32(crc << (32-bits))
  /// @param bits number of bits for the CRC
  /// @param poly generator polynomial without the x**bits coefficient, in the
  /// representation as specified by le
  /// @param ctx_size size of ctx in bytes
  /// @return <0 on failure
  int av_crc_init(
    ffi.Pointer<ffi.Uint32> ctx,
    int le,
    int bits,
    int poly,
    int ctx_size,
  ) {
    _av_crc_init ??=
        _dylib.lookupFunction<_c_av_crc_init, _dart_av_crc_init>('av_crc_init');
    return _av_crc_init(
      ctx,
      le,
      bits,
      poly,
      ctx_size,
    );
  }

  _dart_av_crc_init _av_crc_init;

  /// Get an initialized standard CRC table.
  /// @param crc_id ID of a standard CRC
  /// @return a pointer to the CRC table or NULL on failure
  ffi.Pointer<ffi.Uint32> av_crc_get_table(
    int crc_id,
  ) {
    _av_crc_get_table ??=
        _dylib.lookupFunction<_c_av_crc_get_table, _dart_av_crc_get_table>(
            'av_crc_get_table');
    return _av_crc_get_table(
      crc_id,
    );
  }

  _dart_av_crc_get_table _av_crc_get_table;

  /// Calculate the CRC of a block.
  /// @param crc CRC of previous blocks if any or initial value for CRC
  /// @return CRC updated with the data from the given block
  ///
  /// @see av_crc_init() "le" parameter
  int av_crc(
    ffi.Pointer<ffi.Uint32> ctx,
    int crc,
    ffi.Pointer<ffi.Uint8> buffer,
    int length,
  ) {
    _av_crc ??= _dylib.lookupFunction<_c_av_crc, _dart_av_crc>('av_crc');
    return _av_crc(
      ctx,
      crc,
      buffer,
      length,
    );
  }

  _dart_av_crc _av_crc;

  /// Allocate an AVDES context.
  ffi.Pointer<AVDES> av_des_alloc() {
    _av_des_alloc ??= _dylib
        .lookupFunction<_c_av_des_alloc, _dart_av_des_alloc>('av_des_alloc');
    return _av_des_alloc();
  }

  _dart_av_des_alloc _av_des_alloc;

  /// @brief Initializes an AVDES context.
  ///
  /// @param key_bits must be 64 or 192
  /// @param decrypt 0 for encryption/CBC-MAC, 1 for decryption
  /// @return zero on success, negative value otherwise
  int av_des_init(
    ffi.Pointer<AVDES> d,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
    int decrypt,
  ) {
    _av_des_init ??=
        _dylib.lookupFunction<_c_av_des_init, _dart_av_des_init>('av_des_init');
    return _av_des_init(
      d,
      key,
      key_bits,
      decrypt,
    );
  }

  _dart_av_des_init _av_des_init;

  /// @brief Encrypts / decrypts using the DES algorithm.
  ///
  /// @param count number of 8 byte blocks
  /// @param dst destination array, can be equal to src, must be 8-byte aligned
  /// @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used,
  /// must be 8-byte aligned
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_des_crypt(
    ffi.Pointer<AVDES> d,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_des_crypt ??= _dylib
        .lookupFunction<_c_av_des_crypt, _dart_av_des_crypt>('av_des_crypt');
    return _av_des_crypt(
      d,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_des_crypt _av_des_crypt;

  /// @brief Calculates CBC-MAC using the DES algorithm.
  ///
  /// @param count number of 8 byte blocks
  /// @param dst destination array, can be equal to src, must be 8-byte aligned
  /// @param src source array, can be equal to dst, must be 8-byte aligned, may be NULL
  void av_des_mac(
    ffi.Pointer<AVDES> d,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
  ) {
    _av_des_mac ??=
        _dylib.lookupFunction<_c_av_des_mac, _dart_av_des_mac>('av_des_mac');
    return _av_des_mac(
      d,
      dst,
      src,
      count,
    );
  }

  _dart_av_des_mac _av_des_mac;

  /// Extract the rotation component of the transformation matrix.
  ///
  /// @param matrix the transformation matrix
  /// @return the angle (in degrees) by which the transformation rotates the frame
  /// counterclockwise. The angle will be in range [-180.0, 180.0],
  /// or NaN if the matrix is singular.
  ///
  /// @note floating point numbers are inherently inexact, so callers are
  /// recommended to round the return value to nearest integer before use.
  double av_display_rotation_get(
    ffi.Pointer<ffi.Int32> matrix,
  ) {
    _av_display_rotation_get ??= _dylib.lookupFunction<
        _c_av_display_rotation_get,
        _dart_av_display_rotation_get>('av_display_rotation_get');
    return _av_display_rotation_get(
      matrix,
    );
  }

  _dart_av_display_rotation_get _av_display_rotation_get;

  /// Initialize a transformation matrix describing a pure counterclockwise
  /// rotation by the specified angle (in degrees).
  ///
  /// @param matrix an allocated transformation matrix (will be fully overwritten
  /// by this function)
  /// @param angle rotation angle in degrees.
  void av_display_rotation_set(
    ffi.Pointer<ffi.Int32> matrix,
    double angle,
  ) {
    _av_display_rotation_set ??= _dylib.lookupFunction<
        _c_av_display_rotation_set,
        _dart_av_display_rotation_set>('av_display_rotation_set');
    return _av_display_rotation_set(
      matrix,
      angle,
    );
  }

  _dart_av_display_rotation_set _av_display_rotation_set;

  /// Flip the input matrix horizontally and/or vertically.
  ///
  /// @param matrix an allocated transformation matrix
  /// @param hflip whether the matrix should be flipped horizontally
  /// @param vflip whether the matrix should be flipped vertically
  void av_display_matrix_flip(
    ffi.Pointer<ffi.Int32> matrix,
    int hflip,
    int vflip,
  ) {
    _av_display_matrix_flip ??= _dylib.lookupFunction<_c_av_display_matrix_flip,
        _dart_av_display_matrix_flip>('av_display_matrix_flip');
    return _av_display_matrix_flip(
      matrix,
      hflip,
      vflip,
    );
  }

  _dart_av_display_matrix_flip _av_display_matrix_flip;

  /// Allocate a AVDOVIDecoderConfigurationRecord structure and initialize its
  /// fields to default values.
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVDOVIDecoderConfigurationRecord> av_dovi_alloc(
    ffi.Pointer<ffi.Uint64> size,
  ) {
    _av_dovi_alloc ??= _dylib
        .lookupFunction<_c_av_dovi_alloc, _dart_av_dovi_alloc>('av_dovi_alloc');
    return _av_dovi_alloc(
      size,
    );
  }

  _dart_av_dovi_alloc _av_dovi_alloc;

  /// Get a frame's AV_FRAME_DATA_DOWNMIX_INFO side data for editing.
  ///
  /// If the side data is absent, it is created and added to the frame.
  ///
  /// @param frame the frame for which the side data is to be obtained or created
  ///
  /// @return the AVDownmixInfo structure to be edited by the caller, or NULL if
  /// the structure cannot be allocated.
  ffi.Pointer<AVDownmixInfo> av_downmix_info_update_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_downmix_info_update_side_data ??= _dylib.lookupFunction<
            _c_av_downmix_info_update_side_data,
            _dart_av_downmix_info_update_side_data>(
        'av_downmix_info_update_side_data');
    return _av_downmix_info_update_side_data(
      frame,
    );
  }

  _dart_av_downmix_info_update_side_data _av_downmix_info_update_side_data;

  /// Allocates an AVEncryptionInfo structure and sub-pointers to hold the given
  /// number of subsamples.  This will allocate pointers for the key ID, IV,
  /// and subsample entries, set the size members, and zero-initialize the rest.
  ///
  /// @param subsample_count The number of subsamples.
  /// @param key_id_size The number of bytes in the key ID, should be 16.
  /// @param iv_size The number of bytes in the IV, should be 16.
  ///
  /// @return The new AVEncryptionInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInfo> av_encryption_info_alloc(
    int subsample_count,
    int key_id_size,
    int iv_size,
  ) {
    _av_encryption_info_alloc ??= _dylib.lookupFunction<
        _c_av_encryption_info_alloc,
        _dart_av_encryption_info_alloc>('av_encryption_info_alloc');
    return _av_encryption_info_alloc(
      subsample_count,
      key_id_size,
      iv_size,
    );
  }

  _dart_av_encryption_info_alloc _av_encryption_info_alloc;

  /// Allocates an AVEncryptionInfo structure with a copy of the given data.
  /// @return The new AVEncryptionInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInfo> av_encryption_info_clone(
    ffi.Pointer<AVEncryptionInfo> info,
  ) {
    _av_encryption_info_clone ??= _dylib.lookupFunction<
        _c_av_encryption_info_clone,
        _dart_av_encryption_info_clone>('av_encryption_info_clone');
    return _av_encryption_info_clone(
      info,
    );
  }

  _dart_av_encryption_info_clone _av_encryption_info_clone;

  /// Frees the given encryption info object.  This MUST NOT be used to free the
  /// side-data data pointer, that should use normal side-data methods.
  void av_encryption_info_free(
    ffi.Pointer<AVEncryptionInfo> info,
  ) {
    _av_encryption_info_free ??= _dylib.lookupFunction<
        _c_av_encryption_info_free,
        _dart_av_encryption_info_free>('av_encryption_info_free');
    return _av_encryption_info_free(
      info,
    );
  }

  _dart_av_encryption_info_free _av_encryption_info_free;

  /// Creates a copy of the AVEncryptionInfo that is contained in the given side
  /// data.  The resulting object should be passed to av_encryption_info_free()
  /// when done.
  ///
  /// @return The new AVEncryptionInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInfo> av_encryption_info_get_side_data(
    ffi.Pointer<ffi.Uint8> side_data,
    int side_data_size,
  ) {
    _av_encryption_info_get_side_data ??= _dylib.lookupFunction<
            _c_av_encryption_info_get_side_data,
            _dart_av_encryption_info_get_side_data>(
        'av_encryption_info_get_side_data');
    return _av_encryption_info_get_side_data(
      side_data,
      side_data_size,
    );
  }

  _dart_av_encryption_info_get_side_data _av_encryption_info_get_side_data;

  /// Allocates and initializes side data that holds a copy of the given encryption
  /// info.  The resulting pointer should be either freed using av_free or given
  /// to av_packet_add_side_data().
  ///
  /// @return The new side-data pointer, or NULL.
  ffi.Pointer<ffi.Uint8> av_encryption_info_add_side_data(
    ffi.Pointer<AVEncryptionInfo> info,
    ffi.Pointer<ffi.Uint64> side_data_size,
  ) {
    _av_encryption_info_add_side_data ??= _dylib.lookupFunction<
            _c_av_encryption_info_add_side_data,
            _dart_av_encryption_info_add_side_data>(
        'av_encryption_info_add_side_data');
    return _av_encryption_info_add_side_data(
      info,
      side_data_size,
    );
  }

  _dart_av_encryption_info_add_side_data _av_encryption_info_add_side_data;

  /// Allocates an AVEncryptionInitInfo structure and sub-pointers to hold the
  /// given sizes.  This will allocate pointers and set all the fields.
  ///
  /// @return The new AVEncryptionInitInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInitInfo> av_encryption_init_info_alloc(
    int system_id_size,
    int num_key_ids,
    int key_id_size,
    int data_size,
  ) {
    _av_encryption_init_info_alloc ??= _dylib.lookupFunction<
        _c_av_encryption_init_info_alloc,
        _dart_av_encryption_init_info_alloc>('av_encryption_init_info_alloc');
    return _av_encryption_init_info_alloc(
      system_id_size,
      num_key_ids,
      key_id_size,
      data_size,
    );
  }

  _dart_av_encryption_init_info_alloc _av_encryption_init_info_alloc;

  /// Frees the given encryption init info object.  This MUST NOT be used to free
  /// the side-data data pointer, that should use normal side-data methods.
  void av_encryption_init_info_free(
    ffi.Pointer<AVEncryptionInitInfo> info,
  ) {
    _av_encryption_init_info_free ??= _dylib.lookupFunction<
        _c_av_encryption_init_info_free,
        _dart_av_encryption_init_info_free>('av_encryption_init_info_free');
    return _av_encryption_init_info_free(
      info,
    );
  }

  _dart_av_encryption_init_info_free _av_encryption_init_info_free;

  /// Creates a copy of the AVEncryptionInitInfo that is contained in the given
  /// side data.  The resulting object should be passed to
  /// av_encryption_init_info_free() when done.
  ///
  /// @return The new AVEncryptionInitInfo structure, or NULL on error.
  ffi.Pointer<AVEncryptionInitInfo> av_encryption_init_info_get_side_data(
    ffi.Pointer<ffi.Uint8> side_data,
    int side_data_size,
  ) {
    _av_encryption_init_info_get_side_data ??= _dylib.lookupFunction<
            _c_av_encryption_init_info_get_side_data,
            _dart_av_encryption_init_info_get_side_data>(
        'av_encryption_init_info_get_side_data');
    return _av_encryption_init_info_get_side_data(
      side_data,
      side_data_size,
    );
  }

  _dart_av_encryption_init_info_get_side_data
      _av_encryption_init_info_get_side_data;

  /// Allocates and initializes side data that holds a copy of the given encryption
  /// init info.  The resulting pointer should be either freed using av_free or
  /// given to av_packet_add_side_data().
  ///
  /// @return The new side-data pointer, or NULL.
  ffi.Pointer<ffi.Uint8> av_encryption_init_info_add_side_data(
    ffi.Pointer<AVEncryptionInitInfo> info,
    ffi.Pointer<ffi.Uint64> side_data_size,
  ) {
    _av_encryption_init_info_add_side_data ??= _dylib.lookupFunction<
            _c_av_encryption_init_info_add_side_data,
            _dart_av_encryption_init_info_add_side_data>(
        'av_encryption_init_info_add_side_data');
    return _av_encryption_init_info_add_side_data(
      info,
      side_data_size,
    );
  }

  _dart_av_encryption_init_info_add_side_data
      _av_encryption_init_info_add_side_data;

  /// Parse and evaluate an expression.
  /// Note, this is significantly slower than av_expr_eval().
  ///
  /// @param res a pointer to a double where is put the result value of
  /// the expression, or NAN in case of error
  /// @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
  /// @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
  /// @param const_values a zero terminated array of values for the identifiers from const_names
  /// @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
  /// @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
  /// @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  /// @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
  /// @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
  /// @param log_ctx parent logging context
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code otherwise
  int av_expr_parse_and_eval(
    ffi.Pointer<ffi.Double> res,
    ffi.Pointer<ffi.Int8> s,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> const_names,
    ffi.Pointer<ffi.Double> const_values,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> func1_names,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_98>>> funcs1,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> func2_names,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_99>>> funcs2,
    ffi.Pointer<ffi.Void> opaque,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_expr_parse_and_eval ??= _dylib.lookupFunction<_c_av_expr_parse_and_eval,
        _dart_av_expr_parse_and_eval>('av_expr_parse_and_eval');
    return _av_expr_parse_and_eval(
      res,
      s,
      const_names,
      const_values,
      func1_names,
      funcs1,
      func2_names,
      funcs2,
      opaque,
      log_offset,
      log_ctx,
    );
  }

  _dart_av_expr_parse_and_eval _av_expr_parse_and_eval;

  /// Parse an expression.
  ///
  /// @param expr a pointer where is put an AVExpr containing the parsed
  /// value in case of successful parsing, or NULL otherwise.
  /// The pointed to AVExpr must be freed with av_expr_free() by the user
  /// when it is not needed anymore.
  /// @param s expression as a zero terminated string, for example "1+2^3+5*5+sin(2/3)"
  /// @param const_names NULL terminated array of zero terminated strings of constant identifiers, for example {"PI", "E", 0}
  /// @param func1_names NULL terminated array of zero terminated strings of funcs1 identifiers
  /// @param funcs1 NULL terminated array of function pointers for functions which take 1 argument
  /// @param func2_names NULL terminated array of zero terminated strings of funcs2 identifiers
  /// @param funcs2 NULL terminated array of function pointers for functions which take 2 arguments
  /// @param log_ctx parent logging context
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code otherwise
  int av_expr_parse(
    ffi.Pointer<ffi.Pointer<AVExpr>> expr,
    ffi.Pointer<ffi.Int8> s,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> const_names,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> func1_names,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_100>>> funcs1,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> func2_names,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_101>>> funcs2,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_expr_parse ??= _dylib
        .lookupFunction<_c_av_expr_parse, _dart_av_expr_parse>('av_expr_parse');
    return _av_expr_parse(
      expr,
      s,
      const_names,
      func1_names,
      funcs1,
      func2_names,
      funcs2,
      log_offset,
      log_ctx,
    );
  }

  _dart_av_expr_parse _av_expr_parse;

  /// Evaluate a previously parsed expression.
  ///
  /// @param const_values a zero terminated array of values for the identifiers from av_expr_parse() const_names
  /// @param opaque a pointer which will be passed to all functions from funcs1 and funcs2
  /// @return the value of the expression
  double av_expr_eval(
    ffi.Pointer<AVExpr> e,
    ffi.Pointer<ffi.Double> const_values,
    ffi.Pointer<ffi.Void> opaque,
  ) {
    _av_expr_eval ??= _dylib
        .lookupFunction<_c_av_expr_eval, _dart_av_expr_eval>('av_expr_eval');
    return _av_expr_eval(
      e,
      const_values,
      opaque,
    );
  }

  _dart_av_expr_eval _av_expr_eval;

  /// Track the presence of variables and their number of occurrences in a parsed expression
  ///
  /// @param counter a zero-initialized array where the count of each variable will be stored
  /// @param size size of array
  /// @return 0 on success, a negative value indicates that no expression or array was passed
  /// or size was zero
  int av_expr_count_vars(
    ffi.Pointer<AVExpr> e,
    ffi.Pointer<ffi.Uint32> counter,
    int size,
  ) {
    _av_expr_count_vars ??=
        _dylib.lookupFunction<_c_av_expr_count_vars, _dart_av_expr_count_vars>(
            'av_expr_count_vars');
    return _av_expr_count_vars(
      e,
      counter,
      size,
    );
  }

  _dart_av_expr_count_vars _av_expr_count_vars;

  /// Track the presence of user provided functions and their number of occurrences
  /// in a parsed expression.
  ///
  /// @param counter a zero-initialized array where the count of each function will be stored
  /// if you passed 5 functions with 2 arguments to av_expr_parse()
  /// then for arg=2 this will use upto 5 entries.
  /// @param size size of array
  /// @param arg number of arguments the counted functions have
  /// @return 0 on success, a negative value indicates that no expression or array was passed
  /// or size was zero
  int av_expr_count_func(
    ffi.Pointer<AVExpr> e,
    ffi.Pointer<ffi.Uint32> counter,
    int size,
    int arg,
  ) {
    _av_expr_count_func ??=
        _dylib.lookupFunction<_c_av_expr_count_func, _dart_av_expr_count_func>(
            'av_expr_count_func');
    return _av_expr_count_func(
      e,
      counter,
      size,
      arg,
    );
  }

  _dart_av_expr_count_func _av_expr_count_func;

  /// Free a parsed expression previously created with av_expr_parse().
  void av_expr_free(
    ffi.Pointer<AVExpr> e,
  ) {
    _av_expr_free ??= _dylib
        .lookupFunction<_c_av_expr_free, _dart_av_expr_free>('av_expr_free');
    return _av_expr_free(
      e,
    );
  }

  _dart_av_expr_free _av_expr_free;

  /// Parse the string in numstr and return its value as a double. If
  /// the string is empty, contains only whitespaces, or does not contain
  /// an initial substring that has the expected syntax for a
  /// floating-point number, no conversion is performed. In this case,
  /// returns a value of zero and the value returned in tail is the value
  /// of numstr.
  ///
  /// @param numstr a string representing a number, may contain one of
  /// the International System number postfixes, for example 'K', 'M',
  /// 'G'. If 'i' is appended after the postfix, powers of 2 are used
  /// instead of powers of 10. The 'B' postfix multiplies the value by
  /// 8, and can be appended after another postfix or used alone. This
  /// allows using for example 'KB', 'MiB', 'G' and 'B' as postfix.
  /// @param tail if non-NULL puts here the pointer to the char next
  /// after the last parsed character
  double av_strtod(
    ffi.Pointer<ffi.Int8> numstr,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> tail,
  ) {
    _av_strtod ??=
        _dylib.lookupFunction<_c_av_strtod, _dart_av_strtod>('av_strtod');
    return _av_strtod(
      numstr,
      tail,
    );
  }

  _dart_av_strtod _av_strtod;

  /// Read the file with name filename, and put its content in a newly
  /// allocated buffer or map it with mmap() when available.
  /// In case of success set *bufptr to the read or mmapped buffer, and
  /// *size to the size in bytes of the buffer in *bufptr.
  /// Unlike mmap this function succeeds with zero sized files, in this
  /// case *bufptr will be set to NULL and *size will be set to 0.
  /// The returned buffer must be released with av_file_unmap().
  ///
  /// @param log_offset loglevel offset used for logging
  /// @param log_ctx context used for logging
  /// @return a non negative number in case of success, a negative value
  /// corresponding to an AVERROR error code in case of failure
  int av_file_map(
    ffi.Pointer<ffi.Int8> filename,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufptr,
    ffi.Pointer<ffi.Uint64> size,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_file_map ??=
        _dylib.lookupFunction<_c_av_file_map, _dart_av_file_map>('av_file_map');
    return _av_file_map(
      filename,
      bufptr,
      size,
      log_offset,
      log_ctx,
    );
  }

  _dart_av_file_map _av_file_map;

  /// Unmap or free the buffer bufptr created by av_file_map().
  ///
  /// @param size size in bytes of bufptr, must be the same as returned
  /// by av_file_map()
  void av_file_unmap(
    ffi.Pointer<ffi.Uint8> bufptr,
    int size,
  ) {
    _av_file_unmap ??= _dylib
        .lookupFunction<_c_av_file_unmap, _dart_av_file_unmap>('av_file_unmap');
    return _av_file_unmap(
      bufptr,
      size,
    );
  }

  _dart_av_file_unmap _av_file_unmap;

  /// Wrapper to work around the lack of mkstemp() on mingw.
  /// Also, tries to create file in /tmp first, if possible.
  /// *prefix can be a character constant; *filename will be allocated internally.
  /// @return file descriptor of opened file (or negative value corresponding to an
  /// AVERROR code on error)
  /// and opened file name in **filename.
  /// @note On very old libcs it is necessary to set a secure umask before
  /// calling this, av_tempfile() can't call umask itself as it is used in
  /// libraries and could interfere with the calling application.
  /// @deprecated as fd numbers cannot be passed saftely between libs on some platforms
  int av_tempfile(
    ffi.Pointer<ffi.Int8> prefix,
    ffi.Pointer<ffi.Pointer<ffi.Int8>> filename,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_tempfile ??=
        _dylib.lookupFunction<_c_av_tempfile, _dart_av_tempfile>('av_tempfile');
    return _av_tempfile(
      prefix,
      filename,
      log_offset,
      log_ctx,
    );
  }

  _dart_av_tempfile _av_tempfile;

  /// Allocate an AVFilmGrainParams structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  /// If size is not NULL it will be set to the number of bytes allocated.
  ///
  /// @return An AVFilmGrainParams filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVFilmGrainParams> av_film_grain_params_alloc(
    ffi.Pointer<ffi.Uint64> size,
  ) {
    _av_film_grain_params_alloc ??= _dylib.lookupFunction<
        _c_av_film_grain_params_alloc,
        _dart_av_film_grain_params_alloc>('av_film_grain_params_alloc');
    return _av_film_grain_params_alloc(
      size,
    );
  }

  _dart_av_film_grain_params_alloc _av_film_grain_params_alloc;

  /// Allocate a complete AVFilmGrainParams and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVFilmGrainParams structure to be filled by caller.
  ffi.Pointer<AVFilmGrainParams> av_film_grain_params_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_film_grain_params_create_side_data ??= _dylib.lookupFunction<
            _c_av_film_grain_params_create_side_data,
            _dart_av_film_grain_params_create_side_data>(
        'av_film_grain_params_create_side_data');
    return _av_film_grain_params_create_side_data(
      frame,
    );
  }

  _dart_av_film_grain_params_create_side_data
      _av_film_grain_params_create_side_data;

  /// Allocate a hash context for the algorithm specified by name.
  ///
  /// @return  >= 0 for success, a negative error code for failure
  ///
  /// @note The context is not initialized after a call to this function; you must
  /// call av_hash_init() to do so.
  int av_hash_alloc(
    ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_hash_alloc ??= _dylib
        .lookupFunction<_c_av_hash_alloc, _dart_av_hash_alloc>('av_hash_alloc');
    return _av_hash_alloc(
      ctx,
      name,
    );
  }

  _dart_av_hash_alloc _av_hash_alloc;

  /// Get the names of available hash algorithms.
  ///
  /// This function can be used to enumerate the algorithms.
  ///
  /// @param[in] i  Index of the hash algorithm, starting from 0
  /// @return       Pointer to a static string or `NULL` if `i` is out of range
  ffi.Pointer<ffi.Int8> av_hash_names(
    int i,
  ) {
    _av_hash_names ??= _dylib
        .lookupFunction<_c_av_hash_names, _dart_av_hash_names>('av_hash_names');
    return _av_hash_names(
      i,
    );
  }

  _dart_av_hash_names _av_hash_names;

  /// Get the name of the algorithm corresponding to the given hash context.
  ffi.Pointer<ffi.Int8> av_hash_get_name(
    ffi.Pointer<AVHashContext> ctx,
  ) {
    _av_hash_get_name ??=
        _dylib.lookupFunction<_c_av_hash_get_name, _dart_av_hash_get_name>(
            'av_hash_get_name');
    return _av_hash_get_name(
      ctx,
    );
  }

  _dart_av_hash_get_name _av_hash_get_name;

  /// Get the size of the resulting hash value in bytes.
  ///
  /// The maximum value this function will currently return is available as macro
  /// #AV_HASH_MAX_SIZE.
  ///
  /// @param[in]     ctx Hash context
  /// @return            Size of the hash value in bytes
  int av_hash_get_size(
    ffi.Pointer<AVHashContext> ctx,
  ) {
    _av_hash_get_size ??=
        _dylib.lookupFunction<_c_av_hash_get_size, _dart_av_hash_get_size>(
            'av_hash_get_size');
    return _av_hash_get_size(
      ctx,
    );
  }

  _dart_av_hash_get_size _av_hash_get_size;

  /// Initialize or reset a hash context.
  ///
  /// @param[in,out] ctx Hash context
  void av_hash_init(
    ffi.Pointer<AVHashContext> ctx,
  ) {
    _av_hash_init ??= _dylib
        .lookupFunction<_c_av_hash_init, _dart_av_hash_init>('av_hash_init');
    return _av_hash_init(
      ctx,
    );
  }

  _dart_av_hash_init _av_hash_init;

  void av_hash_update(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    _av_hash_update ??=
        _dylib.lookupFunction<_c_av_hash_update, _dart_av_hash_update>(
            'av_hash_update');
    return _av_hash_update(
      ctx,
      src,
      len,
    );
  }

  _dart_av_hash_update _av_hash_update;

  /// Finalize a hash context and compute the actual hash value.
  ///
  /// The minimum size of `dst` buffer is given by av_hash_get_size() or
  /// #AV_HASH_MAX_SIZE. The use of the latter macro is discouraged.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// @param[in,out] ctx Hash context
  /// @param[out]    dst Where the final hash value will be stored
  ///
  /// @see av_hash_final_bin() provides an alternative API
  void av_hash_final(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
  ) {
    _av_hash_final ??= _dylib
        .lookupFunction<_c_av_hash_final, _dart_av_hash_final>('av_hash_final');
    return _av_hash_final(
      ctx,
      dst,
    );
  }

  _dart_av_hash_final _av_hash_final;

  /// Finalize a hash context and store the actual hash value in a buffer.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// If `size` is smaller than the hash size (given by av_hash_get_size()), the
  /// hash is truncated; if size is larger, the buffer is padded with 0.
  ///
  /// @param[in,out] ctx  Hash context
  /// @param[out]    dst  Where the final hash value will be stored
  /// @param[in]     size Number of bytes to write to `dst`
  void av_hash_final_bin(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    int size,
  ) {
    _av_hash_final_bin ??=
        _dylib.lookupFunction<_c_av_hash_final_bin, _dart_av_hash_final_bin>(
            'av_hash_final_bin');
    return _av_hash_final_bin(
      ctx,
      dst,
      size,
    );
  }

  _dart_av_hash_final_bin _av_hash_final_bin;

  /// Finalize a hash context and store the hexadecimal representation of the
  /// actual hash value as a string.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// The string is always 0-terminated.
  ///
  /// If `size` is smaller than `2 * hash_size + 1`, where `hash_size` is the
  /// value returned by av_hash_get_size(), the string will be truncated.
  ///
  /// @param[in,out] ctx  Hash context
  /// @param[out]    dst  Where the string will be stored
  /// @param[in]     size Maximum number of bytes to write to `dst`
  void av_hash_final_hex(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    int size,
  ) {
    _av_hash_final_hex ??=
        _dylib.lookupFunction<_c_av_hash_final_hex, _dart_av_hash_final_hex>(
            'av_hash_final_hex');
    return _av_hash_final_hex(
      ctx,
      dst,
      size,
    );
  }

  _dart_av_hash_final_hex _av_hash_final_hex;

  /// Finalize a hash context and store the Base64 representation of the
  /// actual hash value as a string.
  ///
  /// It is not safe to update or finalize a hash context again, if it has already
  /// been finalized.
  ///
  /// The string is always 0-terminated.
  ///
  /// If `size` is smaller than AV_BASE64_SIZE(hash_size), where `hash_size` is
  /// the value returned by av_hash_get_size(), the string will be truncated.
  ///
  /// @param[in,out] ctx  Hash context
  /// @param[out]    dst  Where the final hash value will be stored
  /// @param[in]     size Maximum number of bytes to write to `dst`
  void av_hash_final_b64(
    ffi.Pointer<AVHashContext> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    int size,
  ) {
    _av_hash_final_b64 ??=
        _dylib.lookupFunction<_c_av_hash_final_b64, _dart_av_hash_final_b64>(
            'av_hash_final_b64');
    return _av_hash_final_b64(
      ctx,
      dst,
      size,
    );
  }

  _dart_av_hash_final_b64 _av_hash_final_b64;

  /// Free hash context and set hash context pointer to `NULL`.
  ///
  /// @param[in,out] ctx  Pointer to hash context
  void av_hash_freep(
    ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
  ) {
    _av_hash_freep ??= _dylib
        .lookupFunction<_c_av_hash_freep, _dart_av_hash_freep>('av_hash_freep');
    return _av_hash_freep(
      ctx,
    );
  }

  _dart_av_hash_freep _av_hash_freep;

  /// Allocate an AVDynamicHDRPlus structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVDynamicHDRPlus filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVDynamicHDRPlus> av_dynamic_hdr_plus_alloc(
    ffi.Pointer<ffi.Uint64> size,
  ) {
    _av_dynamic_hdr_plus_alloc ??= _dylib.lookupFunction<
        _c_av_dynamic_hdr_plus_alloc,
        _dart_av_dynamic_hdr_plus_alloc>('av_dynamic_hdr_plus_alloc');
    return _av_dynamic_hdr_plus_alloc(
      size,
    );
  }

  _dart_av_dynamic_hdr_plus_alloc _av_dynamic_hdr_plus_alloc;

  /// Allocate a complete AVDynamicHDRPlus and add it to the frame.
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVDynamicHDRPlus structure to be filled by caller or NULL
  /// on failure.
  ffi.Pointer<AVDynamicHDRPlus> av_dynamic_hdr_plus_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_dynamic_hdr_plus_create_side_data ??= _dylib.lookupFunction<
            _c_av_dynamic_hdr_plus_create_side_data,
            _dart_av_dynamic_hdr_plus_create_side_data>(
        'av_dynamic_hdr_plus_create_side_data');
    return _av_dynamic_hdr_plus_create_side_data(
      frame,
    );
  }

  _dart_av_dynamic_hdr_plus_create_side_data
      _av_dynamic_hdr_plus_create_side_data;

  /// Allocate an AVHMAC context.
  /// @param type The hash function used for the HMAC.
  ffi.Pointer<AVHMAC> av_hmac_alloc(
    int type,
  ) {
    _av_hmac_alloc ??= _dylib
        .lookupFunction<_c_av_hmac_alloc, _dart_av_hmac_alloc>('av_hmac_alloc');
    return _av_hmac_alloc(
      type,
    );
  }

  _dart_av_hmac_alloc _av_hmac_alloc;

  /// Free an AVHMAC context.
  /// @param ctx The context to free, may be NULL
  void av_hmac_free(
    ffi.Pointer<AVHMAC> ctx,
  ) {
    _av_hmac_free ??= _dylib
        .lookupFunction<_c_av_hmac_free, _dart_av_hmac_free>('av_hmac_free');
    return _av_hmac_free(
      ctx,
    );
  }

  _dart_av_hmac_free _av_hmac_free;

  /// Initialize an AVHMAC context with an authentication key.
  /// @param ctx    The HMAC context
  /// @param key    The authentication key
  /// @param keylen The length of the key, in bytes
  void av_hmac_init(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int keylen,
  ) {
    _av_hmac_init ??= _dylib
        .lookupFunction<_c_av_hmac_init, _dart_av_hmac_init>('av_hmac_init');
    return _av_hmac_init(
      ctx,
      key,
      keylen,
    );
  }

  _dart_av_hmac_init _av_hmac_init;

  /// Hash data with the HMAC.
  /// @param ctx  The HMAC context
  /// @param data The data to hash
  /// @param len  The length of the data, in bytes
  void av_hmac_update(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    _av_hmac_update ??=
        _dylib.lookupFunction<_c_av_hmac_update, _dart_av_hmac_update>(
            'av_hmac_update');
    return _av_hmac_update(
      ctx,
      data,
      len,
    );
  }

  _dart_av_hmac_update _av_hmac_update;

  /// Finish hashing and output the HMAC digest.
  /// @param ctx    The HMAC context
  /// @param out    The output buffer to write the digest into
  /// @param outlen The length of the out buffer, in bytes
  /// @return       The number of bytes written to out, or a negative error code.
  int av_hmac_final(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> out,
    int outlen,
  ) {
    _av_hmac_final ??= _dylib
        .lookupFunction<_c_av_hmac_final, _dart_av_hmac_final>('av_hmac_final');
    return _av_hmac_final(
      ctx,
      out,
      outlen,
    );
  }

  _dart_av_hmac_final _av_hmac_final;

  /// Hash an array of data with a key.
  /// @param ctx    The HMAC context
  /// @param data   The data to hash
  /// @param len    The length of the data, in bytes
  /// @param key    The authentication key
  /// @param keylen The length of the key, in bytes
  /// @param out    The output buffer to write the digest into
  /// @param outlen The length of the out buffer, in bytes
  /// @return       The number of bytes written to out, or a negative error code.
  int av_hmac_calc(
    ffi.Pointer<AVHMAC> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int len,
    ffi.Pointer<ffi.Uint8> key,
    int keylen,
    ffi.Pointer<ffi.Uint8> out,
    int outlen,
  ) {
    _av_hmac_calc ??= _dylib
        .lookupFunction<_c_av_hmac_calc, _dart_av_hmac_calc>('av_hmac_calc');
    return _av_hmac_calc(
      ctx,
      data,
      len,
      key,
      keylen,
      out,
      outlen,
    );
  }

  _dart_av_hmac_calc _av_hmac_calc;

  /// Convert a VideoToolbox (actually CoreVideo) format to AVPixelFormat.
  /// Returns AV_PIX_FMT_NONE if no known equivalent was found.
  int av_map_videotoolbox_format_to_pixfmt(
    int cv_fmt,
  ) {
    _av_map_videotoolbox_format_to_pixfmt ??= _dylib.lookupFunction<
            _c_av_map_videotoolbox_format_to_pixfmt,
            _dart_av_map_videotoolbox_format_to_pixfmt>(
        'av_map_videotoolbox_format_to_pixfmt');
    return _av_map_videotoolbox_format_to_pixfmt(
      cv_fmt,
    );
  }

  _dart_av_map_videotoolbox_format_to_pixfmt
      _av_map_videotoolbox_format_to_pixfmt;

  /// Convert an AVPixelFormat to a VideoToolbox (actually CoreVideo) format.
  /// Returns 0 if no known equivalent was found.
  int av_map_videotoolbox_format_from_pixfmt(
    int pix_fmt,
  ) {
    _av_map_videotoolbox_format_from_pixfmt ??= _dylib.lookupFunction<
            _c_av_map_videotoolbox_format_from_pixfmt,
            _dart_av_map_videotoolbox_format_from_pixfmt>(
        'av_map_videotoolbox_format_from_pixfmt');
    return _av_map_videotoolbox_format_from_pixfmt(
      pix_fmt,
    );
  }

  _dart_av_map_videotoolbox_format_from_pixfmt
      _av_map_videotoolbox_format_from_pixfmt;

  /// Same as av_map_videotoolbox_format_from_pixfmt function, but can map and
  /// return full range pixel formats via a flag.
  int av_map_videotoolbox_format_from_pixfmt2(
    int pix_fmt,
    int full_range,
  ) {
    _av_map_videotoolbox_format_from_pixfmt2 ??= _dylib.lookupFunction<
            _c_av_map_videotoolbox_format_from_pixfmt2,
            _dart_av_map_videotoolbox_format_from_pixfmt2>(
        'av_map_videotoolbox_format_from_pixfmt2');
    return _av_map_videotoolbox_format_from_pixfmt2(
      pix_fmt,
      full_range,
    );
  }

  _dart_av_map_videotoolbox_format_from_pixfmt2
      _av_map_videotoolbox_format_from_pixfmt2;

  /// Allocates a single AVVkFrame and initializes everything as 0.
  /// @note Must be freed via av_free()
  ffi.Pointer<AVVkFrame> av_vk_frame_alloc() {
    _av_vk_frame_alloc ??=
        _dylib.lookupFunction<_c_av_vk_frame_alloc, _dart_av_vk_frame_alloc>(
            'av_vk_frame_alloc');
    return _av_vk_frame_alloc();
  }

  _dart_av_vk_frame_alloc _av_vk_frame_alloc;

  /// Returns the format of each image up to the number of planes for a given sw_format.
  /// Returns NULL on unsupported formats.
  ffi.Pointer<ffi.Int32> av_vkfmt_from_pixfmt(
    int p,
  ) {
    _av_vkfmt_from_pixfmt ??= _dylib.lookupFunction<_c_av_vkfmt_from_pixfmt,
        _dart_av_vkfmt_from_pixfmt>('av_vkfmt_from_pixfmt');
    return _av_vkfmt_from_pixfmt(
      p,
    );
  }

  _dart_av_vkfmt_from_pixfmt _av_vkfmt_from_pixfmt;

  /// Return the number of bits per pixel used by the pixel format
  /// described by pixdesc. Note that this is not the same as the number
  /// of bits per sample.
  ///
  /// The returned number of bits refers to the number of bits actually
  /// used for storing the pixel information, that is padding bits are
  /// not counted.
  int av_get_bits_per_pixel(
    ffi.Pointer<AVPixFmtDescriptor> pixdesc,
  ) {
    _av_get_bits_per_pixel ??= _dylib.lookupFunction<_c_av_get_bits_per_pixel,
        _dart_av_get_bits_per_pixel>('av_get_bits_per_pixel');
    return _av_get_bits_per_pixel(
      pixdesc,
    );
  }

  _dart_av_get_bits_per_pixel _av_get_bits_per_pixel;

  /// Return the number of bits per pixel for the pixel format
  /// described by pixdesc, including any padding or unused bits.
  int av_get_padded_bits_per_pixel(
    ffi.Pointer<AVPixFmtDescriptor> pixdesc,
  ) {
    _av_get_padded_bits_per_pixel ??= _dylib.lookupFunction<
        _c_av_get_padded_bits_per_pixel,
        _dart_av_get_padded_bits_per_pixel>('av_get_padded_bits_per_pixel');
    return _av_get_padded_bits_per_pixel(
      pixdesc,
    );
  }

  _dart_av_get_padded_bits_per_pixel _av_get_padded_bits_per_pixel;

  /// @return a pixel format descriptor for provided pixel format or NULL if
  /// this pixel format is unknown.
  ffi.Pointer<AVPixFmtDescriptor> av_pix_fmt_desc_get(
    int pix_fmt,
  ) {
    _av_pix_fmt_desc_get ??= _dylib.lookupFunction<_c_av_pix_fmt_desc_get,
        _dart_av_pix_fmt_desc_get>('av_pix_fmt_desc_get');
    return _av_pix_fmt_desc_get(
      pix_fmt,
    );
  }

  _dart_av_pix_fmt_desc_get _av_pix_fmt_desc_get;

  /// Iterate over all pixel format descriptors known to libavutil.
  ///
  /// @param prev previous descriptor. NULL to get the first descriptor.
  ///
  /// @return next descriptor or NULL after the last descriptor
  ffi.Pointer<AVPixFmtDescriptor> av_pix_fmt_desc_next(
    ffi.Pointer<AVPixFmtDescriptor> prev,
  ) {
    _av_pix_fmt_desc_next ??= _dylib.lookupFunction<_c_av_pix_fmt_desc_next,
        _dart_av_pix_fmt_desc_next>('av_pix_fmt_desc_next');
    return _av_pix_fmt_desc_next(
      prev,
    );
  }

  _dart_av_pix_fmt_desc_next _av_pix_fmt_desc_next;

  /// @return an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc
  /// is not a valid pointer to a pixel format descriptor.
  int av_pix_fmt_desc_get_id(
    ffi.Pointer<AVPixFmtDescriptor> desc,
  ) {
    _av_pix_fmt_desc_get_id ??= _dylib.lookupFunction<_c_av_pix_fmt_desc_get_id,
        _dart_av_pix_fmt_desc_get_id>('av_pix_fmt_desc_get_id');
    return _av_pix_fmt_desc_get_id(
      desc,
    );
  }

  _dart_av_pix_fmt_desc_get_id _av_pix_fmt_desc_get_id;

  /// Utility function to access log2_chroma_w log2_chroma_h from
  /// the pixel format AVPixFmtDescriptor.
  ///
  /// @param[in]  pix_fmt the pixel format
  /// @param[out] h_shift store log2_chroma_w (horizontal/width shift)
  /// @param[out] v_shift store log2_chroma_h (vertical/height shift)
  ///
  /// @return 0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format
  int av_pix_fmt_get_chroma_sub_sample(
    int pix_fmt,
    ffi.Pointer<ffi.Int32> h_shift,
    ffi.Pointer<ffi.Int32> v_shift,
  ) {
    _av_pix_fmt_get_chroma_sub_sample ??= _dylib.lookupFunction<
            _c_av_pix_fmt_get_chroma_sub_sample,
            _dart_av_pix_fmt_get_chroma_sub_sample>(
        'av_pix_fmt_get_chroma_sub_sample');
    return _av_pix_fmt_get_chroma_sub_sample(
      pix_fmt,
      h_shift,
      v_shift,
    );
  }

  _dart_av_pix_fmt_get_chroma_sub_sample _av_pix_fmt_get_chroma_sub_sample;

  /// @return number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a
  /// valid pixel format.
  int av_pix_fmt_count_planes(
    int pix_fmt,
  ) {
    _av_pix_fmt_count_planes ??= _dylib.lookupFunction<
        _c_av_pix_fmt_count_planes,
        _dart_av_pix_fmt_count_planes>('av_pix_fmt_count_planes');
    return _av_pix_fmt_count_planes(
      pix_fmt,
    );
  }

  _dart_av_pix_fmt_count_planes _av_pix_fmt_count_planes;

  /// @return the name for provided color range or NULL if unknown.
  ffi.Pointer<ffi.Int8> av_color_range_name(
    int range,
  ) {
    _av_color_range_name ??= _dylib.lookupFunction<_c_av_color_range_name,
        _dart_av_color_range_name>('av_color_range_name');
    return _av_color_range_name(
      range,
    );
  }

  _dart_av_color_range_name _av_color_range_name;

  /// @return the AVColorRange value for name or an AVError if not found.
  int av_color_range_from_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_color_range_from_name ??= _dylib.lookupFunction<
        _c_av_color_range_from_name,
        _dart_av_color_range_from_name>('av_color_range_from_name');
    return _av_color_range_from_name(
      name,
    );
  }

  _dart_av_color_range_from_name _av_color_range_from_name;

  /// @return the name for provided color primaries or NULL if unknown.
  ffi.Pointer<ffi.Int8> av_color_primaries_name(
    int primaries,
  ) {
    _av_color_primaries_name ??= _dylib.lookupFunction<
        _c_av_color_primaries_name,
        _dart_av_color_primaries_name>('av_color_primaries_name');
    return _av_color_primaries_name(
      primaries,
    );
  }

  _dart_av_color_primaries_name _av_color_primaries_name;

  /// @return the AVColorPrimaries value for name or an AVError if not found.
  int av_color_primaries_from_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_color_primaries_from_name ??= _dylib.lookupFunction<
        _c_av_color_primaries_from_name,
        _dart_av_color_primaries_from_name>('av_color_primaries_from_name');
    return _av_color_primaries_from_name(
      name,
    );
  }

  _dart_av_color_primaries_from_name _av_color_primaries_from_name;

  /// @return the name for provided color transfer or NULL if unknown.
  ffi.Pointer<ffi.Int8> av_color_transfer_name(
    int transfer,
  ) {
    _av_color_transfer_name ??= _dylib.lookupFunction<_c_av_color_transfer_name,
        _dart_av_color_transfer_name>('av_color_transfer_name');
    return _av_color_transfer_name(
      transfer,
    );
  }

  _dart_av_color_transfer_name _av_color_transfer_name;

  /// @return the AVColorTransferCharacteristic value for name or an AVError if not found.
  int av_color_transfer_from_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_color_transfer_from_name ??= _dylib.lookupFunction<
        _c_av_color_transfer_from_name,
        _dart_av_color_transfer_from_name>('av_color_transfer_from_name');
    return _av_color_transfer_from_name(
      name,
    );
  }

  _dart_av_color_transfer_from_name _av_color_transfer_from_name;

  /// @return the name for provided color space or NULL if unknown.
  ffi.Pointer<ffi.Int8> av_color_space_name(
    int space,
  ) {
    _av_color_space_name ??= _dylib.lookupFunction<_c_av_color_space_name,
        _dart_av_color_space_name>('av_color_space_name');
    return _av_color_space_name(
      space,
    );
  }

  _dart_av_color_space_name _av_color_space_name;

  /// @return the AVColorSpace value for name or an AVError if not found.
  int av_color_space_from_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_color_space_from_name ??= _dylib.lookupFunction<
        _c_av_color_space_from_name,
        _dart_av_color_space_from_name>('av_color_space_from_name');
    return _av_color_space_from_name(
      name,
    );
  }

  _dart_av_color_space_from_name _av_color_space_from_name;

  /// @return the name for provided chroma location or NULL if unknown.
  ffi.Pointer<ffi.Int8> av_chroma_location_name(
    int location,
  ) {
    _av_chroma_location_name ??= _dylib.lookupFunction<
        _c_av_chroma_location_name,
        _dart_av_chroma_location_name>('av_chroma_location_name');
    return _av_chroma_location_name(
      location,
    );
  }

  _dart_av_chroma_location_name _av_chroma_location_name;

  /// @return the AVChromaLocation value for name or an AVError if not found.
  int av_chroma_location_from_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_chroma_location_from_name ??= _dylib.lookupFunction<
        _c_av_chroma_location_from_name,
        _dart_av_chroma_location_from_name>('av_chroma_location_from_name');
    return _av_chroma_location_from_name(
      name,
    );
  }

  _dart_av_chroma_location_from_name _av_chroma_location_from_name;

  /// Return the pixel format corresponding to name.
  ///
  /// If there is no pixel format with name name, then looks for a
  /// pixel format with the name corresponding to the native endian
  /// format of name.
  /// For example in a little-endian system, first looks for "gray16",
  /// then for "gray16le".
  ///
  /// Finally if no pixel format has been found, returns AV_PIX_FMT_NONE.
  int av_get_pix_fmt(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_get_pix_fmt ??=
        _dylib.lookupFunction<_c_av_get_pix_fmt, _dart_av_get_pix_fmt>(
            'av_get_pix_fmt');
    return _av_get_pix_fmt(
      name,
    );
  }

  _dart_av_get_pix_fmt _av_get_pix_fmt;

  /// Return the short name for a pixel format, NULL in case pix_fmt is
  /// unknown.
  ///
  /// @see av_get_pix_fmt(), av_get_pix_fmt_string()
  ffi.Pointer<ffi.Int8> av_get_pix_fmt_name(
    int pix_fmt,
  ) {
    _av_get_pix_fmt_name ??= _dylib.lookupFunction<_c_av_get_pix_fmt_name,
        _dart_av_get_pix_fmt_name>('av_get_pix_fmt_name');
    return _av_get_pix_fmt_name(
      pix_fmt,
    );
  }

  _dart_av_get_pix_fmt_name _av_get_pix_fmt_name;

  /// Print in buf the string corresponding to the pixel format with
  /// number pix_fmt, or a header if pix_fmt is negative.
  ///
  /// @param buf the buffer where to write the string
  /// @param buf_size the size of buf
  /// @param pix_fmt the number of the pixel format to print the
  /// corresponding info string, or a negative value to print the
  /// corresponding header.
  ffi.Pointer<ffi.Int8> av_get_pix_fmt_string(
    ffi.Pointer<ffi.Int8> buf,
    int buf_size,
    int pix_fmt,
  ) {
    _av_get_pix_fmt_string ??= _dylib.lookupFunction<_c_av_get_pix_fmt_string,
        _dart_av_get_pix_fmt_string>('av_get_pix_fmt_string');
    return _av_get_pix_fmt_string(
      buf,
      buf_size,
      pix_fmt,
    );
  }

  _dart_av_get_pix_fmt_string _av_get_pix_fmt_string;

  /// Read a line from an image, and write the values of the
  /// pixel format component c to dst.
  ///
  /// @param data the array containing the pointers to the planes of the image
  /// @param linesize the array containing the linesizes of the image
  /// @param desc the pixel format descriptor for the image
  /// @param x the horizontal coordinate of the first pixel to read
  /// @param y the vertical coordinate of the first pixel to read
  /// @param w the width of the line to read, that is the number of
  /// values to write to dst
  /// @param read_pal_component if not zero and the format is a paletted
  /// format writes the values corresponding to the palette
  /// component c in data[1] to dst, rather than the palette indexes in
  /// data[0]. The behavior is undefined if the format is not paletted.
  /// @param dst_element_size size of elements in dst array (2 or 4 byte)
  void av_read_image_line2(
    ffi.Pointer<ffi.Void> dst,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int32> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
    int read_pal_component,
    int dst_element_size,
  ) {
    _av_read_image_line2 ??= _dylib.lookupFunction<_c_av_read_image_line2,
        _dart_av_read_image_line2>('av_read_image_line2');
    return _av_read_image_line2(
      dst,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
      read_pal_component,
      dst_element_size,
    );
  }

  _dart_av_read_image_line2 _av_read_image_line2;

  void av_read_image_line(
    ffi.Pointer<ffi.Uint16> dst,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int32> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
    int read_pal_component,
  ) {
    _av_read_image_line ??=
        _dylib.lookupFunction<_c_av_read_image_line, _dart_av_read_image_line>(
            'av_read_image_line');
    return _av_read_image_line(
      dst,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
      read_pal_component,
    );
  }

  _dart_av_read_image_line _av_read_image_line;

  /// Write the values from src to the pixel format component c of an
  /// image line.
  ///
  /// @param src array containing the values to write
  /// @param data the array containing the pointers to the planes of the
  /// image to write into. It is supposed to be zeroed.
  /// @param linesize the array containing the linesizes of the image
  /// @param desc the pixel format descriptor for the image
  /// @param x the horizontal coordinate of the first pixel to write
  /// @param y the vertical coordinate of the first pixel to write
  /// @param w the width of the line to write, that is the number of
  /// values to write to the image line
  /// @param src_element_size size of elements in src array (2 or 4 byte)
  void av_write_image_line2(
    ffi.Pointer<ffi.Void> src,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int32> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
    int src_element_size,
  ) {
    _av_write_image_line2 ??= _dylib.lookupFunction<_c_av_write_image_line2,
        _dart_av_write_image_line2>('av_write_image_line2');
    return _av_write_image_line2(
      src,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
      src_element_size,
    );
  }

  _dart_av_write_image_line2 _av_write_image_line2;

  void av_write_image_line(
    ffi.Pointer<ffi.Uint16> src,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    ffi.Pointer<ffi.Int32> linesize,
    ffi.Pointer<AVPixFmtDescriptor> desc,
    int x,
    int y,
    int c,
    int w,
  ) {
    _av_write_image_line ??= _dylib.lookupFunction<_c_av_write_image_line,
        _dart_av_write_image_line>('av_write_image_line');
    return _av_write_image_line(
      src,
      data,
      linesize,
      desc,
      x,
      y,
      c,
      w,
    );
  }

  _dart_av_write_image_line _av_write_image_line;

  /// Utility function to swap the endianness of a pixel format.
  ///
  /// @param[in]  pix_fmt the pixel format
  ///
  /// @return pixel format with swapped endianness if it exists,
  /// otherwise AV_PIX_FMT_NONE
  int av_pix_fmt_swap_endianness(
    int pix_fmt,
  ) {
    _av_pix_fmt_swap_endianness ??= _dylib.lookupFunction<
        _c_av_pix_fmt_swap_endianness,
        _dart_av_pix_fmt_swap_endianness>('av_pix_fmt_swap_endianness');
    return _av_pix_fmt_swap_endianness(
      pix_fmt,
    );
  }

  _dart_av_pix_fmt_swap_endianness _av_pix_fmt_swap_endianness;

  /// Compute what kind of losses will occur when converting from one specific
  /// pixel format to another.
  /// When converting from one pixel format to another, information loss may occur.
  /// For example, when converting from RGB24 to GRAY, the color information will
  /// be lost. Similarly, other losses occur when converting from some formats to
  /// other formats. These losses can involve loss of chroma, but also loss of
  /// resolution, loss of color depth, loss due to the color space conversion, loss
  /// of the alpha bits or loss due to color quantization.
  /// av_get_fix_fmt_loss() informs you about the various types of losses
  /// which will occur when converting from one pixel format to another.
  ///
  /// @param[in] dst_pix_fmt destination pixel format
  /// @param[in] src_pix_fmt source pixel format
  /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
  /// @return Combination of flags informing you what kind of losses will occur
  /// (maximum loss for an invalid dst_pix_fmt).
  int av_get_pix_fmt_loss(
    int dst_pix_fmt,
    int src_pix_fmt,
    int has_alpha,
  ) {
    _av_get_pix_fmt_loss ??= _dylib.lookupFunction<_c_av_get_pix_fmt_loss,
        _dart_av_get_pix_fmt_loss>('av_get_pix_fmt_loss');
    return _av_get_pix_fmt_loss(
      dst_pix_fmt,
      src_pix_fmt,
      has_alpha,
    );
  }

  _dart_av_get_pix_fmt_loss _av_get_pix_fmt_loss;

  /// Compute what kind of losses will occur when converting from one specific
  /// pixel format to another.
  /// When converting from one pixel format to another, information loss may occur.
  /// For example, when converting from RGB24 to GRAY, the color information will
  /// be lost. Similarly, other losses occur when converting from some formats to
  /// other formats. These losses can involve loss of chroma, but also loss of
  /// resolution, loss of color depth, loss due to the color space conversion, loss
  /// of the alpha bits or loss due to color quantization.
  /// av_get_fix_fmt_loss() informs you about the various types of losses
  /// which will occur when converting from one pixel format to another.
  ///
  /// @param[in] dst_pix_fmt destination pixel format
  /// @param[in] src_pix_fmt source pixel format
  /// @param[in] has_alpha Whether the source pixel format alpha channel is used.
  /// @return Combination of flags informing you what kind of losses will occur
  /// (maximum loss for an invalid dst_pix_fmt).
  int av_find_best_pix_fmt_of_2(
    int dst_pix_fmt1,
    int dst_pix_fmt2,
    int src_pix_fmt,
    int has_alpha,
    ffi.Pointer<ffi.Int32> loss_ptr,
  ) {
    _av_find_best_pix_fmt_of_2 ??= _dylib.lookupFunction<
        _c_av_find_best_pix_fmt_of_2,
        _dart_av_find_best_pix_fmt_of_2>('av_find_best_pix_fmt_of_2');
    return _av_find_best_pix_fmt_of_2(
      dst_pix_fmt1,
      dst_pix_fmt2,
      src_pix_fmt,
      has_alpha,
      loss_ptr,
    );
  }

  _dart_av_find_best_pix_fmt_of_2 _av_find_best_pix_fmt_of_2;

  /// Compute the max pixel step for each plane of an image with a
  /// format described by pixdesc.
  ///
  /// The pixel step is the distance in bytes between the first byte of
  /// the group of bytes which describe a pixel component and the first
  /// byte of the successive group in the same plane for the same
  /// component.
  ///
  /// @param max_pixsteps an array which is filled with the max pixel step
  /// for each plane. Since a plane may contain different pixel
  /// components, the computed max_pixsteps[plane] is relative to the
  /// component in the plane with the max pixel step.
  /// @param max_pixstep_comps an array which is filled with the component
  /// for each plane which has the max pixel step. May be NULL.
  void av_image_fill_max_pixsteps(
    ffi.Pointer<ffi.Int32> max_pixsteps,
    ffi.Pointer<ffi.Int32> max_pixstep_comps,
    ffi.Pointer<AVPixFmtDescriptor> pixdesc,
  ) {
    _av_image_fill_max_pixsteps ??= _dylib.lookupFunction<
        _c_av_image_fill_max_pixsteps,
        _dart_av_image_fill_max_pixsteps>('av_image_fill_max_pixsteps');
    return _av_image_fill_max_pixsteps(
      max_pixsteps,
      max_pixstep_comps,
      pixdesc,
    );
  }

  _dart_av_image_fill_max_pixsteps _av_image_fill_max_pixsteps;

  /// Compute the size of an image line with format pix_fmt and width
  /// width for the plane plane.
  ///
  /// @return the computed size in bytes
  int av_image_get_linesize(
    int pix_fmt,
    int width,
    int plane,
  ) {
    _av_image_get_linesize ??= _dylib.lookupFunction<_c_av_image_get_linesize,
        _dart_av_image_get_linesize>('av_image_get_linesize');
    return _av_image_get_linesize(
      pix_fmt,
      width,
      plane,
    );
  }

  _dart_av_image_get_linesize _av_image_get_linesize;

  /// Fill plane linesizes for an image with pixel format pix_fmt and
  /// width width.
  ///
  /// @param linesizes array to be filled with the linesize for each plane
  /// @return >= 0 in case of success, a negative error code otherwise
  int av_image_fill_linesizes(
    ffi.Pointer<ffi.Int32> linesizes,
    int pix_fmt,
    int width,
  ) {
    _av_image_fill_linesizes ??= _dylib.lookupFunction<
        _c_av_image_fill_linesizes,
        _dart_av_image_fill_linesizes>('av_image_fill_linesizes');
    return _av_image_fill_linesizes(
      linesizes,
      pix_fmt,
      width,
    );
  }

  _dart_av_image_fill_linesizes _av_image_fill_linesizes;

  /// Fill plane sizes for an image with pixel format pix_fmt and height height.
  ///
  /// @param size the array to be filled with the size of each image plane
  /// @param linesizes the array containing the linesize for each
  /// plane, should be filled by av_image_fill_linesizes()
  /// @return >= 0 in case of success, a negative error code otherwise
  ///
  /// @note The linesize parameters have the type ptrdiff_t here, while they are
  /// int for av_image_fill_linesizes().
  int av_image_fill_plane_sizes(
    ffi.Pointer<ffi.Uint64> size,
    int pix_fmt,
    int height,
    ffi.Pointer<ffi.Int64> linesizes,
  ) {
    _av_image_fill_plane_sizes ??= _dylib.lookupFunction<
        _c_av_image_fill_plane_sizes,
        _dart_av_image_fill_plane_sizes>('av_image_fill_plane_sizes');
    return _av_image_fill_plane_sizes(
      size,
      pix_fmt,
      height,
      linesizes,
    );
  }

  _dart_av_image_fill_plane_sizes _av_image_fill_plane_sizes;

  /// Fill plane data pointers for an image with pixel format pix_fmt and
  /// height height.
  ///
  /// @param data pointers array to be filled with the pointer for each image plane
  /// @param ptr the pointer to a buffer which will contain the image
  /// @param linesizes the array containing the linesize for each
  /// plane, should be filled by av_image_fill_linesizes()
  /// @return the size in bytes required for the image buffer, a negative
  /// error code in case of failure
  int av_image_fill_pointers(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
    int pix_fmt,
    int height,
    ffi.Pointer<ffi.Uint8> ptr,
    ffi.Pointer<ffi.Int32> linesizes,
  ) {
    _av_image_fill_pointers ??= _dylib.lookupFunction<_c_av_image_fill_pointers,
        _dart_av_image_fill_pointers>('av_image_fill_pointers');
    return _av_image_fill_pointers(
      data,
      pix_fmt,
      height,
      ptr,
      linesizes,
    );
  }

  _dart_av_image_fill_pointers _av_image_fill_pointers;

  /// Allocate an image with size w and h and pixel format pix_fmt, and
  /// fill pointers and linesizes accordingly.
  /// The allocated image buffer has to be freed by using
  /// av_freep(&pointers[0]).
  ///
  /// @param align the value to use for buffer size alignment
  /// @return the size in bytes required for the image buffer, a negative
  /// error code in case of failure
  int av_image_alloc(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> pointers,
    ffi.Pointer<ffi.Int32> linesizes,
    int w,
    int h,
    int pix_fmt,
    int align,
  ) {
    _av_image_alloc ??=
        _dylib.lookupFunction<_c_av_image_alloc, _dart_av_image_alloc>(
            'av_image_alloc');
    return _av_image_alloc(
      pointers,
      linesizes,
      w,
      h,
      pix_fmt,
      align,
    );
  }

  _dart_av_image_alloc _av_image_alloc;

  /// Copy image plane from src to dst.
  /// That is, copy "height" number of lines of "bytewidth" bytes each.
  /// The first byte of each successive line is separated by *_linesize
  /// bytes.
  ///
  /// bytewidth must be contained by both absolute values of dst_linesize
  /// and src_linesize, otherwise the function behavior is undefined.
  ///
  /// @param dst_linesize linesize for the image plane in dst
  /// @param src_linesize linesize for the image plane in src
  void av_image_copy_plane(
    ffi.Pointer<ffi.Uint8> dst,
    int dst_linesize,
    ffi.Pointer<ffi.Uint8> src,
    int src_linesize,
    int bytewidth,
    int height,
  ) {
    _av_image_copy_plane ??= _dylib.lookupFunction<_c_av_image_copy_plane,
        _dart_av_image_copy_plane>('av_image_copy_plane');
    return _av_image_copy_plane(
      dst,
      dst_linesize,
      src,
      src_linesize,
      bytewidth,
      height,
    );
  }

  _dart_av_image_copy_plane _av_image_copy_plane;

  /// Copy image in src_data to dst_data.
  ///
  /// @param dst_linesizes linesizes for the image in dst_data
  /// @param src_linesizes linesizes for the image in src_data
  void av_image_copy(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ffi.Int32> dst_linesizes,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
    ffi.Pointer<ffi.Int32> src_linesizes,
    int pix_fmt,
    int width,
    int height,
  ) {
    _av_image_copy ??= _dylib
        .lookupFunction<_c_av_image_copy, _dart_av_image_copy>('av_image_copy');
    return _av_image_copy(
      dst_data,
      dst_linesizes,
      src_data,
      src_linesizes,
      pix_fmt,
      width,
      height,
    );
  }

  _dart_av_image_copy _av_image_copy;

  /// Copy image data located in uncacheable (e.g. GPU mapped) memory. Where
  /// available, this function will use special functionality for reading from such
  /// memory, which may result in greatly improved performance compared to plain
  /// av_image_copy().
  ///
  /// The data pointers and the linesizes must be aligned to the maximum required
  /// by the CPU architecture.
  ///
  /// @note The linesize parameters have the type ptrdiff_t here, while they are
  /// int for av_image_copy().
  /// @note On x86, the linesizes currently need to be aligned to the cacheline
  /// size (i.e. 64) to get improved performance.
  void av_image_copy_uc_from(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ffi.Int64> dst_linesizes,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
    ffi.Pointer<ffi.Int64> src_linesizes,
    int pix_fmt,
    int width,
    int height,
  ) {
    _av_image_copy_uc_from ??= _dylib.lookupFunction<_c_av_image_copy_uc_from,
        _dart_av_image_copy_uc_from>('av_image_copy_uc_from');
    return _av_image_copy_uc_from(
      dst_data,
      dst_linesizes,
      src_data,
      src_linesizes,
      pix_fmt,
      width,
      height,
    );
  }

  _dart_av_image_copy_uc_from _av_image_copy_uc_from;

  /// Setup the data pointers and linesizes based on the specified image
  /// parameters and the provided array.
  ///
  /// The fields of the given image are filled in by using the src
  /// address which points to the image data buffer. Depending on the
  /// specified pixel format, one or multiple image data pointers and
  /// line sizes will be set.  If a planar format is specified, several
  /// pointers will be set pointing to the different picture planes and
  /// the line sizes of the different planes will be stored in the
  /// lines_sizes array. Call with src == NULL to get the required
  /// size for the src buffer.
  ///
  /// To allocate the buffer and fill in the dst_data and dst_linesize in
  /// one call, use av_image_alloc().
  ///
  /// @param dst_data      data pointers to be filled in
  /// @param dst_linesize  linesizes for the image in dst_data to be filled in
  /// @param src           buffer which will contain or contains the actual image data, can be NULL
  /// @param pix_fmt       the pixel format of the image
  /// @param width         the width of the image in pixels
  /// @param height        the height of the image in pixels
  /// @param align         the value used in src for linesize alignment
  /// @return the size in bytes required for src, a negative error code
  /// in case of failure
  int av_image_fill_arrays(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ffi.Int32> dst_linesize,
    ffi.Pointer<ffi.Uint8> src,
    int pix_fmt,
    int width,
    int height,
    int align,
  ) {
    _av_image_fill_arrays ??= _dylib.lookupFunction<_c_av_image_fill_arrays,
        _dart_av_image_fill_arrays>('av_image_fill_arrays');
    return _av_image_fill_arrays(
      dst_data,
      dst_linesize,
      src,
      pix_fmt,
      width,
      height,
      align,
    );
  }

  _dart_av_image_fill_arrays _av_image_fill_arrays;

  /// Return the size in bytes of the amount of data required to store an
  /// image with the given parameters.
  ///
  /// @param pix_fmt  the pixel format of the image
  /// @param width    the width of the image in pixels
  /// @param height   the height of the image in pixels
  /// @param align    the assumed linesize alignment
  /// @return the buffer size in bytes, a negative error code in case of failure
  int av_image_get_buffer_size(
    int pix_fmt,
    int width,
    int height,
    int align,
  ) {
    _av_image_get_buffer_size ??= _dylib.lookupFunction<
        _c_av_image_get_buffer_size,
        _dart_av_image_get_buffer_size>('av_image_get_buffer_size');
    return _av_image_get_buffer_size(
      pix_fmt,
      width,
      height,
      align,
    );
  }

  _dart_av_image_get_buffer_size _av_image_get_buffer_size;

  /// Copy image data from an image into a buffer.
  ///
  /// av_image_get_buffer_size() can be used to compute the required size
  /// for the buffer to fill.
  ///
  /// @param dst           a buffer into which picture data will be copied
  /// @param dst_size      the size in bytes of dst
  /// @param src_data      pointers containing the source image data
  /// @param src_linesize  linesizes for the image in src_data
  /// @param pix_fmt       the pixel format of the source image
  /// @param width         the width of the source image in pixels
  /// @param height        the height of the source image in pixels
  /// @param align         the assumed linesize alignment for dst
  /// @return the number of bytes written to dst, or a negative value
  /// (error code) on error
  int av_image_copy_to_buffer(
    ffi.Pointer<ffi.Uint8> dst,
    int dst_size,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
    ffi.Pointer<ffi.Int32> src_linesize,
    int pix_fmt,
    int width,
    int height,
    int align,
  ) {
    _av_image_copy_to_buffer ??= _dylib.lookupFunction<
        _c_av_image_copy_to_buffer,
        _dart_av_image_copy_to_buffer>('av_image_copy_to_buffer');
    return _av_image_copy_to_buffer(
      dst,
      dst_size,
      src_data,
      src_linesize,
      pix_fmt,
      width,
      height,
      align,
    );
  }

  _dart_av_image_copy_to_buffer _av_image_copy_to_buffer;

  /// Check if the given dimension of an image is valid, meaning that all
  /// bytes of the image can be addressed with a signed int.
  ///
  /// @param w the width of the picture
  /// @param h the height of the picture
  /// @param log_offset the offset to sum to the log level for logging with log_ctx
  /// @param log_ctx the parent logging context, it may be NULL
  /// @return >= 0 if valid, a negative error code otherwise
  int av_image_check_size(
    int w,
    int h,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_image_check_size ??= _dylib.lookupFunction<_c_av_image_check_size,
        _dart_av_image_check_size>('av_image_check_size');
    return _av_image_check_size(
      w,
      h,
      log_offset,
      log_ctx,
    );
  }

  _dart_av_image_check_size _av_image_check_size;

  /// Check if the given dimension of an image is valid, meaning that all
  /// bytes of a plane of an image with the specified pix_fmt can be addressed
  /// with a signed int.
  ///
  /// @param w the width of the picture
  /// @param h the height of the picture
  /// @param max_pixels the maximum number of pixels the user wants to accept
  /// @param pix_fmt the pixel format, can be AV_PIX_FMT_NONE if unknown.
  /// @param log_offset the offset to sum to the log level for logging with log_ctx
  /// @param log_ctx the parent logging context, it may be NULL
  /// @return >= 0 if valid, a negative error code otherwise
  int av_image_check_size2(
    int w,
    int h,
    int max_pixels,
    int pix_fmt,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_image_check_size2 ??= _dylib.lookupFunction<_c_av_image_check_size2,
        _dart_av_image_check_size2>('av_image_check_size2');
    return _av_image_check_size2(
      w,
      h,
      max_pixels,
      pix_fmt,
      log_offset,
      log_ctx,
    );
  }

  _dart_av_image_check_size2 _av_image_check_size2;

  /// Overwrite the image data with black. This is suitable for filling a
  /// sub-rectangle of an image, meaning the padding between the right most pixel
  /// and the left most pixel on the next line will not be overwritten. For some
  /// formats, the image size might be rounded up due to inherent alignment.
  ///
  /// If the pixel format has alpha, the alpha is cleared to opaque.
  ///
  /// This can return an error if the pixel format is not supported. Normally, all
  /// non-hwaccel pixel formats should be supported.
  ///
  /// Passing NULL for dst_data is allowed. Then the function returns whether the
  /// operation would have succeeded. (It can return an error if the pix_fmt is
  /// not supported.)
  ///
  /// @param dst_data      data pointers to destination image
  /// @param dst_linesize  linesizes for the destination image
  /// @param pix_fmt       the pixel format of the image
  /// @param range         the color range of the image (important for colorspaces such as YUV)
  /// @param width         the width of the image in pixels
  /// @param height        the height of the image in pixels
  /// @return 0 if the image data was cleared, a negative AVERROR code otherwise
  int av_image_fill_black(
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
    ffi.Pointer<ffi.Int64> dst_linesize,
    int pix_fmt,
    int range,
    int width,
    int height,
  ) {
    _av_image_fill_black ??= _dylib.lookupFunction<_c_av_image_fill_black,
        _dart_av_image_fill_black>('av_image_fill_black');
    return _av_image_fill_black(
      dst_data,
      dst_linesize,
      pix_fmt,
      range,
      width,
      height,
    );
  }

  _dart_av_image_fill_black _av_image_fill_black;

  void av_lfg_init(
    ffi.Pointer<AVLFG> c,
    int seed,
  ) {
    _av_lfg_init ??=
        _dylib.lookupFunction<_c_av_lfg_init, _dart_av_lfg_init>('av_lfg_init');
    return _av_lfg_init(
      c,
      seed,
    );
  }

  _dart_av_lfg_init _av_lfg_init;

  /// Seed the state of the ALFG using binary data.
  ///
  /// Return value: 0 on success, negative value (AVERROR) on failure.
  int av_lfg_init_from_data(
    ffi.Pointer<AVLFG> c,
    ffi.Pointer<ffi.Uint8> data,
    int length,
  ) {
    _av_lfg_init_from_data ??= _dylib.lookupFunction<_c_av_lfg_init_from_data,
        _dart_av_lfg_init_from_data>('av_lfg_init_from_data');
    return _av_lfg_init_from_data(
      c,
      data,
      length,
    );
  }

  _dart_av_lfg_init_from_data _av_lfg_init_from_data;

  /// Get the next random unsigned 32-bit number using an ALFG.
  ///
  /// Please also consider a simple LCG like state= state*1664525+1013904223,
  /// it may be good enough and faster for your specific use case.
  int av_lfg_get(
    ffi.Pointer<AVLFG> c,
  ) {
    _av_lfg_get ??=
        _dylib.lookupFunction<_c_av_lfg_get, _dart_av_lfg_get>('av_lfg_get');
    return _av_lfg_get(
      c,
    );
  }

  _dart_av_lfg_get _av_lfg_get;

  /// Get the next random unsigned 32-bit number using a MLFG.
  ///
  /// Please also consider av_lfg_get() above, it is faster.
  int av_mlfg_get(
    ffi.Pointer<AVLFG> c,
  ) {
    _av_mlfg_get ??=
        _dylib.lookupFunction<_c_av_mlfg_get, _dart_av_mlfg_get>('av_mlfg_get');
    return _av_mlfg_get(
      c,
    );
  }

  _dart_av_mlfg_get _av_mlfg_get;

  /// Get the next two numbers generated by a Box-Muller Gaussian
  /// generator using the random numbers issued by lfg.
  ///
  /// @param out array where the two generated numbers are placed
  void av_bmg_get(
    ffi.Pointer<AVLFG> lfg,
    ffi.Pointer<ffi.Double> out,
  ) {
    _av_bmg_get ??=
        _dylib.lookupFunction<_c_av_bmg_get, _dart_av_bmg_get>('av_bmg_get');
    return _av_bmg_get(
      lfg,
      out,
    );
  }

  _dart_av_bmg_get _av_bmg_get;

  /// @brief Decodes LZO 1x compressed data.
  /// @param out output buffer
  /// @param outlen size of output buffer, number of bytes left are returned here
  /// @param in input buffer
  /// @param inlen size of input buffer, number of bytes left are returned here
  /// @return 0 on success, otherwise a combination of the error flags above
  ///
  /// Make sure all buffers are appropriately padded, in must provide
  /// AV_LZO_INPUT_PADDING, out must provide AV_LZO_OUTPUT_PADDING additional bytes.
  int av_lzo1x_decode(
    ffi.Pointer<ffi.Void> out,
    ffi.Pointer<ffi.Int32> outlen,
    ffi.Pointer<ffi.Void> in_1,
    ffi.Pointer<ffi.Int32> inlen,
  ) {
    _av_lzo1x_decode ??=
        _dylib.lookupFunction<_c_av_lzo1x_decode, _dart_av_lzo1x_decode>(
            'av_lzo1x_decode');
    return _av_lzo1x_decode(
      out,
      outlen,
      in_1,
      inlen,
    );
  }

  _dart_av_lzo1x_decode _av_lzo1x_decode;

  /// Allocate an AVMasteringDisplayMetadata structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVMasteringDisplayMetadata filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVMasteringDisplayMetadata>
      av_mastering_display_metadata_alloc() {
    _av_mastering_display_metadata_alloc ??= _dylib.lookupFunction<
            _c_av_mastering_display_metadata_alloc,
            _dart_av_mastering_display_metadata_alloc>(
        'av_mastering_display_metadata_alloc');
    return _av_mastering_display_metadata_alloc();
  }

  _dart_av_mastering_display_metadata_alloc
      _av_mastering_display_metadata_alloc;

  /// Allocate a complete AVMasteringDisplayMetadata and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVMasteringDisplayMetadata structure to be filled by caller.
  ffi.Pointer<AVMasteringDisplayMetadata>
      av_mastering_display_metadata_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_mastering_display_metadata_create_side_data ??= _dylib.lookupFunction<
            _c_av_mastering_display_metadata_create_side_data,
            _dart_av_mastering_display_metadata_create_side_data>(
        'av_mastering_display_metadata_create_side_data');
    return _av_mastering_display_metadata_create_side_data(
      frame,
    );
  }

  _dart_av_mastering_display_metadata_create_side_data
      _av_mastering_display_metadata_create_side_data;

  /// Allocate an AVContentLightMetadata structure and set its fields to
  /// default values. The resulting struct can be freed using av_freep().
  ///
  /// @return An AVContentLightMetadata filled with default values or NULL
  /// on failure.
  ffi.Pointer<AVContentLightMetadata> av_content_light_metadata_alloc(
    ffi.Pointer<ffi.Uint64> size,
  ) {
    _av_content_light_metadata_alloc ??= _dylib.lookupFunction<
            _c_av_content_light_metadata_alloc,
            _dart_av_content_light_metadata_alloc>(
        'av_content_light_metadata_alloc');
    return _av_content_light_metadata_alloc(
      size,
    );
  }

  _dart_av_content_light_metadata_alloc _av_content_light_metadata_alloc;

  /// Allocate a complete AVContentLightMetadata and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVContentLightMetadata structure to be filled by caller.
  ffi.Pointer<AVContentLightMetadata>
      av_content_light_metadata_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_content_light_metadata_create_side_data ??= _dylib.lookupFunction<
            _c_av_content_light_metadata_create_side_data,
            _dart_av_content_light_metadata_create_side_data>(
        'av_content_light_metadata_create_side_data');
    return _av_content_light_metadata_create_side_data(
      frame,
    );
  }

  _dart_av_content_light_metadata_create_side_data
      _av_content_light_metadata_create_side_data;

  /// Allocate an AVMD5 context.
  ffi.Pointer<AVMD5> av_md5_alloc() {
    _av_md5_alloc ??= _dylib
        .lookupFunction<_c_av_md5_alloc, _dart_av_md5_alloc>('av_md5_alloc');
    return _av_md5_alloc();
  }

  _dart_av_md5_alloc _av_md5_alloc;

  /// Initialize MD5 hashing.
  ///
  /// @param ctx pointer to the function context (of size av_md5_size)
  void av_md5_init(
    ffi.Pointer<AVMD5> ctx,
  ) {
    _av_md5_init ??=
        _dylib.lookupFunction<_c_av_md5_init, _dart_av_md5_init>('av_md5_init');
    return _av_md5_init(
      ctx,
    );
  }

  _dart_av_md5_init _av_md5_init;

  void av_md5_update(
    ffi.Pointer<AVMD5> ctx,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    _av_md5_update ??= _dylib
        .lookupFunction<_c_av_md5_update, _dart_av_md5_update>('av_md5_update');
    return _av_md5_update(
      ctx,
      src,
      len,
    );
  }

  _dart_av_md5_update _av_md5_update;

  /// Finish hashing and output digest value.
  ///
  /// @param ctx hash function context
  /// @param dst buffer where output digest value is stored
  void av_md5_final(
    ffi.Pointer<AVMD5> ctx,
    ffi.Pointer<ffi.Uint8> dst,
  ) {
    _av_md5_final ??= _dylib
        .lookupFunction<_c_av_md5_final, _dart_av_md5_final>('av_md5_final');
    return _av_md5_final(
      ctx,
      dst,
    );
  }

  _dart_av_md5_final _av_md5_final;

  void av_md5_sum(
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    _av_md5_sum ??=
        _dylib.lookupFunction<_c_av_md5_sum, _dart_av_md5_sum>('av_md5_sum');
    return _av_md5_sum(
      dst,
      src,
      len,
    );
  }

  _dart_av_md5_sum _av_md5_sum;

  /// Allocate an AVMurMur3 hash context.
  ///
  /// @return Uninitialized hash context or `NULL` in case of error
  ffi.Pointer<AVMurMur3> av_murmur3_alloc() {
    _av_murmur3_alloc ??=
        _dylib.lookupFunction<_c_av_murmur3_alloc, _dart_av_murmur3_alloc>(
            'av_murmur3_alloc');
    return _av_murmur3_alloc();
  }

  _dart_av_murmur3_alloc _av_murmur3_alloc;

  /// Initialize or reinitialize an AVMurMur3 hash context with a seed.
  ///
  /// @param[out] c    Hash context
  /// @param[in]  seed Random seed
  ///
  /// @see av_murmur3_init()
  /// @see @ref lavu_murmur3_seedinfo "Detailed description" on a discussion of
  /// seeds for MurmurHash3.
  void av_murmur3_init_seeded(
    ffi.Pointer<AVMurMur3> c,
    int seed,
  ) {
    _av_murmur3_init_seeded ??= _dylib.lookupFunction<_c_av_murmur3_init_seeded,
        _dart_av_murmur3_init_seeded>('av_murmur3_init_seeded');
    return _av_murmur3_init_seeded(
      c,
      seed,
    );
  }

  _dart_av_murmur3_init_seeded _av_murmur3_init_seeded;

  /// Initialize or reinitialize an AVMurMur3 hash context.
  ///
  /// Equivalent to av_murmur3_init_seeded() with a built-in seed.
  ///
  /// @param[out] c    Hash context
  ///
  /// @see av_murmur3_init_seeded()
  /// @see @ref lavu_murmur3_seedinfo "Detailed description" on a discussion of
  /// seeds for MurmurHash3.
  void av_murmur3_init(
    ffi.Pointer<AVMurMur3> c,
  ) {
    _av_murmur3_init ??=
        _dylib.lookupFunction<_c_av_murmur3_init, _dart_av_murmur3_init>(
            'av_murmur3_init');
    return _av_murmur3_init(
      c,
    );
  }

  _dart_av_murmur3_init _av_murmur3_init;

  void av_murmur3_update(
    ffi.Pointer<AVMurMur3> c,
    ffi.Pointer<ffi.Uint8> src,
    int len,
  ) {
    _av_murmur3_update ??=
        _dylib.lookupFunction<_c_av_murmur3_update, _dart_av_murmur3_update>(
            'av_murmur3_update');
    return _av_murmur3_update(
      c,
      src,
      len,
    );
  }

  _dart_av_murmur3_update _av_murmur3_update;

  /// Finish hashing and output digest value.
  ///
  /// @param[in,out] c    Hash context
  /// @param[out]    dst  Buffer where output digest value is stored
  void av_murmur3_final(
    ffi.Pointer<AVMurMur3> c,
    ffi.Pointer<ffi.Uint8> dst,
  ) {
    _av_murmur3_final ??=
        _dylib.lookupFunction<_c_av_murmur3_final, _dart_av_murmur3_final>(
            'av_murmur3_final');
    return _av_murmur3_final(
      c,
      dst,
    );
  }

  _dart_av_murmur3_final _av_murmur3_final;

  /// Parse str and store the parsed ratio in q.
  ///
  /// Note that a ratio with infinite (1/0) or negative value is
  /// considered valid, so you should check on the returned value if you
  /// want to exclude those values.
  ///
  /// The undefined value can be expressed using the "0:0" string.
  ///
  /// @param[in,out] q pointer to the AVRational which will contain the ratio
  /// @param[in] str the string to parse: it has to be a string in the format
  /// num:den, a float number or an expression
  /// @param[in] max the maximum allowed numerator and denominator
  /// @param[in] log_offset log level offset which is applied to the log
  /// level of log_ctx
  /// @param[in] log_ctx parent logging context
  /// @return >= 0 on success, a negative error code otherwise
  int av_parse_ratio(
    ffi.Pointer<AVRational> q,
    ffi.Pointer<ffi.Int8> str,
    int max,
    int log_offset,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_parse_ratio ??=
        _dylib.lookupFunction<_c_av_parse_ratio, _dart_av_parse_ratio>(
            'av_parse_ratio');
    return _av_parse_ratio(
      q,
      str,
      max,
      log_offset,
      log_ctx,
    );
  }

  _dart_av_parse_ratio _av_parse_ratio;

  /// Parse str and put in width_ptr and height_ptr the detected values.
  ///
  /// @param[in,out] width_ptr pointer to the variable which will contain the detected
  /// width value
  /// @param[in,out] height_ptr pointer to the variable which will contain the detected
  /// height value
  /// @param[in] str the string to parse: it has to be a string in the format
  /// width x height or a valid video size abbreviation.
  /// @return >= 0 on success, a negative error code otherwise
  int av_parse_video_size(
    ffi.Pointer<ffi.Int32> width_ptr,
    ffi.Pointer<ffi.Int32> height_ptr,
    ffi.Pointer<ffi.Int8> str,
  ) {
    _av_parse_video_size ??= _dylib.lookupFunction<_c_av_parse_video_size,
        _dart_av_parse_video_size>('av_parse_video_size');
    return _av_parse_video_size(
      width_ptr,
      height_ptr,
      str,
    );
  }

  _dart_av_parse_video_size _av_parse_video_size;

  /// Parse str and store the detected values in *rate.
  ///
  /// @param[in,out] rate pointer to the AVRational which will contain the detected
  /// frame rate
  /// @param[in] str the string to parse: it has to be a string in the format
  /// rate_num / rate_den, a float number or a valid video rate abbreviation
  /// @return >= 0 on success, a negative error code otherwise
  int av_parse_video_rate(
    ffi.Pointer<AVRational> rate,
    ffi.Pointer<ffi.Int8> str,
  ) {
    _av_parse_video_rate ??= _dylib.lookupFunction<_c_av_parse_video_rate,
        _dart_av_parse_video_rate>('av_parse_video_rate');
    return _av_parse_video_rate(
      rate,
      str,
    );
  }

  _dart_av_parse_video_rate _av_parse_video_rate;

  /// Put the RGBA values that correspond to color_string in rgba_color.
  ///
  /// @param color_string a string specifying a color. It can be the name of
  /// a color (case insensitive match) or a [0x|#]RRGGBB[AA] sequence,
  /// possibly followed by "@" and a string representing the alpha
  /// component.
  /// The alpha component may be a string composed by "0x" followed by an
  /// hexadecimal number or a decimal number between 0.0 and 1.0, which
  /// represents the opacity value (0x00/0.0 means completely transparent,
  /// 0xff/1.0 completely opaque).
  /// If the alpha component is not specified then 0xff is assumed.
  /// The string "random" will result in a random color.
  /// @param slen length of the initial part of color_string containing the
  /// color. It can be set to -1 if color_string is a null terminated string
  /// containing nothing else than the color.
  /// @return >= 0 in case of success, a negative value in case of
  /// failure (for example if color_string cannot be parsed).
  int av_parse_color(
    ffi.Pointer<ffi.Uint8> rgba_color,
    ffi.Pointer<ffi.Int8> color_string,
    int slen,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_parse_color ??=
        _dylib.lookupFunction<_c_av_parse_color, _dart_av_parse_color>(
            'av_parse_color');
    return _av_parse_color(
      rgba_color,
      color_string,
      slen,
      log_ctx,
    );
  }

  _dart_av_parse_color _av_parse_color;

  /// Get the name of a color from the internal table of hard-coded named
  /// colors.
  ///
  /// This function is meant to enumerate the color names recognized by
  /// av_parse_color().
  ///
  /// @param color_idx index of the requested color, starting from 0
  /// @param rgbp      if not NULL, will point to a 3-elements array with the color value in RGB
  /// @return the color name string or NULL if color_idx is not in the array
  ffi.Pointer<ffi.Int8> av_get_known_color_name(
    int color_idx,
    ffi.Pointer<ffi.Pointer<ffi.Uint8>> rgb,
  ) {
    _av_get_known_color_name ??= _dylib.lookupFunction<
        _c_av_get_known_color_name,
        _dart_av_get_known_color_name>('av_get_known_color_name');
    return _av_get_known_color_name(
      color_idx,
      rgb,
    );
  }

  _dart_av_get_known_color_name _av_get_known_color_name;

  /// Parse timestr and return in *time a corresponding number of
  /// microseconds.
  ///
  /// @param timeval puts here the number of microseconds corresponding
  /// to the string in timestr. If the string represents a duration, it
  /// is the number of microseconds contained in the time interval.  If
  /// the string is a date, is the number of microseconds since 1st of
  /// January, 1970 up to the time of the parsed date.  If timestr cannot
  /// be successfully parsed, set *time to INT64_MIN.
  ///
  /// @param timestr a string representing a date or a duration.
  /// - If a date the syntax is:
  /// @code
  /// [{YYYY-MM-DD|YYYYMMDD}[T|t| ]]{{HH:MM:SS[.m...]]]}|{HHMMSS[.m...]]]}}[Z]
  /// now
  /// @endcode
  /// If the value is "now" it takes the current time.
  /// Time is local time unless Z is appended, in which case it is
  /// interpreted as UTC.
  /// If the year-month-day part is not specified it takes the current
  /// year-month-day.
  /// - If a duration the syntax is:
  /// @code
  /// [-][HH:]MM:SS[.m...]
  /// [-]S+[.m...]
  /// @endcode
  /// @param duration flag which tells how to interpret timestr, if not
  /// zero timestr is interpreted as a duration, otherwise as a date
  /// @return >= 0 in case of success, a negative value corresponding to an
  /// AVERROR code otherwise
  int av_parse_time(
    ffi.Pointer<ffi.Int64> timeval,
    ffi.Pointer<ffi.Int8> timestr,
    int duration,
  ) {
    _av_parse_time ??= _dylib
        .lookupFunction<_c_av_parse_time, _dart_av_parse_time>('av_parse_time');
    return _av_parse_time(
      timeval,
      timestr,
      duration,
    );
  }

  _dart_av_parse_time _av_parse_time;

  /// Attempt to find a specific tag in a URL.
  ///
  /// syntax: '?tag1=val1&tag2=val2...'. Little URL decoding is done.
  /// Return 1 if found.
  int av_find_info_tag(
    ffi.Pointer<ffi.Int8> arg,
    int arg_size,
    ffi.Pointer<ffi.Int8> tag1,
    ffi.Pointer<ffi.Int8> info,
  ) {
    _av_find_info_tag ??=
        _dylib.lookupFunction<_c_av_find_info_tag, _dart_av_find_info_tag>(
            'av_find_info_tag');
    return _av_find_info_tag(
      arg,
      arg_size,
      tag1,
      info,
    );
  }

  _dart_av_find_info_tag _av_find_info_tag;

  /// Simplified version of strptime
  ///
  /// Parse the input string p according to the format string fmt and
  /// store its results in the structure dt.
  /// This implementation supports only a subset of the formats supported
  /// by the standard strptime().
  ///
  /// The supported input field descriptors are listed below.
  /// - %H: the hour as a decimal number, using a 24-hour clock, in the
  /// range '00' through '23'
  /// - %J: hours as a decimal number, in the range '0' through INT_MAX
  /// - %M: the minute as a decimal number, using a 24-hour clock, in the
  /// range '00' through '59'
  /// - %S: the second as a decimal number, using a 24-hour clock, in the
  /// range '00' through '59'
  /// - %Y: the year as a decimal number, using the Gregorian calendar
  /// - %m: the month as a decimal number, in the range '1' through '12'
  /// - %d: the day of the month as a decimal number, in the range '1'
  /// through '31'
  /// - %T: alias for '%H:%M:%S'
  /// - %%: a literal '%'
  ///
  /// @return a pointer to the first character not processed in this function
  /// call. In case the input string contains more characters than
  /// required by the format string the return value points right after
  /// the last consumed input character. In case the whole input string
  /// is consumed the return value points to the null byte at the end of
  /// the string. On failure NULL is returned.
  ffi.Pointer<ffi.Int8> av_small_strptime(
    ffi.Pointer<ffi.Int8> p,
    ffi.Pointer<ffi.Int8> fmt,
    ffi.Pointer<tm> dt,
  ) {
    _av_small_strptime ??=
        _dylib.lookupFunction<_c_av_small_strptime, _dart_av_small_strptime>(
            'av_small_strptime');
    return _av_small_strptime(
      p,
      fmt,
      dt,
    );
  }

  _dart_av_small_strptime _av_small_strptime;

  /// Convert the decomposed UTC time in tm to a time_t value.
  int av_timegm(
    ffi.Pointer<tm> tm,
  ) {
    _av_timegm ??=
        _dylib.lookupFunction<_c_av_timegm, _dart_av_timegm>('av_timegm');
    return _av_timegm(
      tm,
    );
  }

  _dart_av_timegm _av_timegm;

  /// Get a potentially optimized pointer to a Sum-of-absolute-differences
  /// function (see the av_pixelutils_sad_fn prototype).
  ///
  /// @param w_bits  1<<w_bits is the requested width of the block size
  /// @param h_bits  1<<h_bits is the requested height of the block size
  /// @param aligned If set to 2, the returned sad function will assume src1 and
  /// src2 addresses are aligned on the block size.
  /// If set to 1, the returned sad function will assume src1 is
  /// aligned on the block size.
  /// If set to 0, the returned sad function assume no particular
  /// alignment.
  /// @param log_ctx context used for logging, can be NULL
  ///
  /// @return a pointer to the SAD function or NULL in case of error (because of
  /// invalid parameters)
  ffi.Pointer<ffi.NativeFunction<av_pixelutils_sad_fn>>
      av_pixelutils_get_sad_fn(
    int w_bits,
    int h_bits,
    int aligned,
    ffi.Pointer<ffi.Void> log_ctx,
  ) {
    _av_pixelutils_get_sad_fn ??= _dylib.lookupFunction<
        _c_av_pixelutils_get_sad_fn,
        _dart_av_pixelutils_get_sad_fn>('av_pixelutils_get_sad_fn');
    return _av_pixelutils_get_sad_fn(
      w_bits,
      h_bits,
      aligned,
      log_ctx,
    );
  }

  _dart_av_pixelutils_get_sad_fn _av_pixelutils_get_sad_fn;

  /// Get a seed to use in conjunction with random functions.
  /// This function tries to provide a good seed at a best effort bases.
  /// Its possible to call this function multiple times if more bits are needed.
  /// It can be quite slow, which is why it should only be used as seed for a faster
  /// PRNG. The quality of the seed depends on the platform.
  int av_get_random_seed() {
    _av_get_random_seed ??=
        _dylib.lookupFunction<_c_av_get_random_seed, _dart_av_get_random_seed>(
            'av_get_random_seed');
    return _av_get_random_seed();
  }

  _dart_av_get_random_seed _av_get_random_seed;

  /// Allocate an AVRC4 context.
  ffi.Pointer<AVRC4> av_rc4_alloc() {
    _av_rc4_alloc ??= _dylib
        .lookupFunction<_c_av_rc4_alloc, _dart_av_rc4_alloc>('av_rc4_alloc');
    return _av_rc4_alloc();
  }

  _dart_av_rc4_alloc _av_rc4_alloc;

  /// @brief Initializes an AVRC4 context.
  ///
  /// @param key_bits must be a multiple of 8
  /// @param decrypt 0 for encryption, 1 for decryption, currently has no effect
  /// @return zero on success, negative value otherwise
  int av_rc4_init(
    ffi.Pointer<AVRC4> d,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
    int decrypt,
  ) {
    _av_rc4_init ??=
        _dylib.lookupFunction<_c_av_rc4_init, _dart_av_rc4_init>('av_rc4_init');
    return _av_rc4_init(
      d,
      key,
      key_bits,
      decrypt,
    );
  }

  _dart_av_rc4_init _av_rc4_init;

  /// @brief Encrypts / decrypts using the RC4 algorithm.
  ///
  /// @param count number of bytes
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst, may be NULL
  /// @param iv not (yet) used for RC4, should be NULL
  /// @param decrypt 0 for encryption, 1 for decryption, not (yet) used
  void av_rc4_crypt(
    ffi.Pointer<AVRC4> d,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_rc4_crypt ??= _dylib
        .lookupFunction<_c_av_rc4_crypt, _dart_av_rc4_crypt>('av_rc4_crypt');
    return _av_rc4_crypt(
      d,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_rc4_crypt _av_rc4_crypt;

  /// Allocate an AVRIPEMD context.
  ffi.Pointer<AVRIPEMD> av_ripemd_alloc() {
    _av_ripemd_alloc ??=
        _dylib.lookupFunction<_c_av_ripemd_alloc, _dart_av_ripemd_alloc>(
            'av_ripemd_alloc');
    return _av_ripemd_alloc();
  }

  _dart_av_ripemd_alloc _av_ripemd_alloc;

  /// Initialize RIPEMD hashing.
  ///
  /// @param context pointer to the function context (of size av_ripemd_size)
  /// @param bits    number of bits in digest (128, 160, 256 or 320 bits)
  /// @return        zero if initialization succeeded, -1 otherwise
  int av_ripemd_init(
    ffi.Pointer<AVRIPEMD> context,
    int bits,
  ) {
    _av_ripemd_init ??=
        _dylib.lookupFunction<_c_av_ripemd_init, _dart_av_ripemd_init>(
            'av_ripemd_init');
    return _av_ripemd_init(
      context,
      bits,
    );
  }

  _dart_av_ripemd_init _av_ripemd_init;

  void av_ripemd_update(
    ffi.Pointer<AVRIPEMD> context,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    _av_ripemd_update ??=
        _dylib.lookupFunction<_c_av_ripemd_update, _dart_av_ripemd_update>(
            'av_ripemd_update');
    return _av_ripemd_update(
      context,
      data,
      len,
    );
  }

  _dart_av_ripemd_update _av_ripemd_update;

  /// Finish hashing and output digest value.
  ///
  /// @param context hash function context
  /// @param digest  buffer where output digest value is stored
  void av_ripemd_final(
    ffi.Pointer<AVRIPEMD> context,
    ffi.Pointer<ffi.Uint8> digest,
  ) {
    _av_ripemd_final ??=
        _dylib.lookupFunction<_c_av_ripemd_final, _dart_av_ripemd_final>(
            'av_ripemd_final');
    return _av_ripemd_final(
      context,
      digest,
    );
  }

  _dart_av_ripemd_final _av_ripemd_final;

  /// Allocate an AVSHA context.
  ffi.Pointer<AVSHA> av_sha_alloc() {
    _av_sha_alloc ??= _dylib
        .lookupFunction<_c_av_sha_alloc, _dart_av_sha_alloc>('av_sha_alloc');
    return _av_sha_alloc();
  }

  _dart_av_sha_alloc _av_sha_alloc;

  /// Initialize SHA-1 or SHA-2 hashing.
  ///
  /// @param context pointer to the function context (of size av_sha_size)
  /// @param bits    number of bits in digest (SHA-1 - 160 bits, SHA-2 224 or 256 bits)
  /// @return        zero if initialization succeeded, -1 otherwise
  int av_sha_init(
    ffi.Pointer<AVSHA> context,
    int bits,
  ) {
    _av_sha_init ??=
        _dylib.lookupFunction<_c_av_sha_init, _dart_av_sha_init>('av_sha_init');
    return _av_sha_init(
      context,
      bits,
    );
  }

  _dart_av_sha_init _av_sha_init;

  void av_sha_update(
    ffi.Pointer<AVSHA> ctx,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    _av_sha_update ??= _dylib
        .lookupFunction<_c_av_sha_update, _dart_av_sha_update>('av_sha_update');
    return _av_sha_update(
      ctx,
      data,
      len,
    );
  }

  _dart_av_sha_update _av_sha_update;

  /// Finish hashing and output digest value.
  ///
  /// @param context hash function context
  /// @param digest  buffer where output digest value is stored
  void av_sha_final(
    ffi.Pointer<AVSHA> context,
    ffi.Pointer<ffi.Uint8> digest,
  ) {
    _av_sha_final ??= _dylib
        .lookupFunction<_c_av_sha_final, _dart_av_sha_final>('av_sha_final');
    return _av_sha_final(
      context,
      digest,
    );
  }

  _dart_av_sha_final _av_sha_final;

  /// Allocate an AVSHA512 context.
  ffi.Pointer<AVSHA512> av_sha512_alloc() {
    _av_sha512_alloc ??=
        _dylib.lookupFunction<_c_av_sha512_alloc, _dart_av_sha512_alloc>(
            'av_sha512_alloc');
    return _av_sha512_alloc();
  }

  _dart_av_sha512_alloc _av_sha512_alloc;

  /// Initialize SHA-2 512 hashing.
  ///
  /// @param context pointer to the function context (of size av_sha512_size)
  /// @param bits    number of bits in digest (224, 256, 384 or 512 bits)
  /// @return        zero if initialization succeeded, -1 otherwise
  int av_sha512_init(
    ffi.Pointer<AVSHA512> context,
    int bits,
  ) {
    _av_sha512_init ??=
        _dylib.lookupFunction<_c_av_sha512_init, _dart_av_sha512_init>(
            'av_sha512_init');
    return _av_sha512_init(
      context,
      bits,
    );
  }

  _dart_av_sha512_init _av_sha512_init;

  void av_sha512_update(
    ffi.Pointer<AVSHA512> context,
    ffi.Pointer<ffi.Uint8> data,
    int len,
  ) {
    _av_sha512_update ??=
        _dylib.lookupFunction<_c_av_sha512_update, _dart_av_sha512_update>(
            'av_sha512_update');
    return _av_sha512_update(
      context,
      data,
      len,
    );
  }

  _dart_av_sha512_update _av_sha512_update;

  /// Finish hashing and output digest value.
  ///
  /// @param context hash function context
  /// @param digest  buffer where output digest value is stored
  void av_sha512_final(
    ffi.Pointer<AVSHA512> context,
    ffi.Pointer<ffi.Uint8> digest,
  ) {
    _av_sha512_final ??=
        _dylib.lookupFunction<_c_av_sha512_final, _dart_av_sha512_final>(
            'av_sha512_final');
    return _av_sha512_final(
      context,
      digest,
    );
  }

  _dart_av_sha512_final _av_sha512_final;

  /// Allocate a AVSphericalVideo structure and initialize its fields to default
  /// values.
  ///
  /// @return the newly allocated struct or NULL on failure
  ffi.Pointer<AVSphericalMapping> av_spherical_alloc(
    ffi.Pointer<ffi.Uint64> size,
  ) {
    _av_spherical_alloc ??=
        _dylib.lookupFunction<_c_av_spherical_alloc, _dart_av_spherical_alloc>(
            'av_spherical_alloc');
    return _av_spherical_alloc(
      size,
    );
  }

  _dart_av_spherical_alloc _av_spherical_alloc;

  /// Convert the @ref bounding fields from an AVSphericalVideo
  /// from 0.32 fixed point to pixels.
  ///
  /// @param map    The AVSphericalVideo map to read bound values from.
  /// @param width  Width of the current frame or stream.
  /// @param height Height of the current frame or stream.
  /// @param left   Pixels from the left edge.
  /// @param top    Pixels from the top edge.
  /// @param right  Pixels from the right edge.
  /// @param bottom Pixels from the bottom edge.
  void av_spherical_tile_bounds(
    ffi.Pointer<AVSphericalMapping> map,
    int width,
    int height,
    ffi.Pointer<ffi.Uint64> left,
    ffi.Pointer<ffi.Uint64> top,
    ffi.Pointer<ffi.Uint64> right,
    ffi.Pointer<ffi.Uint64> bottom,
  ) {
    _av_spherical_tile_bounds ??= _dylib.lookupFunction<
        _c_av_spherical_tile_bounds,
        _dart_av_spherical_tile_bounds>('av_spherical_tile_bounds');
    return _av_spherical_tile_bounds(
      map,
      width,
      height,
      left,
      top,
      right,
      bottom,
    );
  }

  _dart_av_spherical_tile_bounds _av_spherical_tile_bounds;

  /// Provide a human-readable name of a given AVSphericalProjection.
  ///
  /// @param projection The input AVSphericalProjection.
  ///
  /// @return The name of the AVSphericalProjection, or "unknown".
  ffi.Pointer<ffi.Int8> av_spherical_projection_name(
    int projection,
  ) {
    _av_spherical_projection_name ??= _dylib.lookupFunction<
        _c_av_spherical_projection_name,
        _dart_av_spherical_projection_name>('av_spherical_projection_name');
    return _av_spherical_projection_name(
      projection,
    );
  }

  _dart_av_spherical_projection_name _av_spherical_projection_name;

  /// Get the AVSphericalProjection form a human-readable name.
  ///
  /// @param name The input string.
  ///
  /// @return The AVSphericalProjection value, or -1 if not found.
  int av_spherical_from_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_spherical_from_name ??= _dylib.lookupFunction<_c_av_spherical_from_name,
        _dart_av_spherical_from_name>('av_spherical_from_name');
    return _av_spherical_from_name(
      name,
    );
  }

  _dart_av_spherical_from_name _av_spherical_from_name;

  /// Allocate an AVStereo3D structure and set its fields to default values.
  /// The resulting struct can be freed using av_freep().
  ///
  /// @return An AVStereo3D filled with default values or NULL on failure.
  ffi.Pointer<AVStereo3D> av_stereo3d_alloc() {
    _av_stereo3d_alloc ??=
        _dylib.lookupFunction<_c_av_stereo3d_alloc, _dart_av_stereo3d_alloc>(
            'av_stereo3d_alloc');
    return _av_stereo3d_alloc();
  }

  _dart_av_stereo3d_alloc _av_stereo3d_alloc;

  /// Allocate a complete AVFrameSideData and add it to the frame.
  ///
  /// @param frame The frame which side data is added to.
  ///
  /// @return The AVStereo3D structure to be filled by caller.
  ffi.Pointer<AVStereo3D> av_stereo3d_create_side_data(
    ffi.Pointer<AVFrame> frame,
  ) {
    _av_stereo3d_create_side_data ??= _dylib.lookupFunction<
        _c_av_stereo3d_create_side_data,
        _dart_av_stereo3d_create_side_data>('av_stereo3d_create_side_data');
    return _av_stereo3d_create_side_data(
      frame,
    );
  }

  _dart_av_stereo3d_create_side_data _av_stereo3d_create_side_data;

  /// Provide a human-readable name of a given stereo3d type.
  ///
  /// @param type The input stereo3d type value.
  ///
  /// @return The name of the stereo3d value, or "unknown".
  ffi.Pointer<ffi.Int8> av_stereo3d_type_name(
    int type,
  ) {
    _av_stereo3d_type_name ??= _dylib.lookupFunction<_c_av_stereo3d_type_name,
        _dart_av_stereo3d_type_name>('av_stereo3d_type_name');
    return _av_stereo3d_type_name(
      type,
    );
  }

  _dart_av_stereo3d_type_name _av_stereo3d_type_name;

  /// Get the AVStereo3DType form a human-readable name.
  ///
  /// @param name The input string.
  ///
  /// @return The AVStereo3DType value, or -1 if not found.
  int av_stereo3d_from_name(
    ffi.Pointer<ffi.Int8> name,
  ) {
    _av_stereo3d_from_name ??= _dylib.lookupFunction<_c_av_stereo3d_from_name,
        _dart_av_stereo3d_from_name>('av_stereo3d_from_name');
    return _av_stereo3d_from_name(
      name,
    );
  }

  _dart_av_stereo3d_from_name _av_stereo3d_from_name;

  /// Allocate an AVTEA context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVTEA> av_tea_alloc() {
    _av_tea_alloc ??= _dylib
        .lookupFunction<_c_av_tea_alloc, _dart_av_tea_alloc>('av_tea_alloc');
    return _av_tea_alloc();
  }

  _dart_av_tea_alloc _av_tea_alloc;

  /// Initialize an AVTEA context.
  ///
  /// @param ctx an AVTEA context
  /// @param key a key of 16 bytes used for encryption/decryption
  /// @param rounds the number of rounds in TEA (64 is the "standard")
  void av_tea_init(
    ffi.Pointer<AVTEA> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int rounds,
  ) {
    _av_tea_init ??=
        _dylib.lookupFunction<_c_av_tea_init, _dart_av_tea_init>('av_tea_init');
    return _av_tea_init(
      ctx,
      key,
      rounds,
    );
  }

  _dart_av_tea_init _av_tea_init;

  /// Encrypt or decrypt a buffer using a previously initialized context.
  ///
  /// @param ctx an AVTEA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_tea_crypt(
    ffi.Pointer<AVTEA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_tea_crypt ??= _dylib
        .lookupFunction<_c_av_tea_crypt, _dart_av_tea_crypt>('av_tea_crypt');
    return _av_tea_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_tea_crypt _av_tea_crypt;

  /// Allocate a new message queue.
  ///
  /// @param mq      pointer to the message queue
  /// @param nelem   maximum number of elements in the queue
  /// @param elsize  size of each element in the queue
  /// @return  >=0 for success; <0 for error, in particular AVERROR(ENOSYS) if
  /// lavu was built without thread support
  int av_thread_message_queue_alloc(
    ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
    int nelem,
    int elsize,
  ) {
    _av_thread_message_queue_alloc ??= _dylib.lookupFunction<
        _c_av_thread_message_queue_alloc,
        _dart_av_thread_message_queue_alloc>('av_thread_message_queue_alloc');
    return _av_thread_message_queue_alloc(
      mq,
      nelem,
      elsize,
    );
  }

  _dart_av_thread_message_queue_alloc _av_thread_message_queue_alloc;

  /// Free a message queue.
  ///
  /// The message queue must no longer be in use by another thread.
  void av_thread_message_queue_free(
    ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
  ) {
    _av_thread_message_queue_free ??= _dylib.lookupFunction<
        _c_av_thread_message_queue_free,
        _dart_av_thread_message_queue_free>('av_thread_message_queue_free');
    return _av_thread_message_queue_free(
      mq,
    );
  }

  _dart_av_thread_message_queue_free _av_thread_message_queue_free;

  /// Send a message on the queue.
  int av_thread_message_queue_send(
    ffi.Pointer<AVThreadMessageQueue> mq,
    ffi.Pointer<ffi.Void> msg,
    int flags,
  ) {
    _av_thread_message_queue_send ??= _dylib.lookupFunction<
        _c_av_thread_message_queue_send,
        _dart_av_thread_message_queue_send>('av_thread_message_queue_send');
    return _av_thread_message_queue_send(
      mq,
      msg,
      flags,
    );
  }

  _dart_av_thread_message_queue_send _av_thread_message_queue_send;

  /// Receive a message from the queue.
  int av_thread_message_queue_recv(
    ffi.Pointer<AVThreadMessageQueue> mq,
    ffi.Pointer<ffi.Void> msg,
    int flags,
  ) {
    _av_thread_message_queue_recv ??= _dylib.lookupFunction<
        _c_av_thread_message_queue_recv,
        _dart_av_thread_message_queue_recv>('av_thread_message_queue_recv');
    return _av_thread_message_queue_recv(
      mq,
      msg,
      flags,
    );
  }

  _dart_av_thread_message_queue_recv _av_thread_message_queue_recv;

  /// Set the sending error code.
  ///
  /// If the error code is set to non-zero, av_thread_message_queue_send() will
  /// return it immediately. Conventional values, such as AVERROR_EOF or
  /// AVERROR(EAGAIN), can be used to cause the sending thread to stop or
  /// suspend its operation.
  void av_thread_message_queue_set_err_send(
    ffi.Pointer<AVThreadMessageQueue> mq,
    int err,
  ) {
    _av_thread_message_queue_set_err_send ??= _dylib.lookupFunction<
            _c_av_thread_message_queue_set_err_send,
            _dart_av_thread_message_queue_set_err_send>(
        'av_thread_message_queue_set_err_send');
    return _av_thread_message_queue_set_err_send(
      mq,
      err,
    );
  }

  _dart_av_thread_message_queue_set_err_send
      _av_thread_message_queue_set_err_send;

  /// Set the receiving error code.
  ///
  /// If the error code is set to non-zero, av_thread_message_queue_recv() will
  /// return it immediately when there are no longer available messages.
  /// Conventional values, such as AVERROR_EOF or AVERROR(EAGAIN), can be used
  /// to cause the receiving thread to stop or suspend its operation.
  void av_thread_message_queue_set_err_recv(
    ffi.Pointer<AVThreadMessageQueue> mq,
    int err,
  ) {
    _av_thread_message_queue_set_err_recv ??= _dylib.lookupFunction<
            _c_av_thread_message_queue_set_err_recv,
            _dart_av_thread_message_queue_set_err_recv>(
        'av_thread_message_queue_set_err_recv');
    return _av_thread_message_queue_set_err_recv(
      mq,
      err,
    );
  }

  _dart_av_thread_message_queue_set_err_recv
      _av_thread_message_queue_set_err_recv;

  /// Set the optional free message callback function which will be called if an
  /// operation is removing messages from the queue.
  void av_thread_message_queue_set_free_func(
    ffi.Pointer<AVThreadMessageQueue> mq,
    ffi.Pointer<ffi.NativeFunction<_typedefC_104>> free_func,
  ) {
    _av_thread_message_queue_set_free_func ??= _dylib.lookupFunction<
            _c_av_thread_message_queue_set_free_func,
            _dart_av_thread_message_queue_set_free_func>(
        'av_thread_message_queue_set_free_func');
    return _av_thread_message_queue_set_free_func(
      mq,
      free_func,
    );
  }

  _dart_av_thread_message_queue_set_free_func
      _av_thread_message_queue_set_free_func;

  /// Return the current number of messages in the queue.
  ///
  /// @return the current number of messages or AVERROR(ENOSYS) if lavu was built
  /// without thread support
  int av_thread_message_queue_nb_elems(
    ffi.Pointer<AVThreadMessageQueue> mq,
  ) {
    _av_thread_message_queue_nb_elems ??= _dylib.lookupFunction<
            _c_av_thread_message_queue_nb_elems,
            _dart_av_thread_message_queue_nb_elems>(
        'av_thread_message_queue_nb_elems');
    return _av_thread_message_queue_nb_elems(
      mq,
    );
  }

  _dart_av_thread_message_queue_nb_elems _av_thread_message_queue_nb_elems;

  /// Flush the message queue
  ///
  /// This function is mostly equivalent to reading and free-ing every message
  /// except that it will be done in a single operation (no lock/unlock between
  /// reads).
  void av_thread_message_flush(
    ffi.Pointer<AVThreadMessageQueue> mq,
  ) {
    _av_thread_message_flush ??= _dylib.lookupFunction<
        _c_av_thread_message_flush,
        _dart_av_thread_message_flush>('av_thread_message_flush');
    return _av_thread_message_flush(
      mq,
    );
  }

  _dart_av_thread_message_flush _av_thread_message_flush;

  /// Get the current time in microseconds.
  int av_gettime() {
    _av_gettime ??=
        _dylib.lookupFunction<_c_av_gettime, _dart_av_gettime>('av_gettime');
    return _av_gettime();
  }

  _dart_av_gettime _av_gettime;

  /// Get the current time in microseconds since some unspecified starting point.
  /// On platforms that support it, the time comes from a monotonic clock
  /// This property makes this time source ideal for measuring relative time.
  /// The returned values may not be monotonic on platforms where a monotonic
  /// clock is not available.
  int av_gettime_relative() {
    _av_gettime_relative ??= _dylib.lookupFunction<_c_av_gettime_relative,
        _dart_av_gettime_relative>('av_gettime_relative');
    return _av_gettime_relative();
  }

  _dart_av_gettime_relative _av_gettime_relative;

  /// Indicates with a boolean result if the av_gettime_relative() time source
  /// is monotonic.
  int av_gettime_relative_is_monotonic() {
    _av_gettime_relative_is_monotonic ??= _dylib.lookupFunction<
            _c_av_gettime_relative_is_monotonic,
            _dart_av_gettime_relative_is_monotonic>(
        'av_gettime_relative_is_monotonic');
    return _av_gettime_relative_is_monotonic();
  }

  _dart_av_gettime_relative_is_monotonic _av_gettime_relative_is_monotonic;

  /// Sleep for a period of time.  Although the duration is expressed in
  /// microseconds, the actual delay may be rounded to the precision of the
  /// system timer.
  ///
  /// @param  usec Number of microseconds to sleep.
  /// @return zero on success or (negative) error code.
  int av_usleep(
    int usec,
  ) {
    _av_usleep ??=
        _dylib.lookupFunction<_c_av_usleep, _dart_av_usleep>('av_usleep');
    return _av_usleep(
      usec,
    );
  }

  _dart_av_usleep _av_usleep;

  /// Adjust frame number for NTSC drop frame time code.
  ///
  /// @param framenum frame number to adjust
  /// @param fps      frame per second, multiples of 30
  /// @return         adjusted frame number
  /// @warning        adjustment is only valid for multiples of NTSC 29.97
  int av_timecode_adjust_ntsc_framenum2(
    int framenum,
    int fps,
  ) {
    _av_timecode_adjust_ntsc_framenum2 ??= _dylib.lookupFunction<
            _c_av_timecode_adjust_ntsc_framenum2,
            _dart_av_timecode_adjust_ntsc_framenum2>(
        'av_timecode_adjust_ntsc_framenum2');
    return _av_timecode_adjust_ntsc_framenum2(
      framenum,
      fps,
    );
  }

  _dart_av_timecode_adjust_ntsc_framenum2 _av_timecode_adjust_ntsc_framenum2;

  /// Convert frame number to SMPTE 12M binary representation.
  ///
  /// @param tc       timecode data correctly initialized
  /// @param framenum frame number
  /// @return         the SMPTE binary representation
  ///
  /// See SMPTE ST 314M-2005 Sec 4.4.2.2.1 "Time code pack (TC)"
  /// the format description as follows:
  /// bits 0-5:   hours, in BCD(6bits)
  /// bits 6:     BGF1
  /// bits 7:     BGF2 (NTSC) or FIELD (PAL)
  /// bits 8-14:  minutes, in BCD(7bits)
  /// bits 15:    BGF0 (NTSC) or BGF2 (PAL)
  /// bits 16-22: seconds, in BCD(7bits)
  /// bits 23:    FIELD (NTSC) or BGF0 (PAL)
  /// bits 24-29: frames, in BCD(6bits)
  /// bits 30:    drop  frame flag (0: non drop,    1: drop)
  /// bits 31:    color frame flag (0: unsync mode, 1: sync mode)
  /// @note BCD numbers (6 or 7 bits): 4 or 5 lower bits for units, 2 higher bits for tens.
  /// @note Frame number adjustment is automatically done in case of drop timecode,
  /// you do NOT have to call av_timecode_adjust_ntsc_framenum2().
  /// @note The frame number is relative to tc->start.
  /// @note Color frame (CF) and binary group flags (BGF) bits are set to zero.
  int av_timecode_get_smpte_from_framenum(
    ffi.Pointer<AVTimecode> tc,
    int framenum,
  ) {
    _av_timecode_get_smpte_from_framenum ??= _dylib.lookupFunction<
            _c_av_timecode_get_smpte_from_framenum,
            _dart_av_timecode_get_smpte_from_framenum>(
        'av_timecode_get_smpte_from_framenum');
    return _av_timecode_get_smpte_from_framenum(
      tc,
      framenum,
    );
  }

  _dart_av_timecode_get_smpte_from_framenum
      _av_timecode_get_smpte_from_framenum;

  /// Load timecode string in buf.
  ///
  /// @param buf      destination buffer, must be at least AV_TIMECODE_STR_SIZE long
  /// @param tc       timecode data correctly initialized
  /// @param framenum frame number
  /// @return         the buf parameter
  ///
  /// @note Timecode representation can be a negative timecode and have more than
  /// 24 hours, but will only be honored if the flags are correctly set.
  /// @note The frame number is relative to tc->start.
  ffi.Pointer<ffi.Int8> av_timecode_make_string(
    ffi.Pointer<AVTimecode> tc,
    ffi.Pointer<ffi.Int8> buf,
    int framenum,
  ) {
    _av_timecode_make_string ??= _dylib.lookupFunction<
        _c_av_timecode_make_string,
        _dart_av_timecode_make_string>('av_timecode_make_string');
    return _av_timecode_make_string(
      tc,
      buf,
      framenum,
    );
  }

  _dart_av_timecode_make_string _av_timecode_make_string;

  /// Get the timecode string from the SMPTE timecode format.
  ///
  /// @param buf        destination buffer, must be at least AV_TIMECODE_STR_SIZE long
  /// @param tcsmpte    the 32-bit SMPTE timecode
  /// @param prevent_df prevent the use of a drop flag when it is known the DF bit
  /// is arbitrary
  /// @return           the buf parameter
  ffi.Pointer<ffi.Int8> av_timecode_make_smpte_tc_string(
    ffi.Pointer<ffi.Int8> buf,
    int tcsmpte,
    int prevent_df,
  ) {
    _av_timecode_make_smpte_tc_string ??= _dylib.lookupFunction<
            _c_av_timecode_make_smpte_tc_string,
            _dart_av_timecode_make_smpte_tc_string>(
        'av_timecode_make_smpte_tc_string');
    return _av_timecode_make_smpte_tc_string(
      buf,
      tcsmpte,
      prevent_df,
    );
  }

  _dart_av_timecode_make_smpte_tc_string _av_timecode_make_smpte_tc_string;

  /// Get the timecode string from the 25-bit timecode format (MPEG GOP format).
  ///
  /// @param buf     destination buffer, must be at least AV_TIMECODE_STR_SIZE long
  /// @param tc25bit the 25-bits timecode
  /// @return        the buf parameter
  ffi.Pointer<ffi.Int8> av_timecode_make_mpeg_tc_string(
    ffi.Pointer<ffi.Int8> buf,
    int tc25bit,
  ) {
    _av_timecode_make_mpeg_tc_string ??= _dylib.lookupFunction<
            _c_av_timecode_make_mpeg_tc_string,
            _dart_av_timecode_make_mpeg_tc_string>(
        'av_timecode_make_mpeg_tc_string');
    return _av_timecode_make_mpeg_tc_string(
      buf,
      tc25bit,
    );
  }

  _dart_av_timecode_make_mpeg_tc_string _av_timecode_make_mpeg_tc_string;

  /// Fill the provided buffer with a string containing a timestamp
  /// representation.
  ///
  /// @param buf a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE
  /// @param ts the timestamp to represent
  /// @return the buffer in input
  ffi.Pointer<ffi.Int8> av_ts_make_string(
    ffi.Pointer<ffi.Int8> buf,
    int ts,
  ) {
    _av_ts_make_string ??=
        _dylib.lookupFunction<_c_av_ts_make_string, _dart_av_ts_make_string>(
            'av_ts_make_string');
    return _av_ts_make_string(
      buf,
      ts,
    );
  }

  _dart_av_ts_make_string _av_ts_make_string;

  /// Fill the provided buffer with a string containing a timestamp time
  /// representation.
  ///
  /// @param buf a buffer with size in bytes of at least AV_TS_MAX_STRING_SIZE
  /// @param ts the timestamp to represent
  /// @param tb the timebase of the timestamp
  /// @return the buffer in input
  ffi.Pointer<ffi.Int8> av_ts_make_time_string(
    ffi.Pointer<ffi.Int8> buf,
    int ts,
    ffi.Pointer<AVRational> tb,
  ) {
    _av_ts_make_time_string ??= _dylib.lookupFunction<_c_av_ts_make_time_string,
        _dart_av_ts_make_time_string>('av_ts_make_time_string');
    return _av_ts_make_time_string(
      buf,
      ts,
      tb,
    );
  }

  _dart_av_ts_make_time_string _av_ts_make_time_string;

  /// Allocate an AVTreeNode.
  ffi.Pointer<AVTreeNode> av_tree_node_alloc() {
    _av_tree_node_alloc ??=
        _dylib.lookupFunction<_c_av_tree_node_alloc, _dart_av_tree_node_alloc>(
            'av_tree_node_alloc');
    return _av_tree_node_alloc();
  }

  _dart_av_tree_node_alloc _av_tree_node_alloc;

  /// Find an element.
  /// @param root a pointer to the root node of the tree
  /// @param next If next is not NULL, then next[0] will contain the previous
  /// element and next[1] the next element. If either does not exist,
  /// then the corresponding entry in next is unchanged.
  /// @param cmp compare function used to compare elements in the tree,
  /// API identical to that of Standard C's qsort
  /// It is guaranteed that the first and only the first argument to cmp()
  /// will be the key parameter to av_tree_find(), thus it could if the
  /// user wants, be a different type (like an opaque context).
  /// @return An element with cmp(key, elem) == 0 or NULL if no such element
  /// exists in the tree.
  ffi.Pointer<ffi.Void> av_tree_find(
    ffi.Pointer<AVTreeNode> root,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.NativeFunction<_typedefC_105>> cmp,
    ffi.Pointer<ffi.Pointer<ffi.Void>> next,
  ) {
    _av_tree_find ??= _dylib
        .lookupFunction<_c_av_tree_find, _dart_av_tree_find>('av_tree_find');
    return _av_tree_find(
      root,
      key,
      cmp,
      next,
    );
  }

  _dart_av_tree_find _av_tree_find;

  /// Insert or remove an element.
  ///
  /// If *next is NULL, then the supplied element will be removed if it exists.
  /// If *next is non-NULL, then the supplied element will be inserted, unless
  /// it already exists in the tree.
  ///
  /// @param rootp A pointer to a pointer to the root node of the tree; note that
  /// the root node can change during insertions, this is required
  /// to keep the tree balanced.
  /// @param key  pointer to the element key to insert in the tree
  /// @param next Used to allocate and free AVTreeNodes. For insertion the user
  /// must set it to an allocated and zeroed object of at least
  /// av_tree_node_size bytes size. av_tree_insert() will set it to
  /// NULL if it has been consumed.
  /// For deleting elements *next is set to NULL by the user and
  /// av_tree_insert() will set it to the AVTreeNode which was
  /// used for the removed element.
  /// This allows the use of flat arrays, which have
  /// lower overhead compared to many malloced elements.
  /// You might want to define a function like:
  /// @code
  /// void *tree_insert(struct AVTreeNode **rootp, void *key,
  /// int (*cmp)(void *key, const void *b),
  /// AVTreeNode **next)
  /// {
  /// if (!*next)
  /// *next = av_mallocz(av_tree_node_size);
  /// return av_tree_insert(rootp, key, cmp, next);
  /// }
  /// void *tree_remove(struct AVTreeNode **rootp, void *key,
  /// int (*cmp)(void *key, const void *b, AVTreeNode **next))
  /// {
  /// av_freep(next);
  /// return av_tree_insert(rootp, key, cmp, next);
  /// }
  /// @endcode
  /// @param cmp compare function used to compare elements in the tree, API identical
  /// to that of Standard C's qsort
  /// @return If no insertion happened, the found element; if an insertion or
  /// removal happened, then either key or NULL will be returned.
  /// Which one it is depends on the tree state and the implementation. You
  /// should make no assumptions that it's one or the other in the code.
  ffi.Pointer<ffi.Void> av_tree_insert(
    ffi.Pointer<ffi.Pointer<AVTreeNode>> rootp,
    ffi.Pointer<ffi.Void> key,
    ffi.Pointer<ffi.NativeFunction<_typedefC_106>> cmp,
    ffi.Pointer<ffi.Pointer<AVTreeNode>> next,
  ) {
    _av_tree_insert ??=
        _dylib.lookupFunction<_c_av_tree_insert, _dart_av_tree_insert>(
            'av_tree_insert');
    return _av_tree_insert(
      rootp,
      key,
      cmp,
      next,
    );
  }

  _dart_av_tree_insert _av_tree_insert;

  void av_tree_destroy(
    ffi.Pointer<AVTreeNode> t,
  ) {
    _av_tree_destroy ??=
        _dylib.lookupFunction<_c_av_tree_destroy, _dart_av_tree_destroy>(
            'av_tree_destroy');
    return _av_tree_destroy(
      t,
    );
  }

  _dart_av_tree_destroy _av_tree_destroy;

  /// Apply enu(opaque, &elem) to all the elements in the tree in a given range.
  ///
  /// @param cmp a comparison function that returns < 0 for an element below the
  /// range, > 0 for an element above the range and == 0 for an
  /// element inside the range
  ///
  /// @note The cmp function should use the same ordering used to construct the
  /// tree.
  void av_tree_enumerate(
    ffi.Pointer<AVTreeNode> t,
    ffi.Pointer<ffi.Void> opaque,
    ffi.Pointer<ffi.NativeFunction<_typedefC_107>> cmp,
    ffi.Pointer<ffi.NativeFunction<_typedefC_108>> enu,
  ) {
    _av_tree_enumerate ??=
        _dylib.lookupFunction<_c_av_tree_enumerate, _dart_av_tree_enumerate>(
            'av_tree_enumerate');
    return _av_tree_enumerate(
      t,
      opaque,
      cmp,
      enu,
    );
  }

  _dart_av_tree_enumerate _av_tree_enumerate;

  /// Allocate an AVTWOFISH context
  /// To free the struct: av_free(ptr)
  ffi.Pointer<AVTWOFISH> av_twofish_alloc() {
    _av_twofish_alloc ??=
        _dylib.lookupFunction<_c_av_twofish_alloc, _dart_av_twofish_alloc>(
            'av_twofish_alloc');
    return _av_twofish_alloc();
  }

  _dart_av_twofish_alloc _av_twofish_alloc;

  /// Initialize an AVTWOFISH context.
  ///
  /// @param ctx an AVTWOFISH context
  /// @param key a key of size ranging from 1 to 32 bytes used for encryption/decryption
  /// @param key_bits number of keybits: 128, 192, 256 If less than the required, padded with zeroes to nearest valid value; return value is 0 if key_bits is 128/192/256, -1 if less than 0, 1 otherwise
  int av_twofish_init(
    ffi.Pointer<AVTWOFISH> ctx,
    ffi.Pointer<ffi.Uint8> key,
    int key_bits,
  ) {
    _av_twofish_init ??=
        _dylib.lookupFunction<_c_av_twofish_init, _dart_av_twofish_init>(
            'av_twofish_init');
    return _av_twofish_init(
      ctx,
      key,
      key_bits,
    );
  }

  _dart_av_twofish_init _av_twofish_init;

  /// Encrypt or decrypt a buffer using a previously initialized context
  ///
  /// @param ctx an AVTWOFISH context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 16 byte blocks
  /// @paran iv initialization vector for CBC mode, NULL for ECB mode
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_twofish_crypt(
    ffi.Pointer<AVTWOFISH> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_twofish_crypt ??=
        _dylib.lookupFunction<_c_av_twofish_crypt, _dart_av_twofish_crypt>(
            'av_twofish_crypt');
    return _av_twofish_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_twofish_crypt _av_twofish_crypt;

  /// Initialize a transform context with the given configuration
  /// (i)MDCTs with an odd length are currently not supported.
  ///
  /// @param ctx the context to allocate, will be NULL on error
  /// @param tx pointer to the transform function pointer to set
  /// @param type type the type of transform
  /// @param inv whether to do an inverse or a forward transform
  /// @param len the size of the transform in samples
  /// @param scale pointer to the value to scale the output if supported by type
  /// @param flags currently unused
  ///
  /// @return 0 on success, negative error code on failure
  int av_tx_init(
    ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
    ffi.Pointer<ffi.Pointer<ffi.NativeFunction<av_tx_fn>>> tx,
    int type,
    int inv,
    int len,
    ffi.Pointer<ffi.Void> scale,
    int flags,
  ) {
    _av_tx_init ??=
        _dylib.lookupFunction<_c_av_tx_init, _dart_av_tx_init>('av_tx_init');
    return _av_tx_init(
      ctx,
      tx,
      type,
      inv,
      len,
      scale,
      flags,
    );
  }

  _dart_av_tx_init _av_tx_init;

  /// Frees a context and sets ctx to NULL, does nothing when ctx == NULL
  void av_tx_uninit(
    ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
  ) {
    _av_tx_uninit ??= _dylib
        .lookupFunction<_c_av_tx_uninit, _dart_av_tx_uninit>('av_tx_uninit');
    return _av_tx_uninit(
      ctx,
    );
  }

  _dart_av_tx_uninit _av_tx_uninit;

  ffi.Pointer<AVVideoBlockParams> av_video_enc_params_block(
    ffi.Pointer<AVVideoEncParams> par,
    int idx,
  ) {
    _av_video_enc_params_block ??= _dylib.lookupFunction<
        _c_av_video_enc_params_block,
        _dart_av_video_enc_params_block>('av_video_enc_params_block');
    return _av_video_enc_params_block(
      par,
      idx,
    );
  }

  _dart_av_video_enc_params_block _av_video_enc_params_block;

  /// Allocates memory for AVVideoEncParams of the given type, plus an array of
  /// {@code nb_blocks} AVVideoBlockParams and initializes the variables. Can be
  /// freed with a normal av_free() call.
  ///
  /// @param out_size if non-NULL, the size in bytes of the resulting data array is
  /// written here.
  ffi.Pointer<AVVideoEncParams> av_video_enc_params_alloc(
    int type,
    int nb_blocks,
    ffi.Pointer<ffi.Uint64> out_size,
  ) {
    _av_video_enc_params_alloc ??= _dylib.lookupFunction<
        _c_av_video_enc_params_alloc,
        _dart_av_video_enc_params_alloc>('av_video_enc_params_alloc');
    return _av_video_enc_params_alloc(
      type,
      nb_blocks,
      out_size,
    );
  }

  _dart_av_video_enc_params_alloc _av_video_enc_params_alloc;

  /// Allocates memory for AVEncodeInfoFrame plus an array of
  /// {@code nb_blocks} AVEncodeInfoBlock in the given AVFrame {@code frame}
  /// as AVFrameSideData of type AV_FRAME_DATA_VIDEO_ENC_PARAMS
  /// and initializes the variables.
  ffi.Pointer<AVVideoEncParams> av_video_enc_params_create_side_data(
    ffi.Pointer<AVFrame> frame,
    int type,
    int nb_blocks,
  ) {
    _av_video_enc_params_create_side_data ??= _dylib.lookupFunction<
            _c_av_video_enc_params_create_side_data,
            _dart_av_video_enc_params_create_side_data>(
        'av_video_enc_params_create_side_data');
    return _av_video_enc_params_create_side_data(
      frame,
      type,
      nb_blocks,
    );
  }

  _dart_av_video_enc_params_create_side_data
      _av_video_enc_params_create_side_data;

  /// Allocate an AVXTEA context.
  ffi.Pointer<AVXTEA> av_xtea_alloc() {
    _av_xtea_alloc ??= _dylib
        .lookupFunction<_c_av_xtea_alloc, _dart_av_xtea_alloc>('av_xtea_alloc');
    return _av_xtea_alloc();
  }

  _dart_av_xtea_alloc _av_xtea_alloc;

  /// Initialize an AVXTEA context.
  ///
  /// @param ctx an AVXTEA context
  /// @param key a key of 16 bytes used for encryption/decryption,
  /// interpreted as big endian 32 bit numbers
  void av_xtea_init(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> key,
  ) {
    _av_xtea_init ??= _dylib
        .lookupFunction<_c_av_xtea_init, _dart_av_xtea_init>('av_xtea_init');
    return _av_xtea_init(
      ctx,
      key,
    );
  }

  _dart_av_xtea_init _av_xtea_init;

  /// Initialize an AVXTEA context.
  ///
  /// @param ctx an AVXTEA context
  /// @param key a key of 16 bytes used for encryption/decryption,
  /// interpreted as little endian 32 bit numbers
  void av_xtea_le_init(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> key,
  ) {
    _av_xtea_le_init ??=
        _dylib.lookupFunction<_c_av_xtea_le_init, _dart_av_xtea_le_init>(
            'av_xtea_le_init');
    return _av_xtea_le_init(
      ctx,
      key,
    );
  }

  _dart_av_xtea_le_init _av_xtea_le_init;

  /// Encrypt or decrypt a buffer using a previously initialized context,
  /// in big endian format.
  ///
  /// @param ctx an AVXTEA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_xtea_crypt(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_xtea_crypt ??= _dylib
        .lookupFunction<_c_av_xtea_crypt, _dart_av_xtea_crypt>('av_xtea_crypt');
    return _av_xtea_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_xtea_crypt _av_xtea_crypt;

  /// Encrypt or decrypt a buffer using a previously initialized context,
  /// in little endian format.
  ///
  /// @param ctx an AVXTEA context
  /// @param dst destination array, can be equal to src
  /// @param src source array, can be equal to dst
  /// @param count number of 8 byte blocks
  /// @param iv initialization vector for CBC mode, if NULL then ECB will be used
  /// @param decrypt 0 for encryption, 1 for decryption
  void av_xtea_le_crypt(
    ffi.Pointer<AVXTEA> ctx,
    ffi.Pointer<ffi.Uint8> dst,
    ffi.Pointer<ffi.Uint8> src,
    int count,
    ffi.Pointer<ffi.Uint8> iv,
    int decrypt,
  ) {
    _av_xtea_le_crypt ??=
        _dylib.lookupFunction<_c_av_xtea_le_crypt, _dart_av_xtea_le_crypt>(
            'av_xtea_le_crypt');
    return _av_xtea_le_crypt(
      ctx,
      dst,
      src,
      count,
      iv,
      decrypt,
    );
  }

  _dart_av_xtea_le_crypt _av_xtea_le_crypt;
}

class max_align_t extends ffi.Struct {}

class __fsid_t extends ffi.Struct {
  @ffi.Int32()
  int _unique___val_item_0;
  @ffi.Int32()
  int _unique___val_item_1;

  /// Helper for array `__val`.
  ArrayHelper___fsid_t___val_level0 get __val =>
      ArrayHelper___fsid_t___val_level0(this, [2], 0, 0);
}

/// Helper for array `__val` in struct `__fsid_t`.
class ArrayHelper___fsid_t___val_level0 {
  final __fsid_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___fsid_t___val_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___val_item_0;
      case 1:
        return _struct._unique___val_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___val_item_0 = value;
        break;
      case 1:
        _struct._unique___val_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// @addtogroup lavu_media Media Type
/// @brief Media Type
abstract class AVMediaType {
  /// ///< Usually treated as AVMEDIA_TYPE_DATA
  static const int AVMEDIA_TYPE_UNKNOWN = -1;
  static const int AVMEDIA_TYPE_VIDEO = 0;
  static const int AVMEDIA_TYPE_AUDIO = 1;

  /// ///< Opaque data information usually continuous
  static const int AVMEDIA_TYPE_DATA = 2;
  static const int AVMEDIA_TYPE_SUBTITLE = 3;

  /// ///< Opaque data information usually sparse
  static const int AVMEDIA_TYPE_ATTACHMENT = 4;
  static const int AVMEDIA_TYPE_NB = 5;
}

/// @}
/// @}
/// @defgroup lavu_picture Image related
///
/// AVPicture types, pixel formats and basic image planes manipulation.
///
/// @{
abstract class AVPictureType {
  /// ///< Undefined
  static const int AV_PICTURE_TYPE_NONE = 0;

  /// ///< Intra
  static const int AV_PICTURE_TYPE_I = 1;

  /// ///< Predicted
  static const int AV_PICTURE_TYPE_P = 2;

  /// ///< Bi-dir predicted
  static const int AV_PICTURE_TYPE_B = 3;

  /// ///< S(GMC)-VOP MPEG-4
  static const int AV_PICTURE_TYPE_S = 4;

  /// ///< Switching Intra
  static const int AV_PICTURE_TYPE_SI = 5;

  /// ///< Switching Predicted
  static const int AV_PICTURE_TYPE_SP = 6;

  /// ///< BI type
  static const int AV_PICTURE_TYPE_BI = 7;
}

class imaxdiv_t extends ffi.Struct {
  @ffi.Int64()
  int quot;

  @ffi.Int64()
  int rem;
}

class __mbstate_t extends ffi.Struct {}

class __fpos_t extends ffi.Struct {}

class __fpos64_t extends ffi.Struct {}

class _IO_FILE extends ffi.Struct {}

class _IO_marker extends ffi.Struct {}

class _IO_codecvt extends ffi.Struct {}

class _IO_wide_data extends ffi.Struct {}

abstract class idtype_t {
  static const int P_ALL = 0;
  static const int P_PID = 1;
  static const int P_PGID = 2;
}

class div_t extends ffi.Struct {
  @ffi.Int32()
  int quot;

  @ffi.Int32()
  int rem;
}

class ldiv_t extends ffi.Struct {
  @ffi.Int64()
  int quot;

  @ffi.Int64()
  int rem;
}

class lldiv_t extends ffi.Struct {
  @ffi.Int64()
  int quot;

  @ffi.Int64()
  int rem;
}

class __sigset_t extends ffi.Struct {
  @ffi.Uint64()
  int _unique___val_item_0;
  @ffi.Uint64()
  int _unique___val_item_1;
  @ffi.Uint64()
  int _unique___val_item_2;
  @ffi.Uint64()
  int _unique___val_item_3;
  @ffi.Uint64()
  int _unique___val_item_4;
  @ffi.Uint64()
  int _unique___val_item_5;
  @ffi.Uint64()
  int _unique___val_item_6;
  @ffi.Uint64()
  int _unique___val_item_7;
  @ffi.Uint64()
  int _unique___val_item_8;
  @ffi.Uint64()
  int _unique___val_item_9;
  @ffi.Uint64()
  int _unique___val_item_10;
  @ffi.Uint64()
  int _unique___val_item_11;
  @ffi.Uint64()
  int _unique___val_item_12;
  @ffi.Uint64()
  int _unique___val_item_13;
  @ffi.Uint64()
  int _unique___val_item_14;
  @ffi.Uint64()
  int _unique___val_item_15;

  /// Helper for array `__val`.
  ArrayHelper___sigset_t___val_level0 get __val =>
      ArrayHelper___sigset_t___val_level0(this, [16], 0, 0);
}

/// Helper for array `__val` in struct `__sigset_t`.
class ArrayHelper___sigset_t___val_level0 {
  final __sigset_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___sigset_t___val_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___val_item_0;
      case 1:
        return _struct._unique___val_item_1;
      case 2:
        return _struct._unique___val_item_2;
      case 3:
        return _struct._unique___val_item_3;
      case 4:
        return _struct._unique___val_item_4;
      case 5:
        return _struct._unique___val_item_5;
      case 6:
        return _struct._unique___val_item_6;
      case 7:
        return _struct._unique___val_item_7;
      case 8:
        return _struct._unique___val_item_8;
      case 9:
        return _struct._unique___val_item_9;
      case 10:
        return _struct._unique___val_item_10;
      case 11:
        return _struct._unique___val_item_11;
      case 12:
        return _struct._unique___val_item_12;
      case 13:
        return _struct._unique___val_item_13;
      case 14:
        return _struct._unique___val_item_14;
      case 15:
        return _struct._unique___val_item_15;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___val_item_0 = value;
        break;
      case 1:
        _struct._unique___val_item_1 = value;
        break;
      case 2:
        _struct._unique___val_item_2 = value;
        break;
      case 3:
        _struct._unique___val_item_3 = value;
        break;
      case 4:
        _struct._unique___val_item_4 = value;
        break;
      case 5:
        _struct._unique___val_item_5 = value;
        break;
      case 6:
        _struct._unique___val_item_6 = value;
        break;
      case 7:
        _struct._unique___val_item_7 = value;
        break;
      case 8:
        _struct._unique___val_item_8 = value;
        break;
      case 9:
        _struct._unique___val_item_9 = value;
        break;
      case 10:
        _struct._unique___val_item_10 = value;
        break;
      case 11:
        _struct._unique___val_item_11 = value;
        break;
      case 12:
        _struct._unique___val_item_12 = value;
        break;
      case 13:
        _struct._unique___val_item_13 = value;
        break;
      case 14:
        _struct._unique___val_item_14 = value;
        break;
      case 15:
        _struct._unique___val_item_15 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class timeval extends ffi.Struct {
  @ffi.Int64()
  int tv_sec;

  @ffi.Int64()
  int tv_usec;
}

class timespec extends ffi.Struct {
  @ffi.Int64()
  int tv_sec;

  @ffi.Int64()
  int tv_nsec;
}

class fd_set extends ffi.Struct {
  @ffi.Int64()
  int _unique___fds_bits_item_0;
  @ffi.Int64()
  int _unique___fds_bits_item_1;
  @ffi.Int64()
  int _unique___fds_bits_item_2;
  @ffi.Int64()
  int _unique___fds_bits_item_3;
  @ffi.Int64()
  int _unique___fds_bits_item_4;
  @ffi.Int64()
  int _unique___fds_bits_item_5;
  @ffi.Int64()
  int _unique___fds_bits_item_6;
  @ffi.Int64()
  int _unique___fds_bits_item_7;
  @ffi.Int64()
  int _unique___fds_bits_item_8;
  @ffi.Int64()
  int _unique___fds_bits_item_9;
  @ffi.Int64()
  int _unique___fds_bits_item_10;
  @ffi.Int64()
  int _unique___fds_bits_item_11;
  @ffi.Int64()
  int _unique___fds_bits_item_12;
  @ffi.Int64()
  int _unique___fds_bits_item_13;
  @ffi.Int64()
  int _unique___fds_bits_item_14;
  @ffi.Int64()
  int _unique___fds_bits_item_15;

  /// Helper for array `__fds_bits`.
  ArrayHelper_fd_set___fds_bits_level0 get __fds_bits =>
      ArrayHelper_fd_set___fds_bits_level0(this, [16], 0, 0);
}

/// Helper for array `__fds_bits` in struct `fd_set`.
class ArrayHelper_fd_set___fds_bits_level0 {
  final fd_set _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_fd_set___fds_bits_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___fds_bits_item_0;
      case 1:
        return _struct._unique___fds_bits_item_1;
      case 2:
        return _struct._unique___fds_bits_item_2;
      case 3:
        return _struct._unique___fds_bits_item_3;
      case 4:
        return _struct._unique___fds_bits_item_4;
      case 5:
        return _struct._unique___fds_bits_item_5;
      case 6:
        return _struct._unique___fds_bits_item_6;
      case 7:
        return _struct._unique___fds_bits_item_7;
      case 8:
        return _struct._unique___fds_bits_item_8;
      case 9:
        return _struct._unique___fds_bits_item_9;
      case 10:
        return _struct._unique___fds_bits_item_10;
      case 11:
        return _struct._unique___fds_bits_item_11;
      case 12:
        return _struct._unique___fds_bits_item_12;
      case 13:
        return _struct._unique___fds_bits_item_13;
      case 14:
        return _struct._unique___fds_bits_item_14;
      case 15:
        return _struct._unique___fds_bits_item_15;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___fds_bits_item_0 = value;
        break;
      case 1:
        _struct._unique___fds_bits_item_1 = value;
        break;
      case 2:
        _struct._unique___fds_bits_item_2 = value;
        break;
      case 3:
        _struct._unique___fds_bits_item_3 = value;
        break;
      case 4:
        _struct._unique___fds_bits_item_4 = value;
        break;
      case 5:
        _struct._unique___fds_bits_item_5 = value;
        break;
      case 6:
        _struct._unique___fds_bits_item_6 = value;
        break;
      case 7:
        _struct._unique___fds_bits_item_7 = value;
        break;
      case 8:
        _struct._unique___fds_bits_item_8 = value;
        break;
      case 9:
        _struct._unique___fds_bits_item_9 = value;
        break;
      case 10:
        _struct._unique___fds_bits_item_10 = value;
        break;
      case 11:
        _struct._unique___fds_bits_item_11 = value;
        break;
      case 12:
        _struct._unique___fds_bits_item_12 = value;
        break;
      case 13:
        _struct._unique___fds_bits_item_13 = value;
        break;
      case 14:
        _struct._unique___fds_bits_item_14 = value;
        break;
      case 15:
        _struct._unique___fds_bits_item_15 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class __pthread_list_t extends ffi.Struct {
  ffi.Pointer<__pthread_list_t> __prev;

  ffi.Pointer<__pthread_list_t> __next;
}

class __pthread_slist_t extends ffi.Struct {
  ffi.Pointer<__pthread_slist_t> __next;
}

class __pthread_mutex_s extends ffi.Struct {}

class __pthread_rwlock_arch_t extends ffi.Struct {
  @ffi.Uint32()
  int __readers;

  @ffi.Uint32()
  int __writers;

  @ffi.Uint32()
  int __wrphase_futex;

  @ffi.Uint32()
  int __writers_futex;

  @ffi.Uint32()
  int __pad3;

  @ffi.Uint32()
  int __pad4;

  @ffi.Int32()
  int __cur_writer;

  @ffi.Int32()
  int __shared;

  @ffi.Int8()
  int __rwelision;

  @ffi.Uint8()
  int _unique___pad1_item_0;
  @ffi.Uint8()
  int _unique___pad1_item_1;
  @ffi.Uint8()
  int _unique___pad1_item_2;
  @ffi.Uint8()
  int _unique___pad1_item_3;
  @ffi.Uint8()
  int _unique___pad1_item_4;
  @ffi.Uint8()
  int _unique___pad1_item_5;
  @ffi.Uint8()
  int _unique___pad1_item_6;

  /// Helper for array `__pad1`.
  ArrayHelper___pthread_rwlock_arch_t___pad1_level0 get __pad1 =>
      ArrayHelper___pthread_rwlock_arch_t___pad1_level0(this, [7], 0, 0);
  @ffi.Uint64()
  int __pad2;

  @ffi.Uint32()
  int __flags;
}

/// Helper for array `__pad1` in struct `__pthread_rwlock_arch_t`.
class ArrayHelper___pthread_rwlock_arch_t___pad1_level0 {
  final __pthread_rwlock_arch_t _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___pthread_rwlock_arch_t___pad1_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___pad1_item_0;
      case 1:
        return _struct._unique___pad1_item_1;
      case 2:
        return _struct._unique___pad1_item_2;
      case 3:
        return _struct._unique___pad1_item_3;
      case 4:
        return _struct._unique___pad1_item_4;
      case 5:
        return _struct._unique___pad1_item_5;
      case 6:
        return _struct._unique___pad1_item_6;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___pad1_item_0 = value;
        break;
      case 1:
        _struct._unique___pad1_item_1 = value;
        break;
      case 2:
        _struct._unique___pad1_item_2 = value;
        break;
      case 3:
        _struct._unique___pad1_item_3 = value;
        break;
      case 4:
        _struct._unique___pad1_item_4 = value;
        break;
      case 5:
        _struct._unique___pad1_item_5 = value;
        break;
      case 6:
        _struct._unique___pad1_item_6 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class __pthread_cond_s extends ffi.Struct {
  @ffi.Uint32()
  int _unique___g_refs_item_0;
  @ffi.Uint32()
  int _unique___g_refs_item_1;

  /// Helper for array `__g_refs`.
  ArrayHelper___pthread_cond_s___g_refs_level0 get __g_refs =>
      ArrayHelper___pthread_cond_s___g_refs_level0(this, [2], 0, 0);
  @ffi.Uint32()
  int _unique___g_size_item_0;
  @ffi.Uint32()
  int _unique___g_size_item_1;

  /// Helper for array `__g_size`.
  ArrayHelper___pthread_cond_s___g_size_level0 get __g_size =>
      ArrayHelper___pthread_cond_s___g_size_level0(this, [2], 0, 0);
  @ffi.Uint32()
  int __g1_orig_size;

  @ffi.Uint32()
  int __wrefs;

  @ffi.Uint32()
  int _unique___g_signals_item_0;
  @ffi.Uint32()
  int _unique___g_signals_item_1;

  /// Helper for array `__g_signals`.
  ArrayHelper___pthread_cond_s___g_signals_level0 get __g_signals =>
      ArrayHelper___pthread_cond_s___g_signals_level0(this, [2], 0, 0);
}

/// Helper for array `__g_refs` in struct `__pthread_cond_s`.
class ArrayHelper___pthread_cond_s___g_refs_level0 {
  final __pthread_cond_s _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___pthread_cond_s___g_refs_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___g_refs_item_0;
      case 1:
        return _struct._unique___g_refs_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___g_refs_item_0 = value;
        break;
      case 1:
        _struct._unique___g_refs_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `__g_size` in struct `__pthread_cond_s`.
class ArrayHelper___pthread_cond_s___g_size_level0 {
  final __pthread_cond_s _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___pthread_cond_s___g_size_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___g_size_item_0;
      case 1:
        return _struct._unique___g_size_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___g_size_item_0 = value;
        break;
      case 1:
        _struct._unique___g_size_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `__g_signals` in struct `__pthread_cond_s`.
class ArrayHelper___pthread_cond_s___g_signals_level0 {
  final __pthread_cond_s _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___pthread_cond_s___g_signals_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___g_signals_item_0;
      case 1:
        return _struct._unique___g_signals_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___g_signals_item_0 = value;
        break;
      case 1:
        _struct._unique___g_signals_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class random_data extends ffi.Struct {
  ffi.Pointer<ffi.Int32> fptr;

  ffi.Pointer<ffi.Int32> rptr;

  ffi.Pointer<ffi.Int32> state;

  @ffi.Int32()
  int rand_type;

  @ffi.Int32()
  int rand_deg;

  @ffi.Int32()
  int rand_sep;

  ffi.Pointer<ffi.Int32> end_ptr;
}

class drand48_data extends ffi.Struct {
  @ffi.Uint16()
  int _unique___x_item_0;
  @ffi.Uint16()
  int _unique___x_item_1;
  @ffi.Uint16()
  int _unique___x_item_2;

  /// Helper for array `__x`.
  ArrayHelper_drand48_data___x_level0 get __x =>
      ArrayHelper_drand48_data___x_level0(this, [3], 0, 0);
  @ffi.Uint16()
  int _unique___old_x_item_0;
  @ffi.Uint16()
  int _unique___old_x_item_1;
  @ffi.Uint16()
  int _unique___old_x_item_2;

  /// Helper for array `__old_x`.
  ArrayHelper_drand48_data___old_x_level0 get __old_x =>
      ArrayHelper_drand48_data___old_x_level0(this, [3], 0, 0);
  @ffi.Uint16()
  int __c;

  @ffi.Uint16()
  int __init;

  @ffi.Uint64()
  int __a;
}

/// Helper for array `__x` in struct `drand48_data`.
class ArrayHelper_drand48_data___x_level0 {
  final drand48_data _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_drand48_data___x_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___x_item_0;
      case 1:
        return _struct._unique___x_item_1;
      case 2:
        return _struct._unique___x_item_2;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___x_item_0 = value;
        break;
      case 1:
        _struct._unique___x_item_1 = value;
        break;
      case 2:
        _struct._unique___x_item_2 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `__old_x` in struct `drand48_data`.
class ArrayHelper_drand48_data___old_x_level0 {
  final drand48_data _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_drand48_data___old_x_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___old_x_item_0;
      case 1:
        return _struct._unique___old_x_item_1;
      case 2:
        return _struct._unique___old_x_item_2;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___old_x_item_0 = value;
        break;
      case 1:
        _struct._unique___old_x_item_1 = value;
        break;
      case 2:
        _struct._unique___old_x_item_2 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class __locale_data extends ffi.Struct {}

class __locale_struct extends ffi.Struct {
  ffi.Pointer<__locale_data> _unique___locales_item_0;
  ffi.Pointer<__locale_data> _unique___locales_item_1;
  ffi.Pointer<__locale_data> _unique___locales_item_2;
  ffi.Pointer<__locale_data> _unique___locales_item_3;
  ffi.Pointer<__locale_data> _unique___locales_item_4;
  ffi.Pointer<__locale_data> _unique___locales_item_5;
  ffi.Pointer<__locale_data> _unique___locales_item_6;
  ffi.Pointer<__locale_data> _unique___locales_item_7;
  ffi.Pointer<__locale_data> _unique___locales_item_8;
  ffi.Pointer<__locale_data> _unique___locales_item_9;
  ffi.Pointer<__locale_data> _unique___locales_item_10;
  ffi.Pointer<__locale_data> _unique___locales_item_11;
  ffi.Pointer<__locale_data> _unique___locales_item_12;

  /// Helper for array `__locales`.
  ArrayHelper___locale_struct___locales_level0 get __locales =>
      ArrayHelper___locale_struct___locales_level0(this, [13], 0, 0);
  ffi.Pointer<ffi.Uint16> __ctype_b;

  ffi.Pointer<ffi.Int32> __ctype_tolower;

  ffi.Pointer<ffi.Int32> __ctype_toupper;

  ffi.Pointer<ffi.Int8> _unique___names_item_0;
  ffi.Pointer<ffi.Int8> _unique___names_item_1;
  ffi.Pointer<ffi.Int8> _unique___names_item_2;
  ffi.Pointer<ffi.Int8> _unique___names_item_3;
  ffi.Pointer<ffi.Int8> _unique___names_item_4;
  ffi.Pointer<ffi.Int8> _unique___names_item_5;
  ffi.Pointer<ffi.Int8> _unique___names_item_6;
  ffi.Pointer<ffi.Int8> _unique___names_item_7;
  ffi.Pointer<ffi.Int8> _unique___names_item_8;
  ffi.Pointer<ffi.Int8> _unique___names_item_9;
  ffi.Pointer<ffi.Int8> _unique___names_item_10;
  ffi.Pointer<ffi.Int8> _unique___names_item_11;
  ffi.Pointer<ffi.Int8> _unique___names_item_12;

  /// Helper for array `__names`.
  ArrayHelper___locale_struct___names_level0 get __names =>
      ArrayHelper___locale_struct___names_level0(this, [13], 0, 0);
}

/// Helper for array `__locales` in struct `__locale_struct`.
class ArrayHelper___locale_struct___locales_level0 {
  final __locale_struct _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___locale_struct___locales_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<__locale_data> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___locales_item_0;
      case 1:
        return _struct._unique___locales_item_1;
      case 2:
        return _struct._unique___locales_item_2;
      case 3:
        return _struct._unique___locales_item_3;
      case 4:
        return _struct._unique___locales_item_4;
      case 5:
        return _struct._unique___locales_item_5;
      case 6:
        return _struct._unique___locales_item_6;
      case 7:
        return _struct._unique___locales_item_7;
      case 8:
        return _struct._unique___locales_item_8;
      case 9:
        return _struct._unique___locales_item_9;
      case 10:
        return _struct._unique___locales_item_10;
      case 11:
        return _struct._unique___locales_item_11;
      case 12:
        return _struct._unique___locales_item_12;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<__locale_data> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___locales_item_0 = value;
        break;
      case 1:
        _struct._unique___locales_item_1 = value;
        break;
      case 2:
        _struct._unique___locales_item_2 = value;
        break;
      case 3:
        _struct._unique___locales_item_3 = value;
        break;
      case 4:
        _struct._unique___locales_item_4 = value;
        break;
      case 5:
        _struct._unique___locales_item_5 = value;
        break;
      case 6:
        _struct._unique___locales_item_6 = value;
        break;
      case 7:
        _struct._unique___locales_item_7 = value;
        break;
      case 8:
        _struct._unique___locales_item_8 = value;
        break;
      case 9:
        _struct._unique___locales_item_9 = value;
        break;
      case 10:
        _struct._unique___locales_item_10 = value;
        break;
      case 11:
        _struct._unique___locales_item_11 = value;
        break;
      case 12:
        _struct._unique___locales_item_12 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `__names` in struct `__locale_struct`.
class ArrayHelper___locale_struct___names_level0 {
  final __locale_struct _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper___locale_struct___names_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Int8> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique___names_item_0;
      case 1:
        return _struct._unique___names_item_1;
      case 2:
        return _struct._unique___names_item_2;
      case 3:
        return _struct._unique___names_item_3;
      case 4:
        return _struct._unique___names_item_4;
      case 5:
        return _struct._unique___names_item_5;
      case 6:
        return _struct._unique___names_item_6;
      case 7:
        return _struct._unique___names_item_7;
      case 8:
        return _struct._unique___names_item_8;
      case 9:
        return _struct._unique___names_item_9;
      case 10:
        return _struct._unique___names_item_10;
      case 11:
        return _struct._unique___names_item_11;
      case 12:
        return _struct._unique___names_item_12;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Int8> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique___names_item_0 = value;
        break;
      case 1:
        _struct._unique___names_item_1 = value;
        break;
      case 2:
        _struct._unique___names_item_2 = value;
        break;
      case 3:
        _struct._unique___names_item_3 = value;
        break;
      case 4:
        _struct._unique___names_item_4 = value;
        break;
      case 5:
        _struct._unique___names_item_5 = value;
        break;
      case 6:
        _struct._unique___names_item_6 = value;
        break;
      case 7:
        _struct._unique___names_item_7 = value;
        break;
      case 8:
        _struct._unique___names_item_8 = value;
        break;
      case 9:
        _struct._unique___names_item_9 = value;
        break;
      case 10:
        _struct._unique___names_item_10 = value;
        break;
      case 11:
        _struct._unique___names_item_11 = value;
        break;
      case 12:
        _struct._unique___names_item_12 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Rational number (pair of numerator and denominator).
class AVRational extends ffi.Struct {
  /// ///< Numerator
  @ffi.Int32()
  int num;

  /// ///< Denominator
  @ffi.Int32()
  int den;
}

/// Rounding methods.
abstract class AVRounding {
  /// ///< Round toward zero.
  static const int AV_ROUND_ZERO = 0;

  /// ///< Round away from zero.
  static const int AV_ROUND_INF = 1;

  /// ///< Round toward -infinity.
  static const int AV_ROUND_DOWN = 2;

  /// ///< Round toward +infinity.
  static const int AV_ROUND_UP = 3;

  /// ///< Round to nearest and halfway cases away from zero.
  static const int AV_ROUND_NEAR_INF = 5;

  /// Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through
  /// unchanged, avoiding special cases for #AV_NOPTS_VALUE.
  ///
  /// Unlike other values of the enumeration AVRounding, this value is a
  /// bitmask that must be used in conjunction with another value of the
  /// enumeration through a bitwise OR, in order to set behavior for normal
  /// cases.
  ///
  /// @code{.c}
  /// av_rescale_rnd(3, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
  /// // Rescaling 3:
  /// //     Calculating 3 * 1 / 2
  /// //     3 / 2 is rounded up to 2
  /// //     => 2
  ///
  /// av_rescale_rnd(AV_NOPTS_VALUE, 1, 2, AV_ROUND_UP | AV_ROUND_PASS_MINMAX);
  /// // Rescaling AV_NOPTS_VALUE:
  /// //     AV_NOPTS_VALUE == INT64_MIN
  /// //     AV_NOPTS_VALUE is passed through
  /// //     => AV_NOPTS_VALUE
  /// @endcode
  static const int AV_ROUND_PASS_MINMAX = 8192;
}

abstract class AVClassCategory {
  static const int AV_CLASS_CATEGORY_NA = 0;
  static const int AV_CLASS_CATEGORY_INPUT = 1;
  static const int AV_CLASS_CATEGORY_OUTPUT = 2;
  static const int AV_CLASS_CATEGORY_MUXER = 3;
  static const int AV_CLASS_CATEGORY_DEMUXER = 4;
  static const int AV_CLASS_CATEGORY_ENCODER = 5;
  static const int AV_CLASS_CATEGORY_DECODER = 6;
  static const int AV_CLASS_CATEGORY_FILTER = 7;
  static const int AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8;
  static const int AV_CLASS_CATEGORY_SWSCALER = 9;
  static const int AV_CLASS_CATEGORY_SWRESAMPLER = 10;
  static const int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40;
  static const int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41;
  static const int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42;
  static const int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43;
  static const int AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44;
  static const int AV_CLASS_CATEGORY_DEVICE_INPUT = 45;

  /// ///< not part of ABI/API
  static const int AV_CLASS_CATEGORY_NB = 46;
}

class AVOptionRanges extends ffi.Struct {}

class AVOption extends ffi.Struct {}

/// Describe the class of an AVClass context structure. That is an
/// arbitrary struct of which the first field is a pointer to an
/// AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).
class AVClass extends ffi.Struct {
  /// The name of the class; usually it is the same name as the
  /// context structure type to which the AVClass is associated.
  ffi.Pointer<ffi.Int8> class_name;

  /// A pointer to a function which returns the name of a context
  /// instance ctx associated with the class.
  ffi.Pointer<ffi.NativeFunction<_typedefC_1>> item_name;

  /// a pointer to the first option specified in the class if any or NULL
  ///
  /// @see av_set_default_options()
  ffi.Pointer<AVOption> option;

  /// LIBAVUTIL_VERSION with which this structure was created.
  /// This is used to allow fields to be added without requiring major
  /// version bumps everywhere.
  @ffi.Int32()
  int version;

  /// Offset in the structure where log_level_offset is stored.
  /// 0 means there is no such variable
  @ffi.Int32()
  int log_level_offset_offset;

  /// Offset in the structure where a pointer to the parent context for
  /// logging is stored. For example a decoder could pass its AVCodecContext
  /// to eval as such a parent context, which an av_log() implementation
  /// could then leverage to display the parent context.
  /// The offset can be NULL.
  @ffi.Int32()
  int parent_log_context_offset;

  /// Return next AVOptions-enabled child or NULL
  ffi.Pointer<ffi.NativeFunction<_typedefC_2>> child_next;

  /// Return an AVClass corresponding to the next potential
  /// AVOptions-enabled child.
  ///
  /// The difference between child_next and this is that
  /// child_next iterates over _already existing_ objects, while
  /// child_class_next iterates over _all possible_ children.
  ffi.Pointer<ffi.NativeFunction<_typedefC_3>> child_class_next;

  /// Category used for visualization (like color)
  /// This is only set if the category is equal for all objects using this class.
  /// available since version (51 << 16 | 56 << 8 | 100)
  @ffi.Int32()
  int category;

  /// Callback to return the category.
  /// available since version (51 << 16 | 59 << 8 | 100)
  ffi.Pointer<ffi.NativeFunction<_typedefC_4>> get_category;

  /// Callback to return the supported/allowed ranges.
  /// available since version (52.12)
  ffi.Pointer<ffi.NativeFunction<_typedefC_5>> query_ranges;

  /// Iterate over the AVClasses corresponding to potential AVOptions-enabled
  /// children.
  ///
  /// @param iter pointer to opaque iteration state. The caller must initialize
  /// *iter to NULL before the first call.
  /// @return AVClass for the next AVOptions-enabled child or NULL if there are
  /// no more such children.
  ///
  /// @note The difference between child_next and this is that child_next
  /// iterates over _already existing_ objects, while child_class_iterate
  /// iterates over _all possible_ children.
  ffi.Pointer<ffi.NativeFunction<_typedefC_6>> child_class_iterate;
}

class __va_list_tag extends ffi.Struct {
  @ffi.Uint32()
  int gp_offset;

  @ffi.Uint32()
  int fp_offset;

  ffi.Pointer<ffi.Void> overflow_arg_area;

  ffi.Pointer<ffi.Void> reg_save_area;
}

/// Pixel format.
///
/// @note
/// AV_PIX_FMT_RGB32 is handled in an endian-specific manner. An RGBA
/// color is put together as:
/// (A << 24) | (R << 16) | (G << 8) | B
/// This is stored as BGRA on little-endian CPU architectures and ARGB on
/// big-endian CPUs.
///
/// @note
/// If the resolution is not a multiple of the chroma subsampling factor
/// then the chroma plane resolution must be rounded up.
///
/// @par
/// When the pixel format is palettized RGB32 (AV_PIX_FMT_PAL8), the palettized
/// image data is stored in AVFrame.data[0]. The palette is transported in
/// AVFrame.data[1], is 1024 bytes long (256 4-byte entries) and is
/// formatted the same as in AV_PIX_FMT_RGB32 described above (i.e., it is
/// also endian-specific). Note also that the individual RGB32 palette
/// components stored in AVFrame.data[1] should be in the range 0..255.
/// This is important as many custom PAL8 video codecs that were designed
/// to run on the IBM VGA graphics adapter use 6-bit palette components.
///
/// @par
/// For all the 8 bits per pixel formats, an RGB32 palette is in data[1] like
/// for pal8. This palette is filled in automatically by the function
/// allocating the picture.
abstract class AVPixelFormat {
  static const int AV_PIX_FMT_NONE = -1;

  /// ///< planar YUV 4:2:0, 12bpp, (1 Cr & Cb sample per 2x2 Y samples)
  static const int AV_PIX_FMT_YUV420P = 0;

  /// ///< packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr
  static const int AV_PIX_FMT_YUYV422 = 1;

  /// ///< packed RGB 8:8:8, 24bpp, RGBRGB...
  static const int AV_PIX_FMT_RGB24 = 2;

  /// ///< packed RGB 8:8:8, 24bpp, BGRBGR...
  static const int AV_PIX_FMT_BGR24 = 3;

  /// ///< planar YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
  static const int AV_PIX_FMT_YUV422P = 4;

  /// ///< planar YUV 4:4:4, 24bpp, (1 Cr & Cb sample per 1x1 Y samples)
  static const int AV_PIX_FMT_YUV444P = 5;

  /// ///< planar YUV 4:1:0,  9bpp, (1 Cr & Cb sample per 4x4 Y samples)
  static const int AV_PIX_FMT_YUV410P = 6;

  /// ///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples)
  static const int AV_PIX_FMT_YUV411P = 7;

  /// ///<        Y        ,  8bpp
  static const int AV_PIX_FMT_GRAY8 = 8;

  /// ///<        Y        ,  1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb
  static const int AV_PIX_FMT_MONOWHITE = 9;

  /// ///<        Y        ,  1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb
  static const int AV_PIX_FMT_MONOBLACK = 10;

  /// ///< 8 bits with AV_PIX_FMT_RGB32 palette
  static const int AV_PIX_FMT_PAL8 = 11;

  /// ///< planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range
  static const int AV_PIX_FMT_YUVJ420P = 12;

  /// ///< planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range
  static const int AV_PIX_FMT_YUVJ422P = 13;

  /// ///< planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range
  static const int AV_PIX_FMT_YUVJ444P = 14;

  /// ///< packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1
  static const int AV_PIX_FMT_UYVY422 = 15;

  /// ///< packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3
  static const int AV_PIX_FMT_UYYVYY411 = 16;

  /// ///< packed RGB 3:3:2,  8bpp, (msb)2B 3G 3R(lsb)
  static const int AV_PIX_FMT_BGR8 = 17;

  /// ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
  static const int AV_PIX_FMT_BGR4 = 18;

  /// ///< packed RGB 1:2:1,  8bpp, (msb)1B 2G 1R(lsb)
  static const int AV_PIX_FMT_BGR4_BYTE = 19;

  /// ///< packed RGB 3:3:2,  8bpp, (msb)2R 3G 3B(lsb)
  static const int AV_PIX_FMT_RGB8 = 20;

  /// ///< packed RGB 1:2:1 bitstream,  4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits
  static const int AV_PIX_FMT_RGB4 = 21;

  /// ///< packed RGB 1:2:1,  8bpp, (msb)1R 2G 1B(lsb)
  static const int AV_PIX_FMT_RGB4_BYTE = 22;

  /// ///< planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
  static const int AV_PIX_FMT_NV12 = 23;

  /// ///< as above, but U and V bytes are swapped
  static const int AV_PIX_FMT_NV21 = 24;

  /// ///< packed ARGB 8:8:8:8, 32bpp, ARGBARGB...
  static const int AV_PIX_FMT_ARGB = 25;

  /// ///< packed RGBA 8:8:8:8, 32bpp, RGBARGBA...
  static const int AV_PIX_FMT_RGBA = 26;

  /// ///< packed ABGR 8:8:8:8, 32bpp, ABGRABGR...
  static const int AV_PIX_FMT_ABGR = 27;

  /// ///< packed BGRA 8:8:8:8, 32bpp, BGRABGRA...
  static const int AV_PIX_FMT_BGRA = 28;

  /// ///<        Y        , 16bpp, big-endian
  static const int AV_PIX_FMT_GRAY16BE = 29;

  /// ///<        Y        , 16bpp, little-endian
  static const int AV_PIX_FMT_GRAY16LE = 30;

  /// ///< planar YUV 4:4:0 (1 Cr & Cb sample per 1x2 Y samples)
  static const int AV_PIX_FMT_YUV440P = 31;

  /// ///< planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range
  static const int AV_PIX_FMT_YUVJ440P = 32;

  /// ///< planar YUV 4:2:0, 20bpp, (1 Cr & Cb sample per 2x2 Y & A samples)
  static const int AV_PIX_FMT_YUVA420P = 33;

  /// ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian
  static const int AV_PIX_FMT_RGB48BE = 34;

  /// ///< packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian
  static const int AV_PIX_FMT_RGB48LE = 35;

  /// ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), big-endian
  static const int AV_PIX_FMT_RGB565BE = 36;

  /// ///< packed RGB 5:6:5, 16bpp, (msb)   5R 6G 5B(lsb), little-endian
  static const int AV_PIX_FMT_RGB565LE = 37;

  /// ///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian   , X=unused/undefined
  static const int AV_PIX_FMT_RGB555BE = 38;

  /// ///< packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined
  static const int AV_PIX_FMT_RGB555LE = 39;

  /// ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), big-endian
  static const int AV_PIX_FMT_BGR565BE = 40;

  /// ///< packed BGR 5:6:5, 16bpp, (msb)   5B 6G 5R(lsb), little-endian
  static const int AV_PIX_FMT_BGR565LE = 41;

  /// ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian   , X=unused/undefined
  static const int AV_PIX_FMT_BGR555BE = 42;

  /// ///< packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined
  static const int AV_PIX_FMT_BGR555LE = 43;

  /// ///< HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers
  static const int AV_PIX_FMT_VAAPI_MOCO = 44;

  /// ///< HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers
  static const int AV_PIX_FMT_VAAPI_IDCT = 45;

  /// ///< HW decoding through VA API, Picture.data[3] contains a VASurfaceID
  static const int AV_PIX_FMT_VAAPI_VLD = 46;

  /// @}
  static const int AV_PIX_FMT_VAAPI = 46;

  /// ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  static const int AV_PIX_FMT_YUV420P16LE = 47;

  /// ///< planar YUV 4:2:0, 24bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  static const int AV_PIX_FMT_YUV420P16BE = 48;

  /// ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV422P16LE = 49;

  /// ///< planar YUV 4:2:2, 32bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV422P16BE = 50;

  /// ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV444P16LE = 51;

  /// ///< planar YUV 4:4:4, 48bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV444P16BE = 52;

  /// ///< HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer
  static const int AV_PIX_FMT_DXVA2_VLD = 53;

  /// ///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined
  static const int AV_PIX_FMT_RGB444LE = 54;

  /// ///< packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian,    X=unused/undefined
  static const int AV_PIX_FMT_RGB444BE = 55;

  /// ///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined
  static const int AV_PIX_FMT_BGR444LE = 56;

  /// ///< packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian,    X=unused/undefined
  static const int AV_PIX_FMT_BGR444BE = 57;

  /// ///< 8 bits gray, 8 bits alpha
  static const int AV_PIX_FMT_YA8 = 58;

  /// ///< alias for AV_PIX_FMT_YA8
  static const int AV_PIX_FMT_Y400A = 58;

  /// ///< alias for AV_PIX_FMT_YA8
  static const int AV_PIX_FMT_GRAY8A = 58;

  /// ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian
  static const int AV_PIX_FMT_BGR48BE = 59;

  /// ///< packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian
  static const int AV_PIX_FMT_BGR48LE = 60;

  /// ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  static const int AV_PIX_FMT_YUV420P9BE = 61;

  /// ///< planar YUV 4:2:0, 13.5bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  static const int AV_PIX_FMT_YUV420P9LE = 62;

  /// ///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  static const int AV_PIX_FMT_YUV420P10BE = 63;

  /// ///< planar YUV 4:2:0, 15bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  static const int AV_PIX_FMT_YUV420P10LE = 64;

  /// ///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV422P10BE = 65;

  /// ///< planar YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV422P10LE = 66;

  /// ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV444P9BE = 67;

  /// ///< planar YUV 4:4:4, 27bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV444P9LE = 68;

  /// ///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV444P10BE = 69;

  /// ///< planar YUV 4:4:4, 30bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV444P10LE = 70;

  /// ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV422P9BE = 71;

  /// ///< planar YUV 4:2:2, 18bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV422P9LE = 72;

  /// ///< planar GBR 4:4:4 24bpp
  static const int AV_PIX_FMT_GBRP = 73;
  static const int AV_PIX_FMT_GBR24P = 73;

  /// ///< planar GBR 4:4:4 27bpp, big-endian
  static const int AV_PIX_FMT_GBRP9BE = 74;

  /// ///< planar GBR 4:4:4 27bpp, little-endian
  static const int AV_PIX_FMT_GBRP9LE = 75;

  /// ///< planar GBR 4:4:4 30bpp, big-endian
  static const int AV_PIX_FMT_GBRP10BE = 76;

  /// ///< planar GBR 4:4:4 30bpp, little-endian
  static const int AV_PIX_FMT_GBRP10LE = 77;

  /// ///< planar GBR 4:4:4 48bpp, big-endian
  static const int AV_PIX_FMT_GBRP16BE = 78;

  /// ///< planar GBR 4:4:4 48bpp, little-endian
  static const int AV_PIX_FMT_GBRP16LE = 79;

  /// ///< planar YUV 4:2:2 24bpp, (1 Cr & Cb sample per 2x1 Y & A samples)
  static const int AV_PIX_FMT_YUVA422P = 80;

  /// ///< planar YUV 4:4:4 32bpp, (1 Cr & Cb sample per 1x1 Y & A samples)
  static const int AV_PIX_FMT_YUVA444P = 81;

  /// ///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), big-endian
  static const int AV_PIX_FMT_YUVA420P9BE = 82;

  /// ///< planar YUV 4:2:0 22.5bpp, (1 Cr & Cb sample per 2x2 Y & A samples), little-endian
  static const int AV_PIX_FMT_YUVA420P9LE = 83;

  /// ///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), big-endian
  static const int AV_PIX_FMT_YUVA422P9BE = 84;

  /// ///< planar YUV 4:2:2 27bpp, (1 Cr & Cb sample per 2x1 Y & A samples), little-endian
  static const int AV_PIX_FMT_YUVA422P9LE = 85;

  /// ///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
  static const int AV_PIX_FMT_YUVA444P9BE = 86;

  /// ///< planar YUV 4:4:4 36bpp, (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
  static const int AV_PIX_FMT_YUVA444P9LE = 87;

  /// ///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
  static const int AV_PIX_FMT_YUVA420P10BE = 88;

  /// ///< planar YUV 4:2:0 25bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
  static const int AV_PIX_FMT_YUVA420P10LE = 89;

  /// ///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
  static const int AV_PIX_FMT_YUVA422P10BE = 90;

  /// ///< planar YUV 4:2:2 30bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
  static const int AV_PIX_FMT_YUVA422P10LE = 91;

  /// ///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
  static const int AV_PIX_FMT_YUVA444P10BE = 92;

  /// ///< planar YUV 4:4:4 40bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
  static const int AV_PIX_FMT_YUVA444P10LE = 93;

  /// ///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, big-endian)
  static const int AV_PIX_FMT_YUVA420P16BE = 94;

  /// ///< planar YUV 4:2:0 40bpp, (1 Cr & Cb sample per 2x2 Y & A samples, little-endian)
  static const int AV_PIX_FMT_YUVA420P16LE = 95;

  /// ///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, big-endian)
  static const int AV_PIX_FMT_YUVA422P16BE = 96;

  /// ///< planar YUV 4:2:2 48bpp, (1 Cr & Cb sample per 2x1 Y & A samples, little-endian)
  static const int AV_PIX_FMT_YUVA422P16LE = 97;

  /// ///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, big-endian)
  static const int AV_PIX_FMT_YUVA444P16BE = 98;

  /// ///< planar YUV 4:4:4 64bpp, (1 Cr & Cb sample per 1x1 Y & A samples, little-endian)
  static const int AV_PIX_FMT_YUVA444P16LE = 99;

  /// ///< HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface
  static const int AV_PIX_FMT_VDPAU = 100;

  /// ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0
  static const int AV_PIX_FMT_XYZ12LE = 101;

  /// ///< packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0
  static const int AV_PIX_FMT_XYZ12BE = 102;

  /// ///< interleaved chroma YUV 4:2:2, 16bpp, (1 Cr & Cb sample per 2x1 Y samples)
  static const int AV_PIX_FMT_NV16 = 103;

  /// ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  static const int AV_PIX_FMT_NV20LE = 104;

  /// ///< interleaved chroma YUV 4:2:2, 20bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  static const int AV_PIX_FMT_NV20BE = 105;

  /// ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
  static const int AV_PIX_FMT_RGBA64BE = 106;

  /// ///< packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
  static const int AV_PIX_FMT_RGBA64LE = 107;

  /// ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian
  static const int AV_PIX_FMT_BGRA64BE = 108;

  /// ///< packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian
  static const int AV_PIX_FMT_BGRA64LE = 109;

  /// ///< packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb
  static const int AV_PIX_FMT_YVYU422 = 110;

  /// ///< 16 bits gray, 16 bits alpha (big-endian)
  static const int AV_PIX_FMT_YA16BE = 111;

  /// ///< 16 bits gray, 16 bits alpha (little-endian)
  static const int AV_PIX_FMT_YA16LE = 112;

  /// ///< planar GBRA 4:4:4:4 32bpp
  static const int AV_PIX_FMT_GBRAP = 113;

  /// ///< planar GBRA 4:4:4:4 64bpp, big-endian
  static const int AV_PIX_FMT_GBRAP16BE = 114;

  /// ///< planar GBRA 4:4:4:4 64bpp, little-endian
  static const int AV_PIX_FMT_GBRAP16LE = 115;

  /// HW acceleration through QSV, data[3] contains a pointer to the
  /// mfxFrameSurface1 structure.
  static const int AV_PIX_FMT_QSV = 116;

  /// HW acceleration though MMAL, data[3] contains a pointer to the
  /// MMAL_BUFFER_HEADER_T structure.
  static const int AV_PIX_FMT_MMAL = 117;

  /// ///< HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer
  static const int AV_PIX_FMT_D3D11VA_VLD = 118;

  /// HW acceleration through CUDA. data[i] contain CUdeviceptr pointers
  /// exactly as for system memory frames.
  static const int AV_PIX_FMT_CUDA = 119;

  /// ///< packed RGB 8:8:8, 32bpp, XRGBXRGB...   X=unused/undefined
  static const int AV_PIX_FMT_0RGB = 120;

  /// ///< packed RGB 8:8:8, 32bpp, RGBXRGBX...   X=unused/undefined
  static const int AV_PIX_FMT_RGB0 = 121;

  /// ///< packed BGR 8:8:8, 32bpp, XBGRXBGR...   X=unused/undefined
  static const int AV_PIX_FMT_0BGR = 122;

  /// ///< packed BGR 8:8:8, 32bpp, BGRXBGRX...   X=unused/undefined
  static const int AV_PIX_FMT_BGR0 = 123;

  /// ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  static const int AV_PIX_FMT_YUV420P12BE = 124;

  /// ///< planar YUV 4:2:0,18bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  static const int AV_PIX_FMT_YUV420P12LE = 125;

  /// ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), big-endian
  static const int AV_PIX_FMT_YUV420P14BE = 126;

  /// ///< planar YUV 4:2:0,21bpp, (1 Cr & Cb sample per 2x2 Y samples), little-endian
  static const int AV_PIX_FMT_YUV420P14LE = 127;

  /// ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV422P12BE = 128;

  /// ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV422P12LE = 129;

  /// ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV422P14BE = 130;

  /// ///< planar YUV 4:2:2,28bpp, (1 Cr & Cb sample per 2x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV422P14LE = 131;

  /// ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV444P12BE = 132;

  /// ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV444P12LE = 133;

  /// ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), big-endian
  static const int AV_PIX_FMT_YUV444P14BE = 134;

  /// ///< planar YUV 4:4:4,42bpp, (1 Cr & Cb sample per 1x1 Y samples), little-endian
  static const int AV_PIX_FMT_YUV444P14LE = 135;

  /// ///< planar GBR 4:4:4 36bpp, big-endian
  static const int AV_PIX_FMT_GBRP12BE = 136;

  /// ///< planar GBR 4:4:4 36bpp, little-endian
  static const int AV_PIX_FMT_GBRP12LE = 137;

  /// ///< planar GBR 4:4:4 42bpp, big-endian
  static const int AV_PIX_FMT_GBRP14BE = 138;

  /// ///< planar GBR 4:4:4 42bpp, little-endian
  static const int AV_PIX_FMT_GBRP14LE = 139;

  /// ///< planar YUV 4:1:1, 12bpp, (1 Cr & Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range
  static const int AV_PIX_FMT_YUVJ411P = 140;

  /// ///< bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples
  static const int AV_PIX_FMT_BAYER_BGGR8 = 141;

  /// ///< bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples
  static const int AV_PIX_FMT_BAYER_RGGB8 = 142;

  /// ///< bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples
  static const int AV_PIX_FMT_BAYER_GBRG8 = 143;

  /// ///< bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples
  static const int AV_PIX_FMT_BAYER_GRBG8 = 144;

  /// ///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian
  static const int AV_PIX_FMT_BAYER_BGGR16LE = 145;

  /// ///< bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian
  static const int AV_PIX_FMT_BAYER_BGGR16BE = 146;

  /// ///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian
  static const int AV_PIX_FMT_BAYER_RGGB16LE = 147;

  /// ///< bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian
  static const int AV_PIX_FMT_BAYER_RGGB16BE = 148;

  /// ///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian
  static const int AV_PIX_FMT_BAYER_GBRG16LE = 149;

  /// ///< bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian
  static const int AV_PIX_FMT_BAYER_GBRG16BE = 150;

  /// ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian
  static const int AV_PIX_FMT_BAYER_GRBG16LE = 151;

  /// ///< bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian
  static const int AV_PIX_FMT_BAYER_GRBG16BE = 152;

  /// ///< XVideo Motion Acceleration via common packet passing
  static const int AV_PIX_FMT_XVMC = 153;

  /// ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
  static const int AV_PIX_FMT_YUV440P10LE = 154;

  /// ///< planar YUV 4:4:0,20bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
  static const int AV_PIX_FMT_YUV440P10BE = 155;

  /// ///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), little-endian
  static const int AV_PIX_FMT_YUV440P12LE = 156;

  /// ///< planar YUV 4:4:0,24bpp, (1 Cr & Cb sample per 1x2 Y samples), big-endian
  static const int AV_PIX_FMT_YUV440P12BE = 157;

  /// ///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), little-endian
  static const int AV_PIX_FMT_AYUV64LE = 158;

  /// ///< packed AYUV 4:4:4,64bpp (1 Cr & Cb sample per 1x1 Y & A samples), big-endian
  static const int AV_PIX_FMT_AYUV64BE = 159;

  /// ///< hardware decoding through Videotoolbox
  static const int AV_PIX_FMT_VIDEOTOOLBOX = 160;

  /// ///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian
  static const int AV_PIX_FMT_P010LE = 161;

  /// ///< like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian
  static const int AV_PIX_FMT_P010BE = 162;

  /// ///< planar GBR 4:4:4:4 48bpp, big-endian
  static const int AV_PIX_FMT_GBRAP12BE = 163;

  /// ///< planar GBR 4:4:4:4 48bpp, little-endian
  static const int AV_PIX_FMT_GBRAP12LE = 164;

  /// ///< planar GBR 4:4:4:4 40bpp, big-endian
  static const int AV_PIX_FMT_GBRAP10BE = 165;

  /// ///< planar GBR 4:4:4:4 40bpp, little-endian
  static const int AV_PIX_FMT_GBRAP10LE = 166;

  /// ///< hardware decoding through MediaCodec
  static const int AV_PIX_FMT_MEDIACODEC = 167;

  /// ///<        Y        , 12bpp, big-endian
  static const int AV_PIX_FMT_GRAY12BE = 168;

  /// ///<        Y        , 12bpp, little-endian
  static const int AV_PIX_FMT_GRAY12LE = 169;

  /// ///<        Y        , 10bpp, big-endian
  static const int AV_PIX_FMT_GRAY10BE = 170;

  /// ///<        Y        , 10bpp, little-endian
  static const int AV_PIX_FMT_GRAY10LE = 171;

  /// ///< like NV12, with 16bpp per component, little-endian
  static const int AV_PIX_FMT_P016LE = 172;

  /// ///< like NV12, with 16bpp per component, big-endian
  static const int AV_PIX_FMT_P016BE = 173;

  /// Hardware surfaces for Direct3D11.
  ///
  /// This is preferred over the legacy AV_PIX_FMT_D3D11VA_VLD. The new D3D11
  /// hwaccel API and filtering support AV_PIX_FMT_D3D11 only.
  ///
  /// data[0] contains a ID3D11Texture2D pointer, and data[1] contains the
  /// texture array index of the frame as intptr_t if the ID3D11Texture2D is
  /// an array texture (or always 0 if it's a normal texture).
  static const int AV_PIX_FMT_D3D11 = 174;

  /// ///<        Y        , 9bpp, big-endian
  static const int AV_PIX_FMT_GRAY9BE = 175;

  /// ///<        Y        , 9bpp, little-endian
  static const int AV_PIX_FMT_GRAY9LE = 176;

  /// ///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, big-endian
  static const int AV_PIX_FMT_GBRPF32BE = 177;

  /// ///< IEEE-754 single precision planar GBR 4:4:4,     96bpp, little-endian
  static const int AV_PIX_FMT_GBRPF32LE = 178;

  /// ///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian
  static const int AV_PIX_FMT_GBRAPF32BE = 179;

  /// ///< IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian
  static const int AV_PIX_FMT_GBRAPF32LE = 180;

  /// DRM-managed buffers exposed through PRIME buffer sharing.
  ///
  /// data[0] points to an AVDRMFrameDescriptor.
  static const int AV_PIX_FMT_DRM_PRIME = 181;

  /// Hardware surfaces for OpenCL.
  ///
  /// data[i] contain 2D image objects (typed in C as cl_mem, used
  /// in OpenCL as image2d_t) for each plane of the surface.
  static const int AV_PIX_FMT_OPENCL = 182;

  /// ///<        Y        , 14bpp, big-endian
  static const int AV_PIX_FMT_GRAY14BE = 183;

  /// ///<        Y        , 14bpp, little-endian
  static const int AV_PIX_FMT_GRAY14LE = 184;

  /// ///< IEEE-754 single precision Y, 32bpp, big-endian
  static const int AV_PIX_FMT_GRAYF32BE = 185;

  /// ///< IEEE-754 single precision Y, 32bpp, little-endian
  static const int AV_PIX_FMT_GRAYF32LE = 186;

  /// ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, big-endian
  static const int AV_PIX_FMT_YUVA422P12BE = 187;

  /// ///< planar YUV 4:2:2,24bpp, (1 Cr & Cb sample per 2x1 Y samples), 12b alpha, little-endian
  static const int AV_PIX_FMT_YUVA422P12LE = 188;

  /// ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, big-endian
  static const int AV_PIX_FMT_YUVA444P12BE = 189;

  /// ///< planar YUV 4:4:4,36bpp, (1 Cr & Cb sample per 1x1 Y samples), 12b alpha, little-endian
  static const int AV_PIX_FMT_YUVA444P12LE = 190;

  /// ///< planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)
  static const int AV_PIX_FMT_NV24 = 191;

  /// ///< as above, but U and V bytes are swapped
  static const int AV_PIX_FMT_NV42 = 192;

  /// Vulkan hardware images.
  ///
  /// data[0] points to an AVVkFrame
  static const int AV_PIX_FMT_VULKAN = 193;

  /// ///< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian
  static const int AV_PIX_FMT_Y210BE = 194;

  /// ///< packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian
  static const int AV_PIX_FMT_Y210LE = 195;

  /// ///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), little-endian, X=unused/undefined
  static const int AV_PIX_FMT_X2RGB10LE = 196;

  /// ///< packed RGB 10:10:10, 30bpp, (msb)2X 10R 10G 10B(lsb), big-endian, X=unused/undefined
  static const int AV_PIX_FMT_X2RGB10BE = 197;

  /// ///< number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions
  static const int AV_PIX_FMT_NB = 198;
}

/// Chromaticity coordinates of the source primaries.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.1.
abstract class AVColorPrimaries {
  static const int AVCOL_PRI_RESERVED0 = 0;

  /// ///< also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B
  static const int AVCOL_PRI_BT709 = 1;
  static const int AVCOL_PRI_UNSPECIFIED = 2;
  static const int AVCOL_PRI_RESERVED = 3;

  /// ///< also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
  static const int AVCOL_PRI_BT470M = 4;

  /// ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM
  static const int AVCOL_PRI_BT470BG = 5;

  /// ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
  static const int AVCOL_PRI_SMPTE170M = 6;

  /// ///< functionally identical to above
  static const int AVCOL_PRI_SMPTE240M = 7;

  /// ///< colour filters using Illuminant C
  static const int AVCOL_PRI_FILM = 8;

  /// ///< ITU-R BT2020
  static const int AVCOL_PRI_BT2020 = 9;

  /// ///< SMPTE ST 428-1 (CIE 1931 XYZ)
  static const int AVCOL_PRI_SMPTE428 = 10;
  static const int AVCOL_PRI_SMPTEST428_1 = 10;

  /// ///< SMPTE ST 431-2 (2011) / DCI P3
  static const int AVCOL_PRI_SMPTE431 = 11;

  /// ///< SMPTE ST 432-1 (2010) / P3 D65 / Display P3
  static const int AVCOL_PRI_SMPTE432 = 12;

  /// ///< EBU Tech. 3213-E / JEDEC P22 phosphors
  static const int AVCOL_PRI_EBU3213 = 22;
  static const int AVCOL_PRI_JEDEC_P22 = 22;

  /// ///< Not part of ABI
  static const int AVCOL_PRI_NB = 23;
}

/// Color Transfer Characteristic.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.2.
abstract class AVColorTransferCharacteristic {
  static const int AVCOL_TRC_RESERVED0 = 0;

  /// ///< also ITU-R BT1361
  static const int AVCOL_TRC_BT709 = 1;
  static const int AVCOL_TRC_UNSPECIFIED = 2;
  static const int AVCOL_TRC_RESERVED = 3;

  /// ///< also ITU-R BT470M / ITU-R BT1700 625 PAL & SECAM
  static const int AVCOL_TRC_GAMMA22 = 4;

  /// ///< also ITU-R BT470BG
  static const int AVCOL_TRC_GAMMA28 = 5;

  /// ///< also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC
  static const int AVCOL_TRC_SMPTE170M = 6;
  static const int AVCOL_TRC_SMPTE240M = 7;

  /// ///< "Linear transfer characteristics"
  static const int AVCOL_TRC_LINEAR = 8;

  /// ///< "Logarithmic transfer characteristic (100:1 range)"
  static const int AVCOL_TRC_LOG = 9;

  /// ///< "Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)"
  static const int AVCOL_TRC_LOG_SQRT = 10;

  /// ///< IEC 61966-2-4
  static const int AVCOL_TRC_IEC61966_2_4 = 11;

  /// ///< ITU-R BT1361 Extended Colour Gamut
  static const int AVCOL_TRC_BT1361_ECG = 12;

  /// ///< IEC 61966-2-1 (sRGB or sYCC)
  static const int AVCOL_TRC_IEC61966_2_1 = 13;

  /// ///< ITU-R BT2020 for 10-bit system
  static const int AVCOL_TRC_BT2020_10 = 14;

  /// ///< ITU-R BT2020 for 12-bit system
  static const int AVCOL_TRC_BT2020_12 = 15;

  /// ///< SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems
  static const int AVCOL_TRC_SMPTE2084 = 16;
  static const int AVCOL_TRC_SMPTEST2084 = 16;

  /// ///< SMPTE ST 428-1
  static const int AVCOL_TRC_SMPTE428 = 17;
  static const int AVCOL_TRC_SMPTEST428_1 = 17;

  /// ///< ARIB STD-B67, known as "Hybrid log-gamma"
  static const int AVCOL_TRC_ARIB_STD_B67 = 18;

  /// ///< Not part of ABI
  static const int AVCOL_TRC_NB = 19;
}

/// YUV colorspace type.
/// These values match the ones defined by ISO/IEC 23001-8_2013 § 7.3.
abstract class AVColorSpace {
  /// ///< order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)
  static const int AVCOL_SPC_RGB = 0;

  /// ///< also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B
  static const int AVCOL_SPC_BT709 = 1;
  static const int AVCOL_SPC_UNSPECIFIED = 2;
  static const int AVCOL_SPC_RESERVED = 3;

  /// ///< FCC Title 47 Code of Federal Regulations 73.682 (a)(20)
  static const int AVCOL_SPC_FCC = 4;

  /// ///< also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL & SECAM / IEC 61966-2-4 xvYCC601
  static const int AVCOL_SPC_BT470BG = 5;

  /// ///< also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC
  static const int AVCOL_SPC_SMPTE170M = 6;

  /// ///< functionally identical to above
  static const int AVCOL_SPC_SMPTE240M = 7;

  /// ///< Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16
  static const int AVCOL_SPC_YCGCO = 8;
  static const int AVCOL_SPC_YCOCG = 8;

  /// ///< ITU-R BT2020 non-constant luminance system
  static const int AVCOL_SPC_BT2020_NCL = 9;

  /// ///< ITU-R BT2020 constant luminance system
  static const int AVCOL_SPC_BT2020_CL = 10;

  /// ///< SMPTE 2085, Y'D'zD'x
  static const int AVCOL_SPC_SMPTE2085 = 11;

  /// ///< Chromaticity-derived non-constant luminance system
  static const int AVCOL_SPC_CHROMA_DERIVED_NCL = 12;

  /// ///< Chromaticity-derived constant luminance system
  static const int AVCOL_SPC_CHROMA_DERIVED_CL = 13;

  /// ///< ITU-R BT.2100-0, ICtCp
  static const int AVCOL_SPC_ICTCP = 14;

  /// ///< Not part of ABI
  static const int AVCOL_SPC_NB = 15;
}

/// Visual content value range.
///
/// These values are based on definitions that can be found in multiple
/// specifications, such as ITU-T BT.709 (3.4 - Quantization of RGB, luminance
/// and colour-difference signals), ITU-T BT.2020 (Table 5 - Digital
/// Representation) as well as ITU-T BT.2100 (Table 9 - Digital 10- and 12-bit
/// integer representation). At the time of writing, the BT.2100 one is
/// recommended, as it also defines the full range representation.
///
/// Common definitions:
/// - For RGB and luminance planes such as Y in YCbCr and I in ICtCp,
/// 'E' is the original value in range of 0.0 to 1.0.
/// - For chrominance planes such as Cb,Cr and Ct,Cp, 'E' is the original
/// value in range of -0.5 to 0.5.
/// - 'n' is the output bit depth.
/// - For additional definitions such as rounding and clipping to valid n
/// bit unsigned integer range, please refer to BT.2100 (Table 9).
abstract class AVColorRange {
  static const int AVCOL_RANGE_UNSPECIFIED = 0;

  /// Narrow or limited range content.
  ///
  /// - For luminance planes:
  ///
  /// (219 * E + 16) * 2^(n-8)
  ///
  /// F.ex. the range of 16-235 for 8 bits
  ///
  /// - For chrominance planes:
  ///
  /// (224 * E + 128) * 2^(n-8)
  ///
  /// F.ex. the range of 16-240 for 8 bits
  static const int AVCOL_RANGE_MPEG = 1;

  /// Full range content.
  ///
  /// - For RGB and luminance planes:
  ///
  /// (2^n - 1) * E
  ///
  /// F.ex. the range of 0-255 for 8 bits
  ///
  /// - For chrominance planes:
  ///
  /// (2^n - 1) * E + 2^(n - 1)
  ///
  /// F.ex. the range of 1-255 for 8 bits
  static const int AVCOL_RANGE_JPEG = 2;

  /// ///< Not part of ABI
  static const int AVCOL_RANGE_NB = 3;
}

/// Location of chroma samples.
///
/// Illustration showing the location of the first (top left) chroma sample of the
/// image, the left shows only luma, the right
/// shows the location of the chroma sample, the 2 could be imagined to overlay
/// each other but are drawn separately due to limitations of ASCII
///
/// 1st 2nd       1st 2nd horizontal luma sample positions
/// v   v         v   v
/// ______        ______
/// 1st luma line > |X   X ...    |3 4 X ...     X are luma samples,
/// |             |1 2           1-6 are possible chroma positions
/// 2nd luma line > |X   X ...    |5 6 X ...     0 is undefined/unknown position
abstract class AVChromaLocation {
  static const int AVCHROMA_LOC_UNSPECIFIED = 0;

  /// ///< MPEG-2/4 4:2:0, H.264 default for 4:2:0
  static const int AVCHROMA_LOC_LEFT = 1;

  /// ///< MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0
  static const int AVCHROMA_LOC_CENTER = 2;

  /// ///< ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2
  static const int AVCHROMA_LOC_TOPLEFT = 3;
  static const int AVCHROMA_LOC_TOP = 4;
  static const int AVCHROMA_LOC_BOTTOMLEFT = 5;
  static const int AVCHROMA_LOC_BOTTOM = 6;

  /// ///< Not part of ABI
  static const int AVCHROMA_LOC_NB = 7;
}

/// Audio sample formats
///
/// - The data described by the sample format is always in native-endian order.
/// Sample values can be expressed by native C types, hence the lack of a signed
/// 24-bit sample format even though it is a common raw audio data format.
///
/// - The floating-point formats are based on full volume being in the range
/// [-1.0, 1.0]. Any values outside this range are beyond full volume level.
///
/// - The data layout as used in av_samples_fill_arrays() and elsewhere in FFmpeg
/// (such as AVFrame in libavcodec) is as follows:
///
/// @par
/// For planar sample formats, each audio channel is in a separate data plane,
/// and linesize is the buffer size, in bytes, for a single plane. All data
/// planes must be the same size. For packed sample formats, only the first data
/// plane is used, and samples for each channel are interleaved. In this case,
/// linesize is the buffer size, in bytes, for the 1 plane.
abstract class AVSampleFormat {
  static const int AV_SAMPLE_FMT_NONE = -1;

  /// ///< unsigned 8 bits
  static const int AV_SAMPLE_FMT_U8 = 0;

  /// ///< signed 16 bits
  static const int AV_SAMPLE_FMT_S16 = 1;

  /// ///< signed 32 bits
  static const int AV_SAMPLE_FMT_S32 = 2;

  /// ///< float
  static const int AV_SAMPLE_FMT_FLT = 3;

  /// ///< double
  static const int AV_SAMPLE_FMT_DBL = 4;

  /// ///< unsigned 8 bits, planar
  static const int AV_SAMPLE_FMT_U8P = 5;

  /// ///< signed 16 bits, planar
  static const int AV_SAMPLE_FMT_S16P = 6;

  /// ///< signed 32 bits, planar
  static const int AV_SAMPLE_FMT_S32P = 7;

  /// ///< float, planar
  static const int AV_SAMPLE_FMT_FLTP = 8;

  /// ///< double, planar
  static const int AV_SAMPLE_FMT_DBLP = 9;

  /// ///< signed 64 bits
  static const int AV_SAMPLE_FMT_S64 = 10;

  /// ///< signed 64 bits, planar
  static const int AV_SAMPLE_FMT_S64P = 11;

  /// ///< Number of sample formats. DO NOT USE if linking dynamically
  static const int AV_SAMPLE_FMT_NB = 12;
}

class AVBuffer extends ffi.Struct {}

/// A reference to a data buffer.
///
/// The size of this struct is not a part of the public ABI and it is not meant
/// to be allocated directly.
class AVBufferRef extends ffi.Struct {
  ffi.Pointer<AVBuffer> buffer;

  /// The data buffer. It is considered writable if and only if
  /// this is the only reference to the buffer, in which case
  /// av_buffer_is_writable() returns 1.
  ffi.Pointer<ffi.Uint8> data;

  /// Size of data in bytes.
  @ffi.Int32()
  int size;
}

class AVBufferPool extends ffi.Struct {}

abstract class AVMatrixEncoding {
  static const int AV_MATRIX_ENCODING_NONE = 0;
  static const int AV_MATRIX_ENCODING_DOLBY = 1;
  static const int AV_MATRIX_ENCODING_DPLII = 2;
  static const int AV_MATRIX_ENCODING_DPLIIX = 3;
  static const int AV_MATRIX_ENCODING_DPLIIZ = 4;
  static const int AV_MATRIX_ENCODING_DOLBYEX = 5;
  static const int AV_MATRIX_ENCODING_DOLBYHEADPHONE = 6;
  static const int AV_MATRIX_ENCODING_NB = 7;
}

class AVBPrint extends ffi.Struct {}

class AVDictionaryEntry extends ffi.Struct {
  ffi.Pointer<ffi.Int8> key;

  ffi.Pointer<ffi.Int8> value;
}

class AVDictionary extends ffi.Struct {}

/// @defgroup lavu_frame AVFrame
/// @ingroup lavu_data
///
/// @{
/// AVFrame is an abstraction for reference-counted raw multimedia data.
abstract class AVFrameSideDataType {
  /// The data is the AVPanScan struct defined in libavcodec.
  static const int AV_FRAME_DATA_PANSCAN = 0;

  /// ATSC A53 Part 4 Closed Captions.
  /// A53 CC bitstream is stored as uint8_t in AVFrameSideData.data.
  /// The number of bytes of CC data is AVFrameSideData.size.
  static const int AV_FRAME_DATA_A53_CC = 1;

  /// Stereoscopic 3d metadata.
  /// The data is the AVStereo3D struct defined in libavutil/stereo3d.h.
  static const int AV_FRAME_DATA_STEREO3D = 2;

  /// The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h.
  static const int AV_FRAME_DATA_MATRIXENCODING = 3;

  /// Metadata relevant to a downmix procedure.
  /// The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h.
  static const int AV_FRAME_DATA_DOWNMIX_INFO = 4;

  /// ReplayGain information in the form of the AVReplayGain struct.
  static const int AV_FRAME_DATA_REPLAYGAIN = 5;

  /// This side data contains a 3x3 transformation matrix describing an affine
  /// transformation that needs to be applied to the frame for correct
  /// presentation.
  ///
  /// See libavutil/display.h for a detailed description of the data.
  static const int AV_FRAME_DATA_DISPLAYMATRIX = 6;

  /// Active Format Description data consisting of a single byte as specified
  /// in ETSI TS 101 154 using AVActiveFormatDescription enum.
  static const int AV_FRAME_DATA_AFD = 7;

  /// Motion vectors exported by some codecs (on demand through the export_mvs
  /// flag set in the libavcodec AVCodecContext flags2 option).
  /// The data is the AVMotionVector struct defined in
  /// libavutil/motion_vector.h.
  static const int AV_FRAME_DATA_MOTION_VECTORS = 8;

  /// Recommmends skipping the specified number of samples. This is exported
  /// only if the "skip_manual" AVOption is set in libavcodec.
  /// This has the same format as AV_PKT_DATA_SKIP_SAMPLES.
  /// @code
  /// u32le number of samples to skip from start of this packet
  /// u32le number of samples to skip from end of this packet
  /// u8    reason for start skip
  /// u8    reason for end   skip (0=padding silence, 1=convergence)
  /// @endcode
  static const int AV_FRAME_DATA_SKIP_SAMPLES = 9;

  /// This side data must be associated with an audio frame and corresponds to
  /// enum AVAudioServiceType defined in avcodec.h.
  static const int AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10;

  /// Mastering display metadata associated with a video frame. The payload is
  /// an AVMasteringDisplayMetadata type and contains information about the
  /// mastering display color volume.
  static const int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11;

  /// The GOP timecode in 25 bit timecode format. Data format is 64-bit integer.
  /// This is set on the first frame of a GOP that has a temporal reference of 0.
  static const int AV_FRAME_DATA_GOP_TIMECODE = 12;

  /// The data represents the AVSphericalMapping structure defined in
  /// libavutil/spherical.h.
  static const int AV_FRAME_DATA_SPHERICAL = 13;

  /// Content light level (based on CTA-861.3). This payload contains data in
  /// the form of the AVContentLightMetadata struct.
  static const int AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14;

  /// The data contains an ICC profile as an opaque octet buffer following the
  /// format described by ISO 15076-1 with an optional name defined in the
  /// metadata key entry "name".
  static const int AV_FRAME_DATA_ICC_PROFILE = 15;

  /// Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA.
  /// The contents of this side data are undocumented and internal; use
  /// av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a
  /// meaningful way instead.
  static const int AV_FRAME_DATA_QP_TABLE_PROPERTIES = 16;

  /// Raw QP table data. Its format is described by
  /// AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and
  /// av_frame_get_qp_table() to access this instead.
  static const int AV_FRAME_DATA_QP_TABLE_DATA = 17;

  /// Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t
  /// where the first uint32_t describes how many (1-3) of the other timecodes are used.
  /// The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()
  /// function in libavutil/timecode.h.
  static const int AV_FRAME_DATA_S12M_TIMECODE = 18;

  /// HDR dynamic metadata associated with a video frame. The payload is
  /// an AVDynamicHDRPlus type and contains information for color
  /// volume transform - application 4 of SMPTE 2094-40:2016 standard.
  static const int AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 19;

  /// Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of
  /// array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size.
  static const int AV_FRAME_DATA_REGIONS_OF_INTEREST = 20;

  /// Encoding parameters for a video frame, as described by AVVideoEncParams.
  static const int AV_FRAME_DATA_VIDEO_ENC_PARAMS = 21;

  /// User data unregistered metadata associated with a video frame.
  /// This is the H.26[45] UDU SEI message, and shouldn't be used for any other purpose
  /// The data is stored as uint8_t in AVFrameSideData.data which is 16 bytes of
  /// uuid_iso_iec_11578 followed by AVFrameSideData.size - 16 bytes of user_data_payload_byte.
  static const int AV_FRAME_DATA_SEI_UNREGISTERED = 22;

  /// Film grain parameters for a frame, described by AVFilmGrainParams.
  /// Must be present for every frame which should have film grain applied.
  static const int AV_FRAME_DATA_FILM_GRAIN_PARAMS = 23;
}

abstract class AVActiveFormatDescription {
  static const int AV_AFD_SAME = 8;
  static const int AV_AFD_4_3 = 9;
  static const int AV_AFD_16_9 = 10;
  static const int AV_AFD_14_9 = 11;
  static const int AV_AFD_4_3_SP_14_9 = 13;
  static const int AV_AFD_16_9_SP_14_9 = 14;
  static const int AV_AFD_SP_4_3 = 15;
}

/// Structure to hold side data for an AVFrame.
///
/// sizeof(AVFrameSideData) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
class AVFrameSideData extends ffi.Struct {
  @ffi.Int32()
  int type;

  ffi.Pointer<ffi.Uint8> data;

  @ffi.Int32()
  int size;

  ffi.Pointer<AVDictionary> metadata;

  ffi.Pointer<AVBufferRef> buf;
}

/// Structure describing a single Region Of Interest.
///
/// When multiple regions are defined in a single side-data block, they
/// should be ordered from most to least important - some encoders are only
/// capable of supporting a limited number of distinct regions, so will have
/// to truncate the list.
///
/// When overlapping regions are defined, the first region containing a given
/// area of the frame applies.
class AVRegionOfInterest extends ffi.Struct {}

/// This structure describes decoded (raw) audio or video data.
///
/// AVFrame must be allocated using av_frame_alloc(). Note that this only
/// allocates the AVFrame itself, the buffers for the data must be managed
/// through other means (see below).
/// AVFrame must be freed with av_frame_free().
///
/// AVFrame is typically allocated once and then reused multiple times to hold
/// different data (e.g. a single AVFrame to hold frames received from a
/// decoder). In such a case, av_frame_unref() will free any references held by
/// the frame and reset it to its original clean state before it
/// is reused again.
///
/// The data described by an AVFrame is usually reference counted through the
/// AVBuffer API. The underlying buffer references are stored in AVFrame.buf /
/// AVFrame.extended_buf. An AVFrame is considered to be reference counted if at
/// least one reference is set, i.e. if AVFrame.buf[0] != NULL. In such a case,
/// every single data plane must be contained in one of the buffers in
/// AVFrame.buf or AVFrame.extended_buf.
/// There may be a single buffer for all the data, or one separate buffer for
/// each plane, or anything in between.
///
/// sizeof(AVFrame) is not a part of the public ABI, so new fields may be added
/// to the end with a minor bump.
///
/// Fields can be accessed through AVOptions, the name string used, matches the
/// C structure field name for fields accessible through AVOptions. The AVClass
/// for AVFrame can be obtained from avcodec_get_frame_class()
class AVFrame extends ffi.Struct {}

abstract class AVHWDeviceType {
  static const int AV_HWDEVICE_TYPE_NONE = 0;
  static const int AV_HWDEVICE_TYPE_VDPAU = 1;
  static const int AV_HWDEVICE_TYPE_CUDA = 2;
  static const int AV_HWDEVICE_TYPE_VAAPI = 3;
  static const int AV_HWDEVICE_TYPE_DXVA2 = 4;
  static const int AV_HWDEVICE_TYPE_QSV = 5;
  static const int AV_HWDEVICE_TYPE_VIDEOTOOLBOX = 6;
  static const int AV_HWDEVICE_TYPE_D3D11VA = 7;
  static const int AV_HWDEVICE_TYPE_DRM = 8;
  static const int AV_HWDEVICE_TYPE_OPENCL = 9;
  static const int AV_HWDEVICE_TYPE_MEDIACODEC = 10;
  static const int AV_HWDEVICE_TYPE_VULKAN = 11;
}

class AVHWDeviceInternal extends ffi.Struct {}

/// This struct aggregates all the (hardware/vendor-specific) "high-level" state,
/// i.e. state that is not tied to a concrete processing configuration.
/// E.g., in an API that supports hardware-accelerated encoding and decoding,
/// this struct will (if possible) wrap the state that is common to both encoding
/// and decoding and from which specific instances of encoders or decoders can be
/// derived.
///
/// This struct is reference-counted with the AVBuffer mechanism. The
/// av_hwdevice_ctx_alloc() constructor yields a reference, whose data field
/// points to the actual AVHWDeviceContext. Further objects derived from
/// AVHWDeviceContext (such as AVHWFramesContext, describing a frame pool with
/// specific properties) will hold an internal reference to it. After all the
/// references are released, the AVHWDeviceContext itself will be freed,
/// optionally invoking a user-specified callback for uninitializing the hardware
/// state.
class AVHWDeviceContext extends ffi.Struct {
  /// A class for logging. Set by av_hwdevice_ctx_alloc().
  ffi.Pointer<AVClass> av_class;

  /// Private data used internally by libavutil. Must not be accessed in any
  /// way by the caller.
  ffi.Pointer<AVHWDeviceInternal> internal;

  /// This field identifies the underlying API used for hardware access.
  ///
  /// This field is set when this struct is allocated and never changed
  /// afterwards.
  @ffi.Int32()
  int type;

  /// The format-specific data, allocated and freed by libavutil along with
  /// this context.
  ///
  /// Should be cast by the user to the format-specific context defined in the
  /// corresponding header (hwcontext_*.h) and filled as described in the
  /// documentation before calling av_hwdevice_ctx_init().
  ///
  /// After calling av_hwdevice_ctx_init() this struct should not be modified
  /// by the caller.
  ffi.Pointer<ffi.Void> hwctx;

  /// This field may be set by the caller before calling av_hwdevice_ctx_init().
  ///
  /// If non-NULL, this callback will be called when the last reference to
  /// this context is unreferenced, immediately before it is freed.
  ///
  /// @note when other objects (e.g an AVHWFramesContext) are derived from this
  /// struct, this callback will be invoked after all such child objects
  /// are fully uninitialized and their respective destructors invoked.
  ffi.Pointer<ffi.NativeFunction<_typedefC_12>> free;

  /// Arbitrary user data, to be used e.g. by the free() callback.
  ffi.Pointer<ffi.Void> user_opaque;
}

class AVHWFramesInternal extends ffi.Struct {}

/// This struct describes a set or pool of "hardware" frames (i.e. those with
/// data not located in normal system memory). All the frames in the pool are
/// assumed to be allocated in the same way and interchangeable.
///
/// This struct is reference-counted with the AVBuffer mechanism and tied to a
/// given AVHWDeviceContext instance. The av_hwframe_ctx_alloc() constructor
/// yields a reference, whose data field points to the actual AVHWFramesContext
/// struct.
class AVHWFramesContext extends ffi.Struct {
  /// A class for logging.
  ffi.Pointer<AVClass> av_class;

  /// Private data used internally by libavutil. Must not be accessed in any
  /// way by the caller.
  ffi.Pointer<AVHWFramesInternal> internal;

  /// A reference to the parent AVHWDeviceContext. This reference is owned and
  /// managed by the enclosing AVHWFramesContext, but the caller may derive
  /// additional references from it.
  ffi.Pointer<AVBufferRef> device_ref;

  /// The parent AVHWDeviceContext. This is simply a pointer to
  /// device_ref->data provided for convenience.
  ///
  /// Set by libavutil in av_hwframe_ctx_init().
  ffi.Pointer<AVHWDeviceContext> device_ctx;

  /// The format-specific data, allocated and freed automatically along with
  /// this context.
  ///
  /// Should be cast by the user to the format-specific context defined in the
  /// corresponding header (hwframe_*.h) and filled as described in the
  /// documentation before calling av_hwframe_ctx_init().
  ///
  /// After any frames using this context are created, the contents of this
  /// struct should not be modified by the caller.
  ffi.Pointer<ffi.Void> hwctx;

  /// This field may be set by the caller before calling av_hwframe_ctx_init().
  ///
  /// If non-NULL, this callback will be called when the last reference to
  /// this context is unreferenced, immediately before it is freed.
  ffi.Pointer<ffi.NativeFunction<_typedefC_13>> free;

  /// Arbitrary user data, to be used e.g. by the free() callback.
  ffi.Pointer<ffi.Void> user_opaque;

  /// A pool from which the frames are allocated by av_hwframe_get_buffer().
  /// This field may be set by the caller before calling av_hwframe_ctx_init().
  /// The buffers returned by calling av_buffer_pool_get() on this pool must
  /// have the properties described in the documentation in the corresponding hw
  /// type's header (hwcontext_*.h). The pool will be freed strictly before
  /// this struct's free() callback is invoked.
  ///
  /// This field may be NULL, then libavutil will attempt to allocate a pool
  /// internally. Note that certain device types enforce pools allocated at
  /// fixed size (frame count), which cannot be extended dynamically. In such a
  /// case, initial_pool_size must be set appropriately.
  ffi.Pointer<AVBufferPool> pool;

  /// Initial size of the frame pool. If a device type does not support
  /// dynamically resizing the pool, then this is also the maximum pool size.
  ///
  /// May be set by the caller before calling av_hwframe_ctx_init(). Must be
  /// set if pool is NULL and the device type does not support dynamic pools.
  @ffi.Int32()
  int initial_pool_size;

  /// The pixel format identifying the underlying HW surface type.
  ///
  /// Must be a hwaccel format, i.e. the corresponding descriptor must have the
  /// AV_PIX_FMT_FLAG_HWACCEL flag set.
  ///
  /// Must be set by the user before calling av_hwframe_ctx_init().
  @ffi.Int32()
  int format;

  /// The pixel format identifying the actual data layout of the hardware
  /// frames.
  ///
  /// Must be set by the caller before calling av_hwframe_ctx_init().
  ///
  /// @note when the underlying API does not provide the exact data layout, but
  /// only the colorspace/bit depth, this field should be set to the fully
  /// planar version of that format (e.g. for 8-bit 420 YUV it should be
  /// AV_PIX_FMT_YUV420P, not AV_PIX_FMT_NV12 or anything else).
  @ffi.Int32()
  int sw_format;

  /// The allocated dimensions of the frames in this pool.
  ///
  /// Must be set by the user before calling av_hwframe_ctx_init().
  @ffi.Int32()
  int width;

  @ffi.Int32()
  int height;
}

abstract class AVHWFrameTransferDirection {
  /// Transfer the data from the queried hw frame.
  static const int AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0;

  /// Transfer the data to the queried hw frame.
  static const int AV_HWFRAME_TRANSFER_DIRECTION_TO = 1;
}

/// This struct describes the constraints on hardware frames attached to
/// a given device with a hardware-specific configuration.  This is returned
/// by av_hwdevice_get_hwframe_constraints() and must be freed by
/// av_hwframe_constraints_free() after use.
class AVHWFramesConstraints extends ffi.Struct {
  /// A list of possible values for format in the hw_frames_ctx,
  /// terminated by AV_PIX_FMT_NONE.  This member will always be filled.
  ffi.Pointer<ffi.Int32> valid_hw_formats;

  /// A list of possible values for sw_format in the hw_frames_ctx,
  /// terminated by AV_PIX_FMT_NONE.  Can be NULL if this information is
  /// not known.
  ffi.Pointer<ffi.Int32> valid_sw_formats;

  /// The minimum size of frames in this hw_frames_ctx.
  /// (Zero if not known.)
  @ffi.Int32()
  int min_width;

  @ffi.Int32()
  int min_height;

  /// The maximum size of frames in this hw_frames_ctx.
  /// (INT_MAX if not known / no limit.)
  @ffi.Int32()
  int max_width;

  @ffi.Int32()
  int max_height;
}

/// Identify the syntax and semantics of the bitstream.
/// The principle is roughly:
/// Two decoders with the same ID can decode the same streams.
/// Two encoders with the same ID can encode compatible streams.
/// There may be slight deviations from the principle due to implementation
/// details.
///
/// If you add a codec ID to this list, add it so that
/// 1. no value of an existing codec ID changes (that would break ABI),
/// 2. it is as close as possible to similar codecs
///
/// After adding new codec IDs, do not forget to add an entry to the codec
/// descriptor list and bump libavcodec minor version.
abstract class AVCodecID {
  static const int AV_CODEC_ID_NONE = 0;
  static const int AV_CODEC_ID_MPEG1VIDEO = 1;

  /// ///< preferred ID for MPEG-1/2 video decoding
  static const int AV_CODEC_ID_MPEG2VIDEO = 2;
  static const int AV_CODEC_ID_H261 = 3;
  static const int AV_CODEC_ID_H263 = 4;
  static const int AV_CODEC_ID_RV10 = 5;
  static const int AV_CODEC_ID_RV20 = 6;
  static const int AV_CODEC_ID_MJPEG = 7;
  static const int AV_CODEC_ID_MJPEGB = 8;
  static const int AV_CODEC_ID_LJPEG = 9;
  static const int AV_CODEC_ID_SP5X = 10;
  static const int AV_CODEC_ID_JPEGLS = 11;
  static const int AV_CODEC_ID_MPEG4 = 12;
  static const int AV_CODEC_ID_RAWVIDEO = 13;
  static const int AV_CODEC_ID_MSMPEG4V1 = 14;
  static const int AV_CODEC_ID_MSMPEG4V2 = 15;
  static const int AV_CODEC_ID_MSMPEG4V3 = 16;
  static const int AV_CODEC_ID_WMV1 = 17;
  static const int AV_CODEC_ID_WMV2 = 18;
  static const int AV_CODEC_ID_H263P = 19;
  static const int AV_CODEC_ID_H263I = 20;
  static const int AV_CODEC_ID_FLV1 = 21;
  static const int AV_CODEC_ID_SVQ1 = 22;
  static const int AV_CODEC_ID_SVQ3 = 23;
  static const int AV_CODEC_ID_DVVIDEO = 24;
  static const int AV_CODEC_ID_HUFFYUV = 25;
  static const int AV_CODEC_ID_CYUV = 26;
  static const int AV_CODEC_ID_H264 = 27;
  static const int AV_CODEC_ID_INDEO3 = 28;
  static const int AV_CODEC_ID_VP3 = 29;
  static const int AV_CODEC_ID_THEORA = 30;
  static const int AV_CODEC_ID_ASV1 = 31;
  static const int AV_CODEC_ID_ASV2 = 32;
  static const int AV_CODEC_ID_FFV1 = 33;
  static const int AV_CODEC_ID_4XM = 34;
  static const int AV_CODEC_ID_VCR1 = 35;
  static const int AV_CODEC_ID_CLJR = 36;
  static const int AV_CODEC_ID_MDEC = 37;
  static const int AV_CODEC_ID_ROQ = 38;
  static const int AV_CODEC_ID_INTERPLAY_VIDEO = 39;
  static const int AV_CODEC_ID_XAN_WC3 = 40;
  static const int AV_CODEC_ID_XAN_WC4 = 41;
  static const int AV_CODEC_ID_RPZA = 42;
  static const int AV_CODEC_ID_CINEPAK = 43;
  static const int AV_CODEC_ID_WS_VQA = 44;
  static const int AV_CODEC_ID_MSRLE = 45;
  static const int AV_CODEC_ID_MSVIDEO1 = 46;
  static const int AV_CODEC_ID_IDCIN = 47;
  static const int AV_CODEC_ID_8BPS = 48;
  static const int AV_CODEC_ID_SMC = 49;
  static const int AV_CODEC_ID_FLIC = 50;
  static const int AV_CODEC_ID_TRUEMOTION1 = 51;
  static const int AV_CODEC_ID_VMDVIDEO = 52;
  static const int AV_CODEC_ID_MSZH = 53;
  static const int AV_CODEC_ID_ZLIB = 54;
  static const int AV_CODEC_ID_QTRLE = 55;
  static const int AV_CODEC_ID_TSCC = 56;
  static const int AV_CODEC_ID_ULTI = 57;
  static const int AV_CODEC_ID_QDRAW = 58;
  static const int AV_CODEC_ID_VIXL = 59;
  static const int AV_CODEC_ID_QPEG = 60;
  static const int AV_CODEC_ID_PNG = 61;
  static const int AV_CODEC_ID_PPM = 62;
  static const int AV_CODEC_ID_PBM = 63;
  static const int AV_CODEC_ID_PGM = 64;
  static const int AV_CODEC_ID_PGMYUV = 65;
  static const int AV_CODEC_ID_PAM = 66;
  static const int AV_CODEC_ID_FFVHUFF = 67;
  static const int AV_CODEC_ID_RV30 = 68;
  static const int AV_CODEC_ID_RV40 = 69;
  static const int AV_CODEC_ID_VC1 = 70;
  static const int AV_CODEC_ID_WMV3 = 71;
  static const int AV_CODEC_ID_LOCO = 72;
  static const int AV_CODEC_ID_WNV1 = 73;
  static const int AV_CODEC_ID_AASC = 74;
  static const int AV_CODEC_ID_INDEO2 = 75;
  static const int AV_CODEC_ID_FRAPS = 76;
  static const int AV_CODEC_ID_TRUEMOTION2 = 77;
  static const int AV_CODEC_ID_BMP = 78;
  static const int AV_CODEC_ID_CSCD = 79;
  static const int AV_CODEC_ID_MMVIDEO = 80;
  static const int AV_CODEC_ID_ZMBV = 81;
  static const int AV_CODEC_ID_AVS = 82;
  static const int AV_CODEC_ID_SMACKVIDEO = 83;
  static const int AV_CODEC_ID_NUV = 84;
  static const int AV_CODEC_ID_KMVC = 85;
  static const int AV_CODEC_ID_FLASHSV = 86;
  static const int AV_CODEC_ID_CAVS = 87;
  static const int AV_CODEC_ID_JPEG2000 = 88;
  static const int AV_CODEC_ID_VMNC = 89;
  static const int AV_CODEC_ID_VP5 = 90;
  static const int AV_CODEC_ID_VP6 = 91;
  static const int AV_CODEC_ID_VP6F = 92;
  static const int AV_CODEC_ID_TARGA = 93;
  static const int AV_CODEC_ID_DSICINVIDEO = 94;
  static const int AV_CODEC_ID_TIERTEXSEQVIDEO = 95;
  static const int AV_CODEC_ID_TIFF = 96;
  static const int AV_CODEC_ID_GIF = 97;
  static const int AV_CODEC_ID_DXA = 98;
  static const int AV_CODEC_ID_DNXHD = 99;
  static const int AV_CODEC_ID_THP = 100;
  static const int AV_CODEC_ID_SGI = 101;
  static const int AV_CODEC_ID_C93 = 102;
  static const int AV_CODEC_ID_BETHSOFTVID = 103;
  static const int AV_CODEC_ID_PTX = 104;
  static const int AV_CODEC_ID_TXD = 105;
  static const int AV_CODEC_ID_VP6A = 106;
  static const int AV_CODEC_ID_AMV = 107;
  static const int AV_CODEC_ID_VB = 108;
  static const int AV_CODEC_ID_PCX = 109;
  static const int AV_CODEC_ID_SUNRAST = 110;
  static const int AV_CODEC_ID_INDEO4 = 111;
  static const int AV_CODEC_ID_INDEO5 = 112;
  static const int AV_CODEC_ID_MIMIC = 113;
  static const int AV_CODEC_ID_RL2 = 114;
  static const int AV_CODEC_ID_ESCAPE124 = 115;
  static const int AV_CODEC_ID_DIRAC = 116;
  static const int AV_CODEC_ID_BFI = 117;
  static const int AV_CODEC_ID_CMV = 118;
  static const int AV_CODEC_ID_MOTIONPIXELS = 119;
  static const int AV_CODEC_ID_TGV = 120;
  static const int AV_CODEC_ID_TGQ = 121;
  static const int AV_CODEC_ID_TQI = 122;
  static const int AV_CODEC_ID_AURA = 123;
  static const int AV_CODEC_ID_AURA2 = 124;
  static const int AV_CODEC_ID_V210X = 125;
  static const int AV_CODEC_ID_TMV = 126;
  static const int AV_CODEC_ID_V210 = 127;
  static const int AV_CODEC_ID_DPX = 128;
  static const int AV_CODEC_ID_MAD = 129;
  static const int AV_CODEC_ID_FRWU = 130;
  static const int AV_CODEC_ID_FLASHSV2 = 131;
  static const int AV_CODEC_ID_CDGRAPHICS = 132;
  static const int AV_CODEC_ID_R210 = 133;
  static const int AV_CODEC_ID_ANM = 134;
  static const int AV_CODEC_ID_BINKVIDEO = 135;
  static const int AV_CODEC_ID_IFF_ILBM = 136;
  static const int AV_CODEC_ID_KGV1 = 137;
  static const int AV_CODEC_ID_YOP = 138;
  static const int AV_CODEC_ID_VP8 = 139;
  static const int AV_CODEC_ID_PICTOR = 140;
  static const int AV_CODEC_ID_ANSI = 141;
  static const int AV_CODEC_ID_A64_MULTI = 142;
  static const int AV_CODEC_ID_A64_MULTI5 = 143;
  static const int AV_CODEC_ID_R10K = 144;
  static const int AV_CODEC_ID_MXPEG = 145;
  static const int AV_CODEC_ID_LAGARITH = 146;
  static const int AV_CODEC_ID_PRORES = 147;
  static const int AV_CODEC_ID_JV = 148;
  static const int AV_CODEC_ID_DFA = 149;
  static const int AV_CODEC_ID_WMV3IMAGE = 150;
  static const int AV_CODEC_ID_VC1IMAGE = 151;
  static const int AV_CODEC_ID_UTVIDEO = 152;
  static const int AV_CODEC_ID_BMV_VIDEO = 153;
  static const int AV_CODEC_ID_VBLE = 154;
  static const int AV_CODEC_ID_DXTORY = 155;
  static const int AV_CODEC_ID_V410 = 156;
  static const int AV_CODEC_ID_XWD = 157;
  static const int AV_CODEC_ID_CDXL = 158;
  static const int AV_CODEC_ID_XBM = 159;
  static const int AV_CODEC_ID_ZEROCODEC = 160;
  static const int AV_CODEC_ID_MSS1 = 161;
  static const int AV_CODEC_ID_MSA1 = 162;
  static const int AV_CODEC_ID_TSCC2 = 163;
  static const int AV_CODEC_ID_MTS2 = 164;
  static const int AV_CODEC_ID_CLLC = 165;
  static const int AV_CODEC_ID_MSS2 = 166;
  static const int AV_CODEC_ID_VP9 = 167;
  static const int AV_CODEC_ID_AIC = 168;
  static const int AV_CODEC_ID_ESCAPE130 = 169;
  static const int AV_CODEC_ID_G2M = 170;
  static const int AV_CODEC_ID_WEBP = 171;
  static const int AV_CODEC_ID_HNM4_VIDEO = 172;
  static const int AV_CODEC_ID_HEVC = 173;
  static const int AV_CODEC_ID_FIC = 174;
  static const int AV_CODEC_ID_ALIAS_PIX = 175;
  static const int AV_CODEC_ID_BRENDER_PIX = 176;
  static const int AV_CODEC_ID_PAF_VIDEO = 177;
  static const int AV_CODEC_ID_EXR = 178;
  static const int AV_CODEC_ID_VP7 = 179;
  static const int AV_CODEC_ID_SANM = 180;
  static const int AV_CODEC_ID_SGIRLE = 181;
  static const int AV_CODEC_ID_MVC1 = 182;
  static const int AV_CODEC_ID_MVC2 = 183;
  static const int AV_CODEC_ID_HQX = 184;
  static const int AV_CODEC_ID_TDSC = 185;
  static const int AV_CODEC_ID_HQ_HQA = 186;
  static const int AV_CODEC_ID_HAP = 187;
  static const int AV_CODEC_ID_DDS = 188;
  static const int AV_CODEC_ID_DXV = 189;
  static const int AV_CODEC_ID_SCREENPRESSO = 190;
  static const int AV_CODEC_ID_RSCC = 191;
  static const int AV_CODEC_ID_AVS2 = 192;
  static const int AV_CODEC_ID_PGX = 193;
  static const int AV_CODEC_ID_AVS3 = 194;
  static const int AV_CODEC_ID_MSP2 = 195;
  static const int AV_CODEC_ID_VVC = 196;
  static const int AV_CODEC_ID_Y41P = 32768;
  static const int AV_CODEC_ID_AVRP = 32769;
  static const int AV_CODEC_ID_012V = 32770;
  static const int AV_CODEC_ID_AVUI = 32771;
  static const int AV_CODEC_ID_AYUV = 32772;
  static const int AV_CODEC_ID_TARGA_Y216 = 32773;
  static const int AV_CODEC_ID_V308 = 32774;
  static const int AV_CODEC_ID_V408 = 32775;
  static const int AV_CODEC_ID_YUV4 = 32776;
  static const int AV_CODEC_ID_AVRN = 32777;
  static const int AV_CODEC_ID_CPIA = 32778;
  static const int AV_CODEC_ID_XFACE = 32779;
  static const int AV_CODEC_ID_SNOW = 32780;
  static const int AV_CODEC_ID_SMVJPEG = 32781;
  static const int AV_CODEC_ID_APNG = 32782;
  static const int AV_CODEC_ID_DAALA = 32783;
  static const int AV_CODEC_ID_CFHD = 32784;
  static const int AV_CODEC_ID_TRUEMOTION2RT = 32785;
  static const int AV_CODEC_ID_M101 = 32786;
  static const int AV_CODEC_ID_MAGICYUV = 32787;
  static const int AV_CODEC_ID_SHEERVIDEO = 32788;
  static const int AV_CODEC_ID_YLC = 32789;
  static const int AV_CODEC_ID_PSD = 32790;
  static const int AV_CODEC_ID_PIXLET = 32791;
  static const int AV_CODEC_ID_SPEEDHQ = 32792;
  static const int AV_CODEC_ID_FMVC = 32793;
  static const int AV_CODEC_ID_SCPR = 32794;
  static const int AV_CODEC_ID_CLEARVIDEO = 32795;
  static const int AV_CODEC_ID_XPM = 32796;
  static const int AV_CODEC_ID_AV1 = 32797;
  static const int AV_CODEC_ID_BITPACKED = 32798;
  static const int AV_CODEC_ID_MSCC = 32799;
  static const int AV_CODEC_ID_SRGC = 32800;
  static const int AV_CODEC_ID_SVG = 32801;
  static const int AV_CODEC_ID_GDV = 32802;
  static const int AV_CODEC_ID_FITS = 32803;
  static const int AV_CODEC_ID_IMM4 = 32804;
  static const int AV_CODEC_ID_PROSUMER = 32805;
  static const int AV_CODEC_ID_MWSC = 32806;
  static const int AV_CODEC_ID_WCMV = 32807;
  static const int AV_CODEC_ID_RASC = 32808;
  static const int AV_CODEC_ID_HYMT = 32809;
  static const int AV_CODEC_ID_ARBC = 32810;
  static const int AV_CODEC_ID_AGM = 32811;
  static const int AV_CODEC_ID_LSCR = 32812;
  static const int AV_CODEC_ID_VP4 = 32813;
  static const int AV_CODEC_ID_IMM5 = 32814;
  static const int AV_CODEC_ID_MVDV = 32815;
  static const int AV_CODEC_ID_MVHA = 32816;
  static const int AV_CODEC_ID_CDTOONS = 32817;
  static const int AV_CODEC_ID_MV30 = 32818;
  static const int AV_CODEC_ID_NOTCHLC = 32819;
  static const int AV_CODEC_ID_PFM = 32820;
  static const int AV_CODEC_ID_MOBICLIP = 32821;
  static const int AV_CODEC_ID_PHOTOCD = 32822;
  static const int AV_CODEC_ID_IPU = 32823;
  static const int AV_CODEC_ID_ARGO = 32824;
  static const int AV_CODEC_ID_CRI = 32825;

  /// ///< A dummy id pointing at the start of audio codecs
  static const int AV_CODEC_ID_FIRST_AUDIO = 65536;
  static const int AV_CODEC_ID_PCM_S16LE = 65536;
  static const int AV_CODEC_ID_PCM_S16BE = 65537;
  static const int AV_CODEC_ID_PCM_U16LE = 65538;
  static const int AV_CODEC_ID_PCM_U16BE = 65539;
  static const int AV_CODEC_ID_PCM_S8 = 65540;
  static const int AV_CODEC_ID_PCM_U8 = 65541;
  static const int AV_CODEC_ID_PCM_MULAW = 65542;
  static const int AV_CODEC_ID_PCM_ALAW = 65543;
  static const int AV_CODEC_ID_PCM_S32LE = 65544;
  static const int AV_CODEC_ID_PCM_S32BE = 65545;
  static const int AV_CODEC_ID_PCM_U32LE = 65546;
  static const int AV_CODEC_ID_PCM_U32BE = 65547;
  static const int AV_CODEC_ID_PCM_S24LE = 65548;
  static const int AV_CODEC_ID_PCM_S24BE = 65549;
  static const int AV_CODEC_ID_PCM_U24LE = 65550;
  static const int AV_CODEC_ID_PCM_U24BE = 65551;
  static const int AV_CODEC_ID_PCM_S24DAUD = 65552;
  static const int AV_CODEC_ID_PCM_ZORK = 65553;
  static const int AV_CODEC_ID_PCM_S16LE_PLANAR = 65554;
  static const int AV_CODEC_ID_PCM_DVD = 65555;
  static const int AV_CODEC_ID_PCM_F32BE = 65556;
  static const int AV_CODEC_ID_PCM_F32LE = 65557;
  static const int AV_CODEC_ID_PCM_F64BE = 65558;
  static const int AV_CODEC_ID_PCM_F64LE = 65559;
  static const int AV_CODEC_ID_PCM_BLURAY = 65560;
  static const int AV_CODEC_ID_PCM_LXF = 65561;
  static const int AV_CODEC_ID_S302M = 65562;
  static const int AV_CODEC_ID_PCM_S8_PLANAR = 65563;
  static const int AV_CODEC_ID_PCM_S24LE_PLANAR = 65564;
  static const int AV_CODEC_ID_PCM_S32LE_PLANAR = 65565;
  static const int AV_CODEC_ID_PCM_S16BE_PLANAR = 65566;
  static const int AV_CODEC_ID_PCM_S64LE = 67584;
  static const int AV_CODEC_ID_PCM_S64BE = 67585;
  static const int AV_CODEC_ID_PCM_F16LE = 67586;
  static const int AV_CODEC_ID_PCM_F24LE = 67587;
  static const int AV_CODEC_ID_PCM_VIDC = 67588;
  static const int AV_CODEC_ID_ADPCM_IMA_QT = 69632;
  static const int AV_CODEC_ID_ADPCM_IMA_WAV = 69633;
  static const int AV_CODEC_ID_ADPCM_IMA_DK3 = 69634;
  static const int AV_CODEC_ID_ADPCM_IMA_DK4 = 69635;
  static const int AV_CODEC_ID_ADPCM_IMA_WS = 69636;
  static const int AV_CODEC_ID_ADPCM_IMA_SMJPEG = 69637;
  static const int AV_CODEC_ID_ADPCM_MS = 69638;
  static const int AV_CODEC_ID_ADPCM_4XM = 69639;
  static const int AV_CODEC_ID_ADPCM_XA = 69640;
  static const int AV_CODEC_ID_ADPCM_ADX = 69641;
  static const int AV_CODEC_ID_ADPCM_EA = 69642;
  static const int AV_CODEC_ID_ADPCM_G726 = 69643;
  static const int AV_CODEC_ID_ADPCM_CT = 69644;
  static const int AV_CODEC_ID_ADPCM_SWF = 69645;
  static const int AV_CODEC_ID_ADPCM_YAMAHA = 69646;
  static const int AV_CODEC_ID_ADPCM_SBPRO_4 = 69647;
  static const int AV_CODEC_ID_ADPCM_SBPRO_3 = 69648;
  static const int AV_CODEC_ID_ADPCM_SBPRO_2 = 69649;
  static const int AV_CODEC_ID_ADPCM_THP = 69650;
  static const int AV_CODEC_ID_ADPCM_IMA_AMV = 69651;
  static const int AV_CODEC_ID_ADPCM_EA_R1 = 69652;
  static const int AV_CODEC_ID_ADPCM_EA_R3 = 69653;
  static const int AV_CODEC_ID_ADPCM_EA_R2 = 69654;
  static const int AV_CODEC_ID_ADPCM_IMA_EA_SEAD = 69655;
  static const int AV_CODEC_ID_ADPCM_IMA_EA_EACS = 69656;
  static const int AV_CODEC_ID_ADPCM_EA_XAS = 69657;
  static const int AV_CODEC_ID_ADPCM_EA_MAXIS_XA = 69658;
  static const int AV_CODEC_ID_ADPCM_IMA_ISS = 69659;
  static const int AV_CODEC_ID_ADPCM_G722 = 69660;
  static const int AV_CODEC_ID_ADPCM_IMA_APC = 69661;
  static const int AV_CODEC_ID_ADPCM_VIMA = 69662;
  static const int AV_CODEC_ID_ADPCM_AFC = 71680;
  static const int AV_CODEC_ID_ADPCM_IMA_OKI = 71681;
  static const int AV_CODEC_ID_ADPCM_DTK = 71682;
  static const int AV_CODEC_ID_ADPCM_IMA_RAD = 71683;
  static const int AV_CODEC_ID_ADPCM_G726LE = 71684;
  static const int AV_CODEC_ID_ADPCM_THP_LE = 71685;
  static const int AV_CODEC_ID_ADPCM_PSX = 71686;
  static const int AV_CODEC_ID_ADPCM_AICA = 71687;
  static const int AV_CODEC_ID_ADPCM_IMA_DAT4 = 71688;
  static const int AV_CODEC_ID_ADPCM_MTAF = 71689;
  static const int AV_CODEC_ID_ADPCM_AGM = 71690;
  static const int AV_CODEC_ID_ADPCM_ARGO = 71691;
  static const int AV_CODEC_ID_ADPCM_IMA_SSI = 71692;
  static const int AV_CODEC_ID_ADPCM_ZORK = 71693;
  static const int AV_CODEC_ID_ADPCM_IMA_APM = 71694;
  static const int AV_CODEC_ID_ADPCM_IMA_ALP = 71695;
  static const int AV_CODEC_ID_ADPCM_IMA_MTF = 71696;
  static const int AV_CODEC_ID_ADPCM_IMA_CUNNING = 71697;
  static const int AV_CODEC_ID_ADPCM_IMA_MOFLEX = 71698;
  static const int AV_CODEC_ID_AMR_NB = 73728;
  static const int AV_CODEC_ID_AMR_WB = 73729;
  static const int AV_CODEC_ID_RA_144 = 77824;
  static const int AV_CODEC_ID_RA_288 = 77825;
  static const int AV_CODEC_ID_ROQ_DPCM = 81920;
  static const int AV_CODEC_ID_INTERPLAY_DPCM = 81921;
  static const int AV_CODEC_ID_XAN_DPCM = 81922;
  static const int AV_CODEC_ID_SOL_DPCM = 81923;
  static const int AV_CODEC_ID_SDX2_DPCM = 83968;
  static const int AV_CODEC_ID_GREMLIN_DPCM = 83969;
  static const int AV_CODEC_ID_DERF_DPCM = 83970;
  static const int AV_CODEC_ID_MP2 = 86016;

  /// ///< preferred ID for decoding MPEG audio layer 1, 2 or 3
  static const int AV_CODEC_ID_MP3 = 86017;
  static const int AV_CODEC_ID_AAC = 86018;
  static const int AV_CODEC_ID_AC3 = 86019;
  static const int AV_CODEC_ID_DTS = 86020;
  static const int AV_CODEC_ID_VORBIS = 86021;
  static const int AV_CODEC_ID_DVAUDIO = 86022;
  static const int AV_CODEC_ID_WMAV1 = 86023;
  static const int AV_CODEC_ID_WMAV2 = 86024;
  static const int AV_CODEC_ID_MACE3 = 86025;
  static const int AV_CODEC_ID_MACE6 = 86026;
  static const int AV_CODEC_ID_VMDAUDIO = 86027;
  static const int AV_CODEC_ID_FLAC = 86028;
  static const int AV_CODEC_ID_MP3ADU = 86029;
  static const int AV_CODEC_ID_MP3ON4 = 86030;
  static const int AV_CODEC_ID_SHORTEN = 86031;
  static const int AV_CODEC_ID_ALAC = 86032;
  static const int AV_CODEC_ID_WESTWOOD_SND1 = 86033;

  /// ///< as in Berlin toast format
  static const int AV_CODEC_ID_GSM = 86034;
  static const int AV_CODEC_ID_QDM2 = 86035;
  static const int AV_CODEC_ID_COOK = 86036;
  static const int AV_CODEC_ID_TRUESPEECH = 86037;
  static const int AV_CODEC_ID_TTA = 86038;
  static const int AV_CODEC_ID_SMACKAUDIO = 86039;
  static const int AV_CODEC_ID_QCELP = 86040;
  static const int AV_CODEC_ID_WAVPACK = 86041;
  static const int AV_CODEC_ID_DSICINAUDIO = 86042;
  static const int AV_CODEC_ID_IMC = 86043;
  static const int AV_CODEC_ID_MUSEPACK7 = 86044;
  static const int AV_CODEC_ID_MLP = 86045;
  static const int AV_CODEC_ID_GSM_MS = 86046;
  static const int AV_CODEC_ID_ATRAC3 = 86047;
  static const int AV_CODEC_ID_APE = 86048;
  static const int AV_CODEC_ID_NELLYMOSER = 86049;
  static const int AV_CODEC_ID_MUSEPACK8 = 86050;
  static const int AV_CODEC_ID_SPEEX = 86051;
  static const int AV_CODEC_ID_WMAVOICE = 86052;
  static const int AV_CODEC_ID_WMAPRO = 86053;
  static const int AV_CODEC_ID_WMALOSSLESS = 86054;
  static const int AV_CODEC_ID_ATRAC3P = 86055;
  static const int AV_CODEC_ID_EAC3 = 86056;
  static const int AV_CODEC_ID_SIPR = 86057;
  static const int AV_CODEC_ID_MP1 = 86058;
  static const int AV_CODEC_ID_TWINVQ = 86059;
  static const int AV_CODEC_ID_TRUEHD = 86060;
  static const int AV_CODEC_ID_MP4ALS = 86061;
  static const int AV_CODEC_ID_ATRAC1 = 86062;
  static const int AV_CODEC_ID_BINKAUDIO_RDFT = 86063;
  static const int AV_CODEC_ID_BINKAUDIO_DCT = 86064;
  static const int AV_CODEC_ID_AAC_LATM = 86065;
  static const int AV_CODEC_ID_QDMC = 86066;
  static const int AV_CODEC_ID_CELT = 86067;
  static const int AV_CODEC_ID_G723_1 = 86068;
  static const int AV_CODEC_ID_G729 = 86069;
  static const int AV_CODEC_ID_8SVX_EXP = 86070;
  static const int AV_CODEC_ID_8SVX_FIB = 86071;
  static const int AV_CODEC_ID_BMV_AUDIO = 86072;
  static const int AV_CODEC_ID_RALF = 86073;
  static const int AV_CODEC_ID_IAC = 86074;
  static const int AV_CODEC_ID_ILBC = 86075;
  static const int AV_CODEC_ID_OPUS = 86076;
  static const int AV_CODEC_ID_COMFORT_NOISE = 86077;
  static const int AV_CODEC_ID_TAK = 86078;
  static const int AV_CODEC_ID_METASOUND = 86079;
  static const int AV_CODEC_ID_PAF_AUDIO = 86080;
  static const int AV_CODEC_ID_ON2AVC = 86081;
  static const int AV_CODEC_ID_DSS_SP = 86082;
  static const int AV_CODEC_ID_CODEC2 = 86083;
  static const int AV_CODEC_ID_FFWAVESYNTH = 88064;
  static const int AV_CODEC_ID_SONIC = 88065;
  static const int AV_CODEC_ID_SONIC_LS = 88066;
  static const int AV_CODEC_ID_EVRC = 88067;
  static const int AV_CODEC_ID_SMV = 88068;
  static const int AV_CODEC_ID_DSD_LSBF = 88069;
  static const int AV_CODEC_ID_DSD_MSBF = 88070;
  static const int AV_CODEC_ID_DSD_LSBF_PLANAR = 88071;
  static const int AV_CODEC_ID_DSD_MSBF_PLANAR = 88072;
  static const int AV_CODEC_ID_4GV = 88073;
  static const int AV_CODEC_ID_INTERPLAY_ACM = 88074;
  static const int AV_CODEC_ID_XMA1 = 88075;
  static const int AV_CODEC_ID_XMA2 = 88076;
  static const int AV_CODEC_ID_DST = 88077;
  static const int AV_CODEC_ID_ATRAC3AL = 88078;
  static const int AV_CODEC_ID_ATRAC3PAL = 88079;
  static const int AV_CODEC_ID_DOLBY_E = 88080;
  static const int AV_CODEC_ID_APTX = 88081;
  static const int AV_CODEC_ID_APTX_HD = 88082;
  static const int AV_CODEC_ID_SBC = 88083;
  static const int AV_CODEC_ID_ATRAC9 = 88084;
  static const int AV_CODEC_ID_HCOM = 88085;
  static const int AV_CODEC_ID_ACELP_KELVIN = 88086;
  static const int AV_CODEC_ID_MPEGH_3D_AUDIO = 88087;
  static const int AV_CODEC_ID_SIREN = 88088;
  static const int AV_CODEC_ID_HCA = 88089;
  static const int AV_CODEC_ID_FASTAUDIO = 88090;

  /// ///< A dummy ID pointing at the start of subtitle codecs.
  static const int AV_CODEC_ID_FIRST_SUBTITLE = 94208;
  static const int AV_CODEC_ID_DVD_SUBTITLE = 94208;
  static const int AV_CODEC_ID_DVB_SUBTITLE = 94209;

  /// ///< raw UTF-8 text
  static const int AV_CODEC_ID_TEXT = 94210;
  static const int AV_CODEC_ID_XSUB = 94211;
  static const int AV_CODEC_ID_SSA = 94212;
  static const int AV_CODEC_ID_MOV_TEXT = 94213;
  static const int AV_CODEC_ID_HDMV_PGS_SUBTITLE = 94214;
  static const int AV_CODEC_ID_DVB_TELETEXT = 94215;
  static const int AV_CODEC_ID_SRT = 94216;
  static const int AV_CODEC_ID_MICRODVD = 96256;
  static const int AV_CODEC_ID_EIA_608 = 96257;
  static const int AV_CODEC_ID_JACOSUB = 96258;
  static const int AV_CODEC_ID_SAMI = 96259;
  static const int AV_CODEC_ID_REALTEXT = 96260;
  static const int AV_CODEC_ID_STL = 96261;
  static const int AV_CODEC_ID_SUBVIEWER1 = 96262;
  static const int AV_CODEC_ID_SUBVIEWER = 96263;
  static const int AV_CODEC_ID_SUBRIP = 96264;
  static const int AV_CODEC_ID_WEBVTT = 96265;
  static const int AV_CODEC_ID_MPL2 = 96266;
  static const int AV_CODEC_ID_VPLAYER = 96267;
  static const int AV_CODEC_ID_PJS = 96268;
  static const int AV_CODEC_ID_ASS = 96269;
  static const int AV_CODEC_ID_HDMV_TEXT_SUBTITLE = 96270;
  static const int AV_CODEC_ID_TTML = 96271;
  static const int AV_CODEC_ID_ARIB_CAPTION = 96272;

  /// ///< A dummy ID pointing at the start of various fake codecs.
  static const int AV_CODEC_ID_FIRST_UNKNOWN = 98304;
  static const int AV_CODEC_ID_TTF = 98304;

  /// ///< Contain timestamp estimated through PCR of program stream.
  static const int AV_CODEC_ID_SCTE_35 = 98305;
  static const int AV_CODEC_ID_EPG = 98306;
  static const int AV_CODEC_ID_BINTEXT = 100352;
  static const int AV_CODEC_ID_XBIN = 100353;
  static const int AV_CODEC_ID_IDF = 100354;
  static const int AV_CODEC_ID_OTF = 100355;
  static const int AV_CODEC_ID_SMPTE_KLV = 100356;
  static const int AV_CODEC_ID_DVD_NAV = 100357;
  static const int AV_CODEC_ID_TIMED_ID3 = 100358;
  static const int AV_CODEC_ID_BIN_DATA = 100359;

  /// ///< codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it
  static const int AV_CODEC_ID_PROBE = 102400;

  /// < _FAKE_ codec to indicate a raw MPEG-2 TS
  /// stream (only used by libavformat)
  static const int AV_CODEC_ID_MPEG2TS = 131072;

  /// < _FAKE_ codec to indicate a MPEG-4 Systems
  /// stream (only used by libavformat)
  static const int AV_CODEC_ID_MPEG4SYSTEMS = 131073;

  /// ///< Dummy codec for streams containing only metadata information.
  static const int AV_CODEC_ID_FFMETADATA = 135168;

  /// ///< Passthrough codec, AVFrames wrapped in AVPacket
  static const int AV_CODEC_ID_WRAPPED_AVFRAME = 135169;
}

/// @addtogroup lavc_core
abstract class AVFieldOrder {
  static const int AV_FIELD_UNKNOWN = 0;
  static const int AV_FIELD_PROGRESSIVE = 1;
  static const int AV_FIELD_TT = 2;
  static const int AV_FIELD_BB = 3;
  static const int AV_FIELD_TB = 4;
  static const int AV_FIELD_BT = 5;
}

/// This struct describes the properties of an encoded stream.
///
/// sizeof(AVCodecParameters) is not a part of the public ABI, this struct must
/// be allocated with avcodec_parameters_alloc() and freed with
/// avcodec_parameters_free().
class AVCodecParameters extends ffi.Struct {}

/// @defgroup lavc_packet AVPacket
///
/// Types and functions for working with AVPacket.
/// @{
abstract class AVPacketSideDataType {
  /// An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE
  /// bytes worth of palette. This side data signals that a new palette is
  /// present.
  static const int AV_PKT_DATA_PALETTE = 0;

  /// The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format
  /// that the extradata buffer was changed and the receiving side should
  /// act upon it appropriately. The new extradata is embedded in the side
  /// data buffer and should be immediately used for processing the current
  /// frame or packet.
  static const int AV_PKT_DATA_NEW_EXTRADATA = 1;

  /// An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:
  /// @code
  /// u32le param_flags
  /// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT)
  /// s32le channel_count
  /// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT)
  /// u64le channel_layout
  /// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE)
  /// s32le sample_rate
  /// if (param_flags & AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS)
  /// s32le width
  /// s32le height
  /// @endcode
  static const int AV_PKT_DATA_PARAM_CHANGE = 2;

  /// An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of
  /// structures with info about macroblocks relevant to splitting the
  /// packet into smaller packets on macroblock edges (e.g. as for RFC 2190).
  /// That is, it does not necessarily contain info about all macroblocks,
  /// as long as the distance between macroblocks in the info is smaller
  /// than the target payload size.
  /// Each MB info structure is 12 bytes, and is laid out as follows:
  /// @code
  /// u32le bit offset from the start of the packet
  /// u8    current quantizer at the start of the macroblock
  /// u8    GOB number
  /// u16le macroblock address within the GOB
  /// u8    horizontal MV predictor
  /// u8    vertical MV predictor
  /// u8    horizontal MV predictor for block number 3
  /// u8    vertical MV predictor for block number 3
  /// @endcode
  static const int AV_PKT_DATA_H263_MB_INFO = 3;

  /// This side data should be associated with an audio stream and contains
  /// ReplayGain information in form of the AVReplayGain struct.
  static const int AV_PKT_DATA_REPLAYGAIN = 4;

  /// This side data contains a 3x3 transformation matrix describing an affine
  /// transformation that needs to be applied to the decoded video frames for
  /// correct presentation.
  ///
  /// See libavutil/display.h for a detailed description of the data.
  static const int AV_PKT_DATA_DISPLAYMATRIX = 5;

  /// This side data should be associated with a video stream and contains
  /// Stereoscopic 3D information in form of the AVStereo3D struct.
  static const int AV_PKT_DATA_STEREO3D = 6;

  /// This side data should be associated with an audio stream and corresponds
  /// to enum AVAudioServiceType.
  static const int AV_PKT_DATA_AUDIO_SERVICE_TYPE = 7;

  /// This side data contains quality related information from the encoder.
  /// @code
  /// u32le quality factor of the compressed frame. Allowed range is between 1 (good) and FF_LAMBDA_MAX (bad).
  /// u8    picture type
  /// u8    error count
  /// u16   reserved
  /// u64le[error count] sum of squared differences between encoder in and output
  /// @endcode
  static const int AV_PKT_DATA_QUALITY_STATS = 8;

  /// This side data contains an integer value representing the stream index
  /// of a "fallback" track.  A fallback track indicates an alternate
  /// track to use when the current track can not be decoded for some reason.
  /// e.g. no decoder available for codec.
  static const int AV_PKT_DATA_FALLBACK_TRACK = 9;

  /// This side data corresponds to the AVCPBProperties struct.
  static const int AV_PKT_DATA_CPB_PROPERTIES = 10;

  /// Recommmends skipping the specified number of samples
  /// @code
  /// u32le number of samples to skip from start of this packet
  /// u32le number of samples to skip from end of this packet
  /// u8    reason for start skip
  /// u8    reason for end   skip (0=padding silence, 1=convergence)
  /// @endcode
  static const int AV_PKT_DATA_SKIP_SAMPLES = 11;

  /// An AV_PKT_DATA_JP_DUALMONO side data packet indicates that
  /// the packet may contain "dual mono" audio specific to Japanese DTV
  /// and if it is true, recommends only the selected channel to be used.
  /// @code
  /// u8    selected channels (0=mail/left, 1=sub/right, 2=both)
  /// @endcode
  static const int AV_PKT_DATA_JP_DUALMONO = 12;

  /// A list of zero terminated key/value strings. There is no end marker for
  /// the list, so it is required to rely on the side data size to stop.
  static const int AV_PKT_DATA_STRINGS_METADATA = 13;

  /// Subtitle event position
  /// @code
  /// u32le x1
  /// u32le y1
  /// u32le x2
  /// u32le y2
  /// @endcode
  static const int AV_PKT_DATA_SUBTITLE_POSITION = 14;

  /// Data found in BlockAdditional element of matroska container. There is
  /// no end marker for the data, so it is required to rely on the side data
  /// size to recognize the end. 8 byte id (as found in BlockAddId) followed
  /// by data.
  static const int AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL = 15;

  /// The optional first identifier line of a WebVTT cue.
  static const int AV_PKT_DATA_WEBVTT_IDENTIFIER = 16;

  /// The optional settings (rendering instructions) that immediately
  /// follow the timestamp specifier of a WebVTT cue.
  static const int AV_PKT_DATA_WEBVTT_SETTINGS = 17;

  /// A list of zero terminated key/value strings. There is no end marker for
  /// the list, so it is required to rely on the side data size to stop. This
  /// side data includes updated metadata which appeared in the stream.
  static const int AV_PKT_DATA_METADATA_UPDATE = 18;

  /// MPEGTS stream ID as uint8_t, this is required to pass the stream ID
  /// information from the demuxer to the corresponding muxer.
  static const int AV_PKT_DATA_MPEGTS_STREAM_ID = 19;

  /// Mastering display metadata (based on SMPTE-2086:2014). This metadata
  /// should be associated with a video stream and contains data in the form
  /// of the AVMasteringDisplayMetadata struct.
  static const int AV_PKT_DATA_MASTERING_DISPLAY_METADATA = 20;

  /// This side data should be associated with a video stream and corresponds
  /// to the AVSphericalMapping structure.
  static const int AV_PKT_DATA_SPHERICAL = 21;

  /// Content light level (based on CTA-861.3). This metadata should be
  /// associated with a video stream and contains data in the form of the
  /// AVContentLightMetadata struct.
  static const int AV_PKT_DATA_CONTENT_LIGHT_LEVEL = 22;

  /// ATSC A53 Part 4 Closed Captions. This metadata should be associated with
  /// a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data.
  /// The number of bytes of CC data is AVPacketSideData.size.
  static const int AV_PKT_DATA_A53_CC = 23;

  /// This side data is encryption initialization data.
  /// The format is not part of ABI, use av_encryption_init_info_* methods to
  /// access.
  static const int AV_PKT_DATA_ENCRYPTION_INIT_INFO = 24;

  /// This side data contains encryption info for how to decrypt the packet.
  /// The format is not part of ABI, use av_encryption_info_* methods to access.
  static const int AV_PKT_DATA_ENCRYPTION_INFO = 25;

  /// Active Format Description data consisting of a single byte as specified
  /// in ETSI TS 101 154 using AVActiveFormatDescription enum.
  static const int AV_PKT_DATA_AFD = 26;

  /// Producer Reference Time data corresponding to the AVProducerReferenceTime struct,
  /// usually exported by some encoders (on demand through the prft flag set in the
  /// AVCodecContext export_side_data field).
  static const int AV_PKT_DATA_PRFT = 27;

  /// ICC profile data consisting of an opaque octet buffer following the
  /// format described by ISO 15076-1.
  static const int AV_PKT_DATA_ICC_PROFILE = 28;

  /// DOVI configuration
  /// ref:
  /// dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2
  /// dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3
  /// Tags are stored in struct AVDOVIDecoderConfigurationRecord.
  static const int AV_PKT_DATA_DOVI_CONF = 29;

  /// Timecode which conforms to SMPTE ST 12-1:2014. The data is an array of 4 uint32_t
  /// where the first uint32_t describes how many (1-3) of the other timecodes are used.
  /// The timecode format is described in the documentation of av_timecode_get_smpte_from_framenum()
  /// function in libavutil/timecode.h.
  static const int AV_PKT_DATA_S12M_TIMECODE = 30;

  /// The number of side data types.
  /// This is not part of the public API/ABI in the sense that it may
  /// change when new side data types are added.
  /// This must stay the last enum value.
  /// If its value becomes huge, some code using it
  /// needs to be updated as it assumes it to be smaller than other limits.
  static const int AV_PKT_DATA_NB = 31;
}

class AVPacketSideData extends ffi.Struct {
  ffi.Pointer<ffi.Uint8> data;

  @ffi.Int32()
  int size;

  @ffi.Int32()
  int type;
}

/// This structure stores compressed data. It is typically exported by demuxers
/// and then passed as input to decoders, or received as output from encoders and
/// then passed to muxers.
///
/// For video, it should typically contain one compressed frame. For audio it may
/// contain several compressed frames. Encoders are allowed to output empty
/// packets, with no compressed data, containing only side data
/// (e.g. to update some stream parameters at the end of encoding).
///
/// AVPacket is one of the few structs in FFmpeg, whose size is a part of public
/// ABI. Thus it may be allocated on stack and no new fields can be added to it
/// without libavcodec and libavformat major bump.
///
/// The semantics of data ownership depends on the buf field.
/// If it is set, the packet data is dynamically allocated and is
/// valid indefinitely until a call to av_packet_unref() reduces the
/// reference count to 0.
///
/// If the buf field is not set av_packet_ref() would make a copy instead
/// of increasing the reference count.
///
/// The side data is always allocated with av_malloc(), copied by
/// av_packet_ref() and freed by av_packet_unref().
///
/// @see av_packet_ref
/// @see av_packet_unref
class AVPacket extends ffi.Struct {
  /// A reference to the reference-counted buffer where the packet data is
  /// stored.
  /// May be NULL, then the packet data is not reference-counted.
  ffi.Pointer<AVBufferRef> buf;

  /// Presentation timestamp in AVStream->time_base units; the time at which
  /// the decompressed packet will be presented to the user.
  /// Can be AV_NOPTS_VALUE if it is not stored in the file.
  /// pts MUST be larger or equal to dts as presentation cannot happen before
  /// decompression, unless one wants to view hex dumps. Some formats misuse
  /// the terms dts and pts/cts to mean something different. Such timestamps
  /// must be converted to true pts/dts before they are stored in AVPacket.
  @ffi.Int64()
  int pts;

  /// Decompression timestamp in AVStream->time_base units; the time at which
  /// the packet is decompressed.
  /// Can be AV_NOPTS_VALUE if it is not stored in the file.
  @ffi.Int64()
  int dts;

  ffi.Pointer<ffi.Uint8> data;

  @ffi.Int32()
  int size;

  @ffi.Int32()
  int stream_index;

  /// A combination of AV_PKT_FLAG values
  @ffi.Int32()
  int flags;

  /// Additional packet data that can be provided by the container.
  /// Packet can contain several types of side information.
  ffi.Pointer<AVPacketSideData> side_data;

  @ffi.Int32()
  int side_data_elems;

  /// Duration of this packet in AVStream->time_base units, 0 if unknown.
  /// Equals next_pts - this_pts in presentation order.
  @ffi.Int64()
  int duration;

  /// ///< byte position in stream, -1 if unknown
  @ffi.Int64()
  int pos;

  /// @deprecated Same as the duration field, but as int64_t. This was required
  /// for Matroska subtitles, whose duration values could overflow when the
  /// duration field was still an int.
  @ffi.Int64()
  int convergence_duration;
}

class AVPacketList extends ffi.Struct {}

abstract class AVSideDataParamChangeFlags {
  static const int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_COUNT = 1;
  static const int AV_SIDE_DATA_PARAM_CHANGE_CHANNEL_LAYOUT = 2;
  static const int AV_SIDE_DATA_PARAM_CHANGE_SAMPLE_RATE = 4;
  static const int AV_SIDE_DATA_PARAM_CHANGE_DIMENSIONS = 8;
}

class AVBSFInternal extends ffi.Struct {}

class AVBitStreamFilter extends ffi.Struct {
  ffi.Pointer<ffi.Int8> name;

  /// A list of codec ids supported by the filter, terminated by
  /// AV_CODEC_ID_NONE.
  /// May be NULL, in that case the bitstream filter works with any codec id.
  ffi.Pointer<ffi.Int32> codec_ids;

  /// A class for the private data, used to declare bitstream filter private
  /// AVOptions. This field is NULL for bitstream filters that do not declare
  /// any options.
  ///
  /// If this field is non-NULL, the first member of the filter private data
  /// must be a pointer to AVClass, which will be set by libavcodec generic
  /// code to this class.
  ffi.Pointer<AVClass> priv_class;

  /// No fields below this line are part of the public API. They
  /// may not be used outside of libavcodec and can be changed and
  /// removed at will.
  /// New public fields should be added right above.
  @ffi.Int32()
  int priv_data_size;

  ffi.Pointer<ffi.NativeFunction<_typedefC_14>> init;

  ffi.Pointer<ffi.NativeFunction<_typedefC_15>> filter;

  ffi.Pointer<ffi.NativeFunction<_typedefC_16>> close;

  ffi.Pointer<ffi.NativeFunction<_typedefC_17>> flush;
}

/// The bitstream filter state.
///
/// This struct must be allocated with av_bsf_alloc() and freed with
/// av_bsf_free().
///
/// The fields in the struct will only be changed (by the caller or by the
/// filter) as described in their documentation, and are to be considered
/// immutable otherwise.
class AVBSFContext extends ffi.Struct {}

class AVBSFList extends ffi.Struct {}

/// AVProfile.
class AVProfile extends ffi.Struct {
  @ffi.Int32()
  int profile;

  /// ///< short name for the profile
  ffi.Pointer<ffi.Int8> name;
}

class AVCodecDefault extends ffi.Struct {}

/// main external API structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user
/// applications.
/// The name string for AVOptions options matches the associated command line
/// parameter name and can be found in libavcodec/options_table.h
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
/// sizeof(AVCodecContext) must not be used outside libav*.
class AVCodecContext extends ffi.Struct {}

class AVSubtitle extends ffi.Struct {}

class AVCodecHWConfigInternal extends ffi.Struct {}

/// AVCodec.
class AVCodec extends ffi.Struct {
  /// Name of the codec implementation.
  /// The name is globally unique among encoders and among decoders (but an
  /// encoder and a decoder can share the same name).
  /// This is the primary way to find a codec from the user perspective.
  ffi.Pointer<ffi.Int8> name;

  /// Descriptive name for the codec, meant to be more human readable than name.
  /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
  ffi.Pointer<ffi.Int8> long_name;

  @ffi.Int32()
  int type;

  @ffi.Int32()
  int id;

  /// Codec capabilities.
  /// see AV_CODEC_CAP_*
  @ffi.Int32()
  int capabilities;

  /// ///< array of supported framerates, or NULL if any, array is terminated by {0,0}
  ffi.Pointer<AVRational> supported_framerates;

  /// ///< array of supported pixel formats, or NULL if unknown, array is terminated by -1
  ffi.Pointer<ffi.Int32> pix_fmts;

  /// ///< array of supported audio samplerates, or NULL if unknown, array is terminated by 0
  ffi.Pointer<ffi.Int32> supported_samplerates;

  /// ///< array of supported sample formats, or NULL if unknown, array is terminated by -1
  ffi.Pointer<ffi.Int32> sample_fmts;

  /// ///< array of support channel layouts, or NULL if unknown. array is terminated by 0
  ffi.Pointer<ffi.Uint64> channel_layouts;

  /// ///< maximum value for lowres supported by the decoder
  @ffi.Uint8()
  int max_lowres;

  /// ///< AVClass for the private context
  ffi.Pointer<AVClass> priv_class;

  /// ///< array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}
  ffi.Pointer<AVProfile> profiles;

  /// Group name of the codec implementation.
  /// This is a short symbolic name of the wrapper backing this codec. A
  /// wrapper uses some kind of external implementation for the codec, such
  /// as an external library, or a codec implementation provided by the OS or
  /// the hardware.
  /// If this field is NULL, this is a builtin, libavcodec native codec.
  /// If non-NULL, this will be the suffix in AVCodec.name in most cases
  /// (usually AVCodec.name will be of the form "<codec_name>_<wrapper_name>").
  ffi.Pointer<ffi.Int8> wrapper_name;

  /// No fields below this line are part of the public API. They
  /// may not be used outside of libavcodec and can be changed and
  /// removed at will.
  /// New public fields should be added right above.
  @ffi.Int32()
  int priv_data_size;

  ffi.Pointer<AVCodec> next;

  /// @name Frame-level threading support functions
  /// @{
  ///
  ///
  /// Copy necessary context variables from a previous thread context to the current one.
  /// If not defined, the next thread will start automatically; otherwise, the codec
  /// must call ff_thread_finish_setup().
  ///
  /// dst and src will (rarely) point to the same context, in which case memcpy should be skipped.
  ffi.Pointer<ffi.NativeFunction<_typedefC_18>> update_thread_context;

  /// Private codec-specific defaults.
  ffi.Pointer<AVCodecDefault> defaults;

  /// Initialize codec static data, called from avcodec_register().
  ///
  /// This is not intended for time consuming operations as it is
  /// run for every codec regardless of that codec being used.
  ffi.Pointer<ffi.NativeFunction<_typedefC_19>> init_static_data;

  ffi.Pointer<ffi.NativeFunction<_typedefC_20>> init;

  ffi.Pointer<ffi.NativeFunction<_typedefC_21>> encode_sub;

  /// Encode data to an AVPacket.
  ///
  /// @param      avctx          codec context
  /// @param      avpkt          output AVPacket (may contain a user-provided buffer)
  /// @param[in]  frame          AVFrame containing the raw data to be encoded
  /// @param[out] got_packet_ptr encoder sets to 0 or 1 to indicate that a
  /// non-empty packet was returned in avpkt.
  /// @return 0 on success, negative error code on failure
  ffi.Pointer<ffi.NativeFunction<_typedefC_22>> encode2;

  ffi.Pointer<ffi.NativeFunction<_typedefC_23>> decode;

  ffi.Pointer<ffi.NativeFunction<_typedefC_24>> close;

  /// Encode API with decoupled frame/packet dataflow. This function is called
  /// to get one output packet. It should call ff_encode_get_frame() to obtain
  /// input data.
  ffi.Pointer<ffi.NativeFunction<_typedefC_25>> receive_packet;

  /// Decode API with decoupled packet/frame dataflow. This function is called
  /// to get one output frame. It should call ff_decode_get_packet() to obtain
  /// input data.
  ffi.Pointer<ffi.NativeFunction<_typedefC_26>> receive_frame;

  /// Flush buffers.
  /// Will be called when seeking
  ffi.Pointer<ffi.NativeFunction<_typedefC_27>> flush;

  /// Internal codec capabilities.
  /// See FF_CODEC_CAP_* in internal.h
  @ffi.Int32()
  int caps_internal;

  /// Decoding only, a comma-separated list of bitstream filters to apply to
  /// packets before decoding.
  ffi.Pointer<ffi.Int8> bsfs;

  /// Array of pointers to hardware configurations supported by the codec,
  /// or NULL if no hardware supported.  The array is terminated by a NULL
  /// pointer.
  ///
  /// The user can only access this field via avcodec_get_hw_config().
  ffi.Pointer<ffi.Pointer<AVCodecHWConfigInternal>> hw_configs;

  /// List of supported codec_tags, terminated by FF_CODEC_TAGS_END.
  ffi.Pointer<ffi.Uint32> codec_tags;
}

class AVCodecHWConfig extends ffi.Struct {
  /// For decoders, a hardware pixel format which that decoder may be
  /// able to decode to if suitable hardware is available.
  ///
  /// For encoders, a pixel format which the encoder may be able to
  /// accept.  If set to AV_PIX_FMT_NONE, this applies to all pixel
  /// formats supported by the codec.
  @ffi.Int32()
  int pix_fmt;

  /// Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible
  /// setup methods which can be used with this configuration.
  @ffi.Int32()
  int methods;

  /// The device type associated with the configuration.
  ///
  /// Must be set for AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX and
  /// AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX, otherwise unused.
  @ffi.Int32()
  int device_type;
}

/// This struct describes the properties of a single codec described by an
/// AVCodecID.
/// @see avcodec_descriptor_get()
class AVCodecDescriptor extends ffi.Struct {
  @ffi.Int32()
  int id;

  @ffi.Int32()
  int type;

  /// Name of the codec described by this descriptor. It is non-empty and
  /// unique for each codec descriptor. It should contain alphanumeric
  /// characters and '_' only.
  ffi.Pointer<ffi.Int8> name;

  /// A more descriptive name for this codec. May be NULL.
  ffi.Pointer<ffi.Int8> long_name;

  /// Codec properties, a combination of AV_CODEC_PROP_* flags.
  @ffi.Int32()
  int props;

  /// MIME type(s) associated with the codec.
  /// May be NULL; if not, a NULL-terminated array of MIME types.
  /// The first item is always non-NULL and is the preferred MIME type.
  ffi.Pointer<ffi.Pointer<ffi.Int8>> mime_types;

  /// If non-NULL, an array of profiles recognized for this codec.
  /// Terminated with FF_PROFILE_UNKNOWN.
  ffi.Pointer<AVProfile> profiles;
}

/// @ingroup lavc_decoding
abstract class AVDiscard {
  /// ///< discard nothing
  static const int AVDISCARD_NONE = -16;

  /// ///< discard useless packets like 0 size packets in avi
  static const int AVDISCARD_DEFAULT = 0;

  /// ///< discard all non reference
  static const int AVDISCARD_NONREF = 8;

  /// ///< discard all bidirectional frames
  static const int AVDISCARD_BIDIR = 16;

  /// ///< discard all non intra frames
  static const int AVDISCARD_NONINTRA = 24;

  /// ///< discard all frames except keyframes
  static const int AVDISCARD_NONKEY = 32;

  /// ///< discard all
  static const int AVDISCARD_ALL = 48;
}

abstract class AVAudioServiceType {
  static const int AV_AUDIO_SERVICE_TYPE_MAIN = 0;
  static const int AV_AUDIO_SERVICE_TYPE_EFFECTS = 1;
  static const int AV_AUDIO_SERVICE_TYPE_VISUALLY_IMPAIRED = 2;
  static const int AV_AUDIO_SERVICE_TYPE_HEARING_IMPAIRED = 3;
  static const int AV_AUDIO_SERVICE_TYPE_DIALOGUE = 4;
  static const int AV_AUDIO_SERVICE_TYPE_COMMENTARY = 5;
  static const int AV_AUDIO_SERVICE_TYPE_EMERGENCY = 6;
  static const int AV_AUDIO_SERVICE_TYPE_VOICE_OVER = 7;
  static const int AV_AUDIO_SERVICE_TYPE_KARAOKE = 8;

  /// ///< Not part of ABI
  static const int AV_AUDIO_SERVICE_TYPE_NB = 9;
}

/// @ingroup lavc_encoding
class RcOverride extends ffi.Struct {
  @ffi.Int32()
  int start_frame;

  @ffi.Int32()
  int end_frame;

  @ffi.Int32()
  int qscale;

  @ffi.Float()
  double quality_factor;
}

/// Pan Scan area.
/// This specifies the area which should be displayed.
/// Note there may be multiple such areas for one frame.
class AVPanScan extends ffi.Struct {
  /// id
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  @ffi.Int32()
  int id;

  /// width and height in 1/16 pel
  /// - encoding: Set by user.
  /// - decoding: Set by libavcodec.
  @ffi.Int32()
  int width;

  @ffi.Int32()
  int height;

  @ffi.Int16()
  int _unique_position_item_0;
  @ffi.Int16()
  int _unique_position_item_1;
  @ffi.Int16()
  int _unique_position_item_2;
  @ffi.Int16()
  int _unique_position_item_3;
  @ffi.Int16()
  int _unique_position_item_4;
  @ffi.Int16()
  int _unique_position_item_5;

  /// Helper for array `position`.
  ArrayHelper_AVPanScan_position_level0 get position =>
      ArrayHelper_AVPanScan_position_level0(this, [3, 2], 0, 0);
}

/// Helper for array `position` in struct `AVPanScan`.
class ArrayHelper_AVPanScan_position_level0 {
  final AVPanScan _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVPanScan_position_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVPanScan_position_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVPanScan_position_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `position` in struct `AVPanScan`.
class ArrayHelper_AVPanScan_position_level1 {
  final AVPanScan _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVPanScan_position_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_position_item_0;
      case 1:
        return _struct._unique_position_item_1;
      case 2:
        return _struct._unique_position_item_2;
      case 3:
        return _struct._unique_position_item_3;
      case 4:
        return _struct._unique_position_item_4;
      case 5:
        return _struct._unique_position_item_5;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_position_item_0 = value;
        break;
      case 1:
        _struct._unique_position_item_1 = value;
        break;
      case 2:
        _struct._unique_position_item_2 = value;
        break;
      case 3:
        _struct._unique_position_item_3 = value;
        break;
      case 4:
        _struct._unique_position_item_4 = value;
        break;
      case 5:
        _struct._unique_position_item_5 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// This structure describes the bitrate properties of an encoded bitstream. It
/// roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD
/// parameters for H.264/HEVC.
class AVCPBProperties extends ffi.Struct {
  @ffi.Int32()
  int max_bitrate;

  @ffi.Int32()
  int min_bitrate;

  @ffi.Int32()
  int avg_bitrate;

  /// The size of the buffer to which the ratecontrol is applied, in bits.
  /// Zero if unknown or unspecified.
  @ffi.Int32()
  int buffer_size;

  /// The delay between the time the packet this structure is associated with
  /// is received and the time when it should be decoded, in periods of a 27MHz
  /// clock.
  ///
  /// UINT64_MAX when unknown or unspecified.
  @ffi.Uint64()
  int vbv_delay;
}

/// This structure supplies correlation between a packet timestamp and a wall clock
/// production time. The definition follows the Producer Reference Time ('prft')
/// as defined in ISO/IEC 14496-12
class AVProducerReferenceTime extends ffi.Struct {
  /// A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime()).
  @ffi.Int64()
  int wallclock;

  @ffi.Int32()
  int flags;
}

class AVCodecInternal extends ffi.Struct {}

class MpegEncContext extends ffi.Struct {}

/// @defgroup lavc_hwaccel AVHWAccel
///
/// @note  Nothing in this structure should be accessed by the user.  At some
/// point in future it will not be externally visible at all.
///
/// @{
class AVHWAccel extends ffi.Struct {
  /// Name of the hardware accelerated codec.
  /// The name is globally unique among encoders and among decoders (but an
  /// encoder and a decoder can share the same name).
  ffi.Pointer<ffi.Int8> name;

  /// Type of codec implemented by the hardware accelerator.
  ///
  /// See AVMEDIA_TYPE_xxx
  @ffi.Int32()
  int type;

  /// Codec implemented by the hardware accelerator.
  ///
  /// See AV_CODEC_ID_xxx
  @ffi.Int32()
  int id;

  /// Supported pixel format.
  ///
  /// Only hardware accelerated formats are supported here.
  @ffi.Int32()
  int pix_fmt;

  /// Hardware accelerated codec capabilities.
  /// see AV_HWACCEL_CODEC_CAP_*
  @ffi.Int32()
  int capabilities;

  /// Allocate a custom buffer
  ffi.Pointer<ffi.NativeFunction<_typedefC_28>> alloc_frame;

  /// Called at the beginning of each frame or field picture.
  ///
  /// Meaningful frame information (codec specific) is guaranteed to
  /// be parsed at this point. This function is mandatory.
  ///
  /// Note that buf can be NULL along with buf_size set to 0.
  /// Otherwise, this means the whole frame is available at this point.
  ///
  /// @param avctx the codec context
  /// @param buf the frame data buffer base
  /// @param buf_size the size of the frame in bytes
  /// @return zero if successful, a negative value otherwise
  ffi.Pointer<ffi.NativeFunction<_typedefC_29>> start_frame;

  /// Callback for parameter data (SPS/PPS/VPS etc).
  ///
  /// Useful for hardware decoders which keep persistent state about the
  /// video parameters, and need to receive any changes to update that state.
  ///
  /// @param avctx the codec context
  /// @param type the nal unit type
  /// @param buf the nal unit data buffer
  /// @param buf_size the size of the nal unit in bytes
  /// @return zero if successful, a negative value otherwise
  ffi.Pointer<ffi.NativeFunction<_typedefC_30>> decode_params;

  /// Callback for each slice.
  ///
  /// Meaningful slice information (codec specific) is guaranteed to
  /// be parsed at this point. This function is mandatory.
  /// The only exception is XvMC, that works on MB level.
  ///
  /// @param avctx the codec context
  /// @param buf the slice data buffer base
  /// @param buf_size the size of the slice in bytes
  /// @return zero if successful, a negative value otherwise
  ffi.Pointer<ffi.NativeFunction<_typedefC_31>> decode_slice;

  /// Called at the end of each frame or field picture.
  ///
  /// The whole picture is parsed at this point and can now be sent
  /// to the hardware accelerator. This function is mandatory.
  ///
  /// @param avctx the codec context
  /// @return zero if successful, a negative value otherwise
  ffi.Pointer<ffi.NativeFunction<_typedefC_32>> end_frame;

  /// Size of per-frame hardware accelerator private data.
  ///
  /// Private data is allocated with av_mallocz() before
  /// AVCodecContext.get_buffer() and deallocated after
  /// AVCodecContext.release_buffer().
  @ffi.Int32()
  int frame_priv_data_size;

  /// Called for every Macroblock in a slice.
  ///
  /// XvMC uses it to replace the ff_mpv_reconstruct_mb().
  /// Instead of decoding to raw picture, MB parameters are
  /// stored in an array provided by the video driver.
  ///
  /// @param s the mpeg context
  ffi.Pointer<ffi.NativeFunction<_typedefC_33>> decode_mb;

  /// Initialize the hwaccel private data.
  ///
  /// This will be called from ff_get_format(), after hwaccel and
  /// hwaccel_context are set and the hwaccel private data in AVCodecInternal
  /// is allocated.
  ffi.Pointer<ffi.NativeFunction<_typedefC_34>> init;

  /// Uninitialize the hwaccel private data.
  ///
  /// This will be called from get_format() or avcodec_close(), after hwaccel
  /// and hwaccel_context are already uninitialized.
  ffi.Pointer<ffi.NativeFunction<_typedefC_35>> uninit;

  /// Size of the private data to allocate in
  /// AVCodecInternal.hwaccel_priv_data.
  @ffi.Int32()
  int priv_data_size;

  /// Internal hwaccel capabilities.
  @ffi.Int32()
  int caps_internal;

  /// Fill the given hw_frames context with current codec parameters. Called
  /// from get_format. Refer to avcodec_get_hw_frames_parameters() for
  /// details.
  ///
  /// This CAN be called before AVHWAccel.init is called, and you must assume
  /// that avctx->hwaccel_priv_data is invalid.
  ffi.Pointer<ffi.NativeFunction<_typedefC_36>> frame_params;
}

/// Picture data structure.
///
/// Up to four components can be stored into it, the last component is
/// alpha.
/// @deprecated use AVFrame or imgutils functions instead
class AVPicture extends ffi.Struct {
  ffi.Pointer<ffi.Uint8> _unique_data_item_0;
  ffi.Pointer<ffi.Uint8> _unique_data_item_1;
  ffi.Pointer<ffi.Uint8> _unique_data_item_2;
  ffi.Pointer<ffi.Uint8> _unique_data_item_3;
  ffi.Pointer<ffi.Uint8> _unique_data_item_4;
  ffi.Pointer<ffi.Uint8> _unique_data_item_5;
  ffi.Pointer<ffi.Uint8> _unique_data_item_6;
  ffi.Pointer<ffi.Uint8> _unique_data_item_7;

  /// Helper for array `data`.
  ArrayHelper_AVPicture_data_level0 get data =>
      ArrayHelper_AVPicture_data_level0(this, [8], 0, 0);
  @ffi.Int32()
  int _unique_linesize_item_0;
  @ffi.Int32()
  int _unique_linesize_item_1;
  @ffi.Int32()
  int _unique_linesize_item_2;
  @ffi.Int32()
  int _unique_linesize_item_3;
  @ffi.Int32()
  int _unique_linesize_item_4;
  @ffi.Int32()
  int _unique_linesize_item_5;
  @ffi.Int32()
  int _unique_linesize_item_6;
  @ffi.Int32()
  int _unique_linesize_item_7;

  /// Helper for array `linesize`.
  ArrayHelper_AVPicture_linesize_level0 get linesize =>
      ArrayHelper_AVPicture_linesize_level0(this, [8], 0, 0);
}

/// Helper for array `data` in struct `AVPicture`.
class ArrayHelper_AVPicture_data_level0 {
  final AVPicture _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVPicture_data_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Uint8> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_data_item_0;
      case 1:
        return _struct._unique_data_item_1;
      case 2:
        return _struct._unique_data_item_2;
      case 3:
        return _struct._unique_data_item_3;
      case 4:
        return _struct._unique_data_item_4;
      case 5:
        return _struct._unique_data_item_5;
      case 6:
        return _struct._unique_data_item_6;
      case 7:
        return _struct._unique_data_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Uint8> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_data_item_0 = value;
        break;
      case 1:
        _struct._unique_data_item_1 = value;
        break;
      case 2:
        _struct._unique_data_item_2 = value;
        break;
      case 3:
        _struct._unique_data_item_3 = value;
        break;
      case 4:
        _struct._unique_data_item_4 = value;
        break;
      case 5:
        _struct._unique_data_item_5 = value;
        break;
      case 6:
        _struct._unique_data_item_6 = value;
        break;
      case 7:
        _struct._unique_data_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `linesize` in struct `AVPicture`.
class ArrayHelper_AVPicture_linesize_level0 {
  final AVPicture _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVPicture_linesize_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_linesize_item_0;
      case 1:
        return _struct._unique_linesize_item_1;
      case 2:
        return _struct._unique_linesize_item_2;
      case 3:
        return _struct._unique_linesize_item_3;
      case 4:
        return _struct._unique_linesize_item_4;
      case 5:
        return _struct._unique_linesize_item_5;
      case 6:
        return _struct._unique_linesize_item_6;
      case 7:
        return _struct._unique_linesize_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_linesize_item_0 = value;
        break;
      case 1:
        _struct._unique_linesize_item_1 = value;
        break;
      case 2:
        _struct._unique_linesize_item_2 = value;
        break;
      case 3:
        _struct._unique_linesize_item_3 = value;
        break;
      case 4:
        _struct._unique_linesize_item_4 = value;
        break;
      case 5:
        _struct._unique_linesize_item_5 = value;
        break;
      case 6:
        _struct._unique_linesize_item_6 = value;
        break;
      case 7:
        _struct._unique_linesize_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

abstract class AVSubtitleType {
  static const int SUBTITLE_NONE = 0;

  /// ///< A bitmap, pict will be set
  static const int SUBTITLE_BITMAP = 1;

  /// Plain text, the text field must be set by the decoder and is
  /// authoritative. ass and pict fields may contain approximations.
  static const int SUBTITLE_TEXT = 2;

  /// Formatted text, the ass field must be set by the decoder and is
  /// authoritative. pict and text fields may contain approximations.
  static const int SUBTITLE_ASS = 3;
}

class AVSubtitleRect extends ffi.Struct {}

/// @defgroup lavc_parsing Frame parsing
/// @{
abstract class AVPictureStructure {
  static const int AV_PICTURE_STRUCTURE_UNKNOWN = 0;
  static const int AV_PICTURE_STRUCTURE_TOP_FIELD = 1;
  static const int AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2;
  static const int AV_PICTURE_STRUCTURE_FRAME = 3;
}

class AVCodecParser extends ffi.Struct {
  @ffi.Int32()
  int _unique_codec_ids_item_0;
  @ffi.Int32()
  int _unique_codec_ids_item_1;
  @ffi.Int32()
  int _unique_codec_ids_item_2;
  @ffi.Int32()
  int _unique_codec_ids_item_3;
  @ffi.Int32()
  int _unique_codec_ids_item_4;

  /// Helper for array `codec_ids`.
  ArrayHelper_AVCodecParser_codec_ids_level0 get codec_ids =>
      ArrayHelper_AVCodecParser_codec_ids_level0(this, [5], 0, 0);
  @ffi.Int32()
  int priv_data_size;

  ffi.Pointer<ffi.NativeFunction<_typedefC_37>> parser_init;

  ffi.Pointer<ffi.NativeFunction<_typedefC_38>> parser_parse;

  ffi.Pointer<ffi.NativeFunction<_typedefC_39>> parser_close;

  ffi.Pointer<ffi.NativeFunction<_typedefC_40>> split;

  ffi.Pointer<AVCodecParser> next;
}

/// Helper for array `codec_ids` in struct `AVCodecParser`.
class ArrayHelper_AVCodecParser_codec_ids_level0 {
  final AVCodecParser _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVCodecParser_codec_ids_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_codec_ids_item_0;
      case 1:
        return _struct._unique_codec_ids_item_1;
      case 2:
        return _struct._unique_codec_ids_item_2;
      case 3:
        return _struct._unique_codec_ids_item_3;
      case 4:
        return _struct._unique_codec_ids_item_4;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_codec_ids_item_0 = value;
        break;
      case 1:
        _struct._unique_codec_ids_item_1 = value;
        break;
      case 2:
        _struct._unique_codec_ids_item_2 = value;
        break;
      case 3:
        _struct._unique_codec_ids_item_3 = value;
        break;
      case 4:
        _struct._unique_codec_ids_item_4 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class AVCodecParserContext extends ffi.Struct {
  ffi.Pointer<ffi.Void> priv_data;

  ffi.Pointer<AVCodecParser> parser;

  @ffi.Int64()
  int frame_offset;

  @ffi.Int64()
  int cur_offset;

  @ffi.Int64()
  int next_frame_offset;

  @ffi.Int32()
  int pict_type;

  /// This field is used for proper frame duration computation in lavf.
  /// It signals, how much longer the frame duration of the current frame
  /// is compared to normal frame duration.
  ///
  /// frame_duration = (1 + repeat_pict) * time_base
  ///
  /// It is used by codecs like H.264 to display telecined material.
  @ffi.Int32()
  int repeat_pict;

  @ffi.Int64()
  int pts;

  @ffi.Int64()
  int dts;

  @ffi.Int64()
  int last_pts;

  @ffi.Int64()
  int last_dts;

  @ffi.Int32()
  int fetch_timestamp;

  @ffi.Int32()
  int cur_frame_start_index;

  @ffi.Int64()
  int _unique_cur_frame_offset_item_0;
  @ffi.Int64()
  int _unique_cur_frame_offset_item_1;
  @ffi.Int64()
  int _unique_cur_frame_offset_item_2;
  @ffi.Int64()
  int _unique_cur_frame_offset_item_3;

  /// Helper for array `cur_frame_offset`.
  ArrayHelper_AVCodecParserContext_cur_frame_offset_level0
      get cur_frame_offset =>
          ArrayHelper_AVCodecParserContext_cur_frame_offset_level0(
              this, [4], 0, 0);
  @ffi.Int64()
  int _unique_cur_frame_pts_item_0;
  @ffi.Int64()
  int _unique_cur_frame_pts_item_1;
  @ffi.Int64()
  int _unique_cur_frame_pts_item_2;
  @ffi.Int64()
  int _unique_cur_frame_pts_item_3;

  /// Helper for array `cur_frame_pts`.
  ArrayHelper_AVCodecParserContext_cur_frame_pts_level0 get cur_frame_pts =>
      ArrayHelper_AVCodecParserContext_cur_frame_pts_level0(this, [4], 0, 0);
  @ffi.Int64()
  int _unique_cur_frame_dts_item_0;
  @ffi.Int64()
  int _unique_cur_frame_dts_item_1;
  @ffi.Int64()
  int _unique_cur_frame_dts_item_2;
  @ffi.Int64()
  int _unique_cur_frame_dts_item_3;

  /// Helper for array `cur_frame_dts`.
  ArrayHelper_AVCodecParserContext_cur_frame_dts_level0 get cur_frame_dts =>
      ArrayHelper_AVCodecParserContext_cur_frame_dts_level0(this, [4], 0, 0);
  @ffi.Int32()
  int flags;

  /// ///< byte offset from starting packet start
  @ffi.Int64()
  int offset;

  @ffi.Int64()
  int _unique_cur_frame_end_item_0;
  @ffi.Int64()
  int _unique_cur_frame_end_item_1;
  @ffi.Int64()
  int _unique_cur_frame_end_item_2;
  @ffi.Int64()
  int _unique_cur_frame_end_item_3;

  /// Helper for array `cur_frame_end`.
  ArrayHelper_AVCodecParserContext_cur_frame_end_level0 get cur_frame_end =>
      ArrayHelper_AVCodecParserContext_cur_frame_end_level0(this, [4], 0, 0);

  /// Set by parser to 1 for key frames and 0 for non-key frames.
  /// It is initialized to -1, so if the parser doesn't set this flag,
  /// old-style fallback using AV_PICTURE_TYPE_I picture type as key frames
  /// will be used.
  @ffi.Int32()
  int key_frame;

  /// @deprecated unused
  @ffi.Int64()
  int convergence_duration;

  /// Synchronization point for start of timestamp generation.
  ///
  /// Set to >0 for sync point, 0 for no sync point and <0 for undefined
  /// (default).
  ///
  /// For example, this corresponds to presence of H.264 buffering period
  /// SEI message.
  @ffi.Int32()
  int dts_sync_point;

  /// Offset of the current timestamp against last timestamp sync point in
  /// units of AVCodecContext.time_base.
  ///
  /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
  /// contain a valid timestamp offset.
  ///
  /// Note that the timestamp of sync point has usually a nonzero
  /// dts_ref_dts_delta, which refers to the previous sync point. Offset of
  /// the next frame after timestamp sync point will be usually 1.
  ///
  /// For example, this corresponds to H.264 cpb_removal_delay.
  @ffi.Int32()
  int dts_ref_dts_delta;

  /// Presentation delay of current frame in units of AVCodecContext.time_base.
  ///
  /// Set to INT_MIN when dts_sync_point unused. Otherwise, it must
  /// contain valid non-negative timestamp delta (presentation time of a frame
  /// must not lie in the past).
  ///
  /// This delay represents the difference between decoding and presentation
  /// time of the frame.
  ///
  /// For example, this corresponds to H.264 dpb_output_delay.
  @ffi.Int32()
  int pts_dts_delta;

  @ffi.Int64()
  int _unique_cur_frame_pos_item_0;
  @ffi.Int64()
  int _unique_cur_frame_pos_item_1;
  @ffi.Int64()
  int _unique_cur_frame_pos_item_2;
  @ffi.Int64()
  int _unique_cur_frame_pos_item_3;

  /// Helper for array `cur_frame_pos`.
  ArrayHelper_AVCodecParserContext_cur_frame_pos_level0 get cur_frame_pos =>
      ArrayHelper_AVCodecParserContext_cur_frame_pos_level0(this, [4], 0, 0);

  /// Byte position of currently parsed frame in stream.
  @ffi.Int64()
  int pos;

  /// Previous frame byte position.
  @ffi.Int64()
  int last_pos;

  /// Duration of the current frame.
  /// For audio, this is in units of 1 / AVCodecContext.sample_rate.
  /// For all other types, this is in units of AVCodecContext.time_base.
  @ffi.Int32()
  int duration;

  @ffi.Int32()
  int field_order;

  /// Indicate whether a picture is coded as a frame, top field or bottom field.
  ///
  /// For example, H.264 field_pic_flag equal to 0 corresponds to
  /// AV_PICTURE_STRUCTURE_FRAME. An H.264 picture with field_pic_flag
  /// equal to 1 and bottom_field_flag equal to 0 corresponds to
  /// AV_PICTURE_STRUCTURE_TOP_FIELD.
  @ffi.Int32()
  int picture_structure;

  /// Picture number incremented in presentation or output order.
  /// This field may be reinitialized at the first picture of a new sequence.
  ///
  /// For example, this corresponds to H.264 PicOrderCnt.
  @ffi.Int32()
  int output_picture_number;

  /// Dimensions of the decoded video intended for presentation.
  @ffi.Int32()
  int width;

  @ffi.Int32()
  int height;

  /// Dimensions of the coded video.
  @ffi.Int32()
  int coded_width;

  @ffi.Int32()
  int coded_height;

  /// The format of the coded data, corresponds to enum AVPixelFormat for video
  /// and for enum AVSampleFormat for audio.
  ///
  /// Note that a decoder can have considerable freedom in how exactly it
  /// decodes the data, so the format reported here might be different from the
  /// one returned by a decoder.
  @ffi.Int32()
  int format;
}

/// Helper for array `cur_frame_offset` in struct `AVCodecParserContext`.
class ArrayHelper_AVCodecParserContext_cur_frame_offset_level0 {
  final AVCodecParserContext _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVCodecParserContext_cur_frame_offset_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_cur_frame_offset_item_0;
      case 1:
        return _struct._unique_cur_frame_offset_item_1;
      case 2:
        return _struct._unique_cur_frame_offset_item_2;
      case 3:
        return _struct._unique_cur_frame_offset_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_cur_frame_offset_item_0 = value;
        break;
      case 1:
        _struct._unique_cur_frame_offset_item_1 = value;
        break;
      case 2:
        _struct._unique_cur_frame_offset_item_2 = value;
        break;
      case 3:
        _struct._unique_cur_frame_offset_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `cur_frame_pts` in struct `AVCodecParserContext`.
class ArrayHelper_AVCodecParserContext_cur_frame_pts_level0 {
  final AVCodecParserContext _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVCodecParserContext_cur_frame_pts_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_cur_frame_pts_item_0;
      case 1:
        return _struct._unique_cur_frame_pts_item_1;
      case 2:
        return _struct._unique_cur_frame_pts_item_2;
      case 3:
        return _struct._unique_cur_frame_pts_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_cur_frame_pts_item_0 = value;
        break;
      case 1:
        _struct._unique_cur_frame_pts_item_1 = value;
        break;
      case 2:
        _struct._unique_cur_frame_pts_item_2 = value;
        break;
      case 3:
        _struct._unique_cur_frame_pts_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `cur_frame_dts` in struct `AVCodecParserContext`.
class ArrayHelper_AVCodecParserContext_cur_frame_dts_level0 {
  final AVCodecParserContext _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVCodecParserContext_cur_frame_dts_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_cur_frame_dts_item_0;
      case 1:
        return _struct._unique_cur_frame_dts_item_1;
      case 2:
        return _struct._unique_cur_frame_dts_item_2;
      case 3:
        return _struct._unique_cur_frame_dts_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_cur_frame_dts_item_0 = value;
        break;
      case 1:
        _struct._unique_cur_frame_dts_item_1 = value;
        break;
      case 2:
        _struct._unique_cur_frame_dts_item_2 = value;
        break;
      case 3:
        _struct._unique_cur_frame_dts_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `cur_frame_end` in struct `AVCodecParserContext`.
class ArrayHelper_AVCodecParserContext_cur_frame_end_level0 {
  final AVCodecParserContext _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVCodecParserContext_cur_frame_end_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_cur_frame_end_item_0;
      case 1:
        return _struct._unique_cur_frame_end_item_1;
      case 2:
        return _struct._unique_cur_frame_end_item_2;
      case 3:
        return _struct._unique_cur_frame_end_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_cur_frame_end_item_0 = value;
        break;
      case 1:
        _struct._unique_cur_frame_end_item_1 = value;
        break;
      case 2:
        _struct._unique_cur_frame_end_item_2 = value;
        break;
      case 3:
        _struct._unique_cur_frame_end_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `cur_frame_pos` in struct `AVCodecParserContext`.
class ArrayHelper_AVCodecParserContext_cur_frame_pos_level0 {
  final AVCodecParserContext _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVCodecParserContext_cur_frame_pos_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_cur_frame_pos_item_0;
      case 1:
        return _struct._unique_cur_frame_pos_item_1;
      case 2:
        return _struct._unique_cur_frame_pos_item_2;
      case 3:
        return _struct._unique_cur_frame_pos_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_cur_frame_pos_item_0 = value;
        break;
      case 1:
        _struct._unique_cur_frame_pos_item_1 = value;
        break;
      case 2:
        _struct._unique_cur_frame_pos_item_2 = value;
        break;
      case 3:
        _struct._unique_cur_frame_pos_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class AVBitStreamFilterContext extends ffi.Struct {
  ffi.Pointer<ffi.Void> priv_data;

  ffi.Pointer<AVBitStreamFilter> filter;

  ffi.Pointer<AVCodecParserContext> parser;

  ffi.Pointer<AVBitStreamFilterContext> next;

  /// Internal default arguments, used if NULL is passed to av_bitstream_filter_filter().
  /// Not for access by library users.
  ffi.Pointer<ffi.Int8> args;
}

/// Lock operation used by lockmgr
///
/// @deprecated Deprecated together with av_lockmgr_register().
abstract class AVLockOp {
  /// ///< Create a mutex
  static const int AV_LOCK_CREATE = 0;

  /// ///< Lock the mutex
  static const int AV_LOCK_OBTAIN = 1;

  /// ///< Unlock the mutex
  static const int AV_LOCK_RELEASE = 2;

  /// ///< Free mutex resources
  static const int AV_LOCK_DESTROY = 3;
}

/// @defgroup avoptions AVOptions
/// @ingroup lavu_data
/// @{
/// AVOptions provide a generic system to declare options on arbitrary structs
/// ("objects"). An option can have a help text, a type and a range of possible
/// values. Options may then be enumerated, read and written to.
///
/// @section avoptions_implement Implementing AVOptions
/// This section describes how to add AVOptions capabilities to a struct.
///
/// All AVOptions-related information is stored in an AVClass. Therefore
/// the first member of the struct should be a pointer to an AVClass describing it.
/// The option field of the AVClass must be set to a NULL-terminated static array
/// of AVOptions. Each AVOption must have a non-empty name, a type, a default
/// value and for number-type AVOptions also a range of allowed values. It must
/// also declare an offset in bytes from the start of the struct, where the field
/// associated with this AVOption is located. Other fields in the AVOption struct
/// should also be set when applicable, but are not required.
///
/// The following example illustrates an AVOptions-enabled struct:
/// @code
/// typedef struct test_struct {
/// const AVClass *class;
/// int      int_opt;
/// char    *str_opt;
/// uint8_t *bin_opt;
/// int      bin_len;
/// } test_struct;
///
/// static const AVOption test_options[] = {
/// { "test_int", "This is a test option of int type.", offsetof(test_struct, int_opt),
/// AV_OPT_TYPE_INT, { .i64 = -1 }, INT_MIN, INT_MAX },
/// { "test_str", "This is a test option of string type.", offsetof(test_struct, str_opt),
/// AV_OPT_TYPE_STRING },
/// { "test_bin", "This is a test option of binary type.", offsetof(test_struct, bin_opt),
/// AV_OPT_TYPE_BINARY },
/// { NULL },
/// };
///
/// static const AVClass test_class = {
/// .class_name = "test class",
/// .item_name  = av_default_item_name,
/// .option     = test_options,
/// .version    = LIBAVUTIL_VERSION_INT,
/// };
/// @endcode
///
/// Next, when allocating your struct, you must ensure that the AVClass pointer
/// is set to the correct value. Then, av_opt_set_defaults() can be called to
/// initialize defaults. After that the struct is ready to be used with the
/// AVOptions API.
///
/// When cleaning up, you may use the av_opt_free() function to automatically
/// free all the allocated string and binary options.
///
/// Continuing with the above example:
///
/// @code
/// test_struct *alloc_test_struct(void)
/// {
/// test_struct *ret = av_mallocz(sizeof(*ret));
/// ret->class = &test_class;
/// av_opt_set_defaults(ret);
/// return ret;
/// }
/// void free_test_struct(test_struct **foo)
/// {
/// av_opt_free(*foo);
/// av_freep(foo);
/// }
/// @endcode
///
/// @subsection avoptions_implement_nesting Nesting
/// It may happen that an AVOptions-enabled struct contains another
/// AVOptions-enabled struct as a member (e.g. AVCodecContext in
/// libavcodec exports generic options, while its priv_data field exports
/// codec-specific options). In such a case, it is possible to set up the
/// parent struct to export a child's options. To do that, simply
/// implement AVClass.child_next() and AVClass.child_class_iterate() in the
/// parent struct's AVClass.
/// Assuming that the test_struct from above now also contains a
/// child_struct field:
///
/// @code
/// typedef struct child_struct {
/// AVClass *class;
/// int flags_opt;
/// } child_struct;
/// static const AVOption child_opts[] = {
/// { "test_flags", "This is a test option of flags type.",
/// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX },
/// { NULL },
/// };
/// static const AVClass child_class = {
/// .class_name = "child class",
/// .item_name  = av_default_item_name,
/// .option     = child_opts,
/// .version    = LIBAVUTIL_VERSION_INT,
/// };
///
/// void *child_next(void *obj, void *prev)
/// {
/// test_struct *t = obj;
/// if (!prev && t->child_struct)
/// return t->child_struct;
/// return NULL
/// }
/// const AVClass child_class_iterate(void **iter)
/// {
/// const AVClass *c = *iter ? NULL : &child_class;
/// *iter = (void*)(uintptr_t)c;
/// return c;
/// }
/// @endcode
/// Putting child_next() and child_class_iterate() as defined above into
/// test_class will now make child_struct's options accessible through
/// test_struct (again, proper setup as described above needs to be done on
/// child_struct right after it is created).
///
/// From the above example it might not be clear why both child_next()
/// and child_class_iterate() are needed. The distinction is that child_next()
/// iterates over actually existing objects, while child_class_iterate()
/// iterates over all possible child classes. E.g. if an AVCodecContext
/// was initialized to use a codec which has private options, then its
/// child_next() will return AVCodecContext.priv_data and finish
/// iterating. OTOH child_class_iterate() on AVCodecContext.av_class will
/// iterate over all available codecs with private options.
///
/// @subsection avoptions_implement_named_constants Named constants
/// It is possible to create named constants for options. Simply set the unit
/// field of the option the constants should apply to a string and
/// create the constants themselves as options of type AV_OPT_TYPE_CONST
/// with their unit field set to the same string.
/// Their default_val field should contain the value of the named
/// constant.
/// For example, to add some named constants for the test_flags option
/// above, put the following into the child_opts array:
/// @code
/// { "test_flags", "This is a test option of flags type.",
/// offsetof(child_struct, flags_opt), AV_OPT_TYPE_FLAGS, { .i64 = 0 }, INT_MIN, INT_MAX, "test_unit" },
/// { "flag1", "This is a flag with value 16", 0, AV_OPT_TYPE_CONST, { .i64 = 16 }, 0, 0, "test_unit" },
/// @endcode
///
/// @section avoptions_use Using AVOptions
/// This section deals with accessing options in an AVOptions-enabled struct.
/// Such structs in FFmpeg are e.g. AVCodecContext in libavcodec or
/// AVFormatContext in libavformat.
///
/// @subsection avoptions_use_examine Examining AVOptions
/// The basic functions for examining options are av_opt_next(), which iterates
/// over all options defined for one object, and av_opt_find(), which searches
/// for an option with the given name.
///
/// The situation is more complicated with nesting. An AVOptions-enabled struct
/// may have AVOptions-enabled children. Passing the AV_OPT_SEARCH_CHILDREN flag
/// to av_opt_find() will make the function search children recursively.
///
/// For enumerating there are basically two cases. The first is when you want to
/// get all options that may potentially exist on the struct and its children
/// (e.g.  when constructing documentation). In that case you should call
/// av_opt_child_class_iterate() recursively on the parent struct's AVClass.  The
/// second case is when you have an already initialized struct with all its
/// children and you want to get all options that can be actually written or read
/// from it. In that case you should call av_opt_child_next() recursively (and
/// av_opt_next() on each result).
///
/// @subsection avoptions_use_get_set Reading and writing AVOptions
/// When setting options, you often have a string read directly from the
/// user. In such a case, simply passing it to av_opt_set() is enough. For
/// non-string type options, av_opt_set() will parse the string according to the
/// option type.
///
/// Similarly av_opt_get() will read any option type and convert it to a string
/// which will be returned. Do not forget that the string is allocated, so you
/// have to free it with av_free().
///
/// In some cases it may be more convenient to put all options into an
/// AVDictionary and call av_opt_set_dict() on it. A specific case of this
/// are the format/codec open functions in lavf/lavc which take a dictionary
/// filled with option as a parameter. This makes it possible to set some options
/// that cannot be set otherwise, since e.g. the input file format is not known
/// before the file is actually opened.
abstract class AVOptionType {
  static const int AV_OPT_TYPE_FLAGS = 0;
  static const int AV_OPT_TYPE_INT = 1;
  static const int AV_OPT_TYPE_INT64 = 2;
  static const int AV_OPT_TYPE_DOUBLE = 3;
  static const int AV_OPT_TYPE_FLOAT = 4;
  static const int AV_OPT_TYPE_STRING = 5;
  static const int AV_OPT_TYPE_RATIONAL = 6;

  /// ///< offset must point to a pointer immediately followed by an int for the length
  static const int AV_OPT_TYPE_BINARY = 7;
  static const int AV_OPT_TYPE_DICT = 8;
  static const int AV_OPT_TYPE_UINT64 = 9;
  static const int AV_OPT_TYPE_CONST = 10;

  /// ///< offset must point to two consecutive integers
  static const int AV_OPT_TYPE_IMAGE_SIZE = 11;
  static const int AV_OPT_TYPE_PIXEL_FMT = 12;
  static const int AV_OPT_TYPE_SAMPLE_FMT = 13;

  /// ///< offset must point to AVRational
  static const int AV_OPT_TYPE_VIDEO_RATE = 14;
  static const int AV_OPT_TYPE_DURATION = 15;
  static const int AV_OPT_TYPE_COLOR = 16;
  static const int AV_OPT_TYPE_CHANNEL_LAYOUT = 17;
  static const int AV_OPT_TYPE_BOOL = 18;
}

/// A single allowed range of values, or a single allowed value.
class AVOptionRange extends ffi.Struct {
  ffi.Pointer<ffi.Int8> str;

  /// Value range.
  /// For string ranges this represents the min/max length.
  /// For dimensions this represents the min/max pixel count or width/height in multi-component case.
  @ffi.Double()
  double value_min;

  @ffi.Double()
  double value_max;

  /// Value's component range.
  /// For string this represents the unicode range for chars, 0-127 limits to ASCII.
  @ffi.Double()
  double component_min;

  @ffi.Double()
  double component_max;

  /// Range flag.
  /// If set to 1 the struct encodes a range, if set to 0 a single value.
  @ffi.Int32()
  int is_range;
}

/// AVDCT context.
/// @note function pointers can be NULL if the specific features have been
/// disabled at build time.
class AVDCT extends ffi.Struct {
  ffi.Pointer<AVClass> av_class;

  ffi.Pointer<ffi.NativeFunction<_typedefC_44>> idct;

  @ffi.Uint8()
  int _unique_idct_permutation_item_0;
  @ffi.Uint8()
  int _unique_idct_permutation_item_1;
  @ffi.Uint8()
  int _unique_idct_permutation_item_2;
  @ffi.Uint8()
  int _unique_idct_permutation_item_3;
  @ffi.Uint8()
  int _unique_idct_permutation_item_4;
  @ffi.Uint8()
  int _unique_idct_permutation_item_5;
  @ffi.Uint8()
  int _unique_idct_permutation_item_6;
  @ffi.Uint8()
  int _unique_idct_permutation_item_7;
  @ffi.Uint8()
  int _unique_idct_permutation_item_8;
  @ffi.Uint8()
  int _unique_idct_permutation_item_9;
  @ffi.Uint8()
  int _unique_idct_permutation_item_10;
  @ffi.Uint8()
  int _unique_idct_permutation_item_11;
  @ffi.Uint8()
  int _unique_idct_permutation_item_12;
  @ffi.Uint8()
  int _unique_idct_permutation_item_13;
  @ffi.Uint8()
  int _unique_idct_permutation_item_14;
  @ffi.Uint8()
  int _unique_idct_permutation_item_15;
  @ffi.Uint8()
  int _unique_idct_permutation_item_16;
  @ffi.Uint8()
  int _unique_idct_permutation_item_17;
  @ffi.Uint8()
  int _unique_idct_permutation_item_18;
  @ffi.Uint8()
  int _unique_idct_permutation_item_19;
  @ffi.Uint8()
  int _unique_idct_permutation_item_20;
  @ffi.Uint8()
  int _unique_idct_permutation_item_21;
  @ffi.Uint8()
  int _unique_idct_permutation_item_22;
  @ffi.Uint8()
  int _unique_idct_permutation_item_23;
  @ffi.Uint8()
  int _unique_idct_permutation_item_24;
  @ffi.Uint8()
  int _unique_idct_permutation_item_25;
  @ffi.Uint8()
  int _unique_idct_permutation_item_26;
  @ffi.Uint8()
  int _unique_idct_permutation_item_27;
  @ffi.Uint8()
  int _unique_idct_permutation_item_28;
  @ffi.Uint8()
  int _unique_idct_permutation_item_29;
  @ffi.Uint8()
  int _unique_idct_permutation_item_30;
  @ffi.Uint8()
  int _unique_idct_permutation_item_31;
  @ffi.Uint8()
  int _unique_idct_permutation_item_32;
  @ffi.Uint8()
  int _unique_idct_permutation_item_33;
  @ffi.Uint8()
  int _unique_idct_permutation_item_34;
  @ffi.Uint8()
  int _unique_idct_permutation_item_35;
  @ffi.Uint8()
  int _unique_idct_permutation_item_36;
  @ffi.Uint8()
  int _unique_idct_permutation_item_37;
  @ffi.Uint8()
  int _unique_idct_permutation_item_38;
  @ffi.Uint8()
  int _unique_idct_permutation_item_39;
  @ffi.Uint8()
  int _unique_idct_permutation_item_40;
  @ffi.Uint8()
  int _unique_idct_permutation_item_41;
  @ffi.Uint8()
  int _unique_idct_permutation_item_42;
  @ffi.Uint8()
  int _unique_idct_permutation_item_43;
  @ffi.Uint8()
  int _unique_idct_permutation_item_44;
  @ffi.Uint8()
  int _unique_idct_permutation_item_45;
  @ffi.Uint8()
  int _unique_idct_permutation_item_46;
  @ffi.Uint8()
  int _unique_idct_permutation_item_47;
  @ffi.Uint8()
  int _unique_idct_permutation_item_48;
  @ffi.Uint8()
  int _unique_idct_permutation_item_49;
  @ffi.Uint8()
  int _unique_idct_permutation_item_50;
  @ffi.Uint8()
  int _unique_idct_permutation_item_51;
  @ffi.Uint8()
  int _unique_idct_permutation_item_52;
  @ffi.Uint8()
  int _unique_idct_permutation_item_53;
  @ffi.Uint8()
  int _unique_idct_permutation_item_54;
  @ffi.Uint8()
  int _unique_idct_permutation_item_55;
  @ffi.Uint8()
  int _unique_idct_permutation_item_56;
  @ffi.Uint8()
  int _unique_idct_permutation_item_57;
  @ffi.Uint8()
  int _unique_idct_permutation_item_58;
  @ffi.Uint8()
  int _unique_idct_permutation_item_59;
  @ffi.Uint8()
  int _unique_idct_permutation_item_60;
  @ffi.Uint8()
  int _unique_idct_permutation_item_61;
  @ffi.Uint8()
  int _unique_idct_permutation_item_62;
  @ffi.Uint8()
  int _unique_idct_permutation_item_63;

  /// Helper for array `idct_permutation`.
  ArrayHelper_AVDCT_idct_permutation_level0 get idct_permutation =>
      ArrayHelper_AVDCT_idct_permutation_level0(this, [64], 0, 0);
  ffi.Pointer<ffi.NativeFunction<_typedefC_45>> fdct;

  /// DCT algorithm.
  /// must use AVOptions to set this field.
  @ffi.Int32()
  int dct_algo;

  /// IDCT algorithm.
  /// must use AVOptions to set this field.
  @ffi.Int32()
  int idct_algo;

  ffi.Pointer<ffi.NativeFunction<_typedefC_46>> get_pixels;

  @ffi.Int32()
  int bits_per_sample;

  ffi.Pointer<ffi.NativeFunction<_typedefC_47>> get_pixels_unaligned;
}

/// Helper for array `idct_permutation` in struct `AVDCT`.
class ArrayHelper_AVDCT_idct_permutation_level0 {
  final AVDCT _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVDCT_idct_permutation_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_idct_permutation_item_0;
      case 1:
        return _struct._unique_idct_permutation_item_1;
      case 2:
        return _struct._unique_idct_permutation_item_2;
      case 3:
        return _struct._unique_idct_permutation_item_3;
      case 4:
        return _struct._unique_idct_permutation_item_4;
      case 5:
        return _struct._unique_idct_permutation_item_5;
      case 6:
        return _struct._unique_idct_permutation_item_6;
      case 7:
        return _struct._unique_idct_permutation_item_7;
      case 8:
        return _struct._unique_idct_permutation_item_8;
      case 9:
        return _struct._unique_idct_permutation_item_9;
      case 10:
        return _struct._unique_idct_permutation_item_10;
      case 11:
        return _struct._unique_idct_permutation_item_11;
      case 12:
        return _struct._unique_idct_permutation_item_12;
      case 13:
        return _struct._unique_idct_permutation_item_13;
      case 14:
        return _struct._unique_idct_permutation_item_14;
      case 15:
        return _struct._unique_idct_permutation_item_15;
      case 16:
        return _struct._unique_idct_permutation_item_16;
      case 17:
        return _struct._unique_idct_permutation_item_17;
      case 18:
        return _struct._unique_idct_permutation_item_18;
      case 19:
        return _struct._unique_idct_permutation_item_19;
      case 20:
        return _struct._unique_idct_permutation_item_20;
      case 21:
        return _struct._unique_idct_permutation_item_21;
      case 22:
        return _struct._unique_idct_permutation_item_22;
      case 23:
        return _struct._unique_idct_permutation_item_23;
      case 24:
        return _struct._unique_idct_permutation_item_24;
      case 25:
        return _struct._unique_idct_permutation_item_25;
      case 26:
        return _struct._unique_idct_permutation_item_26;
      case 27:
        return _struct._unique_idct_permutation_item_27;
      case 28:
        return _struct._unique_idct_permutation_item_28;
      case 29:
        return _struct._unique_idct_permutation_item_29;
      case 30:
        return _struct._unique_idct_permutation_item_30;
      case 31:
        return _struct._unique_idct_permutation_item_31;
      case 32:
        return _struct._unique_idct_permutation_item_32;
      case 33:
        return _struct._unique_idct_permutation_item_33;
      case 34:
        return _struct._unique_idct_permutation_item_34;
      case 35:
        return _struct._unique_idct_permutation_item_35;
      case 36:
        return _struct._unique_idct_permutation_item_36;
      case 37:
        return _struct._unique_idct_permutation_item_37;
      case 38:
        return _struct._unique_idct_permutation_item_38;
      case 39:
        return _struct._unique_idct_permutation_item_39;
      case 40:
        return _struct._unique_idct_permutation_item_40;
      case 41:
        return _struct._unique_idct_permutation_item_41;
      case 42:
        return _struct._unique_idct_permutation_item_42;
      case 43:
        return _struct._unique_idct_permutation_item_43;
      case 44:
        return _struct._unique_idct_permutation_item_44;
      case 45:
        return _struct._unique_idct_permutation_item_45;
      case 46:
        return _struct._unique_idct_permutation_item_46;
      case 47:
        return _struct._unique_idct_permutation_item_47;
      case 48:
        return _struct._unique_idct_permutation_item_48;
      case 49:
        return _struct._unique_idct_permutation_item_49;
      case 50:
        return _struct._unique_idct_permutation_item_50;
      case 51:
        return _struct._unique_idct_permutation_item_51;
      case 52:
        return _struct._unique_idct_permutation_item_52;
      case 53:
        return _struct._unique_idct_permutation_item_53;
      case 54:
        return _struct._unique_idct_permutation_item_54;
      case 55:
        return _struct._unique_idct_permutation_item_55;
      case 56:
        return _struct._unique_idct_permutation_item_56;
      case 57:
        return _struct._unique_idct_permutation_item_57;
      case 58:
        return _struct._unique_idct_permutation_item_58;
      case 59:
        return _struct._unique_idct_permutation_item_59;
      case 60:
        return _struct._unique_idct_permutation_item_60;
      case 61:
        return _struct._unique_idct_permutation_item_61;
      case 62:
        return _struct._unique_idct_permutation_item_62;
      case 63:
        return _struct._unique_idct_permutation_item_63;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_idct_permutation_item_0 = value;
        break;
      case 1:
        _struct._unique_idct_permutation_item_1 = value;
        break;
      case 2:
        _struct._unique_idct_permutation_item_2 = value;
        break;
      case 3:
        _struct._unique_idct_permutation_item_3 = value;
        break;
      case 4:
        _struct._unique_idct_permutation_item_4 = value;
        break;
      case 5:
        _struct._unique_idct_permutation_item_5 = value;
        break;
      case 6:
        _struct._unique_idct_permutation_item_6 = value;
        break;
      case 7:
        _struct._unique_idct_permutation_item_7 = value;
        break;
      case 8:
        _struct._unique_idct_permutation_item_8 = value;
        break;
      case 9:
        _struct._unique_idct_permutation_item_9 = value;
        break;
      case 10:
        _struct._unique_idct_permutation_item_10 = value;
        break;
      case 11:
        _struct._unique_idct_permutation_item_11 = value;
        break;
      case 12:
        _struct._unique_idct_permutation_item_12 = value;
        break;
      case 13:
        _struct._unique_idct_permutation_item_13 = value;
        break;
      case 14:
        _struct._unique_idct_permutation_item_14 = value;
        break;
      case 15:
        _struct._unique_idct_permutation_item_15 = value;
        break;
      case 16:
        _struct._unique_idct_permutation_item_16 = value;
        break;
      case 17:
        _struct._unique_idct_permutation_item_17 = value;
        break;
      case 18:
        _struct._unique_idct_permutation_item_18 = value;
        break;
      case 19:
        _struct._unique_idct_permutation_item_19 = value;
        break;
      case 20:
        _struct._unique_idct_permutation_item_20 = value;
        break;
      case 21:
        _struct._unique_idct_permutation_item_21 = value;
        break;
      case 22:
        _struct._unique_idct_permutation_item_22 = value;
        break;
      case 23:
        _struct._unique_idct_permutation_item_23 = value;
        break;
      case 24:
        _struct._unique_idct_permutation_item_24 = value;
        break;
      case 25:
        _struct._unique_idct_permutation_item_25 = value;
        break;
      case 26:
        _struct._unique_idct_permutation_item_26 = value;
        break;
      case 27:
        _struct._unique_idct_permutation_item_27 = value;
        break;
      case 28:
        _struct._unique_idct_permutation_item_28 = value;
        break;
      case 29:
        _struct._unique_idct_permutation_item_29 = value;
        break;
      case 30:
        _struct._unique_idct_permutation_item_30 = value;
        break;
      case 31:
        _struct._unique_idct_permutation_item_31 = value;
        break;
      case 32:
        _struct._unique_idct_permutation_item_32 = value;
        break;
      case 33:
        _struct._unique_idct_permutation_item_33 = value;
        break;
      case 34:
        _struct._unique_idct_permutation_item_34 = value;
        break;
      case 35:
        _struct._unique_idct_permutation_item_35 = value;
        break;
      case 36:
        _struct._unique_idct_permutation_item_36 = value;
        break;
      case 37:
        _struct._unique_idct_permutation_item_37 = value;
        break;
      case 38:
        _struct._unique_idct_permutation_item_38 = value;
        break;
      case 39:
        _struct._unique_idct_permutation_item_39 = value;
        break;
      case 40:
        _struct._unique_idct_permutation_item_40 = value;
        break;
      case 41:
        _struct._unique_idct_permutation_item_41 = value;
        break;
      case 42:
        _struct._unique_idct_permutation_item_42 = value;
        break;
      case 43:
        _struct._unique_idct_permutation_item_43 = value;
        break;
      case 44:
        _struct._unique_idct_permutation_item_44 = value;
        break;
      case 45:
        _struct._unique_idct_permutation_item_45 = value;
        break;
      case 46:
        _struct._unique_idct_permutation_item_46 = value;
        break;
      case 47:
        _struct._unique_idct_permutation_item_47 = value;
        break;
      case 48:
        _struct._unique_idct_permutation_item_48 = value;
        break;
      case 49:
        _struct._unique_idct_permutation_item_49 = value;
        break;
      case 50:
        _struct._unique_idct_permutation_item_50 = value;
        break;
      case 51:
        _struct._unique_idct_permutation_item_51 = value;
        break;
      case 52:
        _struct._unique_idct_permutation_item_52 = value;
        break;
      case 53:
        _struct._unique_idct_permutation_item_53 = value;
        break;
      case 54:
        _struct._unique_idct_permutation_item_54 = value;
        break;
      case 55:
        _struct._unique_idct_permutation_item_55 = value;
        break;
      case 56:
        _struct._unique_idct_permutation_item_56 = value;
        break;
      case 57:
        _struct._unique_idct_permutation_item_57 = value;
        break;
      case 58:
        _struct._unique_idct_permutation_item_58 = value;
        break;
      case 59:
        _struct._unique_idct_permutation_item_59 = value;
        break;
      case 60:
        _struct._unique_idct_permutation_item_60 = value;
        break;
      case 61:
        _struct._unique_idct_permutation_item_61 = value;
        break;
      case 62:
        _struct._unique_idct_permutation_item_62 = value;
        break;
      case 63:
        _struct._unique_idct_permutation_item_63 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class FFTComplex extends ffi.Struct {
  @ffi.Float()
  double re;

  @ffi.Float()
  double im;
}

class FFTContext extends ffi.Struct {}

abstract class RDFTransformType {
  static const int DFT_R2C = 0;
  static const int IDFT_C2R = 1;
  static const int IDFT_R2C = 2;
  static const int DFT_C2R = 3;
}

class RDFTContext extends ffi.Struct {}

class DCTContext extends ffi.Struct {}

abstract class DCTTransformType {
  static const int DCT_II = 0;
  static const int DCT_III = 1;
  static const int DCT_I = 2;
  static const int DST_I = 3;
}

/// This structure is used to provides the necessary configurations and data
/// to the Direct3D11 FFmpeg HWAccel implementation.
///
/// The application must make it available as AVCodecContext.hwaccel_context.
///
/// Use av_d3d11va_alloc_context() exclusively to allocate an AVD3D11VAContext.
class AVD3D11VAContext extends ffi.Struct {
  /// D3D11 decoder object
  ffi.Pointer<ffi.Int32> decoder;

  /// D3D11 VideoContext
  ffi.Pointer<ffi.Int32> video_context;

  /// D3D11 configuration used to create the decoder
  ffi.Pointer<ffi.Int32> cfg;

  /// The number of surface in the surface array
  @ffi.Uint32()
  int surface_count;

  /// The array of Direct3D surfaces used to create the decoder
  ffi.Pointer<ffi.Pointer<ffi.Int32>> surface;

  /// A bit field configuring the workarounds needed for using the decoder
  @ffi.Uint64()
  int workaround;

  /// Private to the FFmpeg AVHWAccel implementation
  @ffi.Uint32()
  int report_id;

  /// Mutex to access video_context
  @ffi.Int32()
  int context_mutex;
}

/// Parse code values:
///
/// Dirac Specification ->
/// 9.6.1  Table 9.1
///
/// VC-2 Specification  ->
/// 10.4.1 Table 10.1
abstract class DiracParseCodes {
  static const int DIRAC_PCODE_SEQ_HEADER = 0;
  static const int DIRAC_PCODE_END_SEQ = 16;
  static const int DIRAC_PCODE_AUX = 32;
  static const int DIRAC_PCODE_PAD = 48;
  static const int DIRAC_PCODE_PICTURE_CODED = 8;
  static const int DIRAC_PCODE_PICTURE_RAW = 72;
  static const int DIRAC_PCODE_PICTURE_LOW_DEL = 200;
  static const int DIRAC_PCODE_PICTURE_HQ = 232;
  static const int DIRAC_PCODE_INTER_NOREF_CO1 = 10;
  static const int DIRAC_PCODE_INTER_NOREF_CO2 = 9;
  static const int DIRAC_PCODE_INTER_REF_CO1 = 13;
  static const int DIRAC_PCODE_INTER_REF_CO2 = 14;
  static const int DIRAC_PCODE_INTRA_REF_CO = 12;
  static const int DIRAC_PCODE_INTRA_REF_RAW = 76;
  static const int DIRAC_PCODE_INTRA_REF_PICT = 204;
  static const int DIRAC_PCODE_MAGIC = 1111638852;
}

class DiracVersionInfo extends ffi.Struct {
  @ffi.Int32()
  int major;

  @ffi.Int32()
  int minor;
}

class AVDiracSeqHeader extends ffi.Struct {}

class AVDVProfile extends ffi.Struct {}

/// This structure is used to provides the necessary configurations and data
/// to the DXVA2 FFmpeg HWAccel implementation.
///
/// The application must make it available as AVCodecContext.hwaccel_context.
class dxva_context extends ffi.Struct {
  /// DXVA2 decoder object
  ffi.Pointer<ffi.Int32> decoder;

  /// DXVA2 configuration used to create the decoder
  ffi.Pointer<ffi.Int32> cfg;

  /// The number of surface in the surface array
  @ffi.Uint32()
  int surface_count;

  /// The array of Direct3D surfaces used to create the decoder
  ffi.Pointer<ffi.Int32> surface;

  /// A bit field configuring the workarounds needed for using the decoder
  @ffi.Uint64()
  int workaround;

  /// Private to the FFmpeg AVHWAccel implementation
  @ffi.Uint32()
  int report_id;
}

/// This structure holds a reference to a android/view/Surface object that will
/// be used as output by the decoder.
class AVMediaCodecContext extends ffi.Struct {
  /// android/view/Surface object reference.
  ffi.Pointer<ffi.Void> surface;
}

class MediaCodecBuffer extends ffi.Struct {}

/// This struct is used for communicating QSV parameters between libavcodec and
/// the caller. It is managed by the caller and must be assigned to
/// AVCodecContext.hwaccel_context.
/// - decoding: hwaccel_context must be set on return from the get_format()
/// callback
/// - encoding: hwaccel_context must be set before avcodec_open2()
class AVQSVContext extends ffi.Struct {
  /// If non-NULL, the session to use for encoding or decoding.
  /// Otherwise, libavcodec will try to create an internal session.
  @ffi.Int32()
  int session;

  /// The IO pattern to use.
  @ffi.Int32()
  int iopattern;

  /// Extra buffers to pass to encoder or decoder initialization.
  ffi.Pointer<ffi.Pointer<ffi.Int32>> ext_buffers;

  @ffi.Int32()
  int nb_ext_buffers;

  /// Encoding only. If this field is set to non-zero by the caller, libavcodec
  /// will create an mfxExtOpaqueSurfaceAlloc extended buffer and pass it to
  /// the encoder initialization. This only makes sense if iopattern is also
  /// set to MFX_IOPATTERN_IN_OPAQUE_MEMORY.
  ///
  /// The number of allocated opaque surfaces will be the sum of the number
  /// required by the encoder and the user-provided value nb_opaque_surfaces.
  /// The array of the opaque surfaces will be exported to the caller through
  /// the opaque_surfaces field.
  @ffi.Int32()
  int opaque_alloc;

  /// Encoding only, and only if opaque_alloc is set to non-zero. Before
  /// calling avcodec_open2(), the caller should set this field to the number
  /// of extra opaque surfaces to allocate beyond what is required by the
  /// encoder.
  ///
  /// On return from avcodec_open2(), this field will be set by libavcodec to
  /// the total number of allocated opaque surfaces.
  @ffi.Int32()
  int nb_opaque_surfaces;

  /// Encoding only, and only if opaque_alloc is set to non-zero. On return
  /// from avcodec_open2(), this field will be used by libavcodec to export the
  /// array of the allocated opaque surfaces to the caller, so they can be
  /// passed to other parts of the pipeline.
  ///
  /// The buffer reference exported here is owned and managed by libavcodec,
  /// the callers should make their own reference with av_buffer_ref() and free
  /// it with av_buffer_unref() when it is no longer needed.
  ///
  /// The buffer data is an nb_opaque_surfaces-sized array of mfxFrameSurface1.
  ffi.Pointer<AVBufferRef> opaque_surfaces;

  /// Encoding only, and only if opaque_alloc is set to non-zero. On return
  /// from avcodec_open2(), this field will be set to the surface type used in
  /// the opaque allocation request.
  @ffi.Int32()
  int opaque_alloc_type;
}

/// This structure is used to share data between the FFmpeg library and
/// the client video application.
/// This shall be zero-allocated and available as
/// AVCodecContext.hwaccel_context. All user members can be set once
/// during initialization or through each AVCodecContext.get_buffer()
/// function call. In any case, they must be valid prior to calling
/// decoding functions.
///
/// Deprecated: use AVCodecContext.hw_frames_ctx instead.
class vaapi_context extends ffi.Struct {
  /// Window system dependent data
  ///
  /// - encoding: unused
  /// - decoding: Set by user
  ffi.Pointer<ffi.Void> display;

  /// Configuration ID
  ///
  /// - encoding: unused
  /// - decoding: Set by user
  @ffi.Uint32()
  int config_id;

  /// Context ID (video decode pipeline)
  ///
  /// - encoding: unused
  /// - decoding: Set by user
  @ffi.Uint32()
  int context_id;
}

/// This structure is used to share data between the libavcodec library and
/// the client video application.
/// The user shall allocate the structure via the av_alloc_vdpau_hwaccel
/// function and make it available as
/// AVCodecContext.hwaccel_context. Members can be set by the user once
/// during initialization or through each AVCodecContext.get_buffer()
/// function call. In any case, they must be valid prior to calling
/// decoding functions.
///
/// The size of this structure is not a part of the public ABI and must not
/// be used outside of libavcodec. Use av_vdpau_alloc_context() to allocate an
/// AVVDPAUContext.
class AVVDPAUContext extends ffi.Struct {
  /// VDPAU decoder handle
  ///
  /// Set by user.
  @ffi.Int32()
  int decoder;

  /// VDPAU decoder render callback
  ///
  /// Set by the user.
  ffi.Pointer<ffi.Int32> render;

  ffi.Pointer<ffi.NativeFunction<AVVDPAU_Render2>> render2;
}

/// This struct holds all the information that needs to be passed
/// between the caller and libavcodec for initializing Videotoolbox decoding.
/// Its size is not a part of the public ABI, it must be allocated with
/// av_videotoolbox_alloc_context() and freed with av_free().
class AVVideotoolboxContext extends ffi.Struct {
  /// Videotoolbox decompression session object.
  /// Created and freed the caller.
  @ffi.Int32()
  int session;

  /// The output callback that must be passed to the session.
  /// Set by av_videottoolbox_default_init()
  @ffi.Int32()
  int output_callback;

  /// CVPixelBuffer Format Type that Videotoolbox will use for decoded frames.
  /// set by the caller. If this is set to 0, then no specific format is
  /// requested from the decoder, and its native format is output.
  @ffi.Int32()
  int cv_pix_fmt_type;

  /// CoreMedia Format Description that Videotoolbox will use to create the decompression session.
  /// Set by the caller.
  @ffi.Int32()
  int cm_fmt_desc;

  /// CoreMedia codec type that Videotoolbox will use to create the decompression session.
  /// Set by the caller.
  @ffi.Int32()
  int cm_codec_type;
}

class AVVorbisParseContext extends ffi.Struct {}

class XvMCSurfaceInfo extends ffi.Struct {
  @ffi.Int32()
  int surface_type_id;

  @ffi.Int32()
  int chroma_format;

  @ffi.Uint16()
  int max_width;

  @ffi.Uint16()
  int max_height;

  @ffi.Uint16()
  int subpicture_max_width;

  @ffi.Uint16()
  int subpicture_max_height;

  @ffi.Int32()
  int mc_type;

  @ffi.Int32()
  int flags;
}

class XvMCContext extends ffi.Struct {
  @ffi.Uint64()
  int context_id;

  @ffi.Int32()
  int surface_type_id;

  @ffi.Uint16()
  int width;

  @ffi.Uint16()
  int height;

  @ffi.Uint64()
  int port;

  @ffi.Int32()
  int flags;

  ffi.Pointer<ffi.Void> privData;
}

class XvMCSurface extends ffi.Struct {
  @ffi.Uint64()
  int surface_id;

  @ffi.Uint64()
  int context_id;

  @ffi.Int32()
  int surface_type_id;

  @ffi.Uint16()
  int width;

  @ffi.Uint16()
  int height;

  ffi.Pointer<ffi.Void> privData;
}

class XvMCSubpicture extends ffi.Struct {
  @ffi.Uint64()
  int subpicture_id;

  @ffi.Uint64()
  int context_id;

  @ffi.Int32()
  int xvimage_id;

  @ffi.Uint16()
  int width;

  @ffi.Uint16()
  int height;

  @ffi.Int32()
  int num_palette_entries;

  @ffi.Int32()
  int entry_bytes;

  @ffi.Int8()
  int _unique_component_order_item_0;
  @ffi.Int8()
  int _unique_component_order_item_1;
  @ffi.Int8()
  int _unique_component_order_item_2;
  @ffi.Int8()
  int _unique_component_order_item_3;

  /// Helper for array `component_order`.
  ArrayHelper_XvMCSubpicture_component_order_level0 get component_order =>
      ArrayHelper_XvMCSubpicture_component_order_level0(this, [4], 0, 0);
  ffi.Pointer<ffi.Void> privData;
}

/// Helper for array `component_order` in struct `XvMCSubpicture`.
class ArrayHelper_XvMCSubpicture_component_order_level0 {
  final XvMCSubpicture _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_XvMCSubpicture_component_order_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_component_order_item_0;
      case 1:
        return _struct._unique_component_order_item_1;
      case 2:
        return _struct._unique_component_order_item_2;
      case 3:
        return _struct._unique_component_order_item_3;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_component_order_item_0 = value;
        break;
      case 1:
        _struct._unique_component_order_item_1 = value;
        break;
      case 2:
        _struct._unique_component_order_item_2 = value;
        break;
      case 3:
        _struct._unique_component_order_item_3 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class XvMCBlockArray extends ffi.Struct {
  @ffi.Uint32()
  int num_blocks;

  @ffi.Uint64()
  int context_id;

  ffi.Pointer<ffi.Void> privData;

  ffi.Pointer<ffi.Int16> blocks;
}

class XvMCMacroBlock extends ffi.Struct {
  @ffi.Uint16()
  int x;

  @ffi.Uint16()
  int y;

  @ffi.Uint8()
  int macroblock_type;

  @ffi.Uint8()
  int motion_type;

  @ffi.Uint8()
  int motion_vertical_field_select;

  @ffi.Uint8()
  int dct_type;

  @ffi.Int16()
  int _unique_PMV_item_0;
  @ffi.Int16()
  int _unique_PMV_item_1;
  @ffi.Int16()
  int _unique_PMV_item_2;
  @ffi.Int16()
  int _unique_PMV_item_3;
  @ffi.Int16()
  int _unique_PMV_item_4;
  @ffi.Int16()
  int _unique_PMV_item_5;
  @ffi.Int16()
  int _unique_PMV_item_6;
  @ffi.Int16()
  int _unique_PMV_item_7;

  /// Helper for array `PMV`.
  ArrayHelper_XvMCMacroBlock_PMV_level0 get PMV =>
      ArrayHelper_XvMCMacroBlock_PMV_level0(this, [2, 2, 2], 0, 0);
  @ffi.Uint32()
  int index;

  @ffi.Uint16()
  int coded_block_pattern;

  @ffi.Uint16()
  int pad0;
}

/// Helper for array `PMV` in struct `XvMCMacroBlock`.
class ArrayHelper_XvMCMacroBlock_PMV_level0 {
  final XvMCMacroBlock _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_XvMCMacroBlock_PMV_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_XvMCMacroBlock_PMV_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_XvMCMacroBlock_PMV_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `PMV` in struct `XvMCMacroBlock`.
class ArrayHelper_XvMCMacroBlock_PMV_level1 {
  final XvMCMacroBlock _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_XvMCMacroBlock_PMV_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_XvMCMacroBlock_PMV_level2 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_XvMCMacroBlock_PMV_level2(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `PMV` in struct `XvMCMacroBlock`.
class ArrayHelper_XvMCMacroBlock_PMV_level2 {
  final XvMCMacroBlock _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_XvMCMacroBlock_PMV_level2(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_PMV_item_0;
      case 1:
        return _struct._unique_PMV_item_1;
      case 2:
        return _struct._unique_PMV_item_2;
      case 3:
        return _struct._unique_PMV_item_3;
      case 4:
        return _struct._unique_PMV_item_4;
      case 5:
        return _struct._unique_PMV_item_5;
      case 6:
        return _struct._unique_PMV_item_6;
      case 7:
        return _struct._unique_PMV_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_PMV_item_0 = value;
        break;
      case 1:
        _struct._unique_PMV_item_1 = value;
        break;
      case 2:
        _struct._unique_PMV_item_2 = value;
        break;
      case 3:
        _struct._unique_PMV_item_3 = value;
        break;
      case 4:
        _struct._unique_PMV_item_4 = value;
        break;
      case 5:
        _struct._unique_PMV_item_5 = value;
        break;
      case 6:
        _struct._unique_PMV_item_6 = value;
        break;
      case 7:
        _struct._unique_PMV_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class XvMCMacroBlockArray extends ffi.Struct {
  @ffi.Uint32()
  int num_blocks;

  @ffi.Uint64()
  int context_id;

  ffi.Pointer<ffi.Void> privData;

  ffi.Pointer<XvMCMacroBlock> macro_blocks;
}

class xvmc_pix_fmt extends ffi.Struct {
  /// The field contains the special constant value AV_XVMC_ID.
  /// It is used as a test that the application correctly uses the API,
  /// and that there is no corruption caused by pixel routines.
  /// - application - set during initialization
  /// - libavcodec  - unchanged
  @ffi.Int32()
  int xvmc_id;

  /// Pointer to the block array allocated by XvMCCreateBlocks().
  /// The array has to be freed by XvMCDestroyBlocks().
  /// Each group of 64 values represents one data block of differential
  /// pixel information (in MoCo mode) or coefficients for IDCT.
  /// - application - set the pointer during initialization
  /// - libavcodec  - fills coefficients/pixel data into the array
  ffi.Pointer<ffi.Int16> data_blocks;

  /// Pointer to the macroblock description array allocated by
  /// XvMCCreateMacroBlocks() and freed by XvMCDestroyMacroBlocks().
  /// - application - set the pointer during initialization
  /// - libavcodec  - fills description data into the array
  ffi.Pointer<XvMCMacroBlock> mv_blocks;

  /// Number of macroblock descriptions that can be stored in the mv_blocks
  /// array.
  /// - application - set during initialization
  /// - libavcodec  - unchanged
  @ffi.Int32()
  int allocated_mv_blocks;

  /// Number of blocks that can be stored at once in the data_blocks array.
  /// - application - set during initialization
  /// - libavcodec  - unchanged
  @ffi.Int32()
  int allocated_data_blocks;

  /// Indicate that the hardware would interpret data_blocks as IDCT
  /// coefficients and perform IDCT on them.
  /// - application - set during initialization
  /// - libavcodec  - unchanged
  @ffi.Int32()
  int idct;

  /// In MoCo mode it indicates that intra macroblocks are assumed to be in
  /// unsigned format; same as the XVMC_INTRA_UNSIGNED flag.
  /// - application - set during initialization
  /// - libavcodec  - unchanged
  @ffi.Int32()
  int unsigned_intra;

  /// Pointer to the surface allocated by XvMCCreateSurface().
  /// It has to be freed by XvMCDestroySurface() on application exit.
  /// It identifies the frame and its state on the video hardware.
  /// - application - set during initialization
  /// - libavcodec  - unchanged
  ffi.Pointer<XvMCSurface> p_surface;

  /// Pointer to the surface used as past reference
  /// - application - unchanged
  /// - libavcodec  - set
  ffi.Pointer<XvMCSurface> p_past_surface;

  /// Pointer to the surface used as future reference
  /// - application - unchanged
  /// - libavcodec  - set
  ffi.Pointer<XvMCSurface> p_future_surface;

  /// top/bottom field or frame
  /// - application - unchanged
  /// - libavcodec  - set
  @ffi.Uint32()
  int picture_structure;

  /// XVMC_SECOND_FIELD - 1st or 2nd field in the sequence
  /// - application - unchanged
  /// - libavcodec  - set
  @ffi.Uint32()
  int flags;

  /// Number of macroblock descriptions in the mv_blocks array
  /// that have already been passed to the hardware.
  /// - application - zeroes it on get_buffer().
  /// A successful ff_draw_horiz_band() may increment it
  /// with filled_mb_block_num or zero both.
  /// - libavcodec  - unchanged
  @ffi.Int32()
  int start_mv_blocks_num;

  /// Number of new macroblock descriptions in the mv_blocks array (after
  /// start_mv_blocks_num) that are filled by libavcodec and have to be
  /// passed to the hardware.
  /// - application - zeroes it on get_buffer() or after successful
  /// ff_draw_horiz_band().
  /// - libavcodec  - increment with one of each stored MB
  @ffi.Int32()
  int filled_mv_blocks_num;

  /// Number of the next free data block; one data block consists of
  /// 64 short values in the data_blocks array.
  /// All blocks before this one have already been claimed by placing their
  /// position into the corresponding block description structure field,
  /// that are part of the mv_blocks array.
  /// - application - zeroes it on get_buffer().
  /// A successful ff_draw_horiz_band() may zero it together
  /// with start_mb_blocks_num.
  /// - libavcodec  - each decoded macroblock increases it by the number
  /// of coded blocks it contains.
  @ffi.Int32()
  int next_free_data_block_num;
}

class tm extends ffi.Struct {
  @ffi.Int32()
  int tm_sec;

  @ffi.Int32()
  int tm_min;

  @ffi.Int32()
  int tm_hour;

  @ffi.Int32()
  int tm_mday;

  @ffi.Int32()
  int tm_mon;

  @ffi.Int32()
  int tm_year;

  @ffi.Int32()
  int tm_wday;

  @ffi.Int32()
  int tm_yday;

  @ffi.Int32()
  int tm_isdst;

  @ffi.Int64()
  int tm_gmtoff;

  ffi.Pointer<ffi.Int8> tm_zone;
}

class itimerspec extends ffi.Struct {}

class sigevent extends ffi.Struct {}

/// Callback for checking whether to abort blocking functions.
/// AVERROR_EXIT is returned in this case by the interrupted
/// function. During blocking operations, callback is called with
/// opaque as parameter. If the callback returns 1, the
/// blocking operation will be aborted.
///
/// No members can be added to this struct without a major bump, if
/// new elements have been added after this struct in AVFormatContext
/// or AVIOContext.
class AVIOInterruptCB extends ffi.Struct {
  ffi.Pointer<ffi.NativeFunction<_typedefC_48>> callback;

  ffi.Pointer<ffi.Void> opaque;
}

/// Directory entry types.
abstract class AVIODirEntryType {
  static const int AVIO_ENTRY_UNKNOWN = 0;
  static const int AVIO_ENTRY_BLOCK_DEVICE = 1;
  static const int AVIO_ENTRY_CHARACTER_DEVICE = 2;
  static const int AVIO_ENTRY_DIRECTORY = 3;
  static const int AVIO_ENTRY_NAMED_PIPE = 4;
  static const int AVIO_ENTRY_SYMBOLIC_LINK = 5;
  static const int AVIO_ENTRY_SOCKET = 6;
  static const int AVIO_ENTRY_FILE = 7;
  static const int AVIO_ENTRY_SERVER = 8;
  static const int AVIO_ENTRY_SHARE = 9;
  static const int AVIO_ENTRY_WORKGROUP = 10;
}

/// Describes single entry of the directory.
///
/// Only name and type fields are guaranteed be set.
/// Rest of fields are protocol or/and platform dependent and might be unknown.
class AVIODirEntry extends ffi.Struct {
  /// < Filename
  ffi.Pointer<ffi.Int8> name;

  /// < Type of the entry
  @ffi.Int32()
  int type;

  /// < Set to 1 when name is encoded with UTF-8, 0 otherwise.
  /// Name can be encoded with UTF-8 even though 0 is set.
  @ffi.Int32()
  int utf8;

  /// < File size in bytes, -1 if unknown.
  @ffi.Int64()
  int size;

  /// < Time of last modification in microseconds since unix
  /// epoch, -1 if unknown.
  @ffi.Int64()
  int modification_timestamp;

  /// < Time of last access in microseconds since unix epoch,
  /// -1 if unknown.
  @ffi.Int64()
  int access_timestamp;

  /// < Time of last status change in microseconds since unix
  /// epoch, -1 if unknown.
  @ffi.Int64()
  int status_change_timestamp;

  /// < User ID of owner, -1 if unknown.
  @ffi.Int64()
  int user_id;

  /// < Group ID of owner, -1 if unknown.
  @ffi.Int64()
  int group_id;

  /// < Unix file mode, -1 if unknown.
  @ffi.Int64()
  int filemode;
}

class URLContext extends ffi.Struct {}

class AVIODirContext extends ffi.Struct {
  ffi.Pointer<URLContext> url_context;
}

/// Different data types that can be returned via the AVIO
/// write_data_type callback.
abstract class AVIODataMarkerType {
  /// Header data; this needs to be present for the stream to be decodeable.
  static const int AVIO_DATA_MARKER_HEADER = 0;

  /// A point in the output bytestream where a decoder can start decoding
  /// (i.e. a keyframe). A demuxer/decoder given the data flagged with
  /// AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT,
  /// should give decodeable results.
  static const int AVIO_DATA_MARKER_SYNC_POINT = 1;

  /// A point in the output bytestream where a demuxer can start parsing
  /// (for non self synchronizing bytestream formats). That is, any
  /// non-keyframe packet start point.
  static const int AVIO_DATA_MARKER_BOUNDARY_POINT = 2;

  /// This is any, unlabelled data. It can either be a muxer not marking
  /// any positions at all, it can be an actual boundary/sync point
  /// that the muxer chooses not to mark, or a later part of a packet/fragment
  /// that is cut into multiple write callbacks due to limited IO buffer size.
  static const int AVIO_DATA_MARKER_UNKNOWN = 3;

  /// Trailer data, which doesn't contain actual content, but only for
  /// finalizing the output file.
  static const int AVIO_DATA_MARKER_TRAILER = 4;

  /// A point in the output bytestream where the underlying AVIOContext might
  /// flush the buffer depending on latency or buffering requirements. Typically
  /// means the end of a packet.
  static const int AVIO_DATA_MARKER_FLUSH_POINT = 5;
}

/// Bytestream IO Context.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVIOContext) must not be used outside libav*.
///
/// @note None of the function pointers in AVIOContext should be called
/// directly, they should only be set by the client application
/// when implementing custom I/O. Normally these are set to the
/// function pointers specified in avio_alloc_context()
class AVIOContext extends ffi.Struct {
  /// A class for private options.
  ///
  /// If this AVIOContext is created by avio_open2(), av_class is set and
  /// passes the options down to protocols.
  ///
  /// If this AVIOContext is manually allocated, then av_class may be set by
  /// the caller.
  ///
  /// warning -- this field can be NULL, be sure to not pass this AVIOContext
  /// to any av_opt_* functions in that case.
  ffi.Pointer<AVClass> av_class;

  /// < Start of the buffer.
  ffi.Pointer<ffi.Uint8> buffer;

  /// < Maximum buffer size
  @ffi.Int32()
  int buffer_size;

  /// < Current position in the buffer
  ffi.Pointer<ffi.Uint8> buf_ptr;

  /// < End of the data, may be less than
  /// buffer+buffer_size if the read function returned
  /// less data than requested, e.g. for streams where
  /// no more data has been received yet.
  ffi.Pointer<ffi.Uint8> buf_end;

  /// < A private pointer, passed to the read/write/seek/...
  /// functions.
  ffi.Pointer<ffi.Void> opaque;

  ffi.Pointer<ffi.NativeFunction<_typedefC_49>> read_packet;

  ffi.Pointer<ffi.NativeFunction<_typedefC_50>> write_packet;

  ffi.Pointer<ffi.NativeFunction<_typedefC_51>> seek;

  /// < position in the file of the current buffer
  @ffi.Int64()
  int pos;

  /// < true if was unable to read due to error or eof
  @ffi.Int32()
  int eof_reached;

  /// < true if open for writing
  @ffi.Int32()
  int write_flag;

  @ffi.Int32()
  int max_packet_size;

  @ffi.Uint64()
  int checksum;

  ffi.Pointer<ffi.Uint8> checksum_ptr;

  ffi.Pointer<ffi.NativeFunction<_typedefC_52>> update_checksum;

  /// < contains the error code or 0 if no error happened
  @ffi.Int32()
  int error;

  /// Pause or resume playback for network streaming protocols - e.g. MMS.
  ffi.Pointer<ffi.NativeFunction<_typedefC_53>> read_pause;

  /// Seek to a given timestamp in stream with the specified stream_index.
  /// Needed for some network streaming protocols which don't support seeking
  /// to byte position.
  ffi.Pointer<ffi.NativeFunction<_typedefC_54>> read_seek;

  /// A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.
  @ffi.Int32()
  int seekable;

  /// max filesize, used to limit allocations
  /// This field is internal to libavformat and access from outside is not allowed.
  @ffi.Int64()
  int maxsize;

  /// avio_read and avio_write should if possible be satisfied directly
  /// instead of going through a buffer, and avio_seek will always
  /// call the underlying seek function directly.
  @ffi.Int32()
  int direct;

  /// Bytes read statistic
  /// This field is internal to libavformat and access from outside is not allowed.
  @ffi.Int64()
  int bytes_read;

  /// seek statistic
  /// This field is internal to libavformat and access from outside is not allowed.
  @ffi.Int32()
  int seek_count;

  /// writeout statistic
  /// This field is internal to libavformat and access from outside is not allowed.
  @ffi.Int32()
  int writeout_count;

  /// Original buffer size
  /// used internally after probing and ensure seekback to reset the buffer size
  /// This field is internal to libavformat and access from outside is not allowed.
  @ffi.Int32()
  int orig_buffer_size;

  /// Threshold to favor readahead over seek.
  /// This is current internal only, do not use from outside.
  @ffi.Int32()
  int short_seek_threshold;

  /// ',' separated list of allowed protocols.
  ffi.Pointer<ffi.Int8> protocol_whitelist;

  /// ',' separated list of disallowed protocols.
  ffi.Pointer<ffi.Int8> protocol_blacklist;

  /// A callback that is used instead of write_packet.
  ffi.Pointer<ffi.NativeFunction<_typedefC_55>> write_data_type;

  /// If set, don't call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT,
  /// but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly
  /// small chunks of data returned from the callback).
  @ffi.Int32()
  int ignore_boundary_point;

  /// Internal, not meant to be used from outside of AVIOContext.
  @ffi.Int32()
  int current_type;

  @ffi.Int64()
  int last_time;

  /// A callback that is used instead of short_seek_threshold.
  /// This is current internal only, do not use from outside.
  ffi.Pointer<ffi.NativeFunction<_typedefC_56>> short_seek_get;

  @ffi.Int64()
  int written;

  /// Maximum reached position before a backward seek in the write buffer,
  /// used keeping track of already written data for a later flush.
  ffi.Pointer<ffi.Uint8> buf_ptr_max;

  /// Try to buffer at least this amount of data before flushing it
  @ffi.Int32()
  int min_packet_size;
}

/// Format I/O context.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVFormatContext) must not be used outside libav*, use
/// avformat_alloc_context() to create an AVFormatContext.
///
/// Fields can be accessed through AVOptions (av_opt*),
/// the name string used matches the associated command line parameter name and
/// can be found in libavformat/options_table.h.
/// The AVOption/command line parameter names differ in some cases from the C
/// structure field names for historic reasons or brevity.
class AVFormatContext extends ffi.Struct {}

/// List of devices.
class AVDeviceInfoList extends ffi.Struct {}

/// Structure describes device capabilities.
///
/// It is used by devices in conjunction with av_device_capabilities AVOption table
/// to implement capabilities probing API based on AVOption API. Should not be used directly.
class AVDeviceCapabilitiesQuery extends ffi.Struct {}

///
class AVCodecTag extends ffi.Struct {}

/// This structure contains the data a format has to probe a file.
class AVProbeData extends ffi.Struct {
  ffi.Pointer<ffi.Int8> filename;

  /// < Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero.
  ffi.Pointer<ffi.Uint8> buf;

  /// < Size of buf except extra allocated bytes
  @ffi.Int32()
  int buf_size;

  /// < mime_type, when known.
  ffi.Pointer<ffi.Int8> mime_type;
}

/// @addtogroup lavf_encoding
/// @{
class AVOutputFormat extends ffi.Struct {
  ffi.Pointer<ffi.Int8> name;

  /// Descriptive name for the format, meant to be more human-readable
  /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
  /// to define it.
  ffi.Pointer<ffi.Int8> long_name;

  ffi.Pointer<ffi.Int8> mime_type;

  /// < comma-separated filename extensions
  ffi.Pointer<ffi.Int8> extensions;

  /// < default audio codec
  @ffi.Int32()
  int audio_codec;

  /// < default video codec
  @ffi.Int32()
  int video_codec;

  /// < default subtitle codec
  @ffi.Int32()
  int subtitle_codec;

  /// can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER,
  /// AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS,
  /// AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH,
  /// AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE
  @ffi.Int32()
  int flags;

  /// List of supported codec_id-codec_tag pairs, ordered by "better
  /// choice first". The arrays are all terminated by AV_CODEC_ID_NONE.
  ffi.Pointer<ffi.Pointer<AVCodecTag>> codec_tag;

  /// ///< AVClass for the private context
  ffi.Pointer<AVClass> priv_class;

  ffi.Pointer<AVOutputFormat> next;

  /// size of private data so that it can be allocated in the wrapper
  @ffi.Int32()
  int priv_data_size;

  ffi.Pointer<ffi.NativeFunction<_typedefC_60>> write_header;

  /// Write a packet. If AVFMT_ALLOW_FLUSH is set in flags,
  /// pkt can be NULL in order to flush data buffered in the muxer.
  /// When flushing, return 0 if there still is more data to flush,
  /// or 1 if everything was flushed and there is no more buffered
  /// data.
  ffi.Pointer<ffi.NativeFunction<_typedefC_61>> write_packet;

  ffi.Pointer<ffi.NativeFunction<_typedefC_62>> write_trailer;

  /// A format-specific function for interleavement.
  /// If unset, packets will be interleaved by dts.
  ffi.Pointer<ffi.NativeFunction<_typedefC_63>> interleave_packet;

  /// Test if the given codec can be stored in this container.
  ///
  /// @return 1 if the codec is supported, 0 if it is not.
  /// A negative number if unknown.
  /// MKTAG('A', 'P', 'I', 'C') if the codec is only supported as AV_DISPOSITION_ATTACHED_PIC
  ffi.Pointer<ffi.NativeFunction<_typedefC_64>> query_codec;

  ffi.Pointer<ffi.NativeFunction<_typedefC_65>> get_output_timestamp;

  /// Allows sending messages from application to device.
  ffi.Pointer<ffi.NativeFunction<_typedefC_66>> control_message;

  /// Write an uncoded AVFrame.
  ///
  /// See av_write_uncoded_frame() for details.
  ///
  /// The library will free *frame afterwards, but the muxer can prevent it
  /// by setting the pointer to NULL.
  ffi.Pointer<ffi.NativeFunction<_typedefC_67>> write_uncoded_frame;

  /// Returns device list with it properties.
  /// @see avdevice_list_devices() for more details.
  ffi.Pointer<ffi.NativeFunction<_typedefC_68>> get_device_list;

  /// Initialize device capabilities submodule.
  /// @see avdevice_capabilities_create() for more details.
  ffi.Pointer<ffi.NativeFunction<_typedefC_69>> create_device_capabilities;

  /// Free device capabilities submodule.
  /// @see avdevice_capabilities_free() for more details.
  ffi.Pointer<ffi.NativeFunction<_typedefC_70>> free_device_capabilities;

  /// < default data codec
  @ffi.Int32()
  int data_codec;

  /// Initialize format. May allocate data here, and set any AVFormatContext or
  /// AVStream parameters that need to be set before packets are sent.
  /// This method must not write output.
  ///
  /// Return 0 if streams were fully configured, 1 if not, negative AVERROR on failure
  ///
  /// Any allocations made here must be freed in deinit().
  ffi.Pointer<ffi.NativeFunction<_typedefC_71>> init;

  /// Deinitialize format. If present, this is called whenever the muxer is being
  /// destroyed, regardless of whether or not the header has been written.
  ///
  /// If a trailer is being written, this is called after write_trailer().
  ///
  /// This is called if init() fails as well.
  ffi.Pointer<ffi.NativeFunction<_typedefC_72>> deinit;

  /// Set up any necessary bitstream filtering and extract any extra data needed
  /// for the global header.
  /// Return 0 if more packets from this stream must be checked; 1 if not.
  ffi.Pointer<ffi.NativeFunction<_typedefC_73>> check_bitstream;
}

/// @addtogroup lavf_decoding
/// @{
class AVInputFormat extends ffi.Struct {
  /// A comma separated list of short names for the format. New names
  /// may be appended with a minor bump.
  ffi.Pointer<ffi.Int8> name;

  /// Descriptive name for the format, meant to be more human-readable
  /// than name. You should use the NULL_IF_CONFIG_SMALL() macro
  /// to define it.
  ffi.Pointer<ffi.Int8> long_name;

  /// Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS,
  /// AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH,
  /// AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.
  @ffi.Int32()
  int flags;

  /// If extensions are defined, then no probe is done. You should
  /// usually not use extension format guessing because it is not
  /// reliable enough
  ffi.Pointer<ffi.Int8> extensions;

  ffi.Pointer<ffi.Pointer<AVCodecTag>> codec_tag;

  /// ///< AVClass for the private context
  ffi.Pointer<AVClass> priv_class;

  /// Comma-separated list of mime types.
  /// It is used check for matching mime types while probing.
  /// @see av_probe_input_format2
  ffi.Pointer<ffi.Int8> mime_type;

  ffi.Pointer<AVInputFormat> next;

  /// Raw demuxers store their codec ID here.
  @ffi.Int32()
  int raw_codec_id;

  /// Size of private data so that it can be allocated in the wrapper.
  @ffi.Int32()
  int priv_data_size;

  /// Tell if a given file has a chance of being parsed as this format.
  /// The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
  /// big so you do not have to check for that unless you need more.
  ffi.Pointer<ffi.NativeFunction<_typedefC_74>> read_probe;

  /// Read the format header and initialize the AVFormatContext
  /// structure. Return 0 if OK. 'avformat_new_stream' should be
  /// called to create new streams.
  ffi.Pointer<ffi.NativeFunction<_typedefC_75>> read_header;

  /// Read one packet and put it in 'pkt'. pts and flags are also
  /// set. 'avformat_new_stream' can be called only if the flag
  /// AVFMTCTX_NOHEADER is used and only in the calling thread (not in a
  /// background thread).
  /// @return 0 on success, < 0 on error.
  /// Upon returning an error, pkt must be unreferenced by the caller.
  ffi.Pointer<ffi.NativeFunction<_typedefC_76>> read_packet;

  /// Close the stream. The AVFormatContext and AVStreams are not
  /// freed by this function
  ffi.Pointer<ffi.NativeFunction<_typedefC_77>> read_close;

  /// Seek to a given timestamp relative to the frames in
  /// stream component stream_index.
  /// @param stream_index Must not be -1.
  /// @param flags Selects which direction should be preferred if no exact
  /// match is available.
  /// @return >= 0 on success (but not necessarily the new offset)
  ffi.Pointer<ffi.NativeFunction<_typedefC_78>> read_seek;

  /// Get the next timestamp in stream[stream_index].time_base units.
  /// @return the timestamp or AV_NOPTS_VALUE if an error occurred
  ffi.Pointer<ffi.NativeFunction<_typedefC_79>> read_timestamp;

  /// Start/resume playing - only meaningful if using a network-based format
  /// (RTSP).
  ffi.Pointer<ffi.NativeFunction<_typedefC_80>> read_play;

  /// Pause playing - only meaningful if using a network-based format
  /// (RTSP).
  ffi.Pointer<ffi.NativeFunction<_typedefC_81>> read_pause;

  /// Seek to timestamp ts.
  /// Seeking will be done so that the point from which all active streams
  /// can be presented successfully will be closest to ts and within min/max_ts.
  /// Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
  ffi.Pointer<ffi.NativeFunction<_typedefC_82>> read_seek2;

  /// Returns device list with it properties.
  /// @see avdevice_list_devices() for more details.
  ffi.Pointer<ffi.NativeFunction<_typedefC_83>> get_device_list;

  /// Initialize device capabilities submodule.
  /// @see avdevice_capabilities_create() for more details.
  ffi.Pointer<ffi.NativeFunction<_typedefC_84>> create_device_capabilities;

  /// Free device capabilities submodule.
  /// @see avdevice_capabilities_free() for more details.
  ffi.Pointer<ffi.NativeFunction<_typedefC_85>> free_device_capabilities;
}

/// @}
abstract class AVStreamParseType {
  static const int AVSTREAM_PARSE_NONE = 0;

  /// < full parsing and repack
  static const int AVSTREAM_PARSE_FULL = 1;

  /// < Only parse headers, do not repack.
  static const int AVSTREAM_PARSE_HEADERS = 2;

  /// < full parsing and interpolation of timestamps for frames not starting on a packet boundary
  static const int AVSTREAM_PARSE_TIMESTAMPS = 3;

  /// < full parsing and repack of the first frame only, only implemented for H.264 currently
  static const int AVSTREAM_PARSE_FULL_ONCE = 4;

  /// < full parsing and repack with timestamp and position generation by parser for raw
  /// this assumes that each packet in the file contains no demuxer level headers and
  /// just codec level data, otherwise position generation would fail
  static const int AVSTREAM_PARSE_FULL_RAW = 5;
}

class AVIndexEntry extends ffi.Struct {}

class AVStreamInternal extends ffi.Struct {}

/// Stream structure.
/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVStream) must not be used outside libav*.
class AVStream extends ffi.Struct {}

/// New fields can be added to the end with minor version bumps.
/// Removal, reordering and changes to existing fields require a major
/// version bump.
/// sizeof(AVProgram) must not be used outside libav*.
class AVProgram extends ffi.Struct {
  @ffi.Int32()
  int id;

  @ffi.Int32()
  int flags;

  /// ///< selects which program to discard and which to feed to the caller
  @ffi.Int32()
  int discard;

  ffi.Pointer<ffi.Uint32> stream_index;

  @ffi.Uint32()
  int nb_stream_indexes;

  ffi.Pointer<AVDictionary> metadata;

  @ffi.Int32()
  int program_num;

  @ffi.Int32()
  int pmt_pid;

  @ffi.Int32()
  int pcr_pid;

  @ffi.Int32()
  int pmt_version;

  /// All fields below this line are not part of the public API. They
  /// may not be used outside of libavformat and can be changed and
  /// removed at will.
  /// New public fields should be added right above.
  @ffi.Int64()
  int start_time;

  @ffi.Int64()
  int end_time;

  /// ///< reference dts for wrap detection
  @ffi.Int64()
  int pts_wrap_reference;

  /// ///< behavior on wrap detection
  @ffi.Int32()
  int pts_wrap_behavior;
}

class AVChapter extends ffi.Struct {}

/// The duration of a video can be estimated through various ways, and this enum can be used
/// to know how the duration was estimated.
abstract class AVDurationEstimationMethod {
  /// ///< Duration accurately estimated from PTSes
  static const int AVFMT_DURATION_FROM_PTS = 0;

  /// ///< Duration estimated from a stream with a known duration
  static const int AVFMT_DURATION_FROM_STREAM = 1;

  /// ///< Duration estimated from bitrate (less accurate)
  static const int AVFMT_DURATION_FROM_BITRATE = 2;
}

class AVFormatInternal extends ffi.Struct {}

abstract class AVTimebaseSource {
  static const int AVFMT_TBCF_AUTO = -1;
  static const int AVFMT_TBCF_DECODER = 0;
  static const int AVFMT_TBCF_DEMUXER = 1;
  static const int AVFMT_TBCF_R_FRAMERATE = 2;
}

class AVDeviceRect extends ffi.Struct {
  /// < x coordinate of top left corner
  @ffi.Int32()
  int x;

  /// < y coordinate of top left corner
  @ffi.Int32()
  int y;

  /// < width
  @ffi.Int32()
  int width;

  /// < height
  @ffi.Int32()
  int height;
}

/// Message types used by avdevice_app_to_dev_control_message().
abstract class AVAppToDevMessageType {
  /// Dummy message.
  static const int AV_APP_TO_DEV_NONE = 1313820229;

  /// Window size change message.
  ///
  /// Message is sent to the device every time the application changes the size
  /// of the window device renders to.
  /// Message should also be sent right after window is created.
  ///
  /// data: AVDeviceRect: new window size.
  static const int AV_APP_TO_DEV_WINDOW_SIZE = 1195724621;

  /// Repaint request message.
  ///
  /// Message is sent to the device when window has to be repainted.
  ///
  /// data: AVDeviceRect: area required to be repainted.
  /// NULL: whole area is required to be repainted.
  static const int AV_APP_TO_DEV_WINDOW_REPAINT = 1380274241;

  /// Request pause/play.
  ///
  /// Application requests pause/unpause playback.
  /// Mostly usable with devices that have internal buffer.
  /// By default devices are not paused.
  ///
  /// data: NULL
  static const int AV_APP_TO_DEV_PAUSE = 1346458912;
  static const int AV_APP_TO_DEV_PLAY = 1347174745;
  static const int AV_APP_TO_DEV_TOGGLE_PAUSE = 1346458964;

  /// Volume control message.
  ///
  /// Set volume level. It may be device-dependent if volume
  /// is changed per stream or system wide. Per stream volume
  /// change is expected when possible.
  ///
  /// data: double: new volume with range of 0.0 - 1.0.
  static const int AV_APP_TO_DEV_SET_VOLUME = 1398165324;

  /// Mute control messages.
  ///
  /// Change mute state. It may be device-dependent if mute status
  /// is changed per stream or system wide. Per stream mute status
  /// change is expected when possible.
  ///
  /// data: NULL.
  static const int AV_APP_TO_DEV_MUTE = 541939028;
  static const int AV_APP_TO_DEV_UNMUTE = 1431131476;
  static const int AV_APP_TO_DEV_TOGGLE_MUTE = 1414354260;

  /// Get volume/mute messages.
  ///
  /// Force the device to send AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED or
  /// AV_DEV_TO_APP_MUTE_STATE_CHANGED command respectively.
  ///
  /// data: NULL.
  static const int AV_APP_TO_DEV_GET_VOLUME = 1196838732;
  static const int AV_APP_TO_DEV_GET_MUTE = 1196250452;
}

/// Message types used by avdevice_dev_to_app_control_message().
abstract class AVDevToAppMessageType {
  /// Dummy message.
  static const int AV_DEV_TO_APP_NONE = 1313820229;

  /// Create window buffer message.
  ///
  /// Device requests to create a window buffer. Exact meaning is device-
  /// and application-dependent. Message is sent before rendering first
  /// frame and all one-shot initializations should be done here.
  /// Application is allowed to ignore preferred window buffer size.
  ///
  /// @note: Application is obligated to inform about window buffer size
  /// with AV_APP_TO_DEV_WINDOW_SIZE message.
  ///
  /// data: AVDeviceRect: preferred size of the window buffer.
  /// NULL: no preferred size of the window buffer.
  static const int AV_DEV_TO_APP_CREATE_WINDOW_BUFFER = 1111708229;

  /// Prepare window buffer message.
  ///
  /// Device requests to prepare a window buffer for rendering.
  /// Exact meaning is device- and application-dependent.
  /// Message is sent before rendering of each frame.
  ///
  /// data: NULL.
  static const int AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER = 1112560197;

  /// Display window buffer message.
  ///
  /// Device requests to display a window buffer.
  /// Message is sent when new frame is ready to be displayed.
  /// Usually buffers need to be swapped in handler of this message.
  ///
  /// data: NULL.
  static const int AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER = 1111771475;

  /// Destroy window buffer message.
  ///
  /// Device requests to destroy a window buffer.
  /// Message is sent when device is about to be destroyed and window
  /// buffer is not required anymore.
  ///
  /// data: NULL.
  static const int AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER = 1111770451;

  /// Buffer fullness status messages.
  ///
  /// Device signals buffer overflow/underflow.
  ///
  /// data: NULL.
  static const int AV_DEV_TO_APP_BUFFER_OVERFLOW = 1112491596;
  static const int AV_DEV_TO_APP_BUFFER_UNDERFLOW = 1112884812;

  /// Buffer readable/writable.
  ///
  /// Device informs that buffer is readable/writable.
  /// When possible, device informs how many bytes can be read/write.
  ///
  /// @warning Device may not inform when number of bytes than can be read/write changes.
  ///
  /// data: int64_t: amount of bytes available to read/write.
  /// NULL: amount of bytes available to read/write is not known.
  static const int AV_DEV_TO_APP_BUFFER_READABLE = 1112687648;
  static const int AV_DEV_TO_APP_BUFFER_WRITABLE = 1113018912;

  /// Mute state change message.
  ///
  /// Device informs that mute state has changed.
  ///
  /// data: int: 0 for not muted state, non-zero for muted state.
  static const int AV_DEV_TO_APP_MUTE_STATE_CHANGED = 1129141588;

  /// Volume level change message.
  ///
  /// Device informs that volume level has changed.
  ///
  /// data: double: new volume with range of 0.0 - 1.0.
  static const int AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED = 1129729868;
}

/// Structure describes basic parameters of the device.
class AVDeviceInfo extends ffi.Struct {
  /// < device name, format depends on device
  ffi.Pointer<ffi.Int8> device_name;

  /// < human friendly name
  ffi.Pointer<ffi.Int8> device_description;
}

/// An instance of a filter
class AVFilterContext extends ffi.Struct {}

/// A link between two filters. This contains pointers to the source and
/// destination filters between which this link exists, and the indexes of
/// the pads involved. In addition, this link also contains the parameters
/// which have been negotiated and agreed upon between the filter, such as
/// image dimensions, format, etc.
///
/// Applications must not normally access the link structure directly.
/// Use the buffersrc and buffersink API instead.
/// In the future, access to the header may be reserved for filters
/// implementation.
class AVFilterLink extends ffi.Struct {}

class AVFilterPad extends ffi.Struct {}

class AVFilterFormats extends ffi.Struct {}

class AVFilterChannelLayouts extends ffi.Struct {}

/// Filter definition. This defines the pads a filter contains, and all the
/// callback functions used to interact with the filter.
class AVFilter extends ffi.Struct {
  /// Filter name. Must be non-NULL and unique among filters.
  ffi.Pointer<ffi.Int8> name;

  /// A description of the filter. May be NULL.
  ///
  /// You should use the NULL_IF_CONFIG_SMALL() macro to define it.
  ffi.Pointer<ffi.Int8> description;

  /// List of inputs, terminated by a zeroed element.
  ///
  /// NULL if there are no (static) inputs. Instances of filters with
  /// AVFILTER_FLAG_DYNAMIC_INPUTS set may have more inputs than present in
  /// this list.
  ffi.Pointer<AVFilterPad> inputs;

  /// List of outputs, terminated by a zeroed element.
  ///
  /// NULL if there are no (static) outputs. Instances of filters with
  /// AVFILTER_FLAG_DYNAMIC_OUTPUTS set may have more outputs than present in
  /// this list.
  ffi.Pointer<AVFilterPad> outputs;

  /// A class for the private data, used to declare filter private AVOptions.
  /// This field is NULL for filters that do not declare any options.
  ///
  /// If this field is non-NULL, the first member of the filter private data
  /// must be a pointer to AVClass, which will be set by libavfilter generic
  /// code to this class.
  ffi.Pointer<AVClass> priv_class;

  /// A combination of AVFILTER_FLAG_*
  @ffi.Int32()
  int flags;

  /// Filter pre-initialization function
  ///
  /// This callback will be called immediately after the filter context is
  /// allocated, to allow allocating and initing sub-objects.
  ///
  /// If this callback is not NULL, the uninit callback will be called on
  /// allocation failure.
  ///
  /// @return 0 on success,
  /// AVERROR code on failure (but the code will be
  /// dropped and treated as ENOMEM by the calling code)
  ffi.Pointer<ffi.NativeFunction<_typedefC_86>> preinit;

  /// Filter initialization function.
  ///
  /// This callback will be called only once during the filter lifetime, after
  /// all the options have been set, but before links between filters are
  /// established and format negotiation is done.
  ///
  /// Basic filter initialization should be done here. Filters with dynamic
  /// inputs and/or outputs should create those inputs/outputs here based on
  /// provided options. No more changes to this filter's inputs/outputs can be
  /// done after this callback.
  ///
  /// This callback must not assume that the filter links exist or frame
  /// parameters are known.
  ///
  /// @ref AVFilter.uninit "uninit" is guaranteed to be called even if
  /// initialization fails, so this callback does not have to clean up on
  /// failure.
  ///
  /// @return 0 on success, a negative AVERROR on failure
  ffi.Pointer<ffi.NativeFunction<_typedefC_87>> init;

  /// Should be set instead of @ref AVFilter.init "init" by the filters that
  /// want to pass a dictionary of AVOptions to nested contexts that are
  /// allocated during init.
  ///
  /// On return, the options dict should be freed and replaced with one that
  /// contains all the options which could not be processed by this filter (or
  /// with NULL if all the options were processed).
  ///
  /// Otherwise the semantics is the same as for @ref AVFilter.init "init".
  ffi.Pointer<ffi.NativeFunction<_typedefC_88>> init_dict;

  /// Filter uninitialization function.
  ///
  /// Called only once right before the filter is freed. Should deallocate any
  /// memory held by the filter, release any buffer references, etc. It does
  /// not need to deallocate the AVFilterContext.priv memory itself.
  ///
  /// This callback may be called even if @ref AVFilter.init "init" was not
  /// called or failed, so it must be prepared to handle such a situation.
  ffi.Pointer<ffi.NativeFunction<_typedefC_89>> uninit;

  /// Query formats supported by the filter on its inputs and outputs.
  ///
  /// This callback is called after the filter is initialized (so the inputs
  /// and outputs are fixed), shortly before the format negotiation. This
  /// callback may be called more than once.
  ///
  /// This callback must set AVFilterLink.outcfg.formats on every input link and
  /// AVFilterLink.incfg.formats on every output link to a list of pixel/sample
  /// formats that the filter supports on that link. For audio links, this
  /// filter must also set @ref AVFilterLink.incfg.samplerates "in_samplerates" /
  /// @ref AVFilterLink.outcfg.samplerates "out_samplerates" and
  /// @ref AVFilterLink.incfg.channel_layouts "in_channel_layouts" /
  /// @ref AVFilterLink.outcfg.channel_layouts "out_channel_layouts" analogously.
  ///
  /// This callback may be NULL for filters with one input, in which case
  /// libavfilter assumes that it supports all input formats and preserves
  /// them on output.
  ///
  /// @return zero on success, a negative value corresponding to an
  /// AVERROR code otherwise
  ffi.Pointer<ffi.NativeFunction<_typedefC_90>> query_formats;

  /// ///< size of private data to allocate for the filter
  @ffi.Int32()
  int priv_size;

  /// ///< Additional flags for avfilter internal use only.
  @ffi.Int32()
  int flags_internal;

  /// Used by the filter registration system. Must not be touched by any other
  /// code.
  ffi.Pointer<AVFilter> next;

  /// Make the filter instance process a command.
  ///
  /// @param cmd    the command to process, for handling simplicity all commands must be alphanumeric only
  /// @param arg    the argument for the command
  /// @param res    a buffer with size res_size where the filter(s) can return a response. This must not change when the command is not supported.
  /// @param flags  if AVFILTER_CMD_FLAG_FAST is set and the command would be
  /// time consuming then a filter should treat it like an unsupported command
  ///
  /// @returns >=0 on success otherwise an error code.
  /// AVERROR(ENOSYS) on unsupported commands
  ffi.Pointer<ffi.NativeFunction<_typedefC_91>> process_command;

  /// Filter initialization function, alternative to the init()
  /// callback. Args contains the user-supplied parameters, opaque is
  /// used for providing binary data.
  ffi.Pointer<ffi.NativeFunction<_typedefC_92>> init_opaque;

  /// Filter activation function.
  ///
  /// Called when any processing is needed from the filter, instead of any
  /// filter_frame and request_frame on pads.
  ///
  /// The function must examine inlinks and outlinks and perform a single
  /// step of processing. If there is nothing to do, the function must do
  /// nothing and not return an error. If more steps are or may be
  /// possible, it must use ff_filter_set_ready() to schedule another
  /// activation.
  ffi.Pointer<ffi.NativeFunction<_typedefC_93>> activate;
}

class AVFilterInternal extends ffi.Struct {}

/// Lists of formats / etc. supported by an end of a link.
///
/// This structure is directly part of AVFilterLink, in two copies:
/// one for the source filter, one for the destination filter.
///
/// These lists are used for negotiating the format to actually be used,
/// which will be loaded into the format and channel_layout members of
/// AVFilterLink, when chosen.
class AVFilterFormatsConfig extends ffi.Struct {
  /// List of supported formats (pixel or sample).
  ffi.Pointer<AVFilterFormats> formats;

  /// Lists of supported sample rates, only for audio.
  ffi.Pointer<AVFilterFormats> samplerates;

  /// Lists of supported channel layouts, only for audio.
  ffi.Pointer<AVFilterChannelLayouts> channel_layouts;
}

class AVFilterGraphInternal extends ffi.Struct {}

class AVFilterGraph extends ffi.Struct {
  ffi.Pointer<AVClass> av_class;

  ffi.Pointer<ffi.Pointer<AVFilterContext>> filters;

  @ffi.Uint32()
  int nb_filters;

  /// ///< sws options to use for the auto-inserted scale filters
  ffi.Pointer<ffi.Int8> scale_sws_opts;

  /// ///< libavresample options to use for the auto-inserted resample filters
  ffi.Pointer<ffi.Int8> resample_lavr_opts;

  /// Type of multithreading allowed for filters in this graph. A combination
  /// of AVFILTER_THREAD_* flags.
  ///
  /// May be set by the caller at any point, the setting will apply to all
  /// filters initialized after that. The default is allowing everything.
  ///
  /// When a filter in this graph is initialized, this field is combined using
  /// bit AND with AVFilterContext.thread_type to get the final mask used for
  /// determining allowed threading types. I.e. a threading type needs to be
  /// set in both to be allowed.
  @ffi.Int32()
  int thread_type;

  /// Maximum number of threads used by filters in this graph. May be set by
  /// the caller before adding any filters to the filtergraph. Zero (the
  /// default) means that the number of threads is determined automatically.
  @ffi.Int32()
  int nb_threads;

  /// Opaque object for libavfilter internal use.
  ffi.Pointer<AVFilterGraphInternal> internal;

  /// Opaque user data. May be set by the caller to an arbitrary value, e.g. to
  /// be used from callbacks like @ref AVFilterGraph.execute.
  /// Libavfilter will not touch this field in any way.
  ffi.Pointer<ffi.Void> opaque;

  /// This callback may be set by the caller immediately after allocating the
  /// graph and before adding any filters to it, to provide a custom
  /// multithreading implementation.
  ///
  /// If set, filters with slice threading capability will call this callback
  /// to execute multiple jobs in parallel.
  ///
  /// If this field is left unset, libavfilter will use its internal
  /// implementation, which may or may not be multithreaded depending on the
  /// platform and build options.
  ffi.Pointer<ffi.NativeFunction<avfilter_execute_func>> execute;

  /// ///< swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions
  ffi.Pointer<ffi.Int8> aresample_swr_opts;

  /// Private fields
  ///
  /// The following fields are for internal use only.
  /// Their type, offset, number and semantic can change without notice.
  ffi.Pointer<ffi.Pointer<AVFilterLink>> sink_links;

  @ffi.Int32()
  int sink_links_count;

  @ffi.Uint32()
  int disable_auto_convert;
}

/// A linked-list of the inputs/outputs of the filter chain.
///
/// This is mainly useful for avfilter_graph_parse() / avfilter_graph_parse2(),
/// where it is used to communicate open (unlinked) inputs and outputs from and
/// to the caller.
/// This struct specifies, per each not connected pad contained in the graph, the
/// filter context and the pad index required for establishing a link.
class AVFilterInOut extends ffi.Struct {
  /// unique name for this input/output in the list
  ffi.Pointer<ffi.Int8> name;

  /// filter context associated to this input/output
  ffi.Pointer<AVFilterContext> filter_ctx;

  /// index of the filt_ctx pad to use for linking
  @ffi.Int32()
  int pad_idx;

  /// next input/input in the list, NULL if this is the last
  ffi.Pointer<AVFilterInOut> next;
}

/// Deprecated and unused struct to use for initializing a buffersink context.
class AVBufferSinkParams extends ffi.Struct {
  /// ///< list of allowed pixel formats, terminated by AV_PIX_FMT_NONE
  ffi.Pointer<ffi.Int32> pixel_fmts;
}

/// Deprecated and unused struct to use for initializing an abuffersink context.
class AVABufferSinkParams extends ffi.Struct {
  /// ///< list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE
  ffi.Pointer<ffi.Int32> sample_fmts;

  /// ///< list of allowed channel layouts, terminated by -1
  ffi.Pointer<ffi.Int64> channel_layouts;

  /// ///< list of allowed channel counts, terminated by -1
  ffi.Pointer<ffi.Int32> channel_counts;

  /// ///< if not 0, accept any channel count or layout
  @ffi.Int32()
  int all_channel_counts;

  /// ///< list of allowed sample rates, terminated by -1
  ffi.Pointer<ffi.Int32> sample_rates;
}

/// This structure contains the parameters describing the frames that will be
/// passed to this filter.
///
/// It should be allocated with av_buffersrc_parameters_alloc() and freed with
/// av_free(). All the allocated fields in it remain owned by the caller.
class AVBufferSrcParameters extends ffi.Struct {}

class AVAES extends ffi.Struct {}

class AVAESCTR extends ffi.Struct {}

class AVFifoBuffer extends ffi.Struct {
  ffi.Pointer<ffi.Uint8> buffer;

  ffi.Pointer<ffi.Uint8> rptr;

  ffi.Pointer<ffi.Uint8> wptr;

  ffi.Pointer<ffi.Uint8> end;

  @ffi.Uint32()
  int rndx;

  @ffi.Uint32()
  int wndx;
}

class AVAudioFifo extends ffi.Struct {}

abstract class AVEscapeMode {
  /// ///< Use auto-selected escaping mode.
  static const int AV_ESCAPE_MODE_AUTO = 0;

  /// ///< Use backslash escaping.
  static const int AV_ESCAPE_MODE_BACKSLASH = 1;

  /// ///< Use single-quote escaping.
  static const int AV_ESCAPE_MODE_QUOTE = 2;
}

class AVBlowfish extends ffi.Struct {
  @ffi.Uint32()
  int _unique_p_item_0;
  @ffi.Uint32()
  int _unique_p_item_1;
  @ffi.Uint32()
  int _unique_p_item_2;
  @ffi.Uint32()
  int _unique_p_item_3;
  @ffi.Uint32()
  int _unique_p_item_4;
  @ffi.Uint32()
  int _unique_p_item_5;
  @ffi.Uint32()
  int _unique_p_item_6;
  @ffi.Uint32()
  int _unique_p_item_7;
  @ffi.Uint32()
  int _unique_p_item_8;
  @ffi.Uint32()
  int _unique_p_item_9;
  @ffi.Uint32()
  int _unique_p_item_10;
  @ffi.Uint32()
  int _unique_p_item_11;
  @ffi.Uint32()
  int _unique_p_item_12;
  @ffi.Uint32()
  int _unique_p_item_13;
  @ffi.Uint32()
  int _unique_p_item_14;
  @ffi.Uint32()
  int _unique_p_item_15;
  @ffi.Uint32()
  int _unique_p_item_16;
  @ffi.Uint32()
  int _unique_p_item_17;

  /// Helper for array `p`.
  ArrayHelper_AVBlowfish_p_level0 get p =>
      ArrayHelper_AVBlowfish_p_level0(this, [18], 0, 0);
  @ffi.Uint32()
  int _unique_s_item_0;
  @ffi.Uint32()
  int _unique_s_item_1;
  @ffi.Uint32()
  int _unique_s_item_2;
  @ffi.Uint32()
  int _unique_s_item_3;
  @ffi.Uint32()
  int _unique_s_item_4;
  @ffi.Uint32()
  int _unique_s_item_5;
  @ffi.Uint32()
  int _unique_s_item_6;
  @ffi.Uint32()
  int _unique_s_item_7;
  @ffi.Uint32()
  int _unique_s_item_8;
  @ffi.Uint32()
  int _unique_s_item_9;
  @ffi.Uint32()
  int _unique_s_item_10;
  @ffi.Uint32()
  int _unique_s_item_11;
  @ffi.Uint32()
  int _unique_s_item_12;
  @ffi.Uint32()
  int _unique_s_item_13;
  @ffi.Uint32()
  int _unique_s_item_14;
  @ffi.Uint32()
  int _unique_s_item_15;
  @ffi.Uint32()
  int _unique_s_item_16;
  @ffi.Uint32()
  int _unique_s_item_17;
  @ffi.Uint32()
  int _unique_s_item_18;
  @ffi.Uint32()
  int _unique_s_item_19;
  @ffi.Uint32()
  int _unique_s_item_20;
  @ffi.Uint32()
  int _unique_s_item_21;
  @ffi.Uint32()
  int _unique_s_item_22;
  @ffi.Uint32()
  int _unique_s_item_23;
  @ffi.Uint32()
  int _unique_s_item_24;
  @ffi.Uint32()
  int _unique_s_item_25;
  @ffi.Uint32()
  int _unique_s_item_26;
  @ffi.Uint32()
  int _unique_s_item_27;
  @ffi.Uint32()
  int _unique_s_item_28;
  @ffi.Uint32()
  int _unique_s_item_29;
  @ffi.Uint32()
  int _unique_s_item_30;
  @ffi.Uint32()
  int _unique_s_item_31;
  @ffi.Uint32()
  int _unique_s_item_32;
  @ffi.Uint32()
  int _unique_s_item_33;
  @ffi.Uint32()
  int _unique_s_item_34;
  @ffi.Uint32()
  int _unique_s_item_35;
  @ffi.Uint32()
  int _unique_s_item_36;
  @ffi.Uint32()
  int _unique_s_item_37;
  @ffi.Uint32()
  int _unique_s_item_38;
  @ffi.Uint32()
  int _unique_s_item_39;
  @ffi.Uint32()
  int _unique_s_item_40;
  @ffi.Uint32()
  int _unique_s_item_41;
  @ffi.Uint32()
  int _unique_s_item_42;
  @ffi.Uint32()
  int _unique_s_item_43;
  @ffi.Uint32()
  int _unique_s_item_44;
  @ffi.Uint32()
  int _unique_s_item_45;
  @ffi.Uint32()
  int _unique_s_item_46;
  @ffi.Uint32()
  int _unique_s_item_47;
  @ffi.Uint32()
  int _unique_s_item_48;
  @ffi.Uint32()
  int _unique_s_item_49;
  @ffi.Uint32()
  int _unique_s_item_50;
  @ffi.Uint32()
  int _unique_s_item_51;
  @ffi.Uint32()
  int _unique_s_item_52;
  @ffi.Uint32()
  int _unique_s_item_53;
  @ffi.Uint32()
  int _unique_s_item_54;
  @ffi.Uint32()
  int _unique_s_item_55;
  @ffi.Uint32()
  int _unique_s_item_56;
  @ffi.Uint32()
  int _unique_s_item_57;
  @ffi.Uint32()
  int _unique_s_item_58;
  @ffi.Uint32()
  int _unique_s_item_59;
  @ffi.Uint32()
  int _unique_s_item_60;
  @ffi.Uint32()
  int _unique_s_item_61;
  @ffi.Uint32()
  int _unique_s_item_62;
  @ffi.Uint32()
  int _unique_s_item_63;
  @ffi.Uint32()
  int _unique_s_item_64;
  @ffi.Uint32()
  int _unique_s_item_65;
  @ffi.Uint32()
  int _unique_s_item_66;
  @ffi.Uint32()
  int _unique_s_item_67;
  @ffi.Uint32()
  int _unique_s_item_68;
  @ffi.Uint32()
  int _unique_s_item_69;
  @ffi.Uint32()
  int _unique_s_item_70;
  @ffi.Uint32()
  int _unique_s_item_71;
  @ffi.Uint32()
  int _unique_s_item_72;
  @ffi.Uint32()
  int _unique_s_item_73;
  @ffi.Uint32()
  int _unique_s_item_74;
  @ffi.Uint32()
  int _unique_s_item_75;
  @ffi.Uint32()
  int _unique_s_item_76;
  @ffi.Uint32()
  int _unique_s_item_77;
  @ffi.Uint32()
  int _unique_s_item_78;
  @ffi.Uint32()
  int _unique_s_item_79;
  @ffi.Uint32()
  int _unique_s_item_80;
  @ffi.Uint32()
  int _unique_s_item_81;
  @ffi.Uint32()
  int _unique_s_item_82;
  @ffi.Uint32()
  int _unique_s_item_83;
  @ffi.Uint32()
  int _unique_s_item_84;
  @ffi.Uint32()
  int _unique_s_item_85;
  @ffi.Uint32()
  int _unique_s_item_86;
  @ffi.Uint32()
  int _unique_s_item_87;
  @ffi.Uint32()
  int _unique_s_item_88;
  @ffi.Uint32()
  int _unique_s_item_89;
  @ffi.Uint32()
  int _unique_s_item_90;
  @ffi.Uint32()
  int _unique_s_item_91;
  @ffi.Uint32()
  int _unique_s_item_92;
  @ffi.Uint32()
  int _unique_s_item_93;
  @ffi.Uint32()
  int _unique_s_item_94;
  @ffi.Uint32()
  int _unique_s_item_95;
  @ffi.Uint32()
  int _unique_s_item_96;
  @ffi.Uint32()
  int _unique_s_item_97;
  @ffi.Uint32()
  int _unique_s_item_98;
  @ffi.Uint32()
  int _unique_s_item_99;
  @ffi.Uint32()
  int _unique_s_item_100;
  @ffi.Uint32()
  int _unique_s_item_101;
  @ffi.Uint32()
  int _unique_s_item_102;
  @ffi.Uint32()
  int _unique_s_item_103;
  @ffi.Uint32()
  int _unique_s_item_104;
  @ffi.Uint32()
  int _unique_s_item_105;
  @ffi.Uint32()
  int _unique_s_item_106;
  @ffi.Uint32()
  int _unique_s_item_107;
  @ffi.Uint32()
  int _unique_s_item_108;
  @ffi.Uint32()
  int _unique_s_item_109;
  @ffi.Uint32()
  int _unique_s_item_110;
  @ffi.Uint32()
  int _unique_s_item_111;
  @ffi.Uint32()
  int _unique_s_item_112;
  @ffi.Uint32()
  int _unique_s_item_113;
  @ffi.Uint32()
  int _unique_s_item_114;
  @ffi.Uint32()
  int _unique_s_item_115;
  @ffi.Uint32()
  int _unique_s_item_116;
  @ffi.Uint32()
  int _unique_s_item_117;
  @ffi.Uint32()
  int _unique_s_item_118;
  @ffi.Uint32()
  int _unique_s_item_119;
  @ffi.Uint32()
  int _unique_s_item_120;
  @ffi.Uint32()
  int _unique_s_item_121;
  @ffi.Uint32()
  int _unique_s_item_122;
  @ffi.Uint32()
  int _unique_s_item_123;
  @ffi.Uint32()
  int _unique_s_item_124;
  @ffi.Uint32()
  int _unique_s_item_125;
  @ffi.Uint32()
  int _unique_s_item_126;
  @ffi.Uint32()
  int _unique_s_item_127;
  @ffi.Uint32()
  int _unique_s_item_128;
  @ffi.Uint32()
  int _unique_s_item_129;
  @ffi.Uint32()
  int _unique_s_item_130;
  @ffi.Uint32()
  int _unique_s_item_131;
  @ffi.Uint32()
  int _unique_s_item_132;
  @ffi.Uint32()
  int _unique_s_item_133;
  @ffi.Uint32()
  int _unique_s_item_134;
  @ffi.Uint32()
  int _unique_s_item_135;
  @ffi.Uint32()
  int _unique_s_item_136;
  @ffi.Uint32()
  int _unique_s_item_137;
  @ffi.Uint32()
  int _unique_s_item_138;
  @ffi.Uint32()
  int _unique_s_item_139;
  @ffi.Uint32()
  int _unique_s_item_140;
  @ffi.Uint32()
  int _unique_s_item_141;
  @ffi.Uint32()
  int _unique_s_item_142;
  @ffi.Uint32()
  int _unique_s_item_143;
  @ffi.Uint32()
  int _unique_s_item_144;
  @ffi.Uint32()
  int _unique_s_item_145;
  @ffi.Uint32()
  int _unique_s_item_146;
  @ffi.Uint32()
  int _unique_s_item_147;
  @ffi.Uint32()
  int _unique_s_item_148;
  @ffi.Uint32()
  int _unique_s_item_149;
  @ffi.Uint32()
  int _unique_s_item_150;
  @ffi.Uint32()
  int _unique_s_item_151;
  @ffi.Uint32()
  int _unique_s_item_152;
  @ffi.Uint32()
  int _unique_s_item_153;
  @ffi.Uint32()
  int _unique_s_item_154;
  @ffi.Uint32()
  int _unique_s_item_155;
  @ffi.Uint32()
  int _unique_s_item_156;
  @ffi.Uint32()
  int _unique_s_item_157;
  @ffi.Uint32()
  int _unique_s_item_158;
  @ffi.Uint32()
  int _unique_s_item_159;
  @ffi.Uint32()
  int _unique_s_item_160;
  @ffi.Uint32()
  int _unique_s_item_161;
  @ffi.Uint32()
  int _unique_s_item_162;
  @ffi.Uint32()
  int _unique_s_item_163;
  @ffi.Uint32()
  int _unique_s_item_164;
  @ffi.Uint32()
  int _unique_s_item_165;
  @ffi.Uint32()
  int _unique_s_item_166;
  @ffi.Uint32()
  int _unique_s_item_167;
  @ffi.Uint32()
  int _unique_s_item_168;
  @ffi.Uint32()
  int _unique_s_item_169;
  @ffi.Uint32()
  int _unique_s_item_170;
  @ffi.Uint32()
  int _unique_s_item_171;
  @ffi.Uint32()
  int _unique_s_item_172;
  @ffi.Uint32()
  int _unique_s_item_173;
  @ffi.Uint32()
  int _unique_s_item_174;
  @ffi.Uint32()
  int _unique_s_item_175;
  @ffi.Uint32()
  int _unique_s_item_176;
  @ffi.Uint32()
  int _unique_s_item_177;
  @ffi.Uint32()
  int _unique_s_item_178;
  @ffi.Uint32()
  int _unique_s_item_179;
  @ffi.Uint32()
  int _unique_s_item_180;
  @ffi.Uint32()
  int _unique_s_item_181;
  @ffi.Uint32()
  int _unique_s_item_182;
  @ffi.Uint32()
  int _unique_s_item_183;
  @ffi.Uint32()
  int _unique_s_item_184;
  @ffi.Uint32()
  int _unique_s_item_185;
  @ffi.Uint32()
  int _unique_s_item_186;
  @ffi.Uint32()
  int _unique_s_item_187;
  @ffi.Uint32()
  int _unique_s_item_188;
  @ffi.Uint32()
  int _unique_s_item_189;
  @ffi.Uint32()
  int _unique_s_item_190;
  @ffi.Uint32()
  int _unique_s_item_191;
  @ffi.Uint32()
  int _unique_s_item_192;
  @ffi.Uint32()
  int _unique_s_item_193;
  @ffi.Uint32()
  int _unique_s_item_194;
  @ffi.Uint32()
  int _unique_s_item_195;
  @ffi.Uint32()
  int _unique_s_item_196;
  @ffi.Uint32()
  int _unique_s_item_197;
  @ffi.Uint32()
  int _unique_s_item_198;
  @ffi.Uint32()
  int _unique_s_item_199;
  @ffi.Uint32()
  int _unique_s_item_200;
  @ffi.Uint32()
  int _unique_s_item_201;
  @ffi.Uint32()
  int _unique_s_item_202;
  @ffi.Uint32()
  int _unique_s_item_203;
  @ffi.Uint32()
  int _unique_s_item_204;
  @ffi.Uint32()
  int _unique_s_item_205;
  @ffi.Uint32()
  int _unique_s_item_206;
  @ffi.Uint32()
  int _unique_s_item_207;
  @ffi.Uint32()
  int _unique_s_item_208;
  @ffi.Uint32()
  int _unique_s_item_209;
  @ffi.Uint32()
  int _unique_s_item_210;
  @ffi.Uint32()
  int _unique_s_item_211;
  @ffi.Uint32()
  int _unique_s_item_212;
  @ffi.Uint32()
  int _unique_s_item_213;
  @ffi.Uint32()
  int _unique_s_item_214;
  @ffi.Uint32()
  int _unique_s_item_215;
  @ffi.Uint32()
  int _unique_s_item_216;
  @ffi.Uint32()
  int _unique_s_item_217;
  @ffi.Uint32()
  int _unique_s_item_218;
  @ffi.Uint32()
  int _unique_s_item_219;
  @ffi.Uint32()
  int _unique_s_item_220;
  @ffi.Uint32()
  int _unique_s_item_221;
  @ffi.Uint32()
  int _unique_s_item_222;
  @ffi.Uint32()
  int _unique_s_item_223;
  @ffi.Uint32()
  int _unique_s_item_224;
  @ffi.Uint32()
  int _unique_s_item_225;
  @ffi.Uint32()
  int _unique_s_item_226;
  @ffi.Uint32()
  int _unique_s_item_227;
  @ffi.Uint32()
  int _unique_s_item_228;
  @ffi.Uint32()
  int _unique_s_item_229;
  @ffi.Uint32()
  int _unique_s_item_230;
  @ffi.Uint32()
  int _unique_s_item_231;
  @ffi.Uint32()
  int _unique_s_item_232;
  @ffi.Uint32()
  int _unique_s_item_233;
  @ffi.Uint32()
  int _unique_s_item_234;
  @ffi.Uint32()
  int _unique_s_item_235;
  @ffi.Uint32()
  int _unique_s_item_236;
  @ffi.Uint32()
  int _unique_s_item_237;
  @ffi.Uint32()
  int _unique_s_item_238;
  @ffi.Uint32()
  int _unique_s_item_239;
  @ffi.Uint32()
  int _unique_s_item_240;
  @ffi.Uint32()
  int _unique_s_item_241;
  @ffi.Uint32()
  int _unique_s_item_242;
  @ffi.Uint32()
  int _unique_s_item_243;
  @ffi.Uint32()
  int _unique_s_item_244;
  @ffi.Uint32()
  int _unique_s_item_245;
  @ffi.Uint32()
  int _unique_s_item_246;
  @ffi.Uint32()
  int _unique_s_item_247;
  @ffi.Uint32()
  int _unique_s_item_248;
  @ffi.Uint32()
  int _unique_s_item_249;
  @ffi.Uint32()
  int _unique_s_item_250;
  @ffi.Uint32()
  int _unique_s_item_251;
  @ffi.Uint32()
  int _unique_s_item_252;
  @ffi.Uint32()
  int _unique_s_item_253;
  @ffi.Uint32()
  int _unique_s_item_254;
  @ffi.Uint32()
  int _unique_s_item_255;
  @ffi.Uint32()
  int _unique_s_item_256;
  @ffi.Uint32()
  int _unique_s_item_257;
  @ffi.Uint32()
  int _unique_s_item_258;
  @ffi.Uint32()
  int _unique_s_item_259;
  @ffi.Uint32()
  int _unique_s_item_260;
  @ffi.Uint32()
  int _unique_s_item_261;
  @ffi.Uint32()
  int _unique_s_item_262;
  @ffi.Uint32()
  int _unique_s_item_263;
  @ffi.Uint32()
  int _unique_s_item_264;
  @ffi.Uint32()
  int _unique_s_item_265;
  @ffi.Uint32()
  int _unique_s_item_266;
  @ffi.Uint32()
  int _unique_s_item_267;
  @ffi.Uint32()
  int _unique_s_item_268;
  @ffi.Uint32()
  int _unique_s_item_269;
  @ffi.Uint32()
  int _unique_s_item_270;
  @ffi.Uint32()
  int _unique_s_item_271;
  @ffi.Uint32()
  int _unique_s_item_272;
  @ffi.Uint32()
  int _unique_s_item_273;
  @ffi.Uint32()
  int _unique_s_item_274;
  @ffi.Uint32()
  int _unique_s_item_275;
  @ffi.Uint32()
  int _unique_s_item_276;
  @ffi.Uint32()
  int _unique_s_item_277;
  @ffi.Uint32()
  int _unique_s_item_278;
  @ffi.Uint32()
  int _unique_s_item_279;
  @ffi.Uint32()
  int _unique_s_item_280;
  @ffi.Uint32()
  int _unique_s_item_281;
  @ffi.Uint32()
  int _unique_s_item_282;
  @ffi.Uint32()
  int _unique_s_item_283;
  @ffi.Uint32()
  int _unique_s_item_284;
  @ffi.Uint32()
  int _unique_s_item_285;
  @ffi.Uint32()
  int _unique_s_item_286;
  @ffi.Uint32()
  int _unique_s_item_287;
  @ffi.Uint32()
  int _unique_s_item_288;
  @ffi.Uint32()
  int _unique_s_item_289;
  @ffi.Uint32()
  int _unique_s_item_290;
  @ffi.Uint32()
  int _unique_s_item_291;
  @ffi.Uint32()
  int _unique_s_item_292;
  @ffi.Uint32()
  int _unique_s_item_293;
  @ffi.Uint32()
  int _unique_s_item_294;
  @ffi.Uint32()
  int _unique_s_item_295;
  @ffi.Uint32()
  int _unique_s_item_296;
  @ffi.Uint32()
  int _unique_s_item_297;
  @ffi.Uint32()
  int _unique_s_item_298;
  @ffi.Uint32()
  int _unique_s_item_299;
  @ffi.Uint32()
  int _unique_s_item_300;
  @ffi.Uint32()
  int _unique_s_item_301;
  @ffi.Uint32()
  int _unique_s_item_302;
  @ffi.Uint32()
  int _unique_s_item_303;
  @ffi.Uint32()
  int _unique_s_item_304;
  @ffi.Uint32()
  int _unique_s_item_305;
  @ffi.Uint32()
  int _unique_s_item_306;
  @ffi.Uint32()
  int _unique_s_item_307;
  @ffi.Uint32()
  int _unique_s_item_308;
  @ffi.Uint32()
  int _unique_s_item_309;
  @ffi.Uint32()
  int _unique_s_item_310;
  @ffi.Uint32()
  int _unique_s_item_311;
  @ffi.Uint32()
  int _unique_s_item_312;
  @ffi.Uint32()
  int _unique_s_item_313;
  @ffi.Uint32()
  int _unique_s_item_314;
  @ffi.Uint32()
  int _unique_s_item_315;
  @ffi.Uint32()
  int _unique_s_item_316;
  @ffi.Uint32()
  int _unique_s_item_317;
  @ffi.Uint32()
  int _unique_s_item_318;
  @ffi.Uint32()
  int _unique_s_item_319;
  @ffi.Uint32()
  int _unique_s_item_320;
  @ffi.Uint32()
  int _unique_s_item_321;
  @ffi.Uint32()
  int _unique_s_item_322;
  @ffi.Uint32()
  int _unique_s_item_323;
  @ffi.Uint32()
  int _unique_s_item_324;
  @ffi.Uint32()
  int _unique_s_item_325;
  @ffi.Uint32()
  int _unique_s_item_326;
  @ffi.Uint32()
  int _unique_s_item_327;
  @ffi.Uint32()
  int _unique_s_item_328;
  @ffi.Uint32()
  int _unique_s_item_329;
  @ffi.Uint32()
  int _unique_s_item_330;
  @ffi.Uint32()
  int _unique_s_item_331;
  @ffi.Uint32()
  int _unique_s_item_332;
  @ffi.Uint32()
  int _unique_s_item_333;
  @ffi.Uint32()
  int _unique_s_item_334;
  @ffi.Uint32()
  int _unique_s_item_335;
  @ffi.Uint32()
  int _unique_s_item_336;
  @ffi.Uint32()
  int _unique_s_item_337;
  @ffi.Uint32()
  int _unique_s_item_338;
  @ffi.Uint32()
  int _unique_s_item_339;
  @ffi.Uint32()
  int _unique_s_item_340;
  @ffi.Uint32()
  int _unique_s_item_341;
  @ffi.Uint32()
  int _unique_s_item_342;
  @ffi.Uint32()
  int _unique_s_item_343;
  @ffi.Uint32()
  int _unique_s_item_344;
  @ffi.Uint32()
  int _unique_s_item_345;
  @ffi.Uint32()
  int _unique_s_item_346;
  @ffi.Uint32()
  int _unique_s_item_347;
  @ffi.Uint32()
  int _unique_s_item_348;
  @ffi.Uint32()
  int _unique_s_item_349;
  @ffi.Uint32()
  int _unique_s_item_350;
  @ffi.Uint32()
  int _unique_s_item_351;
  @ffi.Uint32()
  int _unique_s_item_352;
  @ffi.Uint32()
  int _unique_s_item_353;
  @ffi.Uint32()
  int _unique_s_item_354;
  @ffi.Uint32()
  int _unique_s_item_355;
  @ffi.Uint32()
  int _unique_s_item_356;
  @ffi.Uint32()
  int _unique_s_item_357;
  @ffi.Uint32()
  int _unique_s_item_358;
  @ffi.Uint32()
  int _unique_s_item_359;
  @ffi.Uint32()
  int _unique_s_item_360;
  @ffi.Uint32()
  int _unique_s_item_361;
  @ffi.Uint32()
  int _unique_s_item_362;
  @ffi.Uint32()
  int _unique_s_item_363;
  @ffi.Uint32()
  int _unique_s_item_364;
  @ffi.Uint32()
  int _unique_s_item_365;
  @ffi.Uint32()
  int _unique_s_item_366;
  @ffi.Uint32()
  int _unique_s_item_367;
  @ffi.Uint32()
  int _unique_s_item_368;
  @ffi.Uint32()
  int _unique_s_item_369;
  @ffi.Uint32()
  int _unique_s_item_370;
  @ffi.Uint32()
  int _unique_s_item_371;
  @ffi.Uint32()
  int _unique_s_item_372;
  @ffi.Uint32()
  int _unique_s_item_373;
  @ffi.Uint32()
  int _unique_s_item_374;
  @ffi.Uint32()
  int _unique_s_item_375;
  @ffi.Uint32()
  int _unique_s_item_376;
  @ffi.Uint32()
  int _unique_s_item_377;
  @ffi.Uint32()
  int _unique_s_item_378;
  @ffi.Uint32()
  int _unique_s_item_379;
  @ffi.Uint32()
  int _unique_s_item_380;
  @ffi.Uint32()
  int _unique_s_item_381;
  @ffi.Uint32()
  int _unique_s_item_382;
  @ffi.Uint32()
  int _unique_s_item_383;
  @ffi.Uint32()
  int _unique_s_item_384;
  @ffi.Uint32()
  int _unique_s_item_385;
  @ffi.Uint32()
  int _unique_s_item_386;
  @ffi.Uint32()
  int _unique_s_item_387;
  @ffi.Uint32()
  int _unique_s_item_388;
  @ffi.Uint32()
  int _unique_s_item_389;
  @ffi.Uint32()
  int _unique_s_item_390;
  @ffi.Uint32()
  int _unique_s_item_391;
  @ffi.Uint32()
  int _unique_s_item_392;
  @ffi.Uint32()
  int _unique_s_item_393;
  @ffi.Uint32()
  int _unique_s_item_394;
  @ffi.Uint32()
  int _unique_s_item_395;
  @ffi.Uint32()
  int _unique_s_item_396;
  @ffi.Uint32()
  int _unique_s_item_397;
  @ffi.Uint32()
  int _unique_s_item_398;
  @ffi.Uint32()
  int _unique_s_item_399;
  @ffi.Uint32()
  int _unique_s_item_400;
  @ffi.Uint32()
  int _unique_s_item_401;
  @ffi.Uint32()
  int _unique_s_item_402;
  @ffi.Uint32()
  int _unique_s_item_403;
  @ffi.Uint32()
  int _unique_s_item_404;
  @ffi.Uint32()
  int _unique_s_item_405;
  @ffi.Uint32()
  int _unique_s_item_406;
  @ffi.Uint32()
  int _unique_s_item_407;
  @ffi.Uint32()
  int _unique_s_item_408;
  @ffi.Uint32()
  int _unique_s_item_409;
  @ffi.Uint32()
  int _unique_s_item_410;
  @ffi.Uint32()
  int _unique_s_item_411;
  @ffi.Uint32()
  int _unique_s_item_412;
  @ffi.Uint32()
  int _unique_s_item_413;
  @ffi.Uint32()
  int _unique_s_item_414;
  @ffi.Uint32()
  int _unique_s_item_415;
  @ffi.Uint32()
  int _unique_s_item_416;
  @ffi.Uint32()
  int _unique_s_item_417;
  @ffi.Uint32()
  int _unique_s_item_418;
  @ffi.Uint32()
  int _unique_s_item_419;
  @ffi.Uint32()
  int _unique_s_item_420;
  @ffi.Uint32()
  int _unique_s_item_421;
  @ffi.Uint32()
  int _unique_s_item_422;
  @ffi.Uint32()
  int _unique_s_item_423;
  @ffi.Uint32()
  int _unique_s_item_424;
  @ffi.Uint32()
  int _unique_s_item_425;
  @ffi.Uint32()
  int _unique_s_item_426;
  @ffi.Uint32()
  int _unique_s_item_427;
  @ffi.Uint32()
  int _unique_s_item_428;
  @ffi.Uint32()
  int _unique_s_item_429;
  @ffi.Uint32()
  int _unique_s_item_430;
  @ffi.Uint32()
  int _unique_s_item_431;
  @ffi.Uint32()
  int _unique_s_item_432;
  @ffi.Uint32()
  int _unique_s_item_433;
  @ffi.Uint32()
  int _unique_s_item_434;
  @ffi.Uint32()
  int _unique_s_item_435;
  @ffi.Uint32()
  int _unique_s_item_436;
  @ffi.Uint32()
  int _unique_s_item_437;
  @ffi.Uint32()
  int _unique_s_item_438;
  @ffi.Uint32()
  int _unique_s_item_439;
  @ffi.Uint32()
  int _unique_s_item_440;
  @ffi.Uint32()
  int _unique_s_item_441;
  @ffi.Uint32()
  int _unique_s_item_442;
  @ffi.Uint32()
  int _unique_s_item_443;
  @ffi.Uint32()
  int _unique_s_item_444;
  @ffi.Uint32()
  int _unique_s_item_445;
  @ffi.Uint32()
  int _unique_s_item_446;
  @ffi.Uint32()
  int _unique_s_item_447;
  @ffi.Uint32()
  int _unique_s_item_448;
  @ffi.Uint32()
  int _unique_s_item_449;
  @ffi.Uint32()
  int _unique_s_item_450;
  @ffi.Uint32()
  int _unique_s_item_451;
  @ffi.Uint32()
  int _unique_s_item_452;
  @ffi.Uint32()
  int _unique_s_item_453;
  @ffi.Uint32()
  int _unique_s_item_454;
  @ffi.Uint32()
  int _unique_s_item_455;
  @ffi.Uint32()
  int _unique_s_item_456;
  @ffi.Uint32()
  int _unique_s_item_457;
  @ffi.Uint32()
  int _unique_s_item_458;
  @ffi.Uint32()
  int _unique_s_item_459;
  @ffi.Uint32()
  int _unique_s_item_460;
  @ffi.Uint32()
  int _unique_s_item_461;
  @ffi.Uint32()
  int _unique_s_item_462;
  @ffi.Uint32()
  int _unique_s_item_463;
  @ffi.Uint32()
  int _unique_s_item_464;
  @ffi.Uint32()
  int _unique_s_item_465;
  @ffi.Uint32()
  int _unique_s_item_466;
  @ffi.Uint32()
  int _unique_s_item_467;
  @ffi.Uint32()
  int _unique_s_item_468;
  @ffi.Uint32()
  int _unique_s_item_469;
  @ffi.Uint32()
  int _unique_s_item_470;
  @ffi.Uint32()
  int _unique_s_item_471;
  @ffi.Uint32()
  int _unique_s_item_472;
  @ffi.Uint32()
  int _unique_s_item_473;
  @ffi.Uint32()
  int _unique_s_item_474;
  @ffi.Uint32()
  int _unique_s_item_475;
  @ffi.Uint32()
  int _unique_s_item_476;
  @ffi.Uint32()
  int _unique_s_item_477;
  @ffi.Uint32()
  int _unique_s_item_478;
  @ffi.Uint32()
  int _unique_s_item_479;
  @ffi.Uint32()
  int _unique_s_item_480;
  @ffi.Uint32()
  int _unique_s_item_481;
  @ffi.Uint32()
  int _unique_s_item_482;
  @ffi.Uint32()
  int _unique_s_item_483;
  @ffi.Uint32()
  int _unique_s_item_484;
  @ffi.Uint32()
  int _unique_s_item_485;
  @ffi.Uint32()
  int _unique_s_item_486;
  @ffi.Uint32()
  int _unique_s_item_487;
  @ffi.Uint32()
  int _unique_s_item_488;
  @ffi.Uint32()
  int _unique_s_item_489;
  @ffi.Uint32()
  int _unique_s_item_490;
  @ffi.Uint32()
  int _unique_s_item_491;
  @ffi.Uint32()
  int _unique_s_item_492;
  @ffi.Uint32()
  int _unique_s_item_493;
  @ffi.Uint32()
  int _unique_s_item_494;
  @ffi.Uint32()
  int _unique_s_item_495;
  @ffi.Uint32()
  int _unique_s_item_496;
  @ffi.Uint32()
  int _unique_s_item_497;
  @ffi.Uint32()
  int _unique_s_item_498;
  @ffi.Uint32()
  int _unique_s_item_499;
  @ffi.Uint32()
  int _unique_s_item_500;
  @ffi.Uint32()
  int _unique_s_item_501;
  @ffi.Uint32()
  int _unique_s_item_502;
  @ffi.Uint32()
  int _unique_s_item_503;
  @ffi.Uint32()
  int _unique_s_item_504;
  @ffi.Uint32()
  int _unique_s_item_505;
  @ffi.Uint32()
  int _unique_s_item_506;
  @ffi.Uint32()
  int _unique_s_item_507;
  @ffi.Uint32()
  int _unique_s_item_508;
  @ffi.Uint32()
  int _unique_s_item_509;
  @ffi.Uint32()
  int _unique_s_item_510;
  @ffi.Uint32()
  int _unique_s_item_511;
  @ffi.Uint32()
  int _unique_s_item_512;
  @ffi.Uint32()
  int _unique_s_item_513;
  @ffi.Uint32()
  int _unique_s_item_514;
  @ffi.Uint32()
  int _unique_s_item_515;
  @ffi.Uint32()
  int _unique_s_item_516;
  @ffi.Uint32()
  int _unique_s_item_517;
  @ffi.Uint32()
  int _unique_s_item_518;
  @ffi.Uint32()
  int _unique_s_item_519;
  @ffi.Uint32()
  int _unique_s_item_520;
  @ffi.Uint32()
  int _unique_s_item_521;
  @ffi.Uint32()
  int _unique_s_item_522;
  @ffi.Uint32()
  int _unique_s_item_523;
  @ffi.Uint32()
  int _unique_s_item_524;
  @ffi.Uint32()
  int _unique_s_item_525;
  @ffi.Uint32()
  int _unique_s_item_526;
  @ffi.Uint32()
  int _unique_s_item_527;
  @ffi.Uint32()
  int _unique_s_item_528;
  @ffi.Uint32()
  int _unique_s_item_529;
  @ffi.Uint32()
  int _unique_s_item_530;
  @ffi.Uint32()
  int _unique_s_item_531;
  @ffi.Uint32()
  int _unique_s_item_532;
  @ffi.Uint32()
  int _unique_s_item_533;
  @ffi.Uint32()
  int _unique_s_item_534;
  @ffi.Uint32()
  int _unique_s_item_535;
  @ffi.Uint32()
  int _unique_s_item_536;
  @ffi.Uint32()
  int _unique_s_item_537;
  @ffi.Uint32()
  int _unique_s_item_538;
  @ffi.Uint32()
  int _unique_s_item_539;
  @ffi.Uint32()
  int _unique_s_item_540;
  @ffi.Uint32()
  int _unique_s_item_541;
  @ffi.Uint32()
  int _unique_s_item_542;
  @ffi.Uint32()
  int _unique_s_item_543;
  @ffi.Uint32()
  int _unique_s_item_544;
  @ffi.Uint32()
  int _unique_s_item_545;
  @ffi.Uint32()
  int _unique_s_item_546;
  @ffi.Uint32()
  int _unique_s_item_547;
  @ffi.Uint32()
  int _unique_s_item_548;
  @ffi.Uint32()
  int _unique_s_item_549;
  @ffi.Uint32()
  int _unique_s_item_550;
  @ffi.Uint32()
  int _unique_s_item_551;
  @ffi.Uint32()
  int _unique_s_item_552;
  @ffi.Uint32()
  int _unique_s_item_553;
  @ffi.Uint32()
  int _unique_s_item_554;
  @ffi.Uint32()
  int _unique_s_item_555;
  @ffi.Uint32()
  int _unique_s_item_556;
  @ffi.Uint32()
  int _unique_s_item_557;
  @ffi.Uint32()
  int _unique_s_item_558;
  @ffi.Uint32()
  int _unique_s_item_559;
  @ffi.Uint32()
  int _unique_s_item_560;
  @ffi.Uint32()
  int _unique_s_item_561;
  @ffi.Uint32()
  int _unique_s_item_562;
  @ffi.Uint32()
  int _unique_s_item_563;
  @ffi.Uint32()
  int _unique_s_item_564;
  @ffi.Uint32()
  int _unique_s_item_565;
  @ffi.Uint32()
  int _unique_s_item_566;
  @ffi.Uint32()
  int _unique_s_item_567;
  @ffi.Uint32()
  int _unique_s_item_568;
  @ffi.Uint32()
  int _unique_s_item_569;
  @ffi.Uint32()
  int _unique_s_item_570;
  @ffi.Uint32()
  int _unique_s_item_571;
  @ffi.Uint32()
  int _unique_s_item_572;
  @ffi.Uint32()
  int _unique_s_item_573;
  @ffi.Uint32()
  int _unique_s_item_574;
  @ffi.Uint32()
  int _unique_s_item_575;
  @ffi.Uint32()
  int _unique_s_item_576;
  @ffi.Uint32()
  int _unique_s_item_577;
  @ffi.Uint32()
  int _unique_s_item_578;
  @ffi.Uint32()
  int _unique_s_item_579;
  @ffi.Uint32()
  int _unique_s_item_580;
  @ffi.Uint32()
  int _unique_s_item_581;
  @ffi.Uint32()
  int _unique_s_item_582;
  @ffi.Uint32()
  int _unique_s_item_583;
  @ffi.Uint32()
  int _unique_s_item_584;
  @ffi.Uint32()
  int _unique_s_item_585;
  @ffi.Uint32()
  int _unique_s_item_586;
  @ffi.Uint32()
  int _unique_s_item_587;
  @ffi.Uint32()
  int _unique_s_item_588;
  @ffi.Uint32()
  int _unique_s_item_589;
  @ffi.Uint32()
  int _unique_s_item_590;
  @ffi.Uint32()
  int _unique_s_item_591;
  @ffi.Uint32()
  int _unique_s_item_592;
  @ffi.Uint32()
  int _unique_s_item_593;
  @ffi.Uint32()
  int _unique_s_item_594;
  @ffi.Uint32()
  int _unique_s_item_595;
  @ffi.Uint32()
  int _unique_s_item_596;
  @ffi.Uint32()
  int _unique_s_item_597;
  @ffi.Uint32()
  int _unique_s_item_598;
  @ffi.Uint32()
  int _unique_s_item_599;
  @ffi.Uint32()
  int _unique_s_item_600;
  @ffi.Uint32()
  int _unique_s_item_601;
  @ffi.Uint32()
  int _unique_s_item_602;
  @ffi.Uint32()
  int _unique_s_item_603;
  @ffi.Uint32()
  int _unique_s_item_604;
  @ffi.Uint32()
  int _unique_s_item_605;
  @ffi.Uint32()
  int _unique_s_item_606;
  @ffi.Uint32()
  int _unique_s_item_607;
  @ffi.Uint32()
  int _unique_s_item_608;
  @ffi.Uint32()
  int _unique_s_item_609;
  @ffi.Uint32()
  int _unique_s_item_610;
  @ffi.Uint32()
  int _unique_s_item_611;
  @ffi.Uint32()
  int _unique_s_item_612;
  @ffi.Uint32()
  int _unique_s_item_613;
  @ffi.Uint32()
  int _unique_s_item_614;
  @ffi.Uint32()
  int _unique_s_item_615;
  @ffi.Uint32()
  int _unique_s_item_616;
  @ffi.Uint32()
  int _unique_s_item_617;
  @ffi.Uint32()
  int _unique_s_item_618;
  @ffi.Uint32()
  int _unique_s_item_619;
  @ffi.Uint32()
  int _unique_s_item_620;
  @ffi.Uint32()
  int _unique_s_item_621;
  @ffi.Uint32()
  int _unique_s_item_622;
  @ffi.Uint32()
  int _unique_s_item_623;
  @ffi.Uint32()
  int _unique_s_item_624;
  @ffi.Uint32()
  int _unique_s_item_625;
  @ffi.Uint32()
  int _unique_s_item_626;
  @ffi.Uint32()
  int _unique_s_item_627;
  @ffi.Uint32()
  int _unique_s_item_628;
  @ffi.Uint32()
  int _unique_s_item_629;
  @ffi.Uint32()
  int _unique_s_item_630;
  @ffi.Uint32()
  int _unique_s_item_631;
  @ffi.Uint32()
  int _unique_s_item_632;
  @ffi.Uint32()
  int _unique_s_item_633;
  @ffi.Uint32()
  int _unique_s_item_634;
  @ffi.Uint32()
  int _unique_s_item_635;
  @ffi.Uint32()
  int _unique_s_item_636;
  @ffi.Uint32()
  int _unique_s_item_637;
  @ffi.Uint32()
  int _unique_s_item_638;
  @ffi.Uint32()
  int _unique_s_item_639;
  @ffi.Uint32()
  int _unique_s_item_640;
  @ffi.Uint32()
  int _unique_s_item_641;
  @ffi.Uint32()
  int _unique_s_item_642;
  @ffi.Uint32()
  int _unique_s_item_643;
  @ffi.Uint32()
  int _unique_s_item_644;
  @ffi.Uint32()
  int _unique_s_item_645;
  @ffi.Uint32()
  int _unique_s_item_646;
  @ffi.Uint32()
  int _unique_s_item_647;
  @ffi.Uint32()
  int _unique_s_item_648;
  @ffi.Uint32()
  int _unique_s_item_649;
  @ffi.Uint32()
  int _unique_s_item_650;
  @ffi.Uint32()
  int _unique_s_item_651;
  @ffi.Uint32()
  int _unique_s_item_652;
  @ffi.Uint32()
  int _unique_s_item_653;
  @ffi.Uint32()
  int _unique_s_item_654;
  @ffi.Uint32()
  int _unique_s_item_655;
  @ffi.Uint32()
  int _unique_s_item_656;
  @ffi.Uint32()
  int _unique_s_item_657;
  @ffi.Uint32()
  int _unique_s_item_658;
  @ffi.Uint32()
  int _unique_s_item_659;
  @ffi.Uint32()
  int _unique_s_item_660;
  @ffi.Uint32()
  int _unique_s_item_661;
  @ffi.Uint32()
  int _unique_s_item_662;
  @ffi.Uint32()
  int _unique_s_item_663;
  @ffi.Uint32()
  int _unique_s_item_664;
  @ffi.Uint32()
  int _unique_s_item_665;
  @ffi.Uint32()
  int _unique_s_item_666;
  @ffi.Uint32()
  int _unique_s_item_667;
  @ffi.Uint32()
  int _unique_s_item_668;
  @ffi.Uint32()
  int _unique_s_item_669;
  @ffi.Uint32()
  int _unique_s_item_670;
  @ffi.Uint32()
  int _unique_s_item_671;
  @ffi.Uint32()
  int _unique_s_item_672;
  @ffi.Uint32()
  int _unique_s_item_673;
  @ffi.Uint32()
  int _unique_s_item_674;
  @ffi.Uint32()
  int _unique_s_item_675;
  @ffi.Uint32()
  int _unique_s_item_676;
  @ffi.Uint32()
  int _unique_s_item_677;
  @ffi.Uint32()
  int _unique_s_item_678;
  @ffi.Uint32()
  int _unique_s_item_679;
  @ffi.Uint32()
  int _unique_s_item_680;
  @ffi.Uint32()
  int _unique_s_item_681;
  @ffi.Uint32()
  int _unique_s_item_682;
  @ffi.Uint32()
  int _unique_s_item_683;
  @ffi.Uint32()
  int _unique_s_item_684;
  @ffi.Uint32()
  int _unique_s_item_685;
  @ffi.Uint32()
  int _unique_s_item_686;
  @ffi.Uint32()
  int _unique_s_item_687;
  @ffi.Uint32()
  int _unique_s_item_688;
  @ffi.Uint32()
  int _unique_s_item_689;
  @ffi.Uint32()
  int _unique_s_item_690;
  @ffi.Uint32()
  int _unique_s_item_691;
  @ffi.Uint32()
  int _unique_s_item_692;
  @ffi.Uint32()
  int _unique_s_item_693;
  @ffi.Uint32()
  int _unique_s_item_694;
  @ffi.Uint32()
  int _unique_s_item_695;
  @ffi.Uint32()
  int _unique_s_item_696;
  @ffi.Uint32()
  int _unique_s_item_697;
  @ffi.Uint32()
  int _unique_s_item_698;
  @ffi.Uint32()
  int _unique_s_item_699;
  @ffi.Uint32()
  int _unique_s_item_700;
  @ffi.Uint32()
  int _unique_s_item_701;
  @ffi.Uint32()
  int _unique_s_item_702;
  @ffi.Uint32()
  int _unique_s_item_703;
  @ffi.Uint32()
  int _unique_s_item_704;
  @ffi.Uint32()
  int _unique_s_item_705;
  @ffi.Uint32()
  int _unique_s_item_706;
  @ffi.Uint32()
  int _unique_s_item_707;
  @ffi.Uint32()
  int _unique_s_item_708;
  @ffi.Uint32()
  int _unique_s_item_709;
  @ffi.Uint32()
  int _unique_s_item_710;
  @ffi.Uint32()
  int _unique_s_item_711;
  @ffi.Uint32()
  int _unique_s_item_712;
  @ffi.Uint32()
  int _unique_s_item_713;
  @ffi.Uint32()
  int _unique_s_item_714;
  @ffi.Uint32()
  int _unique_s_item_715;
  @ffi.Uint32()
  int _unique_s_item_716;
  @ffi.Uint32()
  int _unique_s_item_717;
  @ffi.Uint32()
  int _unique_s_item_718;
  @ffi.Uint32()
  int _unique_s_item_719;
  @ffi.Uint32()
  int _unique_s_item_720;
  @ffi.Uint32()
  int _unique_s_item_721;
  @ffi.Uint32()
  int _unique_s_item_722;
  @ffi.Uint32()
  int _unique_s_item_723;
  @ffi.Uint32()
  int _unique_s_item_724;
  @ffi.Uint32()
  int _unique_s_item_725;
  @ffi.Uint32()
  int _unique_s_item_726;
  @ffi.Uint32()
  int _unique_s_item_727;
  @ffi.Uint32()
  int _unique_s_item_728;
  @ffi.Uint32()
  int _unique_s_item_729;
  @ffi.Uint32()
  int _unique_s_item_730;
  @ffi.Uint32()
  int _unique_s_item_731;
  @ffi.Uint32()
  int _unique_s_item_732;
  @ffi.Uint32()
  int _unique_s_item_733;
  @ffi.Uint32()
  int _unique_s_item_734;
  @ffi.Uint32()
  int _unique_s_item_735;
  @ffi.Uint32()
  int _unique_s_item_736;
  @ffi.Uint32()
  int _unique_s_item_737;
  @ffi.Uint32()
  int _unique_s_item_738;
  @ffi.Uint32()
  int _unique_s_item_739;
  @ffi.Uint32()
  int _unique_s_item_740;
  @ffi.Uint32()
  int _unique_s_item_741;
  @ffi.Uint32()
  int _unique_s_item_742;
  @ffi.Uint32()
  int _unique_s_item_743;
  @ffi.Uint32()
  int _unique_s_item_744;
  @ffi.Uint32()
  int _unique_s_item_745;
  @ffi.Uint32()
  int _unique_s_item_746;
  @ffi.Uint32()
  int _unique_s_item_747;
  @ffi.Uint32()
  int _unique_s_item_748;
  @ffi.Uint32()
  int _unique_s_item_749;
  @ffi.Uint32()
  int _unique_s_item_750;
  @ffi.Uint32()
  int _unique_s_item_751;
  @ffi.Uint32()
  int _unique_s_item_752;
  @ffi.Uint32()
  int _unique_s_item_753;
  @ffi.Uint32()
  int _unique_s_item_754;
  @ffi.Uint32()
  int _unique_s_item_755;
  @ffi.Uint32()
  int _unique_s_item_756;
  @ffi.Uint32()
  int _unique_s_item_757;
  @ffi.Uint32()
  int _unique_s_item_758;
  @ffi.Uint32()
  int _unique_s_item_759;
  @ffi.Uint32()
  int _unique_s_item_760;
  @ffi.Uint32()
  int _unique_s_item_761;
  @ffi.Uint32()
  int _unique_s_item_762;
  @ffi.Uint32()
  int _unique_s_item_763;
  @ffi.Uint32()
  int _unique_s_item_764;
  @ffi.Uint32()
  int _unique_s_item_765;
  @ffi.Uint32()
  int _unique_s_item_766;
  @ffi.Uint32()
  int _unique_s_item_767;
  @ffi.Uint32()
  int _unique_s_item_768;
  @ffi.Uint32()
  int _unique_s_item_769;
  @ffi.Uint32()
  int _unique_s_item_770;
  @ffi.Uint32()
  int _unique_s_item_771;
  @ffi.Uint32()
  int _unique_s_item_772;
  @ffi.Uint32()
  int _unique_s_item_773;
  @ffi.Uint32()
  int _unique_s_item_774;
  @ffi.Uint32()
  int _unique_s_item_775;
  @ffi.Uint32()
  int _unique_s_item_776;
  @ffi.Uint32()
  int _unique_s_item_777;
  @ffi.Uint32()
  int _unique_s_item_778;
  @ffi.Uint32()
  int _unique_s_item_779;
  @ffi.Uint32()
  int _unique_s_item_780;
  @ffi.Uint32()
  int _unique_s_item_781;
  @ffi.Uint32()
  int _unique_s_item_782;
  @ffi.Uint32()
  int _unique_s_item_783;
  @ffi.Uint32()
  int _unique_s_item_784;
  @ffi.Uint32()
  int _unique_s_item_785;
  @ffi.Uint32()
  int _unique_s_item_786;
  @ffi.Uint32()
  int _unique_s_item_787;
  @ffi.Uint32()
  int _unique_s_item_788;
  @ffi.Uint32()
  int _unique_s_item_789;
  @ffi.Uint32()
  int _unique_s_item_790;
  @ffi.Uint32()
  int _unique_s_item_791;
  @ffi.Uint32()
  int _unique_s_item_792;
  @ffi.Uint32()
  int _unique_s_item_793;
  @ffi.Uint32()
  int _unique_s_item_794;
  @ffi.Uint32()
  int _unique_s_item_795;
  @ffi.Uint32()
  int _unique_s_item_796;
  @ffi.Uint32()
  int _unique_s_item_797;
  @ffi.Uint32()
  int _unique_s_item_798;
  @ffi.Uint32()
  int _unique_s_item_799;
  @ffi.Uint32()
  int _unique_s_item_800;
  @ffi.Uint32()
  int _unique_s_item_801;
  @ffi.Uint32()
  int _unique_s_item_802;
  @ffi.Uint32()
  int _unique_s_item_803;
  @ffi.Uint32()
  int _unique_s_item_804;
  @ffi.Uint32()
  int _unique_s_item_805;
  @ffi.Uint32()
  int _unique_s_item_806;
  @ffi.Uint32()
  int _unique_s_item_807;
  @ffi.Uint32()
  int _unique_s_item_808;
  @ffi.Uint32()
  int _unique_s_item_809;
  @ffi.Uint32()
  int _unique_s_item_810;
  @ffi.Uint32()
  int _unique_s_item_811;
  @ffi.Uint32()
  int _unique_s_item_812;
  @ffi.Uint32()
  int _unique_s_item_813;
  @ffi.Uint32()
  int _unique_s_item_814;
  @ffi.Uint32()
  int _unique_s_item_815;
  @ffi.Uint32()
  int _unique_s_item_816;
  @ffi.Uint32()
  int _unique_s_item_817;
  @ffi.Uint32()
  int _unique_s_item_818;
  @ffi.Uint32()
  int _unique_s_item_819;
  @ffi.Uint32()
  int _unique_s_item_820;
  @ffi.Uint32()
  int _unique_s_item_821;
  @ffi.Uint32()
  int _unique_s_item_822;
  @ffi.Uint32()
  int _unique_s_item_823;
  @ffi.Uint32()
  int _unique_s_item_824;
  @ffi.Uint32()
  int _unique_s_item_825;
  @ffi.Uint32()
  int _unique_s_item_826;
  @ffi.Uint32()
  int _unique_s_item_827;
  @ffi.Uint32()
  int _unique_s_item_828;
  @ffi.Uint32()
  int _unique_s_item_829;
  @ffi.Uint32()
  int _unique_s_item_830;
  @ffi.Uint32()
  int _unique_s_item_831;
  @ffi.Uint32()
  int _unique_s_item_832;
  @ffi.Uint32()
  int _unique_s_item_833;
  @ffi.Uint32()
  int _unique_s_item_834;
  @ffi.Uint32()
  int _unique_s_item_835;
  @ffi.Uint32()
  int _unique_s_item_836;
  @ffi.Uint32()
  int _unique_s_item_837;
  @ffi.Uint32()
  int _unique_s_item_838;
  @ffi.Uint32()
  int _unique_s_item_839;
  @ffi.Uint32()
  int _unique_s_item_840;
  @ffi.Uint32()
  int _unique_s_item_841;
  @ffi.Uint32()
  int _unique_s_item_842;
  @ffi.Uint32()
  int _unique_s_item_843;
  @ffi.Uint32()
  int _unique_s_item_844;
  @ffi.Uint32()
  int _unique_s_item_845;
  @ffi.Uint32()
  int _unique_s_item_846;
  @ffi.Uint32()
  int _unique_s_item_847;
  @ffi.Uint32()
  int _unique_s_item_848;
  @ffi.Uint32()
  int _unique_s_item_849;
  @ffi.Uint32()
  int _unique_s_item_850;
  @ffi.Uint32()
  int _unique_s_item_851;
  @ffi.Uint32()
  int _unique_s_item_852;
  @ffi.Uint32()
  int _unique_s_item_853;
  @ffi.Uint32()
  int _unique_s_item_854;
  @ffi.Uint32()
  int _unique_s_item_855;
  @ffi.Uint32()
  int _unique_s_item_856;
  @ffi.Uint32()
  int _unique_s_item_857;
  @ffi.Uint32()
  int _unique_s_item_858;
  @ffi.Uint32()
  int _unique_s_item_859;
  @ffi.Uint32()
  int _unique_s_item_860;
  @ffi.Uint32()
  int _unique_s_item_861;
  @ffi.Uint32()
  int _unique_s_item_862;
  @ffi.Uint32()
  int _unique_s_item_863;
  @ffi.Uint32()
  int _unique_s_item_864;
  @ffi.Uint32()
  int _unique_s_item_865;
  @ffi.Uint32()
  int _unique_s_item_866;
  @ffi.Uint32()
  int _unique_s_item_867;
  @ffi.Uint32()
  int _unique_s_item_868;
  @ffi.Uint32()
  int _unique_s_item_869;
  @ffi.Uint32()
  int _unique_s_item_870;
  @ffi.Uint32()
  int _unique_s_item_871;
  @ffi.Uint32()
  int _unique_s_item_872;
  @ffi.Uint32()
  int _unique_s_item_873;
  @ffi.Uint32()
  int _unique_s_item_874;
  @ffi.Uint32()
  int _unique_s_item_875;
  @ffi.Uint32()
  int _unique_s_item_876;
  @ffi.Uint32()
  int _unique_s_item_877;
  @ffi.Uint32()
  int _unique_s_item_878;
  @ffi.Uint32()
  int _unique_s_item_879;
  @ffi.Uint32()
  int _unique_s_item_880;
  @ffi.Uint32()
  int _unique_s_item_881;
  @ffi.Uint32()
  int _unique_s_item_882;
  @ffi.Uint32()
  int _unique_s_item_883;
  @ffi.Uint32()
  int _unique_s_item_884;
  @ffi.Uint32()
  int _unique_s_item_885;
  @ffi.Uint32()
  int _unique_s_item_886;
  @ffi.Uint32()
  int _unique_s_item_887;
  @ffi.Uint32()
  int _unique_s_item_888;
  @ffi.Uint32()
  int _unique_s_item_889;
  @ffi.Uint32()
  int _unique_s_item_890;
  @ffi.Uint32()
  int _unique_s_item_891;
  @ffi.Uint32()
  int _unique_s_item_892;
  @ffi.Uint32()
  int _unique_s_item_893;
  @ffi.Uint32()
  int _unique_s_item_894;
  @ffi.Uint32()
  int _unique_s_item_895;
  @ffi.Uint32()
  int _unique_s_item_896;
  @ffi.Uint32()
  int _unique_s_item_897;
  @ffi.Uint32()
  int _unique_s_item_898;
  @ffi.Uint32()
  int _unique_s_item_899;
  @ffi.Uint32()
  int _unique_s_item_900;
  @ffi.Uint32()
  int _unique_s_item_901;
  @ffi.Uint32()
  int _unique_s_item_902;
  @ffi.Uint32()
  int _unique_s_item_903;
  @ffi.Uint32()
  int _unique_s_item_904;
  @ffi.Uint32()
  int _unique_s_item_905;
  @ffi.Uint32()
  int _unique_s_item_906;
  @ffi.Uint32()
  int _unique_s_item_907;
  @ffi.Uint32()
  int _unique_s_item_908;
  @ffi.Uint32()
  int _unique_s_item_909;
  @ffi.Uint32()
  int _unique_s_item_910;
  @ffi.Uint32()
  int _unique_s_item_911;
  @ffi.Uint32()
  int _unique_s_item_912;
  @ffi.Uint32()
  int _unique_s_item_913;
  @ffi.Uint32()
  int _unique_s_item_914;
  @ffi.Uint32()
  int _unique_s_item_915;
  @ffi.Uint32()
  int _unique_s_item_916;
  @ffi.Uint32()
  int _unique_s_item_917;
  @ffi.Uint32()
  int _unique_s_item_918;
  @ffi.Uint32()
  int _unique_s_item_919;
  @ffi.Uint32()
  int _unique_s_item_920;
  @ffi.Uint32()
  int _unique_s_item_921;
  @ffi.Uint32()
  int _unique_s_item_922;
  @ffi.Uint32()
  int _unique_s_item_923;
  @ffi.Uint32()
  int _unique_s_item_924;
  @ffi.Uint32()
  int _unique_s_item_925;
  @ffi.Uint32()
  int _unique_s_item_926;
  @ffi.Uint32()
  int _unique_s_item_927;
  @ffi.Uint32()
  int _unique_s_item_928;
  @ffi.Uint32()
  int _unique_s_item_929;
  @ffi.Uint32()
  int _unique_s_item_930;
  @ffi.Uint32()
  int _unique_s_item_931;
  @ffi.Uint32()
  int _unique_s_item_932;
  @ffi.Uint32()
  int _unique_s_item_933;
  @ffi.Uint32()
  int _unique_s_item_934;
  @ffi.Uint32()
  int _unique_s_item_935;
  @ffi.Uint32()
  int _unique_s_item_936;
  @ffi.Uint32()
  int _unique_s_item_937;
  @ffi.Uint32()
  int _unique_s_item_938;
  @ffi.Uint32()
  int _unique_s_item_939;
  @ffi.Uint32()
  int _unique_s_item_940;
  @ffi.Uint32()
  int _unique_s_item_941;
  @ffi.Uint32()
  int _unique_s_item_942;
  @ffi.Uint32()
  int _unique_s_item_943;
  @ffi.Uint32()
  int _unique_s_item_944;
  @ffi.Uint32()
  int _unique_s_item_945;
  @ffi.Uint32()
  int _unique_s_item_946;
  @ffi.Uint32()
  int _unique_s_item_947;
  @ffi.Uint32()
  int _unique_s_item_948;
  @ffi.Uint32()
  int _unique_s_item_949;
  @ffi.Uint32()
  int _unique_s_item_950;
  @ffi.Uint32()
  int _unique_s_item_951;
  @ffi.Uint32()
  int _unique_s_item_952;
  @ffi.Uint32()
  int _unique_s_item_953;
  @ffi.Uint32()
  int _unique_s_item_954;
  @ffi.Uint32()
  int _unique_s_item_955;
  @ffi.Uint32()
  int _unique_s_item_956;
  @ffi.Uint32()
  int _unique_s_item_957;
  @ffi.Uint32()
  int _unique_s_item_958;
  @ffi.Uint32()
  int _unique_s_item_959;
  @ffi.Uint32()
  int _unique_s_item_960;
  @ffi.Uint32()
  int _unique_s_item_961;
  @ffi.Uint32()
  int _unique_s_item_962;
  @ffi.Uint32()
  int _unique_s_item_963;
  @ffi.Uint32()
  int _unique_s_item_964;
  @ffi.Uint32()
  int _unique_s_item_965;
  @ffi.Uint32()
  int _unique_s_item_966;
  @ffi.Uint32()
  int _unique_s_item_967;
  @ffi.Uint32()
  int _unique_s_item_968;
  @ffi.Uint32()
  int _unique_s_item_969;
  @ffi.Uint32()
  int _unique_s_item_970;
  @ffi.Uint32()
  int _unique_s_item_971;
  @ffi.Uint32()
  int _unique_s_item_972;
  @ffi.Uint32()
  int _unique_s_item_973;
  @ffi.Uint32()
  int _unique_s_item_974;
  @ffi.Uint32()
  int _unique_s_item_975;
  @ffi.Uint32()
  int _unique_s_item_976;
  @ffi.Uint32()
  int _unique_s_item_977;
  @ffi.Uint32()
  int _unique_s_item_978;
  @ffi.Uint32()
  int _unique_s_item_979;
  @ffi.Uint32()
  int _unique_s_item_980;
  @ffi.Uint32()
  int _unique_s_item_981;
  @ffi.Uint32()
  int _unique_s_item_982;
  @ffi.Uint32()
  int _unique_s_item_983;
  @ffi.Uint32()
  int _unique_s_item_984;
  @ffi.Uint32()
  int _unique_s_item_985;
  @ffi.Uint32()
  int _unique_s_item_986;
  @ffi.Uint32()
  int _unique_s_item_987;
  @ffi.Uint32()
  int _unique_s_item_988;
  @ffi.Uint32()
  int _unique_s_item_989;
  @ffi.Uint32()
  int _unique_s_item_990;
  @ffi.Uint32()
  int _unique_s_item_991;
  @ffi.Uint32()
  int _unique_s_item_992;
  @ffi.Uint32()
  int _unique_s_item_993;
  @ffi.Uint32()
  int _unique_s_item_994;
  @ffi.Uint32()
  int _unique_s_item_995;
  @ffi.Uint32()
  int _unique_s_item_996;
  @ffi.Uint32()
  int _unique_s_item_997;
  @ffi.Uint32()
  int _unique_s_item_998;
  @ffi.Uint32()
  int _unique_s_item_999;
  @ffi.Uint32()
  int _unique_s_item_1000;
  @ffi.Uint32()
  int _unique_s_item_1001;
  @ffi.Uint32()
  int _unique_s_item_1002;
  @ffi.Uint32()
  int _unique_s_item_1003;
  @ffi.Uint32()
  int _unique_s_item_1004;
  @ffi.Uint32()
  int _unique_s_item_1005;
  @ffi.Uint32()
  int _unique_s_item_1006;
  @ffi.Uint32()
  int _unique_s_item_1007;
  @ffi.Uint32()
  int _unique_s_item_1008;
  @ffi.Uint32()
  int _unique_s_item_1009;
  @ffi.Uint32()
  int _unique_s_item_1010;
  @ffi.Uint32()
  int _unique_s_item_1011;
  @ffi.Uint32()
  int _unique_s_item_1012;
  @ffi.Uint32()
  int _unique_s_item_1013;
  @ffi.Uint32()
  int _unique_s_item_1014;
  @ffi.Uint32()
  int _unique_s_item_1015;
  @ffi.Uint32()
  int _unique_s_item_1016;
  @ffi.Uint32()
  int _unique_s_item_1017;
  @ffi.Uint32()
  int _unique_s_item_1018;
  @ffi.Uint32()
  int _unique_s_item_1019;
  @ffi.Uint32()
  int _unique_s_item_1020;
  @ffi.Uint32()
  int _unique_s_item_1021;
  @ffi.Uint32()
  int _unique_s_item_1022;
  @ffi.Uint32()
  int _unique_s_item_1023;

  /// Helper for array `s`.
  ArrayHelper_AVBlowfish_s_level0 get s =>
      ArrayHelper_AVBlowfish_s_level0(this, [4, 256], 0, 0);
}

/// Helper for array `p` in struct `AVBlowfish`.
class ArrayHelper_AVBlowfish_p_level0 {
  final AVBlowfish _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVBlowfish_p_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_p_item_0;
      case 1:
        return _struct._unique_p_item_1;
      case 2:
        return _struct._unique_p_item_2;
      case 3:
        return _struct._unique_p_item_3;
      case 4:
        return _struct._unique_p_item_4;
      case 5:
        return _struct._unique_p_item_5;
      case 6:
        return _struct._unique_p_item_6;
      case 7:
        return _struct._unique_p_item_7;
      case 8:
        return _struct._unique_p_item_8;
      case 9:
        return _struct._unique_p_item_9;
      case 10:
        return _struct._unique_p_item_10;
      case 11:
        return _struct._unique_p_item_11;
      case 12:
        return _struct._unique_p_item_12;
      case 13:
        return _struct._unique_p_item_13;
      case 14:
        return _struct._unique_p_item_14;
      case 15:
        return _struct._unique_p_item_15;
      case 16:
        return _struct._unique_p_item_16;
      case 17:
        return _struct._unique_p_item_17;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_p_item_0 = value;
        break;
      case 1:
        _struct._unique_p_item_1 = value;
        break;
      case 2:
        _struct._unique_p_item_2 = value;
        break;
      case 3:
        _struct._unique_p_item_3 = value;
        break;
      case 4:
        _struct._unique_p_item_4 = value;
        break;
      case 5:
        _struct._unique_p_item_5 = value;
        break;
      case 6:
        _struct._unique_p_item_6 = value;
        break;
      case 7:
        _struct._unique_p_item_7 = value;
        break;
      case 8:
        _struct._unique_p_item_8 = value;
        break;
      case 9:
        _struct._unique_p_item_9 = value;
        break;
      case 10:
        _struct._unique_p_item_10 = value;
        break;
      case 11:
        _struct._unique_p_item_11 = value;
        break;
      case 12:
        _struct._unique_p_item_12 = value;
        break;
      case 13:
        _struct._unique_p_item_13 = value;
        break;
      case 14:
        _struct._unique_p_item_14 = value;
        break;
      case 15:
        _struct._unique_p_item_15 = value;
        break;
      case 16:
        _struct._unique_p_item_16 = value;
        break;
      case 17:
        _struct._unique_p_item_17 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `s` in struct `AVBlowfish`.
class ArrayHelper_AVBlowfish_s_level0 {
  final AVBlowfish _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVBlowfish_s_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVBlowfish_s_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVBlowfish_s_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `s` in struct `AVBlowfish`.
class ArrayHelper_AVBlowfish_s_level1 {
  final AVBlowfish _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVBlowfish_s_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_s_item_0;
      case 1:
        return _struct._unique_s_item_1;
      case 2:
        return _struct._unique_s_item_2;
      case 3:
        return _struct._unique_s_item_3;
      case 4:
        return _struct._unique_s_item_4;
      case 5:
        return _struct._unique_s_item_5;
      case 6:
        return _struct._unique_s_item_6;
      case 7:
        return _struct._unique_s_item_7;
      case 8:
        return _struct._unique_s_item_8;
      case 9:
        return _struct._unique_s_item_9;
      case 10:
        return _struct._unique_s_item_10;
      case 11:
        return _struct._unique_s_item_11;
      case 12:
        return _struct._unique_s_item_12;
      case 13:
        return _struct._unique_s_item_13;
      case 14:
        return _struct._unique_s_item_14;
      case 15:
        return _struct._unique_s_item_15;
      case 16:
        return _struct._unique_s_item_16;
      case 17:
        return _struct._unique_s_item_17;
      case 18:
        return _struct._unique_s_item_18;
      case 19:
        return _struct._unique_s_item_19;
      case 20:
        return _struct._unique_s_item_20;
      case 21:
        return _struct._unique_s_item_21;
      case 22:
        return _struct._unique_s_item_22;
      case 23:
        return _struct._unique_s_item_23;
      case 24:
        return _struct._unique_s_item_24;
      case 25:
        return _struct._unique_s_item_25;
      case 26:
        return _struct._unique_s_item_26;
      case 27:
        return _struct._unique_s_item_27;
      case 28:
        return _struct._unique_s_item_28;
      case 29:
        return _struct._unique_s_item_29;
      case 30:
        return _struct._unique_s_item_30;
      case 31:
        return _struct._unique_s_item_31;
      case 32:
        return _struct._unique_s_item_32;
      case 33:
        return _struct._unique_s_item_33;
      case 34:
        return _struct._unique_s_item_34;
      case 35:
        return _struct._unique_s_item_35;
      case 36:
        return _struct._unique_s_item_36;
      case 37:
        return _struct._unique_s_item_37;
      case 38:
        return _struct._unique_s_item_38;
      case 39:
        return _struct._unique_s_item_39;
      case 40:
        return _struct._unique_s_item_40;
      case 41:
        return _struct._unique_s_item_41;
      case 42:
        return _struct._unique_s_item_42;
      case 43:
        return _struct._unique_s_item_43;
      case 44:
        return _struct._unique_s_item_44;
      case 45:
        return _struct._unique_s_item_45;
      case 46:
        return _struct._unique_s_item_46;
      case 47:
        return _struct._unique_s_item_47;
      case 48:
        return _struct._unique_s_item_48;
      case 49:
        return _struct._unique_s_item_49;
      case 50:
        return _struct._unique_s_item_50;
      case 51:
        return _struct._unique_s_item_51;
      case 52:
        return _struct._unique_s_item_52;
      case 53:
        return _struct._unique_s_item_53;
      case 54:
        return _struct._unique_s_item_54;
      case 55:
        return _struct._unique_s_item_55;
      case 56:
        return _struct._unique_s_item_56;
      case 57:
        return _struct._unique_s_item_57;
      case 58:
        return _struct._unique_s_item_58;
      case 59:
        return _struct._unique_s_item_59;
      case 60:
        return _struct._unique_s_item_60;
      case 61:
        return _struct._unique_s_item_61;
      case 62:
        return _struct._unique_s_item_62;
      case 63:
        return _struct._unique_s_item_63;
      case 64:
        return _struct._unique_s_item_64;
      case 65:
        return _struct._unique_s_item_65;
      case 66:
        return _struct._unique_s_item_66;
      case 67:
        return _struct._unique_s_item_67;
      case 68:
        return _struct._unique_s_item_68;
      case 69:
        return _struct._unique_s_item_69;
      case 70:
        return _struct._unique_s_item_70;
      case 71:
        return _struct._unique_s_item_71;
      case 72:
        return _struct._unique_s_item_72;
      case 73:
        return _struct._unique_s_item_73;
      case 74:
        return _struct._unique_s_item_74;
      case 75:
        return _struct._unique_s_item_75;
      case 76:
        return _struct._unique_s_item_76;
      case 77:
        return _struct._unique_s_item_77;
      case 78:
        return _struct._unique_s_item_78;
      case 79:
        return _struct._unique_s_item_79;
      case 80:
        return _struct._unique_s_item_80;
      case 81:
        return _struct._unique_s_item_81;
      case 82:
        return _struct._unique_s_item_82;
      case 83:
        return _struct._unique_s_item_83;
      case 84:
        return _struct._unique_s_item_84;
      case 85:
        return _struct._unique_s_item_85;
      case 86:
        return _struct._unique_s_item_86;
      case 87:
        return _struct._unique_s_item_87;
      case 88:
        return _struct._unique_s_item_88;
      case 89:
        return _struct._unique_s_item_89;
      case 90:
        return _struct._unique_s_item_90;
      case 91:
        return _struct._unique_s_item_91;
      case 92:
        return _struct._unique_s_item_92;
      case 93:
        return _struct._unique_s_item_93;
      case 94:
        return _struct._unique_s_item_94;
      case 95:
        return _struct._unique_s_item_95;
      case 96:
        return _struct._unique_s_item_96;
      case 97:
        return _struct._unique_s_item_97;
      case 98:
        return _struct._unique_s_item_98;
      case 99:
        return _struct._unique_s_item_99;
      case 100:
        return _struct._unique_s_item_100;
      case 101:
        return _struct._unique_s_item_101;
      case 102:
        return _struct._unique_s_item_102;
      case 103:
        return _struct._unique_s_item_103;
      case 104:
        return _struct._unique_s_item_104;
      case 105:
        return _struct._unique_s_item_105;
      case 106:
        return _struct._unique_s_item_106;
      case 107:
        return _struct._unique_s_item_107;
      case 108:
        return _struct._unique_s_item_108;
      case 109:
        return _struct._unique_s_item_109;
      case 110:
        return _struct._unique_s_item_110;
      case 111:
        return _struct._unique_s_item_111;
      case 112:
        return _struct._unique_s_item_112;
      case 113:
        return _struct._unique_s_item_113;
      case 114:
        return _struct._unique_s_item_114;
      case 115:
        return _struct._unique_s_item_115;
      case 116:
        return _struct._unique_s_item_116;
      case 117:
        return _struct._unique_s_item_117;
      case 118:
        return _struct._unique_s_item_118;
      case 119:
        return _struct._unique_s_item_119;
      case 120:
        return _struct._unique_s_item_120;
      case 121:
        return _struct._unique_s_item_121;
      case 122:
        return _struct._unique_s_item_122;
      case 123:
        return _struct._unique_s_item_123;
      case 124:
        return _struct._unique_s_item_124;
      case 125:
        return _struct._unique_s_item_125;
      case 126:
        return _struct._unique_s_item_126;
      case 127:
        return _struct._unique_s_item_127;
      case 128:
        return _struct._unique_s_item_128;
      case 129:
        return _struct._unique_s_item_129;
      case 130:
        return _struct._unique_s_item_130;
      case 131:
        return _struct._unique_s_item_131;
      case 132:
        return _struct._unique_s_item_132;
      case 133:
        return _struct._unique_s_item_133;
      case 134:
        return _struct._unique_s_item_134;
      case 135:
        return _struct._unique_s_item_135;
      case 136:
        return _struct._unique_s_item_136;
      case 137:
        return _struct._unique_s_item_137;
      case 138:
        return _struct._unique_s_item_138;
      case 139:
        return _struct._unique_s_item_139;
      case 140:
        return _struct._unique_s_item_140;
      case 141:
        return _struct._unique_s_item_141;
      case 142:
        return _struct._unique_s_item_142;
      case 143:
        return _struct._unique_s_item_143;
      case 144:
        return _struct._unique_s_item_144;
      case 145:
        return _struct._unique_s_item_145;
      case 146:
        return _struct._unique_s_item_146;
      case 147:
        return _struct._unique_s_item_147;
      case 148:
        return _struct._unique_s_item_148;
      case 149:
        return _struct._unique_s_item_149;
      case 150:
        return _struct._unique_s_item_150;
      case 151:
        return _struct._unique_s_item_151;
      case 152:
        return _struct._unique_s_item_152;
      case 153:
        return _struct._unique_s_item_153;
      case 154:
        return _struct._unique_s_item_154;
      case 155:
        return _struct._unique_s_item_155;
      case 156:
        return _struct._unique_s_item_156;
      case 157:
        return _struct._unique_s_item_157;
      case 158:
        return _struct._unique_s_item_158;
      case 159:
        return _struct._unique_s_item_159;
      case 160:
        return _struct._unique_s_item_160;
      case 161:
        return _struct._unique_s_item_161;
      case 162:
        return _struct._unique_s_item_162;
      case 163:
        return _struct._unique_s_item_163;
      case 164:
        return _struct._unique_s_item_164;
      case 165:
        return _struct._unique_s_item_165;
      case 166:
        return _struct._unique_s_item_166;
      case 167:
        return _struct._unique_s_item_167;
      case 168:
        return _struct._unique_s_item_168;
      case 169:
        return _struct._unique_s_item_169;
      case 170:
        return _struct._unique_s_item_170;
      case 171:
        return _struct._unique_s_item_171;
      case 172:
        return _struct._unique_s_item_172;
      case 173:
        return _struct._unique_s_item_173;
      case 174:
        return _struct._unique_s_item_174;
      case 175:
        return _struct._unique_s_item_175;
      case 176:
        return _struct._unique_s_item_176;
      case 177:
        return _struct._unique_s_item_177;
      case 178:
        return _struct._unique_s_item_178;
      case 179:
        return _struct._unique_s_item_179;
      case 180:
        return _struct._unique_s_item_180;
      case 181:
        return _struct._unique_s_item_181;
      case 182:
        return _struct._unique_s_item_182;
      case 183:
        return _struct._unique_s_item_183;
      case 184:
        return _struct._unique_s_item_184;
      case 185:
        return _struct._unique_s_item_185;
      case 186:
        return _struct._unique_s_item_186;
      case 187:
        return _struct._unique_s_item_187;
      case 188:
        return _struct._unique_s_item_188;
      case 189:
        return _struct._unique_s_item_189;
      case 190:
        return _struct._unique_s_item_190;
      case 191:
        return _struct._unique_s_item_191;
      case 192:
        return _struct._unique_s_item_192;
      case 193:
        return _struct._unique_s_item_193;
      case 194:
        return _struct._unique_s_item_194;
      case 195:
        return _struct._unique_s_item_195;
      case 196:
        return _struct._unique_s_item_196;
      case 197:
        return _struct._unique_s_item_197;
      case 198:
        return _struct._unique_s_item_198;
      case 199:
        return _struct._unique_s_item_199;
      case 200:
        return _struct._unique_s_item_200;
      case 201:
        return _struct._unique_s_item_201;
      case 202:
        return _struct._unique_s_item_202;
      case 203:
        return _struct._unique_s_item_203;
      case 204:
        return _struct._unique_s_item_204;
      case 205:
        return _struct._unique_s_item_205;
      case 206:
        return _struct._unique_s_item_206;
      case 207:
        return _struct._unique_s_item_207;
      case 208:
        return _struct._unique_s_item_208;
      case 209:
        return _struct._unique_s_item_209;
      case 210:
        return _struct._unique_s_item_210;
      case 211:
        return _struct._unique_s_item_211;
      case 212:
        return _struct._unique_s_item_212;
      case 213:
        return _struct._unique_s_item_213;
      case 214:
        return _struct._unique_s_item_214;
      case 215:
        return _struct._unique_s_item_215;
      case 216:
        return _struct._unique_s_item_216;
      case 217:
        return _struct._unique_s_item_217;
      case 218:
        return _struct._unique_s_item_218;
      case 219:
        return _struct._unique_s_item_219;
      case 220:
        return _struct._unique_s_item_220;
      case 221:
        return _struct._unique_s_item_221;
      case 222:
        return _struct._unique_s_item_222;
      case 223:
        return _struct._unique_s_item_223;
      case 224:
        return _struct._unique_s_item_224;
      case 225:
        return _struct._unique_s_item_225;
      case 226:
        return _struct._unique_s_item_226;
      case 227:
        return _struct._unique_s_item_227;
      case 228:
        return _struct._unique_s_item_228;
      case 229:
        return _struct._unique_s_item_229;
      case 230:
        return _struct._unique_s_item_230;
      case 231:
        return _struct._unique_s_item_231;
      case 232:
        return _struct._unique_s_item_232;
      case 233:
        return _struct._unique_s_item_233;
      case 234:
        return _struct._unique_s_item_234;
      case 235:
        return _struct._unique_s_item_235;
      case 236:
        return _struct._unique_s_item_236;
      case 237:
        return _struct._unique_s_item_237;
      case 238:
        return _struct._unique_s_item_238;
      case 239:
        return _struct._unique_s_item_239;
      case 240:
        return _struct._unique_s_item_240;
      case 241:
        return _struct._unique_s_item_241;
      case 242:
        return _struct._unique_s_item_242;
      case 243:
        return _struct._unique_s_item_243;
      case 244:
        return _struct._unique_s_item_244;
      case 245:
        return _struct._unique_s_item_245;
      case 246:
        return _struct._unique_s_item_246;
      case 247:
        return _struct._unique_s_item_247;
      case 248:
        return _struct._unique_s_item_248;
      case 249:
        return _struct._unique_s_item_249;
      case 250:
        return _struct._unique_s_item_250;
      case 251:
        return _struct._unique_s_item_251;
      case 252:
        return _struct._unique_s_item_252;
      case 253:
        return _struct._unique_s_item_253;
      case 254:
        return _struct._unique_s_item_254;
      case 255:
        return _struct._unique_s_item_255;
      case 256:
        return _struct._unique_s_item_256;
      case 257:
        return _struct._unique_s_item_257;
      case 258:
        return _struct._unique_s_item_258;
      case 259:
        return _struct._unique_s_item_259;
      case 260:
        return _struct._unique_s_item_260;
      case 261:
        return _struct._unique_s_item_261;
      case 262:
        return _struct._unique_s_item_262;
      case 263:
        return _struct._unique_s_item_263;
      case 264:
        return _struct._unique_s_item_264;
      case 265:
        return _struct._unique_s_item_265;
      case 266:
        return _struct._unique_s_item_266;
      case 267:
        return _struct._unique_s_item_267;
      case 268:
        return _struct._unique_s_item_268;
      case 269:
        return _struct._unique_s_item_269;
      case 270:
        return _struct._unique_s_item_270;
      case 271:
        return _struct._unique_s_item_271;
      case 272:
        return _struct._unique_s_item_272;
      case 273:
        return _struct._unique_s_item_273;
      case 274:
        return _struct._unique_s_item_274;
      case 275:
        return _struct._unique_s_item_275;
      case 276:
        return _struct._unique_s_item_276;
      case 277:
        return _struct._unique_s_item_277;
      case 278:
        return _struct._unique_s_item_278;
      case 279:
        return _struct._unique_s_item_279;
      case 280:
        return _struct._unique_s_item_280;
      case 281:
        return _struct._unique_s_item_281;
      case 282:
        return _struct._unique_s_item_282;
      case 283:
        return _struct._unique_s_item_283;
      case 284:
        return _struct._unique_s_item_284;
      case 285:
        return _struct._unique_s_item_285;
      case 286:
        return _struct._unique_s_item_286;
      case 287:
        return _struct._unique_s_item_287;
      case 288:
        return _struct._unique_s_item_288;
      case 289:
        return _struct._unique_s_item_289;
      case 290:
        return _struct._unique_s_item_290;
      case 291:
        return _struct._unique_s_item_291;
      case 292:
        return _struct._unique_s_item_292;
      case 293:
        return _struct._unique_s_item_293;
      case 294:
        return _struct._unique_s_item_294;
      case 295:
        return _struct._unique_s_item_295;
      case 296:
        return _struct._unique_s_item_296;
      case 297:
        return _struct._unique_s_item_297;
      case 298:
        return _struct._unique_s_item_298;
      case 299:
        return _struct._unique_s_item_299;
      case 300:
        return _struct._unique_s_item_300;
      case 301:
        return _struct._unique_s_item_301;
      case 302:
        return _struct._unique_s_item_302;
      case 303:
        return _struct._unique_s_item_303;
      case 304:
        return _struct._unique_s_item_304;
      case 305:
        return _struct._unique_s_item_305;
      case 306:
        return _struct._unique_s_item_306;
      case 307:
        return _struct._unique_s_item_307;
      case 308:
        return _struct._unique_s_item_308;
      case 309:
        return _struct._unique_s_item_309;
      case 310:
        return _struct._unique_s_item_310;
      case 311:
        return _struct._unique_s_item_311;
      case 312:
        return _struct._unique_s_item_312;
      case 313:
        return _struct._unique_s_item_313;
      case 314:
        return _struct._unique_s_item_314;
      case 315:
        return _struct._unique_s_item_315;
      case 316:
        return _struct._unique_s_item_316;
      case 317:
        return _struct._unique_s_item_317;
      case 318:
        return _struct._unique_s_item_318;
      case 319:
        return _struct._unique_s_item_319;
      case 320:
        return _struct._unique_s_item_320;
      case 321:
        return _struct._unique_s_item_321;
      case 322:
        return _struct._unique_s_item_322;
      case 323:
        return _struct._unique_s_item_323;
      case 324:
        return _struct._unique_s_item_324;
      case 325:
        return _struct._unique_s_item_325;
      case 326:
        return _struct._unique_s_item_326;
      case 327:
        return _struct._unique_s_item_327;
      case 328:
        return _struct._unique_s_item_328;
      case 329:
        return _struct._unique_s_item_329;
      case 330:
        return _struct._unique_s_item_330;
      case 331:
        return _struct._unique_s_item_331;
      case 332:
        return _struct._unique_s_item_332;
      case 333:
        return _struct._unique_s_item_333;
      case 334:
        return _struct._unique_s_item_334;
      case 335:
        return _struct._unique_s_item_335;
      case 336:
        return _struct._unique_s_item_336;
      case 337:
        return _struct._unique_s_item_337;
      case 338:
        return _struct._unique_s_item_338;
      case 339:
        return _struct._unique_s_item_339;
      case 340:
        return _struct._unique_s_item_340;
      case 341:
        return _struct._unique_s_item_341;
      case 342:
        return _struct._unique_s_item_342;
      case 343:
        return _struct._unique_s_item_343;
      case 344:
        return _struct._unique_s_item_344;
      case 345:
        return _struct._unique_s_item_345;
      case 346:
        return _struct._unique_s_item_346;
      case 347:
        return _struct._unique_s_item_347;
      case 348:
        return _struct._unique_s_item_348;
      case 349:
        return _struct._unique_s_item_349;
      case 350:
        return _struct._unique_s_item_350;
      case 351:
        return _struct._unique_s_item_351;
      case 352:
        return _struct._unique_s_item_352;
      case 353:
        return _struct._unique_s_item_353;
      case 354:
        return _struct._unique_s_item_354;
      case 355:
        return _struct._unique_s_item_355;
      case 356:
        return _struct._unique_s_item_356;
      case 357:
        return _struct._unique_s_item_357;
      case 358:
        return _struct._unique_s_item_358;
      case 359:
        return _struct._unique_s_item_359;
      case 360:
        return _struct._unique_s_item_360;
      case 361:
        return _struct._unique_s_item_361;
      case 362:
        return _struct._unique_s_item_362;
      case 363:
        return _struct._unique_s_item_363;
      case 364:
        return _struct._unique_s_item_364;
      case 365:
        return _struct._unique_s_item_365;
      case 366:
        return _struct._unique_s_item_366;
      case 367:
        return _struct._unique_s_item_367;
      case 368:
        return _struct._unique_s_item_368;
      case 369:
        return _struct._unique_s_item_369;
      case 370:
        return _struct._unique_s_item_370;
      case 371:
        return _struct._unique_s_item_371;
      case 372:
        return _struct._unique_s_item_372;
      case 373:
        return _struct._unique_s_item_373;
      case 374:
        return _struct._unique_s_item_374;
      case 375:
        return _struct._unique_s_item_375;
      case 376:
        return _struct._unique_s_item_376;
      case 377:
        return _struct._unique_s_item_377;
      case 378:
        return _struct._unique_s_item_378;
      case 379:
        return _struct._unique_s_item_379;
      case 380:
        return _struct._unique_s_item_380;
      case 381:
        return _struct._unique_s_item_381;
      case 382:
        return _struct._unique_s_item_382;
      case 383:
        return _struct._unique_s_item_383;
      case 384:
        return _struct._unique_s_item_384;
      case 385:
        return _struct._unique_s_item_385;
      case 386:
        return _struct._unique_s_item_386;
      case 387:
        return _struct._unique_s_item_387;
      case 388:
        return _struct._unique_s_item_388;
      case 389:
        return _struct._unique_s_item_389;
      case 390:
        return _struct._unique_s_item_390;
      case 391:
        return _struct._unique_s_item_391;
      case 392:
        return _struct._unique_s_item_392;
      case 393:
        return _struct._unique_s_item_393;
      case 394:
        return _struct._unique_s_item_394;
      case 395:
        return _struct._unique_s_item_395;
      case 396:
        return _struct._unique_s_item_396;
      case 397:
        return _struct._unique_s_item_397;
      case 398:
        return _struct._unique_s_item_398;
      case 399:
        return _struct._unique_s_item_399;
      case 400:
        return _struct._unique_s_item_400;
      case 401:
        return _struct._unique_s_item_401;
      case 402:
        return _struct._unique_s_item_402;
      case 403:
        return _struct._unique_s_item_403;
      case 404:
        return _struct._unique_s_item_404;
      case 405:
        return _struct._unique_s_item_405;
      case 406:
        return _struct._unique_s_item_406;
      case 407:
        return _struct._unique_s_item_407;
      case 408:
        return _struct._unique_s_item_408;
      case 409:
        return _struct._unique_s_item_409;
      case 410:
        return _struct._unique_s_item_410;
      case 411:
        return _struct._unique_s_item_411;
      case 412:
        return _struct._unique_s_item_412;
      case 413:
        return _struct._unique_s_item_413;
      case 414:
        return _struct._unique_s_item_414;
      case 415:
        return _struct._unique_s_item_415;
      case 416:
        return _struct._unique_s_item_416;
      case 417:
        return _struct._unique_s_item_417;
      case 418:
        return _struct._unique_s_item_418;
      case 419:
        return _struct._unique_s_item_419;
      case 420:
        return _struct._unique_s_item_420;
      case 421:
        return _struct._unique_s_item_421;
      case 422:
        return _struct._unique_s_item_422;
      case 423:
        return _struct._unique_s_item_423;
      case 424:
        return _struct._unique_s_item_424;
      case 425:
        return _struct._unique_s_item_425;
      case 426:
        return _struct._unique_s_item_426;
      case 427:
        return _struct._unique_s_item_427;
      case 428:
        return _struct._unique_s_item_428;
      case 429:
        return _struct._unique_s_item_429;
      case 430:
        return _struct._unique_s_item_430;
      case 431:
        return _struct._unique_s_item_431;
      case 432:
        return _struct._unique_s_item_432;
      case 433:
        return _struct._unique_s_item_433;
      case 434:
        return _struct._unique_s_item_434;
      case 435:
        return _struct._unique_s_item_435;
      case 436:
        return _struct._unique_s_item_436;
      case 437:
        return _struct._unique_s_item_437;
      case 438:
        return _struct._unique_s_item_438;
      case 439:
        return _struct._unique_s_item_439;
      case 440:
        return _struct._unique_s_item_440;
      case 441:
        return _struct._unique_s_item_441;
      case 442:
        return _struct._unique_s_item_442;
      case 443:
        return _struct._unique_s_item_443;
      case 444:
        return _struct._unique_s_item_444;
      case 445:
        return _struct._unique_s_item_445;
      case 446:
        return _struct._unique_s_item_446;
      case 447:
        return _struct._unique_s_item_447;
      case 448:
        return _struct._unique_s_item_448;
      case 449:
        return _struct._unique_s_item_449;
      case 450:
        return _struct._unique_s_item_450;
      case 451:
        return _struct._unique_s_item_451;
      case 452:
        return _struct._unique_s_item_452;
      case 453:
        return _struct._unique_s_item_453;
      case 454:
        return _struct._unique_s_item_454;
      case 455:
        return _struct._unique_s_item_455;
      case 456:
        return _struct._unique_s_item_456;
      case 457:
        return _struct._unique_s_item_457;
      case 458:
        return _struct._unique_s_item_458;
      case 459:
        return _struct._unique_s_item_459;
      case 460:
        return _struct._unique_s_item_460;
      case 461:
        return _struct._unique_s_item_461;
      case 462:
        return _struct._unique_s_item_462;
      case 463:
        return _struct._unique_s_item_463;
      case 464:
        return _struct._unique_s_item_464;
      case 465:
        return _struct._unique_s_item_465;
      case 466:
        return _struct._unique_s_item_466;
      case 467:
        return _struct._unique_s_item_467;
      case 468:
        return _struct._unique_s_item_468;
      case 469:
        return _struct._unique_s_item_469;
      case 470:
        return _struct._unique_s_item_470;
      case 471:
        return _struct._unique_s_item_471;
      case 472:
        return _struct._unique_s_item_472;
      case 473:
        return _struct._unique_s_item_473;
      case 474:
        return _struct._unique_s_item_474;
      case 475:
        return _struct._unique_s_item_475;
      case 476:
        return _struct._unique_s_item_476;
      case 477:
        return _struct._unique_s_item_477;
      case 478:
        return _struct._unique_s_item_478;
      case 479:
        return _struct._unique_s_item_479;
      case 480:
        return _struct._unique_s_item_480;
      case 481:
        return _struct._unique_s_item_481;
      case 482:
        return _struct._unique_s_item_482;
      case 483:
        return _struct._unique_s_item_483;
      case 484:
        return _struct._unique_s_item_484;
      case 485:
        return _struct._unique_s_item_485;
      case 486:
        return _struct._unique_s_item_486;
      case 487:
        return _struct._unique_s_item_487;
      case 488:
        return _struct._unique_s_item_488;
      case 489:
        return _struct._unique_s_item_489;
      case 490:
        return _struct._unique_s_item_490;
      case 491:
        return _struct._unique_s_item_491;
      case 492:
        return _struct._unique_s_item_492;
      case 493:
        return _struct._unique_s_item_493;
      case 494:
        return _struct._unique_s_item_494;
      case 495:
        return _struct._unique_s_item_495;
      case 496:
        return _struct._unique_s_item_496;
      case 497:
        return _struct._unique_s_item_497;
      case 498:
        return _struct._unique_s_item_498;
      case 499:
        return _struct._unique_s_item_499;
      case 500:
        return _struct._unique_s_item_500;
      case 501:
        return _struct._unique_s_item_501;
      case 502:
        return _struct._unique_s_item_502;
      case 503:
        return _struct._unique_s_item_503;
      case 504:
        return _struct._unique_s_item_504;
      case 505:
        return _struct._unique_s_item_505;
      case 506:
        return _struct._unique_s_item_506;
      case 507:
        return _struct._unique_s_item_507;
      case 508:
        return _struct._unique_s_item_508;
      case 509:
        return _struct._unique_s_item_509;
      case 510:
        return _struct._unique_s_item_510;
      case 511:
        return _struct._unique_s_item_511;
      case 512:
        return _struct._unique_s_item_512;
      case 513:
        return _struct._unique_s_item_513;
      case 514:
        return _struct._unique_s_item_514;
      case 515:
        return _struct._unique_s_item_515;
      case 516:
        return _struct._unique_s_item_516;
      case 517:
        return _struct._unique_s_item_517;
      case 518:
        return _struct._unique_s_item_518;
      case 519:
        return _struct._unique_s_item_519;
      case 520:
        return _struct._unique_s_item_520;
      case 521:
        return _struct._unique_s_item_521;
      case 522:
        return _struct._unique_s_item_522;
      case 523:
        return _struct._unique_s_item_523;
      case 524:
        return _struct._unique_s_item_524;
      case 525:
        return _struct._unique_s_item_525;
      case 526:
        return _struct._unique_s_item_526;
      case 527:
        return _struct._unique_s_item_527;
      case 528:
        return _struct._unique_s_item_528;
      case 529:
        return _struct._unique_s_item_529;
      case 530:
        return _struct._unique_s_item_530;
      case 531:
        return _struct._unique_s_item_531;
      case 532:
        return _struct._unique_s_item_532;
      case 533:
        return _struct._unique_s_item_533;
      case 534:
        return _struct._unique_s_item_534;
      case 535:
        return _struct._unique_s_item_535;
      case 536:
        return _struct._unique_s_item_536;
      case 537:
        return _struct._unique_s_item_537;
      case 538:
        return _struct._unique_s_item_538;
      case 539:
        return _struct._unique_s_item_539;
      case 540:
        return _struct._unique_s_item_540;
      case 541:
        return _struct._unique_s_item_541;
      case 542:
        return _struct._unique_s_item_542;
      case 543:
        return _struct._unique_s_item_543;
      case 544:
        return _struct._unique_s_item_544;
      case 545:
        return _struct._unique_s_item_545;
      case 546:
        return _struct._unique_s_item_546;
      case 547:
        return _struct._unique_s_item_547;
      case 548:
        return _struct._unique_s_item_548;
      case 549:
        return _struct._unique_s_item_549;
      case 550:
        return _struct._unique_s_item_550;
      case 551:
        return _struct._unique_s_item_551;
      case 552:
        return _struct._unique_s_item_552;
      case 553:
        return _struct._unique_s_item_553;
      case 554:
        return _struct._unique_s_item_554;
      case 555:
        return _struct._unique_s_item_555;
      case 556:
        return _struct._unique_s_item_556;
      case 557:
        return _struct._unique_s_item_557;
      case 558:
        return _struct._unique_s_item_558;
      case 559:
        return _struct._unique_s_item_559;
      case 560:
        return _struct._unique_s_item_560;
      case 561:
        return _struct._unique_s_item_561;
      case 562:
        return _struct._unique_s_item_562;
      case 563:
        return _struct._unique_s_item_563;
      case 564:
        return _struct._unique_s_item_564;
      case 565:
        return _struct._unique_s_item_565;
      case 566:
        return _struct._unique_s_item_566;
      case 567:
        return _struct._unique_s_item_567;
      case 568:
        return _struct._unique_s_item_568;
      case 569:
        return _struct._unique_s_item_569;
      case 570:
        return _struct._unique_s_item_570;
      case 571:
        return _struct._unique_s_item_571;
      case 572:
        return _struct._unique_s_item_572;
      case 573:
        return _struct._unique_s_item_573;
      case 574:
        return _struct._unique_s_item_574;
      case 575:
        return _struct._unique_s_item_575;
      case 576:
        return _struct._unique_s_item_576;
      case 577:
        return _struct._unique_s_item_577;
      case 578:
        return _struct._unique_s_item_578;
      case 579:
        return _struct._unique_s_item_579;
      case 580:
        return _struct._unique_s_item_580;
      case 581:
        return _struct._unique_s_item_581;
      case 582:
        return _struct._unique_s_item_582;
      case 583:
        return _struct._unique_s_item_583;
      case 584:
        return _struct._unique_s_item_584;
      case 585:
        return _struct._unique_s_item_585;
      case 586:
        return _struct._unique_s_item_586;
      case 587:
        return _struct._unique_s_item_587;
      case 588:
        return _struct._unique_s_item_588;
      case 589:
        return _struct._unique_s_item_589;
      case 590:
        return _struct._unique_s_item_590;
      case 591:
        return _struct._unique_s_item_591;
      case 592:
        return _struct._unique_s_item_592;
      case 593:
        return _struct._unique_s_item_593;
      case 594:
        return _struct._unique_s_item_594;
      case 595:
        return _struct._unique_s_item_595;
      case 596:
        return _struct._unique_s_item_596;
      case 597:
        return _struct._unique_s_item_597;
      case 598:
        return _struct._unique_s_item_598;
      case 599:
        return _struct._unique_s_item_599;
      case 600:
        return _struct._unique_s_item_600;
      case 601:
        return _struct._unique_s_item_601;
      case 602:
        return _struct._unique_s_item_602;
      case 603:
        return _struct._unique_s_item_603;
      case 604:
        return _struct._unique_s_item_604;
      case 605:
        return _struct._unique_s_item_605;
      case 606:
        return _struct._unique_s_item_606;
      case 607:
        return _struct._unique_s_item_607;
      case 608:
        return _struct._unique_s_item_608;
      case 609:
        return _struct._unique_s_item_609;
      case 610:
        return _struct._unique_s_item_610;
      case 611:
        return _struct._unique_s_item_611;
      case 612:
        return _struct._unique_s_item_612;
      case 613:
        return _struct._unique_s_item_613;
      case 614:
        return _struct._unique_s_item_614;
      case 615:
        return _struct._unique_s_item_615;
      case 616:
        return _struct._unique_s_item_616;
      case 617:
        return _struct._unique_s_item_617;
      case 618:
        return _struct._unique_s_item_618;
      case 619:
        return _struct._unique_s_item_619;
      case 620:
        return _struct._unique_s_item_620;
      case 621:
        return _struct._unique_s_item_621;
      case 622:
        return _struct._unique_s_item_622;
      case 623:
        return _struct._unique_s_item_623;
      case 624:
        return _struct._unique_s_item_624;
      case 625:
        return _struct._unique_s_item_625;
      case 626:
        return _struct._unique_s_item_626;
      case 627:
        return _struct._unique_s_item_627;
      case 628:
        return _struct._unique_s_item_628;
      case 629:
        return _struct._unique_s_item_629;
      case 630:
        return _struct._unique_s_item_630;
      case 631:
        return _struct._unique_s_item_631;
      case 632:
        return _struct._unique_s_item_632;
      case 633:
        return _struct._unique_s_item_633;
      case 634:
        return _struct._unique_s_item_634;
      case 635:
        return _struct._unique_s_item_635;
      case 636:
        return _struct._unique_s_item_636;
      case 637:
        return _struct._unique_s_item_637;
      case 638:
        return _struct._unique_s_item_638;
      case 639:
        return _struct._unique_s_item_639;
      case 640:
        return _struct._unique_s_item_640;
      case 641:
        return _struct._unique_s_item_641;
      case 642:
        return _struct._unique_s_item_642;
      case 643:
        return _struct._unique_s_item_643;
      case 644:
        return _struct._unique_s_item_644;
      case 645:
        return _struct._unique_s_item_645;
      case 646:
        return _struct._unique_s_item_646;
      case 647:
        return _struct._unique_s_item_647;
      case 648:
        return _struct._unique_s_item_648;
      case 649:
        return _struct._unique_s_item_649;
      case 650:
        return _struct._unique_s_item_650;
      case 651:
        return _struct._unique_s_item_651;
      case 652:
        return _struct._unique_s_item_652;
      case 653:
        return _struct._unique_s_item_653;
      case 654:
        return _struct._unique_s_item_654;
      case 655:
        return _struct._unique_s_item_655;
      case 656:
        return _struct._unique_s_item_656;
      case 657:
        return _struct._unique_s_item_657;
      case 658:
        return _struct._unique_s_item_658;
      case 659:
        return _struct._unique_s_item_659;
      case 660:
        return _struct._unique_s_item_660;
      case 661:
        return _struct._unique_s_item_661;
      case 662:
        return _struct._unique_s_item_662;
      case 663:
        return _struct._unique_s_item_663;
      case 664:
        return _struct._unique_s_item_664;
      case 665:
        return _struct._unique_s_item_665;
      case 666:
        return _struct._unique_s_item_666;
      case 667:
        return _struct._unique_s_item_667;
      case 668:
        return _struct._unique_s_item_668;
      case 669:
        return _struct._unique_s_item_669;
      case 670:
        return _struct._unique_s_item_670;
      case 671:
        return _struct._unique_s_item_671;
      case 672:
        return _struct._unique_s_item_672;
      case 673:
        return _struct._unique_s_item_673;
      case 674:
        return _struct._unique_s_item_674;
      case 675:
        return _struct._unique_s_item_675;
      case 676:
        return _struct._unique_s_item_676;
      case 677:
        return _struct._unique_s_item_677;
      case 678:
        return _struct._unique_s_item_678;
      case 679:
        return _struct._unique_s_item_679;
      case 680:
        return _struct._unique_s_item_680;
      case 681:
        return _struct._unique_s_item_681;
      case 682:
        return _struct._unique_s_item_682;
      case 683:
        return _struct._unique_s_item_683;
      case 684:
        return _struct._unique_s_item_684;
      case 685:
        return _struct._unique_s_item_685;
      case 686:
        return _struct._unique_s_item_686;
      case 687:
        return _struct._unique_s_item_687;
      case 688:
        return _struct._unique_s_item_688;
      case 689:
        return _struct._unique_s_item_689;
      case 690:
        return _struct._unique_s_item_690;
      case 691:
        return _struct._unique_s_item_691;
      case 692:
        return _struct._unique_s_item_692;
      case 693:
        return _struct._unique_s_item_693;
      case 694:
        return _struct._unique_s_item_694;
      case 695:
        return _struct._unique_s_item_695;
      case 696:
        return _struct._unique_s_item_696;
      case 697:
        return _struct._unique_s_item_697;
      case 698:
        return _struct._unique_s_item_698;
      case 699:
        return _struct._unique_s_item_699;
      case 700:
        return _struct._unique_s_item_700;
      case 701:
        return _struct._unique_s_item_701;
      case 702:
        return _struct._unique_s_item_702;
      case 703:
        return _struct._unique_s_item_703;
      case 704:
        return _struct._unique_s_item_704;
      case 705:
        return _struct._unique_s_item_705;
      case 706:
        return _struct._unique_s_item_706;
      case 707:
        return _struct._unique_s_item_707;
      case 708:
        return _struct._unique_s_item_708;
      case 709:
        return _struct._unique_s_item_709;
      case 710:
        return _struct._unique_s_item_710;
      case 711:
        return _struct._unique_s_item_711;
      case 712:
        return _struct._unique_s_item_712;
      case 713:
        return _struct._unique_s_item_713;
      case 714:
        return _struct._unique_s_item_714;
      case 715:
        return _struct._unique_s_item_715;
      case 716:
        return _struct._unique_s_item_716;
      case 717:
        return _struct._unique_s_item_717;
      case 718:
        return _struct._unique_s_item_718;
      case 719:
        return _struct._unique_s_item_719;
      case 720:
        return _struct._unique_s_item_720;
      case 721:
        return _struct._unique_s_item_721;
      case 722:
        return _struct._unique_s_item_722;
      case 723:
        return _struct._unique_s_item_723;
      case 724:
        return _struct._unique_s_item_724;
      case 725:
        return _struct._unique_s_item_725;
      case 726:
        return _struct._unique_s_item_726;
      case 727:
        return _struct._unique_s_item_727;
      case 728:
        return _struct._unique_s_item_728;
      case 729:
        return _struct._unique_s_item_729;
      case 730:
        return _struct._unique_s_item_730;
      case 731:
        return _struct._unique_s_item_731;
      case 732:
        return _struct._unique_s_item_732;
      case 733:
        return _struct._unique_s_item_733;
      case 734:
        return _struct._unique_s_item_734;
      case 735:
        return _struct._unique_s_item_735;
      case 736:
        return _struct._unique_s_item_736;
      case 737:
        return _struct._unique_s_item_737;
      case 738:
        return _struct._unique_s_item_738;
      case 739:
        return _struct._unique_s_item_739;
      case 740:
        return _struct._unique_s_item_740;
      case 741:
        return _struct._unique_s_item_741;
      case 742:
        return _struct._unique_s_item_742;
      case 743:
        return _struct._unique_s_item_743;
      case 744:
        return _struct._unique_s_item_744;
      case 745:
        return _struct._unique_s_item_745;
      case 746:
        return _struct._unique_s_item_746;
      case 747:
        return _struct._unique_s_item_747;
      case 748:
        return _struct._unique_s_item_748;
      case 749:
        return _struct._unique_s_item_749;
      case 750:
        return _struct._unique_s_item_750;
      case 751:
        return _struct._unique_s_item_751;
      case 752:
        return _struct._unique_s_item_752;
      case 753:
        return _struct._unique_s_item_753;
      case 754:
        return _struct._unique_s_item_754;
      case 755:
        return _struct._unique_s_item_755;
      case 756:
        return _struct._unique_s_item_756;
      case 757:
        return _struct._unique_s_item_757;
      case 758:
        return _struct._unique_s_item_758;
      case 759:
        return _struct._unique_s_item_759;
      case 760:
        return _struct._unique_s_item_760;
      case 761:
        return _struct._unique_s_item_761;
      case 762:
        return _struct._unique_s_item_762;
      case 763:
        return _struct._unique_s_item_763;
      case 764:
        return _struct._unique_s_item_764;
      case 765:
        return _struct._unique_s_item_765;
      case 766:
        return _struct._unique_s_item_766;
      case 767:
        return _struct._unique_s_item_767;
      case 768:
        return _struct._unique_s_item_768;
      case 769:
        return _struct._unique_s_item_769;
      case 770:
        return _struct._unique_s_item_770;
      case 771:
        return _struct._unique_s_item_771;
      case 772:
        return _struct._unique_s_item_772;
      case 773:
        return _struct._unique_s_item_773;
      case 774:
        return _struct._unique_s_item_774;
      case 775:
        return _struct._unique_s_item_775;
      case 776:
        return _struct._unique_s_item_776;
      case 777:
        return _struct._unique_s_item_777;
      case 778:
        return _struct._unique_s_item_778;
      case 779:
        return _struct._unique_s_item_779;
      case 780:
        return _struct._unique_s_item_780;
      case 781:
        return _struct._unique_s_item_781;
      case 782:
        return _struct._unique_s_item_782;
      case 783:
        return _struct._unique_s_item_783;
      case 784:
        return _struct._unique_s_item_784;
      case 785:
        return _struct._unique_s_item_785;
      case 786:
        return _struct._unique_s_item_786;
      case 787:
        return _struct._unique_s_item_787;
      case 788:
        return _struct._unique_s_item_788;
      case 789:
        return _struct._unique_s_item_789;
      case 790:
        return _struct._unique_s_item_790;
      case 791:
        return _struct._unique_s_item_791;
      case 792:
        return _struct._unique_s_item_792;
      case 793:
        return _struct._unique_s_item_793;
      case 794:
        return _struct._unique_s_item_794;
      case 795:
        return _struct._unique_s_item_795;
      case 796:
        return _struct._unique_s_item_796;
      case 797:
        return _struct._unique_s_item_797;
      case 798:
        return _struct._unique_s_item_798;
      case 799:
        return _struct._unique_s_item_799;
      case 800:
        return _struct._unique_s_item_800;
      case 801:
        return _struct._unique_s_item_801;
      case 802:
        return _struct._unique_s_item_802;
      case 803:
        return _struct._unique_s_item_803;
      case 804:
        return _struct._unique_s_item_804;
      case 805:
        return _struct._unique_s_item_805;
      case 806:
        return _struct._unique_s_item_806;
      case 807:
        return _struct._unique_s_item_807;
      case 808:
        return _struct._unique_s_item_808;
      case 809:
        return _struct._unique_s_item_809;
      case 810:
        return _struct._unique_s_item_810;
      case 811:
        return _struct._unique_s_item_811;
      case 812:
        return _struct._unique_s_item_812;
      case 813:
        return _struct._unique_s_item_813;
      case 814:
        return _struct._unique_s_item_814;
      case 815:
        return _struct._unique_s_item_815;
      case 816:
        return _struct._unique_s_item_816;
      case 817:
        return _struct._unique_s_item_817;
      case 818:
        return _struct._unique_s_item_818;
      case 819:
        return _struct._unique_s_item_819;
      case 820:
        return _struct._unique_s_item_820;
      case 821:
        return _struct._unique_s_item_821;
      case 822:
        return _struct._unique_s_item_822;
      case 823:
        return _struct._unique_s_item_823;
      case 824:
        return _struct._unique_s_item_824;
      case 825:
        return _struct._unique_s_item_825;
      case 826:
        return _struct._unique_s_item_826;
      case 827:
        return _struct._unique_s_item_827;
      case 828:
        return _struct._unique_s_item_828;
      case 829:
        return _struct._unique_s_item_829;
      case 830:
        return _struct._unique_s_item_830;
      case 831:
        return _struct._unique_s_item_831;
      case 832:
        return _struct._unique_s_item_832;
      case 833:
        return _struct._unique_s_item_833;
      case 834:
        return _struct._unique_s_item_834;
      case 835:
        return _struct._unique_s_item_835;
      case 836:
        return _struct._unique_s_item_836;
      case 837:
        return _struct._unique_s_item_837;
      case 838:
        return _struct._unique_s_item_838;
      case 839:
        return _struct._unique_s_item_839;
      case 840:
        return _struct._unique_s_item_840;
      case 841:
        return _struct._unique_s_item_841;
      case 842:
        return _struct._unique_s_item_842;
      case 843:
        return _struct._unique_s_item_843;
      case 844:
        return _struct._unique_s_item_844;
      case 845:
        return _struct._unique_s_item_845;
      case 846:
        return _struct._unique_s_item_846;
      case 847:
        return _struct._unique_s_item_847;
      case 848:
        return _struct._unique_s_item_848;
      case 849:
        return _struct._unique_s_item_849;
      case 850:
        return _struct._unique_s_item_850;
      case 851:
        return _struct._unique_s_item_851;
      case 852:
        return _struct._unique_s_item_852;
      case 853:
        return _struct._unique_s_item_853;
      case 854:
        return _struct._unique_s_item_854;
      case 855:
        return _struct._unique_s_item_855;
      case 856:
        return _struct._unique_s_item_856;
      case 857:
        return _struct._unique_s_item_857;
      case 858:
        return _struct._unique_s_item_858;
      case 859:
        return _struct._unique_s_item_859;
      case 860:
        return _struct._unique_s_item_860;
      case 861:
        return _struct._unique_s_item_861;
      case 862:
        return _struct._unique_s_item_862;
      case 863:
        return _struct._unique_s_item_863;
      case 864:
        return _struct._unique_s_item_864;
      case 865:
        return _struct._unique_s_item_865;
      case 866:
        return _struct._unique_s_item_866;
      case 867:
        return _struct._unique_s_item_867;
      case 868:
        return _struct._unique_s_item_868;
      case 869:
        return _struct._unique_s_item_869;
      case 870:
        return _struct._unique_s_item_870;
      case 871:
        return _struct._unique_s_item_871;
      case 872:
        return _struct._unique_s_item_872;
      case 873:
        return _struct._unique_s_item_873;
      case 874:
        return _struct._unique_s_item_874;
      case 875:
        return _struct._unique_s_item_875;
      case 876:
        return _struct._unique_s_item_876;
      case 877:
        return _struct._unique_s_item_877;
      case 878:
        return _struct._unique_s_item_878;
      case 879:
        return _struct._unique_s_item_879;
      case 880:
        return _struct._unique_s_item_880;
      case 881:
        return _struct._unique_s_item_881;
      case 882:
        return _struct._unique_s_item_882;
      case 883:
        return _struct._unique_s_item_883;
      case 884:
        return _struct._unique_s_item_884;
      case 885:
        return _struct._unique_s_item_885;
      case 886:
        return _struct._unique_s_item_886;
      case 887:
        return _struct._unique_s_item_887;
      case 888:
        return _struct._unique_s_item_888;
      case 889:
        return _struct._unique_s_item_889;
      case 890:
        return _struct._unique_s_item_890;
      case 891:
        return _struct._unique_s_item_891;
      case 892:
        return _struct._unique_s_item_892;
      case 893:
        return _struct._unique_s_item_893;
      case 894:
        return _struct._unique_s_item_894;
      case 895:
        return _struct._unique_s_item_895;
      case 896:
        return _struct._unique_s_item_896;
      case 897:
        return _struct._unique_s_item_897;
      case 898:
        return _struct._unique_s_item_898;
      case 899:
        return _struct._unique_s_item_899;
      case 900:
        return _struct._unique_s_item_900;
      case 901:
        return _struct._unique_s_item_901;
      case 902:
        return _struct._unique_s_item_902;
      case 903:
        return _struct._unique_s_item_903;
      case 904:
        return _struct._unique_s_item_904;
      case 905:
        return _struct._unique_s_item_905;
      case 906:
        return _struct._unique_s_item_906;
      case 907:
        return _struct._unique_s_item_907;
      case 908:
        return _struct._unique_s_item_908;
      case 909:
        return _struct._unique_s_item_909;
      case 910:
        return _struct._unique_s_item_910;
      case 911:
        return _struct._unique_s_item_911;
      case 912:
        return _struct._unique_s_item_912;
      case 913:
        return _struct._unique_s_item_913;
      case 914:
        return _struct._unique_s_item_914;
      case 915:
        return _struct._unique_s_item_915;
      case 916:
        return _struct._unique_s_item_916;
      case 917:
        return _struct._unique_s_item_917;
      case 918:
        return _struct._unique_s_item_918;
      case 919:
        return _struct._unique_s_item_919;
      case 920:
        return _struct._unique_s_item_920;
      case 921:
        return _struct._unique_s_item_921;
      case 922:
        return _struct._unique_s_item_922;
      case 923:
        return _struct._unique_s_item_923;
      case 924:
        return _struct._unique_s_item_924;
      case 925:
        return _struct._unique_s_item_925;
      case 926:
        return _struct._unique_s_item_926;
      case 927:
        return _struct._unique_s_item_927;
      case 928:
        return _struct._unique_s_item_928;
      case 929:
        return _struct._unique_s_item_929;
      case 930:
        return _struct._unique_s_item_930;
      case 931:
        return _struct._unique_s_item_931;
      case 932:
        return _struct._unique_s_item_932;
      case 933:
        return _struct._unique_s_item_933;
      case 934:
        return _struct._unique_s_item_934;
      case 935:
        return _struct._unique_s_item_935;
      case 936:
        return _struct._unique_s_item_936;
      case 937:
        return _struct._unique_s_item_937;
      case 938:
        return _struct._unique_s_item_938;
      case 939:
        return _struct._unique_s_item_939;
      case 940:
        return _struct._unique_s_item_940;
      case 941:
        return _struct._unique_s_item_941;
      case 942:
        return _struct._unique_s_item_942;
      case 943:
        return _struct._unique_s_item_943;
      case 944:
        return _struct._unique_s_item_944;
      case 945:
        return _struct._unique_s_item_945;
      case 946:
        return _struct._unique_s_item_946;
      case 947:
        return _struct._unique_s_item_947;
      case 948:
        return _struct._unique_s_item_948;
      case 949:
        return _struct._unique_s_item_949;
      case 950:
        return _struct._unique_s_item_950;
      case 951:
        return _struct._unique_s_item_951;
      case 952:
        return _struct._unique_s_item_952;
      case 953:
        return _struct._unique_s_item_953;
      case 954:
        return _struct._unique_s_item_954;
      case 955:
        return _struct._unique_s_item_955;
      case 956:
        return _struct._unique_s_item_956;
      case 957:
        return _struct._unique_s_item_957;
      case 958:
        return _struct._unique_s_item_958;
      case 959:
        return _struct._unique_s_item_959;
      case 960:
        return _struct._unique_s_item_960;
      case 961:
        return _struct._unique_s_item_961;
      case 962:
        return _struct._unique_s_item_962;
      case 963:
        return _struct._unique_s_item_963;
      case 964:
        return _struct._unique_s_item_964;
      case 965:
        return _struct._unique_s_item_965;
      case 966:
        return _struct._unique_s_item_966;
      case 967:
        return _struct._unique_s_item_967;
      case 968:
        return _struct._unique_s_item_968;
      case 969:
        return _struct._unique_s_item_969;
      case 970:
        return _struct._unique_s_item_970;
      case 971:
        return _struct._unique_s_item_971;
      case 972:
        return _struct._unique_s_item_972;
      case 973:
        return _struct._unique_s_item_973;
      case 974:
        return _struct._unique_s_item_974;
      case 975:
        return _struct._unique_s_item_975;
      case 976:
        return _struct._unique_s_item_976;
      case 977:
        return _struct._unique_s_item_977;
      case 978:
        return _struct._unique_s_item_978;
      case 979:
        return _struct._unique_s_item_979;
      case 980:
        return _struct._unique_s_item_980;
      case 981:
        return _struct._unique_s_item_981;
      case 982:
        return _struct._unique_s_item_982;
      case 983:
        return _struct._unique_s_item_983;
      case 984:
        return _struct._unique_s_item_984;
      case 985:
        return _struct._unique_s_item_985;
      case 986:
        return _struct._unique_s_item_986;
      case 987:
        return _struct._unique_s_item_987;
      case 988:
        return _struct._unique_s_item_988;
      case 989:
        return _struct._unique_s_item_989;
      case 990:
        return _struct._unique_s_item_990;
      case 991:
        return _struct._unique_s_item_991;
      case 992:
        return _struct._unique_s_item_992;
      case 993:
        return _struct._unique_s_item_993;
      case 994:
        return _struct._unique_s_item_994;
      case 995:
        return _struct._unique_s_item_995;
      case 996:
        return _struct._unique_s_item_996;
      case 997:
        return _struct._unique_s_item_997;
      case 998:
        return _struct._unique_s_item_998;
      case 999:
        return _struct._unique_s_item_999;
      case 1000:
        return _struct._unique_s_item_1000;
      case 1001:
        return _struct._unique_s_item_1001;
      case 1002:
        return _struct._unique_s_item_1002;
      case 1003:
        return _struct._unique_s_item_1003;
      case 1004:
        return _struct._unique_s_item_1004;
      case 1005:
        return _struct._unique_s_item_1005;
      case 1006:
        return _struct._unique_s_item_1006;
      case 1007:
        return _struct._unique_s_item_1007;
      case 1008:
        return _struct._unique_s_item_1008;
      case 1009:
        return _struct._unique_s_item_1009;
      case 1010:
        return _struct._unique_s_item_1010;
      case 1011:
        return _struct._unique_s_item_1011;
      case 1012:
        return _struct._unique_s_item_1012;
      case 1013:
        return _struct._unique_s_item_1013;
      case 1014:
        return _struct._unique_s_item_1014;
      case 1015:
        return _struct._unique_s_item_1015;
      case 1016:
        return _struct._unique_s_item_1016;
      case 1017:
        return _struct._unique_s_item_1017;
      case 1018:
        return _struct._unique_s_item_1018;
      case 1019:
        return _struct._unique_s_item_1019;
      case 1020:
        return _struct._unique_s_item_1020;
      case 1021:
        return _struct._unique_s_item_1021;
      case 1022:
        return _struct._unique_s_item_1022;
      case 1023:
        return _struct._unique_s_item_1023;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_s_item_0 = value;
        break;
      case 1:
        _struct._unique_s_item_1 = value;
        break;
      case 2:
        _struct._unique_s_item_2 = value;
        break;
      case 3:
        _struct._unique_s_item_3 = value;
        break;
      case 4:
        _struct._unique_s_item_4 = value;
        break;
      case 5:
        _struct._unique_s_item_5 = value;
        break;
      case 6:
        _struct._unique_s_item_6 = value;
        break;
      case 7:
        _struct._unique_s_item_7 = value;
        break;
      case 8:
        _struct._unique_s_item_8 = value;
        break;
      case 9:
        _struct._unique_s_item_9 = value;
        break;
      case 10:
        _struct._unique_s_item_10 = value;
        break;
      case 11:
        _struct._unique_s_item_11 = value;
        break;
      case 12:
        _struct._unique_s_item_12 = value;
        break;
      case 13:
        _struct._unique_s_item_13 = value;
        break;
      case 14:
        _struct._unique_s_item_14 = value;
        break;
      case 15:
        _struct._unique_s_item_15 = value;
        break;
      case 16:
        _struct._unique_s_item_16 = value;
        break;
      case 17:
        _struct._unique_s_item_17 = value;
        break;
      case 18:
        _struct._unique_s_item_18 = value;
        break;
      case 19:
        _struct._unique_s_item_19 = value;
        break;
      case 20:
        _struct._unique_s_item_20 = value;
        break;
      case 21:
        _struct._unique_s_item_21 = value;
        break;
      case 22:
        _struct._unique_s_item_22 = value;
        break;
      case 23:
        _struct._unique_s_item_23 = value;
        break;
      case 24:
        _struct._unique_s_item_24 = value;
        break;
      case 25:
        _struct._unique_s_item_25 = value;
        break;
      case 26:
        _struct._unique_s_item_26 = value;
        break;
      case 27:
        _struct._unique_s_item_27 = value;
        break;
      case 28:
        _struct._unique_s_item_28 = value;
        break;
      case 29:
        _struct._unique_s_item_29 = value;
        break;
      case 30:
        _struct._unique_s_item_30 = value;
        break;
      case 31:
        _struct._unique_s_item_31 = value;
        break;
      case 32:
        _struct._unique_s_item_32 = value;
        break;
      case 33:
        _struct._unique_s_item_33 = value;
        break;
      case 34:
        _struct._unique_s_item_34 = value;
        break;
      case 35:
        _struct._unique_s_item_35 = value;
        break;
      case 36:
        _struct._unique_s_item_36 = value;
        break;
      case 37:
        _struct._unique_s_item_37 = value;
        break;
      case 38:
        _struct._unique_s_item_38 = value;
        break;
      case 39:
        _struct._unique_s_item_39 = value;
        break;
      case 40:
        _struct._unique_s_item_40 = value;
        break;
      case 41:
        _struct._unique_s_item_41 = value;
        break;
      case 42:
        _struct._unique_s_item_42 = value;
        break;
      case 43:
        _struct._unique_s_item_43 = value;
        break;
      case 44:
        _struct._unique_s_item_44 = value;
        break;
      case 45:
        _struct._unique_s_item_45 = value;
        break;
      case 46:
        _struct._unique_s_item_46 = value;
        break;
      case 47:
        _struct._unique_s_item_47 = value;
        break;
      case 48:
        _struct._unique_s_item_48 = value;
        break;
      case 49:
        _struct._unique_s_item_49 = value;
        break;
      case 50:
        _struct._unique_s_item_50 = value;
        break;
      case 51:
        _struct._unique_s_item_51 = value;
        break;
      case 52:
        _struct._unique_s_item_52 = value;
        break;
      case 53:
        _struct._unique_s_item_53 = value;
        break;
      case 54:
        _struct._unique_s_item_54 = value;
        break;
      case 55:
        _struct._unique_s_item_55 = value;
        break;
      case 56:
        _struct._unique_s_item_56 = value;
        break;
      case 57:
        _struct._unique_s_item_57 = value;
        break;
      case 58:
        _struct._unique_s_item_58 = value;
        break;
      case 59:
        _struct._unique_s_item_59 = value;
        break;
      case 60:
        _struct._unique_s_item_60 = value;
        break;
      case 61:
        _struct._unique_s_item_61 = value;
        break;
      case 62:
        _struct._unique_s_item_62 = value;
        break;
      case 63:
        _struct._unique_s_item_63 = value;
        break;
      case 64:
        _struct._unique_s_item_64 = value;
        break;
      case 65:
        _struct._unique_s_item_65 = value;
        break;
      case 66:
        _struct._unique_s_item_66 = value;
        break;
      case 67:
        _struct._unique_s_item_67 = value;
        break;
      case 68:
        _struct._unique_s_item_68 = value;
        break;
      case 69:
        _struct._unique_s_item_69 = value;
        break;
      case 70:
        _struct._unique_s_item_70 = value;
        break;
      case 71:
        _struct._unique_s_item_71 = value;
        break;
      case 72:
        _struct._unique_s_item_72 = value;
        break;
      case 73:
        _struct._unique_s_item_73 = value;
        break;
      case 74:
        _struct._unique_s_item_74 = value;
        break;
      case 75:
        _struct._unique_s_item_75 = value;
        break;
      case 76:
        _struct._unique_s_item_76 = value;
        break;
      case 77:
        _struct._unique_s_item_77 = value;
        break;
      case 78:
        _struct._unique_s_item_78 = value;
        break;
      case 79:
        _struct._unique_s_item_79 = value;
        break;
      case 80:
        _struct._unique_s_item_80 = value;
        break;
      case 81:
        _struct._unique_s_item_81 = value;
        break;
      case 82:
        _struct._unique_s_item_82 = value;
        break;
      case 83:
        _struct._unique_s_item_83 = value;
        break;
      case 84:
        _struct._unique_s_item_84 = value;
        break;
      case 85:
        _struct._unique_s_item_85 = value;
        break;
      case 86:
        _struct._unique_s_item_86 = value;
        break;
      case 87:
        _struct._unique_s_item_87 = value;
        break;
      case 88:
        _struct._unique_s_item_88 = value;
        break;
      case 89:
        _struct._unique_s_item_89 = value;
        break;
      case 90:
        _struct._unique_s_item_90 = value;
        break;
      case 91:
        _struct._unique_s_item_91 = value;
        break;
      case 92:
        _struct._unique_s_item_92 = value;
        break;
      case 93:
        _struct._unique_s_item_93 = value;
        break;
      case 94:
        _struct._unique_s_item_94 = value;
        break;
      case 95:
        _struct._unique_s_item_95 = value;
        break;
      case 96:
        _struct._unique_s_item_96 = value;
        break;
      case 97:
        _struct._unique_s_item_97 = value;
        break;
      case 98:
        _struct._unique_s_item_98 = value;
        break;
      case 99:
        _struct._unique_s_item_99 = value;
        break;
      case 100:
        _struct._unique_s_item_100 = value;
        break;
      case 101:
        _struct._unique_s_item_101 = value;
        break;
      case 102:
        _struct._unique_s_item_102 = value;
        break;
      case 103:
        _struct._unique_s_item_103 = value;
        break;
      case 104:
        _struct._unique_s_item_104 = value;
        break;
      case 105:
        _struct._unique_s_item_105 = value;
        break;
      case 106:
        _struct._unique_s_item_106 = value;
        break;
      case 107:
        _struct._unique_s_item_107 = value;
        break;
      case 108:
        _struct._unique_s_item_108 = value;
        break;
      case 109:
        _struct._unique_s_item_109 = value;
        break;
      case 110:
        _struct._unique_s_item_110 = value;
        break;
      case 111:
        _struct._unique_s_item_111 = value;
        break;
      case 112:
        _struct._unique_s_item_112 = value;
        break;
      case 113:
        _struct._unique_s_item_113 = value;
        break;
      case 114:
        _struct._unique_s_item_114 = value;
        break;
      case 115:
        _struct._unique_s_item_115 = value;
        break;
      case 116:
        _struct._unique_s_item_116 = value;
        break;
      case 117:
        _struct._unique_s_item_117 = value;
        break;
      case 118:
        _struct._unique_s_item_118 = value;
        break;
      case 119:
        _struct._unique_s_item_119 = value;
        break;
      case 120:
        _struct._unique_s_item_120 = value;
        break;
      case 121:
        _struct._unique_s_item_121 = value;
        break;
      case 122:
        _struct._unique_s_item_122 = value;
        break;
      case 123:
        _struct._unique_s_item_123 = value;
        break;
      case 124:
        _struct._unique_s_item_124 = value;
        break;
      case 125:
        _struct._unique_s_item_125 = value;
        break;
      case 126:
        _struct._unique_s_item_126 = value;
        break;
      case 127:
        _struct._unique_s_item_127 = value;
        break;
      case 128:
        _struct._unique_s_item_128 = value;
        break;
      case 129:
        _struct._unique_s_item_129 = value;
        break;
      case 130:
        _struct._unique_s_item_130 = value;
        break;
      case 131:
        _struct._unique_s_item_131 = value;
        break;
      case 132:
        _struct._unique_s_item_132 = value;
        break;
      case 133:
        _struct._unique_s_item_133 = value;
        break;
      case 134:
        _struct._unique_s_item_134 = value;
        break;
      case 135:
        _struct._unique_s_item_135 = value;
        break;
      case 136:
        _struct._unique_s_item_136 = value;
        break;
      case 137:
        _struct._unique_s_item_137 = value;
        break;
      case 138:
        _struct._unique_s_item_138 = value;
        break;
      case 139:
        _struct._unique_s_item_139 = value;
        break;
      case 140:
        _struct._unique_s_item_140 = value;
        break;
      case 141:
        _struct._unique_s_item_141 = value;
        break;
      case 142:
        _struct._unique_s_item_142 = value;
        break;
      case 143:
        _struct._unique_s_item_143 = value;
        break;
      case 144:
        _struct._unique_s_item_144 = value;
        break;
      case 145:
        _struct._unique_s_item_145 = value;
        break;
      case 146:
        _struct._unique_s_item_146 = value;
        break;
      case 147:
        _struct._unique_s_item_147 = value;
        break;
      case 148:
        _struct._unique_s_item_148 = value;
        break;
      case 149:
        _struct._unique_s_item_149 = value;
        break;
      case 150:
        _struct._unique_s_item_150 = value;
        break;
      case 151:
        _struct._unique_s_item_151 = value;
        break;
      case 152:
        _struct._unique_s_item_152 = value;
        break;
      case 153:
        _struct._unique_s_item_153 = value;
        break;
      case 154:
        _struct._unique_s_item_154 = value;
        break;
      case 155:
        _struct._unique_s_item_155 = value;
        break;
      case 156:
        _struct._unique_s_item_156 = value;
        break;
      case 157:
        _struct._unique_s_item_157 = value;
        break;
      case 158:
        _struct._unique_s_item_158 = value;
        break;
      case 159:
        _struct._unique_s_item_159 = value;
        break;
      case 160:
        _struct._unique_s_item_160 = value;
        break;
      case 161:
        _struct._unique_s_item_161 = value;
        break;
      case 162:
        _struct._unique_s_item_162 = value;
        break;
      case 163:
        _struct._unique_s_item_163 = value;
        break;
      case 164:
        _struct._unique_s_item_164 = value;
        break;
      case 165:
        _struct._unique_s_item_165 = value;
        break;
      case 166:
        _struct._unique_s_item_166 = value;
        break;
      case 167:
        _struct._unique_s_item_167 = value;
        break;
      case 168:
        _struct._unique_s_item_168 = value;
        break;
      case 169:
        _struct._unique_s_item_169 = value;
        break;
      case 170:
        _struct._unique_s_item_170 = value;
        break;
      case 171:
        _struct._unique_s_item_171 = value;
        break;
      case 172:
        _struct._unique_s_item_172 = value;
        break;
      case 173:
        _struct._unique_s_item_173 = value;
        break;
      case 174:
        _struct._unique_s_item_174 = value;
        break;
      case 175:
        _struct._unique_s_item_175 = value;
        break;
      case 176:
        _struct._unique_s_item_176 = value;
        break;
      case 177:
        _struct._unique_s_item_177 = value;
        break;
      case 178:
        _struct._unique_s_item_178 = value;
        break;
      case 179:
        _struct._unique_s_item_179 = value;
        break;
      case 180:
        _struct._unique_s_item_180 = value;
        break;
      case 181:
        _struct._unique_s_item_181 = value;
        break;
      case 182:
        _struct._unique_s_item_182 = value;
        break;
      case 183:
        _struct._unique_s_item_183 = value;
        break;
      case 184:
        _struct._unique_s_item_184 = value;
        break;
      case 185:
        _struct._unique_s_item_185 = value;
        break;
      case 186:
        _struct._unique_s_item_186 = value;
        break;
      case 187:
        _struct._unique_s_item_187 = value;
        break;
      case 188:
        _struct._unique_s_item_188 = value;
        break;
      case 189:
        _struct._unique_s_item_189 = value;
        break;
      case 190:
        _struct._unique_s_item_190 = value;
        break;
      case 191:
        _struct._unique_s_item_191 = value;
        break;
      case 192:
        _struct._unique_s_item_192 = value;
        break;
      case 193:
        _struct._unique_s_item_193 = value;
        break;
      case 194:
        _struct._unique_s_item_194 = value;
        break;
      case 195:
        _struct._unique_s_item_195 = value;
        break;
      case 196:
        _struct._unique_s_item_196 = value;
        break;
      case 197:
        _struct._unique_s_item_197 = value;
        break;
      case 198:
        _struct._unique_s_item_198 = value;
        break;
      case 199:
        _struct._unique_s_item_199 = value;
        break;
      case 200:
        _struct._unique_s_item_200 = value;
        break;
      case 201:
        _struct._unique_s_item_201 = value;
        break;
      case 202:
        _struct._unique_s_item_202 = value;
        break;
      case 203:
        _struct._unique_s_item_203 = value;
        break;
      case 204:
        _struct._unique_s_item_204 = value;
        break;
      case 205:
        _struct._unique_s_item_205 = value;
        break;
      case 206:
        _struct._unique_s_item_206 = value;
        break;
      case 207:
        _struct._unique_s_item_207 = value;
        break;
      case 208:
        _struct._unique_s_item_208 = value;
        break;
      case 209:
        _struct._unique_s_item_209 = value;
        break;
      case 210:
        _struct._unique_s_item_210 = value;
        break;
      case 211:
        _struct._unique_s_item_211 = value;
        break;
      case 212:
        _struct._unique_s_item_212 = value;
        break;
      case 213:
        _struct._unique_s_item_213 = value;
        break;
      case 214:
        _struct._unique_s_item_214 = value;
        break;
      case 215:
        _struct._unique_s_item_215 = value;
        break;
      case 216:
        _struct._unique_s_item_216 = value;
        break;
      case 217:
        _struct._unique_s_item_217 = value;
        break;
      case 218:
        _struct._unique_s_item_218 = value;
        break;
      case 219:
        _struct._unique_s_item_219 = value;
        break;
      case 220:
        _struct._unique_s_item_220 = value;
        break;
      case 221:
        _struct._unique_s_item_221 = value;
        break;
      case 222:
        _struct._unique_s_item_222 = value;
        break;
      case 223:
        _struct._unique_s_item_223 = value;
        break;
      case 224:
        _struct._unique_s_item_224 = value;
        break;
      case 225:
        _struct._unique_s_item_225 = value;
        break;
      case 226:
        _struct._unique_s_item_226 = value;
        break;
      case 227:
        _struct._unique_s_item_227 = value;
        break;
      case 228:
        _struct._unique_s_item_228 = value;
        break;
      case 229:
        _struct._unique_s_item_229 = value;
        break;
      case 230:
        _struct._unique_s_item_230 = value;
        break;
      case 231:
        _struct._unique_s_item_231 = value;
        break;
      case 232:
        _struct._unique_s_item_232 = value;
        break;
      case 233:
        _struct._unique_s_item_233 = value;
        break;
      case 234:
        _struct._unique_s_item_234 = value;
        break;
      case 235:
        _struct._unique_s_item_235 = value;
        break;
      case 236:
        _struct._unique_s_item_236 = value;
        break;
      case 237:
        _struct._unique_s_item_237 = value;
        break;
      case 238:
        _struct._unique_s_item_238 = value;
        break;
      case 239:
        _struct._unique_s_item_239 = value;
        break;
      case 240:
        _struct._unique_s_item_240 = value;
        break;
      case 241:
        _struct._unique_s_item_241 = value;
        break;
      case 242:
        _struct._unique_s_item_242 = value;
        break;
      case 243:
        _struct._unique_s_item_243 = value;
        break;
      case 244:
        _struct._unique_s_item_244 = value;
        break;
      case 245:
        _struct._unique_s_item_245 = value;
        break;
      case 246:
        _struct._unique_s_item_246 = value;
        break;
      case 247:
        _struct._unique_s_item_247 = value;
        break;
      case 248:
        _struct._unique_s_item_248 = value;
        break;
      case 249:
        _struct._unique_s_item_249 = value;
        break;
      case 250:
        _struct._unique_s_item_250 = value;
        break;
      case 251:
        _struct._unique_s_item_251 = value;
        break;
      case 252:
        _struct._unique_s_item_252 = value;
        break;
      case 253:
        _struct._unique_s_item_253 = value;
        break;
      case 254:
        _struct._unique_s_item_254 = value;
        break;
      case 255:
        _struct._unique_s_item_255 = value;
        break;
      case 256:
        _struct._unique_s_item_256 = value;
        break;
      case 257:
        _struct._unique_s_item_257 = value;
        break;
      case 258:
        _struct._unique_s_item_258 = value;
        break;
      case 259:
        _struct._unique_s_item_259 = value;
        break;
      case 260:
        _struct._unique_s_item_260 = value;
        break;
      case 261:
        _struct._unique_s_item_261 = value;
        break;
      case 262:
        _struct._unique_s_item_262 = value;
        break;
      case 263:
        _struct._unique_s_item_263 = value;
        break;
      case 264:
        _struct._unique_s_item_264 = value;
        break;
      case 265:
        _struct._unique_s_item_265 = value;
        break;
      case 266:
        _struct._unique_s_item_266 = value;
        break;
      case 267:
        _struct._unique_s_item_267 = value;
        break;
      case 268:
        _struct._unique_s_item_268 = value;
        break;
      case 269:
        _struct._unique_s_item_269 = value;
        break;
      case 270:
        _struct._unique_s_item_270 = value;
        break;
      case 271:
        _struct._unique_s_item_271 = value;
        break;
      case 272:
        _struct._unique_s_item_272 = value;
        break;
      case 273:
        _struct._unique_s_item_273 = value;
        break;
      case 274:
        _struct._unique_s_item_274 = value;
        break;
      case 275:
        _struct._unique_s_item_275 = value;
        break;
      case 276:
        _struct._unique_s_item_276 = value;
        break;
      case 277:
        _struct._unique_s_item_277 = value;
        break;
      case 278:
        _struct._unique_s_item_278 = value;
        break;
      case 279:
        _struct._unique_s_item_279 = value;
        break;
      case 280:
        _struct._unique_s_item_280 = value;
        break;
      case 281:
        _struct._unique_s_item_281 = value;
        break;
      case 282:
        _struct._unique_s_item_282 = value;
        break;
      case 283:
        _struct._unique_s_item_283 = value;
        break;
      case 284:
        _struct._unique_s_item_284 = value;
        break;
      case 285:
        _struct._unique_s_item_285 = value;
        break;
      case 286:
        _struct._unique_s_item_286 = value;
        break;
      case 287:
        _struct._unique_s_item_287 = value;
        break;
      case 288:
        _struct._unique_s_item_288 = value;
        break;
      case 289:
        _struct._unique_s_item_289 = value;
        break;
      case 290:
        _struct._unique_s_item_290 = value;
        break;
      case 291:
        _struct._unique_s_item_291 = value;
        break;
      case 292:
        _struct._unique_s_item_292 = value;
        break;
      case 293:
        _struct._unique_s_item_293 = value;
        break;
      case 294:
        _struct._unique_s_item_294 = value;
        break;
      case 295:
        _struct._unique_s_item_295 = value;
        break;
      case 296:
        _struct._unique_s_item_296 = value;
        break;
      case 297:
        _struct._unique_s_item_297 = value;
        break;
      case 298:
        _struct._unique_s_item_298 = value;
        break;
      case 299:
        _struct._unique_s_item_299 = value;
        break;
      case 300:
        _struct._unique_s_item_300 = value;
        break;
      case 301:
        _struct._unique_s_item_301 = value;
        break;
      case 302:
        _struct._unique_s_item_302 = value;
        break;
      case 303:
        _struct._unique_s_item_303 = value;
        break;
      case 304:
        _struct._unique_s_item_304 = value;
        break;
      case 305:
        _struct._unique_s_item_305 = value;
        break;
      case 306:
        _struct._unique_s_item_306 = value;
        break;
      case 307:
        _struct._unique_s_item_307 = value;
        break;
      case 308:
        _struct._unique_s_item_308 = value;
        break;
      case 309:
        _struct._unique_s_item_309 = value;
        break;
      case 310:
        _struct._unique_s_item_310 = value;
        break;
      case 311:
        _struct._unique_s_item_311 = value;
        break;
      case 312:
        _struct._unique_s_item_312 = value;
        break;
      case 313:
        _struct._unique_s_item_313 = value;
        break;
      case 314:
        _struct._unique_s_item_314 = value;
        break;
      case 315:
        _struct._unique_s_item_315 = value;
        break;
      case 316:
        _struct._unique_s_item_316 = value;
        break;
      case 317:
        _struct._unique_s_item_317 = value;
        break;
      case 318:
        _struct._unique_s_item_318 = value;
        break;
      case 319:
        _struct._unique_s_item_319 = value;
        break;
      case 320:
        _struct._unique_s_item_320 = value;
        break;
      case 321:
        _struct._unique_s_item_321 = value;
        break;
      case 322:
        _struct._unique_s_item_322 = value;
        break;
      case 323:
        _struct._unique_s_item_323 = value;
        break;
      case 324:
        _struct._unique_s_item_324 = value;
        break;
      case 325:
        _struct._unique_s_item_325 = value;
        break;
      case 326:
        _struct._unique_s_item_326 = value;
        break;
      case 327:
        _struct._unique_s_item_327 = value;
        break;
      case 328:
        _struct._unique_s_item_328 = value;
        break;
      case 329:
        _struct._unique_s_item_329 = value;
        break;
      case 330:
        _struct._unique_s_item_330 = value;
        break;
      case 331:
        _struct._unique_s_item_331 = value;
        break;
      case 332:
        _struct._unique_s_item_332 = value;
        break;
      case 333:
        _struct._unique_s_item_333 = value;
        break;
      case 334:
        _struct._unique_s_item_334 = value;
        break;
      case 335:
        _struct._unique_s_item_335 = value;
        break;
      case 336:
        _struct._unique_s_item_336 = value;
        break;
      case 337:
        _struct._unique_s_item_337 = value;
        break;
      case 338:
        _struct._unique_s_item_338 = value;
        break;
      case 339:
        _struct._unique_s_item_339 = value;
        break;
      case 340:
        _struct._unique_s_item_340 = value;
        break;
      case 341:
        _struct._unique_s_item_341 = value;
        break;
      case 342:
        _struct._unique_s_item_342 = value;
        break;
      case 343:
        _struct._unique_s_item_343 = value;
        break;
      case 344:
        _struct._unique_s_item_344 = value;
        break;
      case 345:
        _struct._unique_s_item_345 = value;
        break;
      case 346:
        _struct._unique_s_item_346 = value;
        break;
      case 347:
        _struct._unique_s_item_347 = value;
        break;
      case 348:
        _struct._unique_s_item_348 = value;
        break;
      case 349:
        _struct._unique_s_item_349 = value;
        break;
      case 350:
        _struct._unique_s_item_350 = value;
        break;
      case 351:
        _struct._unique_s_item_351 = value;
        break;
      case 352:
        _struct._unique_s_item_352 = value;
        break;
      case 353:
        _struct._unique_s_item_353 = value;
        break;
      case 354:
        _struct._unique_s_item_354 = value;
        break;
      case 355:
        _struct._unique_s_item_355 = value;
        break;
      case 356:
        _struct._unique_s_item_356 = value;
        break;
      case 357:
        _struct._unique_s_item_357 = value;
        break;
      case 358:
        _struct._unique_s_item_358 = value;
        break;
      case 359:
        _struct._unique_s_item_359 = value;
        break;
      case 360:
        _struct._unique_s_item_360 = value;
        break;
      case 361:
        _struct._unique_s_item_361 = value;
        break;
      case 362:
        _struct._unique_s_item_362 = value;
        break;
      case 363:
        _struct._unique_s_item_363 = value;
        break;
      case 364:
        _struct._unique_s_item_364 = value;
        break;
      case 365:
        _struct._unique_s_item_365 = value;
        break;
      case 366:
        _struct._unique_s_item_366 = value;
        break;
      case 367:
        _struct._unique_s_item_367 = value;
        break;
      case 368:
        _struct._unique_s_item_368 = value;
        break;
      case 369:
        _struct._unique_s_item_369 = value;
        break;
      case 370:
        _struct._unique_s_item_370 = value;
        break;
      case 371:
        _struct._unique_s_item_371 = value;
        break;
      case 372:
        _struct._unique_s_item_372 = value;
        break;
      case 373:
        _struct._unique_s_item_373 = value;
        break;
      case 374:
        _struct._unique_s_item_374 = value;
        break;
      case 375:
        _struct._unique_s_item_375 = value;
        break;
      case 376:
        _struct._unique_s_item_376 = value;
        break;
      case 377:
        _struct._unique_s_item_377 = value;
        break;
      case 378:
        _struct._unique_s_item_378 = value;
        break;
      case 379:
        _struct._unique_s_item_379 = value;
        break;
      case 380:
        _struct._unique_s_item_380 = value;
        break;
      case 381:
        _struct._unique_s_item_381 = value;
        break;
      case 382:
        _struct._unique_s_item_382 = value;
        break;
      case 383:
        _struct._unique_s_item_383 = value;
        break;
      case 384:
        _struct._unique_s_item_384 = value;
        break;
      case 385:
        _struct._unique_s_item_385 = value;
        break;
      case 386:
        _struct._unique_s_item_386 = value;
        break;
      case 387:
        _struct._unique_s_item_387 = value;
        break;
      case 388:
        _struct._unique_s_item_388 = value;
        break;
      case 389:
        _struct._unique_s_item_389 = value;
        break;
      case 390:
        _struct._unique_s_item_390 = value;
        break;
      case 391:
        _struct._unique_s_item_391 = value;
        break;
      case 392:
        _struct._unique_s_item_392 = value;
        break;
      case 393:
        _struct._unique_s_item_393 = value;
        break;
      case 394:
        _struct._unique_s_item_394 = value;
        break;
      case 395:
        _struct._unique_s_item_395 = value;
        break;
      case 396:
        _struct._unique_s_item_396 = value;
        break;
      case 397:
        _struct._unique_s_item_397 = value;
        break;
      case 398:
        _struct._unique_s_item_398 = value;
        break;
      case 399:
        _struct._unique_s_item_399 = value;
        break;
      case 400:
        _struct._unique_s_item_400 = value;
        break;
      case 401:
        _struct._unique_s_item_401 = value;
        break;
      case 402:
        _struct._unique_s_item_402 = value;
        break;
      case 403:
        _struct._unique_s_item_403 = value;
        break;
      case 404:
        _struct._unique_s_item_404 = value;
        break;
      case 405:
        _struct._unique_s_item_405 = value;
        break;
      case 406:
        _struct._unique_s_item_406 = value;
        break;
      case 407:
        _struct._unique_s_item_407 = value;
        break;
      case 408:
        _struct._unique_s_item_408 = value;
        break;
      case 409:
        _struct._unique_s_item_409 = value;
        break;
      case 410:
        _struct._unique_s_item_410 = value;
        break;
      case 411:
        _struct._unique_s_item_411 = value;
        break;
      case 412:
        _struct._unique_s_item_412 = value;
        break;
      case 413:
        _struct._unique_s_item_413 = value;
        break;
      case 414:
        _struct._unique_s_item_414 = value;
        break;
      case 415:
        _struct._unique_s_item_415 = value;
        break;
      case 416:
        _struct._unique_s_item_416 = value;
        break;
      case 417:
        _struct._unique_s_item_417 = value;
        break;
      case 418:
        _struct._unique_s_item_418 = value;
        break;
      case 419:
        _struct._unique_s_item_419 = value;
        break;
      case 420:
        _struct._unique_s_item_420 = value;
        break;
      case 421:
        _struct._unique_s_item_421 = value;
        break;
      case 422:
        _struct._unique_s_item_422 = value;
        break;
      case 423:
        _struct._unique_s_item_423 = value;
        break;
      case 424:
        _struct._unique_s_item_424 = value;
        break;
      case 425:
        _struct._unique_s_item_425 = value;
        break;
      case 426:
        _struct._unique_s_item_426 = value;
        break;
      case 427:
        _struct._unique_s_item_427 = value;
        break;
      case 428:
        _struct._unique_s_item_428 = value;
        break;
      case 429:
        _struct._unique_s_item_429 = value;
        break;
      case 430:
        _struct._unique_s_item_430 = value;
        break;
      case 431:
        _struct._unique_s_item_431 = value;
        break;
      case 432:
        _struct._unique_s_item_432 = value;
        break;
      case 433:
        _struct._unique_s_item_433 = value;
        break;
      case 434:
        _struct._unique_s_item_434 = value;
        break;
      case 435:
        _struct._unique_s_item_435 = value;
        break;
      case 436:
        _struct._unique_s_item_436 = value;
        break;
      case 437:
        _struct._unique_s_item_437 = value;
        break;
      case 438:
        _struct._unique_s_item_438 = value;
        break;
      case 439:
        _struct._unique_s_item_439 = value;
        break;
      case 440:
        _struct._unique_s_item_440 = value;
        break;
      case 441:
        _struct._unique_s_item_441 = value;
        break;
      case 442:
        _struct._unique_s_item_442 = value;
        break;
      case 443:
        _struct._unique_s_item_443 = value;
        break;
      case 444:
        _struct._unique_s_item_444 = value;
        break;
      case 445:
        _struct._unique_s_item_445 = value;
        break;
      case 446:
        _struct._unique_s_item_446 = value;
        break;
      case 447:
        _struct._unique_s_item_447 = value;
        break;
      case 448:
        _struct._unique_s_item_448 = value;
        break;
      case 449:
        _struct._unique_s_item_449 = value;
        break;
      case 450:
        _struct._unique_s_item_450 = value;
        break;
      case 451:
        _struct._unique_s_item_451 = value;
        break;
      case 452:
        _struct._unique_s_item_452 = value;
        break;
      case 453:
        _struct._unique_s_item_453 = value;
        break;
      case 454:
        _struct._unique_s_item_454 = value;
        break;
      case 455:
        _struct._unique_s_item_455 = value;
        break;
      case 456:
        _struct._unique_s_item_456 = value;
        break;
      case 457:
        _struct._unique_s_item_457 = value;
        break;
      case 458:
        _struct._unique_s_item_458 = value;
        break;
      case 459:
        _struct._unique_s_item_459 = value;
        break;
      case 460:
        _struct._unique_s_item_460 = value;
        break;
      case 461:
        _struct._unique_s_item_461 = value;
        break;
      case 462:
        _struct._unique_s_item_462 = value;
        break;
      case 463:
        _struct._unique_s_item_463 = value;
        break;
      case 464:
        _struct._unique_s_item_464 = value;
        break;
      case 465:
        _struct._unique_s_item_465 = value;
        break;
      case 466:
        _struct._unique_s_item_466 = value;
        break;
      case 467:
        _struct._unique_s_item_467 = value;
        break;
      case 468:
        _struct._unique_s_item_468 = value;
        break;
      case 469:
        _struct._unique_s_item_469 = value;
        break;
      case 470:
        _struct._unique_s_item_470 = value;
        break;
      case 471:
        _struct._unique_s_item_471 = value;
        break;
      case 472:
        _struct._unique_s_item_472 = value;
        break;
      case 473:
        _struct._unique_s_item_473 = value;
        break;
      case 474:
        _struct._unique_s_item_474 = value;
        break;
      case 475:
        _struct._unique_s_item_475 = value;
        break;
      case 476:
        _struct._unique_s_item_476 = value;
        break;
      case 477:
        _struct._unique_s_item_477 = value;
        break;
      case 478:
        _struct._unique_s_item_478 = value;
        break;
      case 479:
        _struct._unique_s_item_479 = value;
        break;
      case 480:
        _struct._unique_s_item_480 = value;
        break;
      case 481:
        _struct._unique_s_item_481 = value;
        break;
      case 482:
        _struct._unique_s_item_482 = value;
        break;
      case 483:
        _struct._unique_s_item_483 = value;
        break;
      case 484:
        _struct._unique_s_item_484 = value;
        break;
      case 485:
        _struct._unique_s_item_485 = value;
        break;
      case 486:
        _struct._unique_s_item_486 = value;
        break;
      case 487:
        _struct._unique_s_item_487 = value;
        break;
      case 488:
        _struct._unique_s_item_488 = value;
        break;
      case 489:
        _struct._unique_s_item_489 = value;
        break;
      case 490:
        _struct._unique_s_item_490 = value;
        break;
      case 491:
        _struct._unique_s_item_491 = value;
        break;
      case 492:
        _struct._unique_s_item_492 = value;
        break;
      case 493:
        _struct._unique_s_item_493 = value;
        break;
      case 494:
        _struct._unique_s_item_494 = value;
        break;
      case 495:
        _struct._unique_s_item_495 = value;
        break;
      case 496:
        _struct._unique_s_item_496 = value;
        break;
      case 497:
        _struct._unique_s_item_497 = value;
        break;
      case 498:
        _struct._unique_s_item_498 = value;
        break;
      case 499:
        _struct._unique_s_item_499 = value;
        break;
      case 500:
        _struct._unique_s_item_500 = value;
        break;
      case 501:
        _struct._unique_s_item_501 = value;
        break;
      case 502:
        _struct._unique_s_item_502 = value;
        break;
      case 503:
        _struct._unique_s_item_503 = value;
        break;
      case 504:
        _struct._unique_s_item_504 = value;
        break;
      case 505:
        _struct._unique_s_item_505 = value;
        break;
      case 506:
        _struct._unique_s_item_506 = value;
        break;
      case 507:
        _struct._unique_s_item_507 = value;
        break;
      case 508:
        _struct._unique_s_item_508 = value;
        break;
      case 509:
        _struct._unique_s_item_509 = value;
        break;
      case 510:
        _struct._unique_s_item_510 = value;
        break;
      case 511:
        _struct._unique_s_item_511 = value;
        break;
      case 512:
        _struct._unique_s_item_512 = value;
        break;
      case 513:
        _struct._unique_s_item_513 = value;
        break;
      case 514:
        _struct._unique_s_item_514 = value;
        break;
      case 515:
        _struct._unique_s_item_515 = value;
        break;
      case 516:
        _struct._unique_s_item_516 = value;
        break;
      case 517:
        _struct._unique_s_item_517 = value;
        break;
      case 518:
        _struct._unique_s_item_518 = value;
        break;
      case 519:
        _struct._unique_s_item_519 = value;
        break;
      case 520:
        _struct._unique_s_item_520 = value;
        break;
      case 521:
        _struct._unique_s_item_521 = value;
        break;
      case 522:
        _struct._unique_s_item_522 = value;
        break;
      case 523:
        _struct._unique_s_item_523 = value;
        break;
      case 524:
        _struct._unique_s_item_524 = value;
        break;
      case 525:
        _struct._unique_s_item_525 = value;
        break;
      case 526:
        _struct._unique_s_item_526 = value;
        break;
      case 527:
        _struct._unique_s_item_527 = value;
        break;
      case 528:
        _struct._unique_s_item_528 = value;
        break;
      case 529:
        _struct._unique_s_item_529 = value;
        break;
      case 530:
        _struct._unique_s_item_530 = value;
        break;
      case 531:
        _struct._unique_s_item_531 = value;
        break;
      case 532:
        _struct._unique_s_item_532 = value;
        break;
      case 533:
        _struct._unique_s_item_533 = value;
        break;
      case 534:
        _struct._unique_s_item_534 = value;
        break;
      case 535:
        _struct._unique_s_item_535 = value;
        break;
      case 536:
        _struct._unique_s_item_536 = value;
        break;
      case 537:
        _struct._unique_s_item_537 = value;
        break;
      case 538:
        _struct._unique_s_item_538 = value;
        break;
      case 539:
        _struct._unique_s_item_539 = value;
        break;
      case 540:
        _struct._unique_s_item_540 = value;
        break;
      case 541:
        _struct._unique_s_item_541 = value;
        break;
      case 542:
        _struct._unique_s_item_542 = value;
        break;
      case 543:
        _struct._unique_s_item_543 = value;
        break;
      case 544:
        _struct._unique_s_item_544 = value;
        break;
      case 545:
        _struct._unique_s_item_545 = value;
        break;
      case 546:
        _struct._unique_s_item_546 = value;
        break;
      case 547:
        _struct._unique_s_item_547 = value;
        break;
      case 548:
        _struct._unique_s_item_548 = value;
        break;
      case 549:
        _struct._unique_s_item_549 = value;
        break;
      case 550:
        _struct._unique_s_item_550 = value;
        break;
      case 551:
        _struct._unique_s_item_551 = value;
        break;
      case 552:
        _struct._unique_s_item_552 = value;
        break;
      case 553:
        _struct._unique_s_item_553 = value;
        break;
      case 554:
        _struct._unique_s_item_554 = value;
        break;
      case 555:
        _struct._unique_s_item_555 = value;
        break;
      case 556:
        _struct._unique_s_item_556 = value;
        break;
      case 557:
        _struct._unique_s_item_557 = value;
        break;
      case 558:
        _struct._unique_s_item_558 = value;
        break;
      case 559:
        _struct._unique_s_item_559 = value;
        break;
      case 560:
        _struct._unique_s_item_560 = value;
        break;
      case 561:
        _struct._unique_s_item_561 = value;
        break;
      case 562:
        _struct._unique_s_item_562 = value;
        break;
      case 563:
        _struct._unique_s_item_563 = value;
        break;
      case 564:
        _struct._unique_s_item_564 = value;
        break;
      case 565:
        _struct._unique_s_item_565 = value;
        break;
      case 566:
        _struct._unique_s_item_566 = value;
        break;
      case 567:
        _struct._unique_s_item_567 = value;
        break;
      case 568:
        _struct._unique_s_item_568 = value;
        break;
      case 569:
        _struct._unique_s_item_569 = value;
        break;
      case 570:
        _struct._unique_s_item_570 = value;
        break;
      case 571:
        _struct._unique_s_item_571 = value;
        break;
      case 572:
        _struct._unique_s_item_572 = value;
        break;
      case 573:
        _struct._unique_s_item_573 = value;
        break;
      case 574:
        _struct._unique_s_item_574 = value;
        break;
      case 575:
        _struct._unique_s_item_575 = value;
        break;
      case 576:
        _struct._unique_s_item_576 = value;
        break;
      case 577:
        _struct._unique_s_item_577 = value;
        break;
      case 578:
        _struct._unique_s_item_578 = value;
        break;
      case 579:
        _struct._unique_s_item_579 = value;
        break;
      case 580:
        _struct._unique_s_item_580 = value;
        break;
      case 581:
        _struct._unique_s_item_581 = value;
        break;
      case 582:
        _struct._unique_s_item_582 = value;
        break;
      case 583:
        _struct._unique_s_item_583 = value;
        break;
      case 584:
        _struct._unique_s_item_584 = value;
        break;
      case 585:
        _struct._unique_s_item_585 = value;
        break;
      case 586:
        _struct._unique_s_item_586 = value;
        break;
      case 587:
        _struct._unique_s_item_587 = value;
        break;
      case 588:
        _struct._unique_s_item_588 = value;
        break;
      case 589:
        _struct._unique_s_item_589 = value;
        break;
      case 590:
        _struct._unique_s_item_590 = value;
        break;
      case 591:
        _struct._unique_s_item_591 = value;
        break;
      case 592:
        _struct._unique_s_item_592 = value;
        break;
      case 593:
        _struct._unique_s_item_593 = value;
        break;
      case 594:
        _struct._unique_s_item_594 = value;
        break;
      case 595:
        _struct._unique_s_item_595 = value;
        break;
      case 596:
        _struct._unique_s_item_596 = value;
        break;
      case 597:
        _struct._unique_s_item_597 = value;
        break;
      case 598:
        _struct._unique_s_item_598 = value;
        break;
      case 599:
        _struct._unique_s_item_599 = value;
        break;
      case 600:
        _struct._unique_s_item_600 = value;
        break;
      case 601:
        _struct._unique_s_item_601 = value;
        break;
      case 602:
        _struct._unique_s_item_602 = value;
        break;
      case 603:
        _struct._unique_s_item_603 = value;
        break;
      case 604:
        _struct._unique_s_item_604 = value;
        break;
      case 605:
        _struct._unique_s_item_605 = value;
        break;
      case 606:
        _struct._unique_s_item_606 = value;
        break;
      case 607:
        _struct._unique_s_item_607 = value;
        break;
      case 608:
        _struct._unique_s_item_608 = value;
        break;
      case 609:
        _struct._unique_s_item_609 = value;
        break;
      case 610:
        _struct._unique_s_item_610 = value;
        break;
      case 611:
        _struct._unique_s_item_611 = value;
        break;
      case 612:
        _struct._unique_s_item_612 = value;
        break;
      case 613:
        _struct._unique_s_item_613 = value;
        break;
      case 614:
        _struct._unique_s_item_614 = value;
        break;
      case 615:
        _struct._unique_s_item_615 = value;
        break;
      case 616:
        _struct._unique_s_item_616 = value;
        break;
      case 617:
        _struct._unique_s_item_617 = value;
        break;
      case 618:
        _struct._unique_s_item_618 = value;
        break;
      case 619:
        _struct._unique_s_item_619 = value;
        break;
      case 620:
        _struct._unique_s_item_620 = value;
        break;
      case 621:
        _struct._unique_s_item_621 = value;
        break;
      case 622:
        _struct._unique_s_item_622 = value;
        break;
      case 623:
        _struct._unique_s_item_623 = value;
        break;
      case 624:
        _struct._unique_s_item_624 = value;
        break;
      case 625:
        _struct._unique_s_item_625 = value;
        break;
      case 626:
        _struct._unique_s_item_626 = value;
        break;
      case 627:
        _struct._unique_s_item_627 = value;
        break;
      case 628:
        _struct._unique_s_item_628 = value;
        break;
      case 629:
        _struct._unique_s_item_629 = value;
        break;
      case 630:
        _struct._unique_s_item_630 = value;
        break;
      case 631:
        _struct._unique_s_item_631 = value;
        break;
      case 632:
        _struct._unique_s_item_632 = value;
        break;
      case 633:
        _struct._unique_s_item_633 = value;
        break;
      case 634:
        _struct._unique_s_item_634 = value;
        break;
      case 635:
        _struct._unique_s_item_635 = value;
        break;
      case 636:
        _struct._unique_s_item_636 = value;
        break;
      case 637:
        _struct._unique_s_item_637 = value;
        break;
      case 638:
        _struct._unique_s_item_638 = value;
        break;
      case 639:
        _struct._unique_s_item_639 = value;
        break;
      case 640:
        _struct._unique_s_item_640 = value;
        break;
      case 641:
        _struct._unique_s_item_641 = value;
        break;
      case 642:
        _struct._unique_s_item_642 = value;
        break;
      case 643:
        _struct._unique_s_item_643 = value;
        break;
      case 644:
        _struct._unique_s_item_644 = value;
        break;
      case 645:
        _struct._unique_s_item_645 = value;
        break;
      case 646:
        _struct._unique_s_item_646 = value;
        break;
      case 647:
        _struct._unique_s_item_647 = value;
        break;
      case 648:
        _struct._unique_s_item_648 = value;
        break;
      case 649:
        _struct._unique_s_item_649 = value;
        break;
      case 650:
        _struct._unique_s_item_650 = value;
        break;
      case 651:
        _struct._unique_s_item_651 = value;
        break;
      case 652:
        _struct._unique_s_item_652 = value;
        break;
      case 653:
        _struct._unique_s_item_653 = value;
        break;
      case 654:
        _struct._unique_s_item_654 = value;
        break;
      case 655:
        _struct._unique_s_item_655 = value;
        break;
      case 656:
        _struct._unique_s_item_656 = value;
        break;
      case 657:
        _struct._unique_s_item_657 = value;
        break;
      case 658:
        _struct._unique_s_item_658 = value;
        break;
      case 659:
        _struct._unique_s_item_659 = value;
        break;
      case 660:
        _struct._unique_s_item_660 = value;
        break;
      case 661:
        _struct._unique_s_item_661 = value;
        break;
      case 662:
        _struct._unique_s_item_662 = value;
        break;
      case 663:
        _struct._unique_s_item_663 = value;
        break;
      case 664:
        _struct._unique_s_item_664 = value;
        break;
      case 665:
        _struct._unique_s_item_665 = value;
        break;
      case 666:
        _struct._unique_s_item_666 = value;
        break;
      case 667:
        _struct._unique_s_item_667 = value;
        break;
      case 668:
        _struct._unique_s_item_668 = value;
        break;
      case 669:
        _struct._unique_s_item_669 = value;
        break;
      case 670:
        _struct._unique_s_item_670 = value;
        break;
      case 671:
        _struct._unique_s_item_671 = value;
        break;
      case 672:
        _struct._unique_s_item_672 = value;
        break;
      case 673:
        _struct._unique_s_item_673 = value;
        break;
      case 674:
        _struct._unique_s_item_674 = value;
        break;
      case 675:
        _struct._unique_s_item_675 = value;
        break;
      case 676:
        _struct._unique_s_item_676 = value;
        break;
      case 677:
        _struct._unique_s_item_677 = value;
        break;
      case 678:
        _struct._unique_s_item_678 = value;
        break;
      case 679:
        _struct._unique_s_item_679 = value;
        break;
      case 680:
        _struct._unique_s_item_680 = value;
        break;
      case 681:
        _struct._unique_s_item_681 = value;
        break;
      case 682:
        _struct._unique_s_item_682 = value;
        break;
      case 683:
        _struct._unique_s_item_683 = value;
        break;
      case 684:
        _struct._unique_s_item_684 = value;
        break;
      case 685:
        _struct._unique_s_item_685 = value;
        break;
      case 686:
        _struct._unique_s_item_686 = value;
        break;
      case 687:
        _struct._unique_s_item_687 = value;
        break;
      case 688:
        _struct._unique_s_item_688 = value;
        break;
      case 689:
        _struct._unique_s_item_689 = value;
        break;
      case 690:
        _struct._unique_s_item_690 = value;
        break;
      case 691:
        _struct._unique_s_item_691 = value;
        break;
      case 692:
        _struct._unique_s_item_692 = value;
        break;
      case 693:
        _struct._unique_s_item_693 = value;
        break;
      case 694:
        _struct._unique_s_item_694 = value;
        break;
      case 695:
        _struct._unique_s_item_695 = value;
        break;
      case 696:
        _struct._unique_s_item_696 = value;
        break;
      case 697:
        _struct._unique_s_item_697 = value;
        break;
      case 698:
        _struct._unique_s_item_698 = value;
        break;
      case 699:
        _struct._unique_s_item_699 = value;
        break;
      case 700:
        _struct._unique_s_item_700 = value;
        break;
      case 701:
        _struct._unique_s_item_701 = value;
        break;
      case 702:
        _struct._unique_s_item_702 = value;
        break;
      case 703:
        _struct._unique_s_item_703 = value;
        break;
      case 704:
        _struct._unique_s_item_704 = value;
        break;
      case 705:
        _struct._unique_s_item_705 = value;
        break;
      case 706:
        _struct._unique_s_item_706 = value;
        break;
      case 707:
        _struct._unique_s_item_707 = value;
        break;
      case 708:
        _struct._unique_s_item_708 = value;
        break;
      case 709:
        _struct._unique_s_item_709 = value;
        break;
      case 710:
        _struct._unique_s_item_710 = value;
        break;
      case 711:
        _struct._unique_s_item_711 = value;
        break;
      case 712:
        _struct._unique_s_item_712 = value;
        break;
      case 713:
        _struct._unique_s_item_713 = value;
        break;
      case 714:
        _struct._unique_s_item_714 = value;
        break;
      case 715:
        _struct._unique_s_item_715 = value;
        break;
      case 716:
        _struct._unique_s_item_716 = value;
        break;
      case 717:
        _struct._unique_s_item_717 = value;
        break;
      case 718:
        _struct._unique_s_item_718 = value;
        break;
      case 719:
        _struct._unique_s_item_719 = value;
        break;
      case 720:
        _struct._unique_s_item_720 = value;
        break;
      case 721:
        _struct._unique_s_item_721 = value;
        break;
      case 722:
        _struct._unique_s_item_722 = value;
        break;
      case 723:
        _struct._unique_s_item_723 = value;
        break;
      case 724:
        _struct._unique_s_item_724 = value;
        break;
      case 725:
        _struct._unique_s_item_725 = value;
        break;
      case 726:
        _struct._unique_s_item_726 = value;
        break;
      case 727:
        _struct._unique_s_item_727 = value;
        break;
      case 728:
        _struct._unique_s_item_728 = value;
        break;
      case 729:
        _struct._unique_s_item_729 = value;
        break;
      case 730:
        _struct._unique_s_item_730 = value;
        break;
      case 731:
        _struct._unique_s_item_731 = value;
        break;
      case 732:
        _struct._unique_s_item_732 = value;
        break;
      case 733:
        _struct._unique_s_item_733 = value;
        break;
      case 734:
        _struct._unique_s_item_734 = value;
        break;
      case 735:
        _struct._unique_s_item_735 = value;
        break;
      case 736:
        _struct._unique_s_item_736 = value;
        break;
      case 737:
        _struct._unique_s_item_737 = value;
        break;
      case 738:
        _struct._unique_s_item_738 = value;
        break;
      case 739:
        _struct._unique_s_item_739 = value;
        break;
      case 740:
        _struct._unique_s_item_740 = value;
        break;
      case 741:
        _struct._unique_s_item_741 = value;
        break;
      case 742:
        _struct._unique_s_item_742 = value;
        break;
      case 743:
        _struct._unique_s_item_743 = value;
        break;
      case 744:
        _struct._unique_s_item_744 = value;
        break;
      case 745:
        _struct._unique_s_item_745 = value;
        break;
      case 746:
        _struct._unique_s_item_746 = value;
        break;
      case 747:
        _struct._unique_s_item_747 = value;
        break;
      case 748:
        _struct._unique_s_item_748 = value;
        break;
      case 749:
        _struct._unique_s_item_749 = value;
        break;
      case 750:
        _struct._unique_s_item_750 = value;
        break;
      case 751:
        _struct._unique_s_item_751 = value;
        break;
      case 752:
        _struct._unique_s_item_752 = value;
        break;
      case 753:
        _struct._unique_s_item_753 = value;
        break;
      case 754:
        _struct._unique_s_item_754 = value;
        break;
      case 755:
        _struct._unique_s_item_755 = value;
        break;
      case 756:
        _struct._unique_s_item_756 = value;
        break;
      case 757:
        _struct._unique_s_item_757 = value;
        break;
      case 758:
        _struct._unique_s_item_758 = value;
        break;
      case 759:
        _struct._unique_s_item_759 = value;
        break;
      case 760:
        _struct._unique_s_item_760 = value;
        break;
      case 761:
        _struct._unique_s_item_761 = value;
        break;
      case 762:
        _struct._unique_s_item_762 = value;
        break;
      case 763:
        _struct._unique_s_item_763 = value;
        break;
      case 764:
        _struct._unique_s_item_764 = value;
        break;
      case 765:
        _struct._unique_s_item_765 = value;
        break;
      case 766:
        _struct._unique_s_item_766 = value;
        break;
      case 767:
        _struct._unique_s_item_767 = value;
        break;
      case 768:
        _struct._unique_s_item_768 = value;
        break;
      case 769:
        _struct._unique_s_item_769 = value;
        break;
      case 770:
        _struct._unique_s_item_770 = value;
        break;
      case 771:
        _struct._unique_s_item_771 = value;
        break;
      case 772:
        _struct._unique_s_item_772 = value;
        break;
      case 773:
        _struct._unique_s_item_773 = value;
        break;
      case 774:
        _struct._unique_s_item_774 = value;
        break;
      case 775:
        _struct._unique_s_item_775 = value;
        break;
      case 776:
        _struct._unique_s_item_776 = value;
        break;
      case 777:
        _struct._unique_s_item_777 = value;
        break;
      case 778:
        _struct._unique_s_item_778 = value;
        break;
      case 779:
        _struct._unique_s_item_779 = value;
        break;
      case 780:
        _struct._unique_s_item_780 = value;
        break;
      case 781:
        _struct._unique_s_item_781 = value;
        break;
      case 782:
        _struct._unique_s_item_782 = value;
        break;
      case 783:
        _struct._unique_s_item_783 = value;
        break;
      case 784:
        _struct._unique_s_item_784 = value;
        break;
      case 785:
        _struct._unique_s_item_785 = value;
        break;
      case 786:
        _struct._unique_s_item_786 = value;
        break;
      case 787:
        _struct._unique_s_item_787 = value;
        break;
      case 788:
        _struct._unique_s_item_788 = value;
        break;
      case 789:
        _struct._unique_s_item_789 = value;
        break;
      case 790:
        _struct._unique_s_item_790 = value;
        break;
      case 791:
        _struct._unique_s_item_791 = value;
        break;
      case 792:
        _struct._unique_s_item_792 = value;
        break;
      case 793:
        _struct._unique_s_item_793 = value;
        break;
      case 794:
        _struct._unique_s_item_794 = value;
        break;
      case 795:
        _struct._unique_s_item_795 = value;
        break;
      case 796:
        _struct._unique_s_item_796 = value;
        break;
      case 797:
        _struct._unique_s_item_797 = value;
        break;
      case 798:
        _struct._unique_s_item_798 = value;
        break;
      case 799:
        _struct._unique_s_item_799 = value;
        break;
      case 800:
        _struct._unique_s_item_800 = value;
        break;
      case 801:
        _struct._unique_s_item_801 = value;
        break;
      case 802:
        _struct._unique_s_item_802 = value;
        break;
      case 803:
        _struct._unique_s_item_803 = value;
        break;
      case 804:
        _struct._unique_s_item_804 = value;
        break;
      case 805:
        _struct._unique_s_item_805 = value;
        break;
      case 806:
        _struct._unique_s_item_806 = value;
        break;
      case 807:
        _struct._unique_s_item_807 = value;
        break;
      case 808:
        _struct._unique_s_item_808 = value;
        break;
      case 809:
        _struct._unique_s_item_809 = value;
        break;
      case 810:
        _struct._unique_s_item_810 = value;
        break;
      case 811:
        _struct._unique_s_item_811 = value;
        break;
      case 812:
        _struct._unique_s_item_812 = value;
        break;
      case 813:
        _struct._unique_s_item_813 = value;
        break;
      case 814:
        _struct._unique_s_item_814 = value;
        break;
      case 815:
        _struct._unique_s_item_815 = value;
        break;
      case 816:
        _struct._unique_s_item_816 = value;
        break;
      case 817:
        _struct._unique_s_item_817 = value;
        break;
      case 818:
        _struct._unique_s_item_818 = value;
        break;
      case 819:
        _struct._unique_s_item_819 = value;
        break;
      case 820:
        _struct._unique_s_item_820 = value;
        break;
      case 821:
        _struct._unique_s_item_821 = value;
        break;
      case 822:
        _struct._unique_s_item_822 = value;
        break;
      case 823:
        _struct._unique_s_item_823 = value;
        break;
      case 824:
        _struct._unique_s_item_824 = value;
        break;
      case 825:
        _struct._unique_s_item_825 = value;
        break;
      case 826:
        _struct._unique_s_item_826 = value;
        break;
      case 827:
        _struct._unique_s_item_827 = value;
        break;
      case 828:
        _struct._unique_s_item_828 = value;
        break;
      case 829:
        _struct._unique_s_item_829 = value;
        break;
      case 830:
        _struct._unique_s_item_830 = value;
        break;
      case 831:
        _struct._unique_s_item_831 = value;
        break;
      case 832:
        _struct._unique_s_item_832 = value;
        break;
      case 833:
        _struct._unique_s_item_833 = value;
        break;
      case 834:
        _struct._unique_s_item_834 = value;
        break;
      case 835:
        _struct._unique_s_item_835 = value;
        break;
      case 836:
        _struct._unique_s_item_836 = value;
        break;
      case 837:
        _struct._unique_s_item_837 = value;
        break;
      case 838:
        _struct._unique_s_item_838 = value;
        break;
      case 839:
        _struct._unique_s_item_839 = value;
        break;
      case 840:
        _struct._unique_s_item_840 = value;
        break;
      case 841:
        _struct._unique_s_item_841 = value;
        break;
      case 842:
        _struct._unique_s_item_842 = value;
        break;
      case 843:
        _struct._unique_s_item_843 = value;
        break;
      case 844:
        _struct._unique_s_item_844 = value;
        break;
      case 845:
        _struct._unique_s_item_845 = value;
        break;
      case 846:
        _struct._unique_s_item_846 = value;
        break;
      case 847:
        _struct._unique_s_item_847 = value;
        break;
      case 848:
        _struct._unique_s_item_848 = value;
        break;
      case 849:
        _struct._unique_s_item_849 = value;
        break;
      case 850:
        _struct._unique_s_item_850 = value;
        break;
      case 851:
        _struct._unique_s_item_851 = value;
        break;
      case 852:
        _struct._unique_s_item_852 = value;
        break;
      case 853:
        _struct._unique_s_item_853 = value;
        break;
      case 854:
        _struct._unique_s_item_854 = value;
        break;
      case 855:
        _struct._unique_s_item_855 = value;
        break;
      case 856:
        _struct._unique_s_item_856 = value;
        break;
      case 857:
        _struct._unique_s_item_857 = value;
        break;
      case 858:
        _struct._unique_s_item_858 = value;
        break;
      case 859:
        _struct._unique_s_item_859 = value;
        break;
      case 860:
        _struct._unique_s_item_860 = value;
        break;
      case 861:
        _struct._unique_s_item_861 = value;
        break;
      case 862:
        _struct._unique_s_item_862 = value;
        break;
      case 863:
        _struct._unique_s_item_863 = value;
        break;
      case 864:
        _struct._unique_s_item_864 = value;
        break;
      case 865:
        _struct._unique_s_item_865 = value;
        break;
      case 866:
        _struct._unique_s_item_866 = value;
        break;
      case 867:
        _struct._unique_s_item_867 = value;
        break;
      case 868:
        _struct._unique_s_item_868 = value;
        break;
      case 869:
        _struct._unique_s_item_869 = value;
        break;
      case 870:
        _struct._unique_s_item_870 = value;
        break;
      case 871:
        _struct._unique_s_item_871 = value;
        break;
      case 872:
        _struct._unique_s_item_872 = value;
        break;
      case 873:
        _struct._unique_s_item_873 = value;
        break;
      case 874:
        _struct._unique_s_item_874 = value;
        break;
      case 875:
        _struct._unique_s_item_875 = value;
        break;
      case 876:
        _struct._unique_s_item_876 = value;
        break;
      case 877:
        _struct._unique_s_item_877 = value;
        break;
      case 878:
        _struct._unique_s_item_878 = value;
        break;
      case 879:
        _struct._unique_s_item_879 = value;
        break;
      case 880:
        _struct._unique_s_item_880 = value;
        break;
      case 881:
        _struct._unique_s_item_881 = value;
        break;
      case 882:
        _struct._unique_s_item_882 = value;
        break;
      case 883:
        _struct._unique_s_item_883 = value;
        break;
      case 884:
        _struct._unique_s_item_884 = value;
        break;
      case 885:
        _struct._unique_s_item_885 = value;
        break;
      case 886:
        _struct._unique_s_item_886 = value;
        break;
      case 887:
        _struct._unique_s_item_887 = value;
        break;
      case 888:
        _struct._unique_s_item_888 = value;
        break;
      case 889:
        _struct._unique_s_item_889 = value;
        break;
      case 890:
        _struct._unique_s_item_890 = value;
        break;
      case 891:
        _struct._unique_s_item_891 = value;
        break;
      case 892:
        _struct._unique_s_item_892 = value;
        break;
      case 893:
        _struct._unique_s_item_893 = value;
        break;
      case 894:
        _struct._unique_s_item_894 = value;
        break;
      case 895:
        _struct._unique_s_item_895 = value;
        break;
      case 896:
        _struct._unique_s_item_896 = value;
        break;
      case 897:
        _struct._unique_s_item_897 = value;
        break;
      case 898:
        _struct._unique_s_item_898 = value;
        break;
      case 899:
        _struct._unique_s_item_899 = value;
        break;
      case 900:
        _struct._unique_s_item_900 = value;
        break;
      case 901:
        _struct._unique_s_item_901 = value;
        break;
      case 902:
        _struct._unique_s_item_902 = value;
        break;
      case 903:
        _struct._unique_s_item_903 = value;
        break;
      case 904:
        _struct._unique_s_item_904 = value;
        break;
      case 905:
        _struct._unique_s_item_905 = value;
        break;
      case 906:
        _struct._unique_s_item_906 = value;
        break;
      case 907:
        _struct._unique_s_item_907 = value;
        break;
      case 908:
        _struct._unique_s_item_908 = value;
        break;
      case 909:
        _struct._unique_s_item_909 = value;
        break;
      case 910:
        _struct._unique_s_item_910 = value;
        break;
      case 911:
        _struct._unique_s_item_911 = value;
        break;
      case 912:
        _struct._unique_s_item_912 = value;
        break;
      case 913:
        _struct._unique_s_item_913 = value;
        break;
      case 914:
        _struct._unique_s_item_914 = value;
        break;
      case 915:
        _struct._unique_s_item_915 = value;
        break;
      case 916:
        _struct._unique_s_item_916 = value;
        break;
      case 917:
        _struct._unique_s_item_917 = value;
        break;
      case 918:
        _struct._unique_s_item_918 = value;
        break;
      case 919:
        _struct._unique_s_item_919 = value;
        break;
      case 920:
        _struct._unique_s_item_920 = value;
        break;
      case 921:
        _struct._unique_s_item_921 = value;
        break;
      case 922:
        _struct._unique_s_item_922 = value;
        break;
      case 923:
        _struct._unique_s_item_923 = value;
        break;
      case 924:
        _struct._unique_s_item_924 = value;
        break;
      case 925:
        _struct._unique_s_item_925 = value;
        break;
      case 926:
        _struct._unique_s_item_926 = value;
        break;
      case 927:
        _struct._unique_s_item_927 = value;
        break;
      case 928:
        _struct._unique_s_item_928 = value;
        break;
      case 929:
        _struct._unique_s_item_929 = value;
        break;
      case 930:
        _struct._unique_s_item_930 = value;
        break;
      case 931:
        _struct._unique_s_item_931 = value;
        break;
      case 932:
        _struct._unique_s_item_932 = value;
        break;
      case 933:
        _struct._unique_s_item_933 = value;
        break;
      case 934:
        _struct._unique_s_item_934 = value;
        break;
      case 935:
        _struct._unique_s_item_935 = value;
        break;
      case 936:
        _struct._unique_s_item_936 = value;
        break;
      case 937:
        _struct._unique_s_item_937 = value;
        break;
      case 938:
        _struct._unique_s_item_938 = value;
        break;
      case 939:
        _struct._unique_s_item_939 = value;
        break;
      case 940:
        _struct._unique_s_item_940 = value;
        break;
      case 941:
        _struct._unique_s_item_941 = value;
        break;
      case 942:
        _struct._unique_s_item_942 = value;
        break;
      case 943:
        _struct._unique_s_item_943 = value;
        break;
      case 944:
        _struct._unique_s_item_944 = value;
        break;
      case 945:
        _struct._unique_s_item_945 = value;
        break;
      case 946:
        _struct._unique_s_item_946 = value;
        break;
      case 947:
        _struct._unique_s_item_947 = value;
        break;
      case 948:
        _struct._unique_s_item_948 = value;
        break;
      case 949:
        _struct._unique_s_item_949 = value;
        break;
      case 950:
        _struct._unique_s_item_950 = value;
        break;
      case 951:
        _struct._unique_s_item_951 = value;
        break;
      case 952:
        _struct._unique_s_item_952 = value;
        break;
      case 953:
        _struct._unique_s_item_953 = value;
        break;
      case 954:
        _struct._unique_s_item_954 = value;
        break;
      case 955:
        _struct._unique_s_item_955 = value;
        break;
      case 956:
        _struct._unique_s_item_956 = value;
        break;
      case 957:
        _struct._unique_s_item_957 = value;
        break;
      case 958:
        _struct._unique_s_item_958 = value;
        break;
      case 959:
        _struct._unique_s_item_959 = value;
        break;
      case 960:
        _struct._unique_s_item_960 = value;
        break;
      case 961:
        _struct._unique_s_item_961 = value;
        break;
      case 962:
        _struct._unique_s_item_962 = value;
        break;
      case 963:
        _struct._unique_s_item_963 = value;
        break;
      case 964:
        _struct._unique_s_item_964 = value;
        break;
      case 965:
        _struct._unique_s_item_965 = value;
        break;
      case 966:
        _struct._unique_s_item_966 = value;
        break;
      case 967:
        _struct._unique_s_item_967 = value;
        break;
      case 968:
        _struct._unique_s_item_968 = value;
        break;
      case 969:
        _struct._unique_s_item_969 = value;
        break;
      case 970:
        _struct._unique_s_item_970 = value;
        break;
      case 971:
        _struct._unique_s_item_971 = value;
        break;
      case 972:
        _struct._unique_s_item_972 = value;
        break;
      case 973:
        _struct._unique_s_item_973 = value;
        break;
      case 974:
        _struct._unique_s_item_974 = value;
        break;
      case 975:
        _struct._unique_s_item_975 = value;
        break;
      case 976:
        _struct._unique_s_item_976 = value;
        break;
      case 977:
        _struct._unique_s_item_977 = value;
        break;
      case 978:
        _struct._unique_s_item_978 = value;
        break;
      case 979:
        _struct._unique_s_item_979 = value;
        break;
      case 980:
        _struct._unique_s_item_980 = value;
        break;
      case 981:
        _struct._unique_s_item_981 = value;
        break;
      case 982:
        _struct._unique_s_item_982 = value;
        break;
      case 983:
        _struct._unique_s_item_983 = value;
        break;
      case 984:
        _struct._unique_s_item_984 = value;
        break;
      case 985:
        _struct._unique_s_item_985 = value;
        break;
      case 986:
        _struct._unique_s_item_986 = value;
        break;
      case 987:
        _struct._unique_s_item_987 = value;
        break;
      case 988:
        _struct._unique_s_item_988 = value;
        break;
      case 989:
        _struct._unique_s_item_989 = value;
        break;
      case 990:
        _struct._unique_s_item_990 = value;
        break;
      case 991:
        _struct._unique_s_item_991 = value;
        break;
      case 992:
        _struct._unique_s_item_992 = value;
        break;
      case 993:
        _struct._unique_s_item_993 = value;
        break;
      case 994:
        _struct._unique_s_item_994 = value;
        break;
      case 995:
        _struct._unique_s_item_995 = value;
        break;
      case 996:
        _struct._unique_s_item_996 = value;
        break;
      case 997:
        _struct._unique_s_item_997 = value;
        break;
      case 998:
        _struct._unique_s_item_998 = value;
        break;
      case 999:
        _struct._unique_s_item_999 = value;
        break;
      case 1000:
        _struct._unique_s_item_1000 = value;
        break;
      case 1001:
        _struct._unique_s_item_1001 = value;
        break;
      case 1002:
        _struct._unique_s_item_1002 = value;
        break;
      case 1003:
        _struct._unique_s_item_1003 = value;
        break;
      case 1004:
        _struct._unique_s_item_1004 = value;
        break;
      case 1005:
        _struct._unique_s_item_1005 = value;
        break;
      case 1006:
        _struct._unique_s_item_1006 = value;
        break;
      case 1007:
        _struct._unique_s_item_1007 = value;
        break;
      case 1008:
        _struct._unique_s_item_1008 = value;
        break;
      case 1009:
        _struct._unique_s_item_1009 = value;
        break;
      case 1010:
        _struct._unique_s_item_1010 = value;
        break;
      case 1011:
        _struct._unique_s_item_1011 = value;
        break;
      case 1012:
        _struct._unique_s_item_1012 = value;
        break;
      case 1013:
        _struct._unique_s_item_1013 = value;
        break;
      case 1014:
        _struct._unique_s_item_1014 = value;
        break;
      case 1015:
        _struct._unique_s_item_1015 = value;
        break;
      case 1016:
        _struct._unique_s_item_1016 = value;
        break;
      case 1017:
        _struct._unique_s_item_1017 = value;
        break;
      case 1018:
        _struct._unique_s_item_1018 = value;
        break;
      case 1019:
        _struct._unique_s_item_1019 = value;
        break;
      case 1020:
        _struct._unique_s_item_1020 = value;
        break;
      case 1021:
        _struct._unique_s_item_1021 = value;
        break;
      case 1022:
        _struct._unique_s_item_1022 = value;
        break;
      case 1023:
        _struct._unique_s_item_1023 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class ff_pad_helper_AVBPrint extends ffi.Struct {
  ffi.Pointer<ffi.Int8> str;

  @ffi.Uint32()
  int len;

  @ffi.Uint32()
  int size;

  @ffi.Uint32()
  int size_max;

  @ffi.Int8()
  int _unique_reserved_internal_buffer_item_0;

  /// Helper for array `reserved_internal_buffer`.
  ArrayHelper_ff_pad_helper_AVBPrint_reserved_internal_buffer_level0
      get reserved_internal_buffer =>
          ArrayHelper_ff_pad_helper_AVBPrint_reserved_internal_buffer_level0(
              this, [1], 0, 0);
}

/// Helper for array `reserved_internal_buffer` in struct `ff_pad_helper_AVBPrint`.
class ArrayHelper_ff_pad_helper_AVBPrint_reserved_internal_buffer_level0 {
  final ff_pad_helper_AVBPrint _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_ff_pad_helper_AVBPrint_reserved_internal_buffer_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_reserved_internal_buffer_item_0;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_reserved_internal_buffer_item_0 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class AVCAMELLIA extends ffi.Struct {}

class AVCAST5 extends ffi.Struct {}

abstract class AVCRCId {
  static const int AV_CRC_8_ATM = 0;
  static const int AV_CRC_16_ANSI = 1;
  static const int AV_CRC_16_CCITT = 2;
  static const int AV_CRC_32_IEEE = 3;
  static const int AV_CRC_32_IEEE_LE = 4;
  static const int AV_CRC_16_ANSI_LE = 5;
  static const int AV_CRC_24_IEEE = 6;
  static const int AV_CRC_8_EBU = 7;
  static const int AV_CRC_MAX = 8;
}

/// @defgroup lavu_des DES
/// @ingroup lavu_crypto
/// @{
class AVDES extends ffi.Struct {
  @ffi.Uint64()
  int _unique_round_keys_item_0;
  @ffi.Uint64()
  int _unique_round_keys_item_1;
  @ffi.Uint64()
  int _unique_round_keys_item_2;
  @ffi.Uint64()
  int _unique_round_keys_item_3;
  @ffi.Uint64()
  int _unique_round_keys_item_4;
  @ffi.Uint64()
  int _unique_round_keys_item_5;
  @ffi.Uint64()
  int _unique_round_keys_item_6;
  @ffi.Uint64()
  int _unique_round_keys_item_7;
  @ffi.Uint64()
  int _unique_round_keys_item_8;
  @ffi.Uint64()
  int _unique_round_keys_item_9;
  @ffi.Uint64()
  int _unique_round_keys_item_10;
  @ffi.Uint64()
  int _unique_round_keys_item_11;
  @ffi.Uint64()
  int _unique_round_keys_item_12;
  @ffi.Uint64()
  int _unique_round_keys_item_13;
  @ffi.Uint64()
  int _unique_round_keys_item_14;
  @ffi.Uint64()
  int _unique_round_keys_item_15;
  @ffi.Uint64()
  int _unique_round_keys_item_16;
  @ffi.Uint64()
  int _unique_round_keys_item_17;
  @ffi.Uint64()
  int _unique_round_keys_item_18;
  @ffi.Uint64()
  int _unique_round_keys_item_19;
  @ffi.Uint64()
  int _unique_round_keys_item_20;
  @ffi.Uint64()
  int _unique_round_keys_item_21;
  @ffi.Uint64()
  int _unique_round_keys_item_22;
  @ffi.Uint64()
  int _unique_round_keys_item_23;
  @ffi.Uint64()
  int _unique_round_keys_item_24;
  @ffi.Uint64()
  int _unique_round_keys_item_25;
  @ffi.Uint64()
  int _unique_round_keys_item_26;
  @ffi.Uint64()
  int _unique_round_keys_item_27;
  @ffi.Uint64()
  int _unique_round_keys_item_28;
  @ffi.Uint64()
  int _unique_round_keys_item_29;
  @ffi.Uint64()
  int _unique_round_keys_item_30;
  @ffi.Uint64()
  int _unique_round_keys_item_31;
  @ffi.Uint64()
  int _unique_round_keys_item_32;
  @ffi.Uint64()
  int _unique_round_keys_item_33;
  @ffi.Uint64()
  int _unique_round_keys_item_34;
  @ffi.Uint64()
  int _unique_round_keys_item_35;
  @ffi.Uint64()
  int _unique_round_keys_item_36;
  @ffi.Uint64()
  int _unique_round_keys_item_37;
  @ffi.Uint64()
  int _unique_round_keys_item_38;
  @ffi.Uint64()
  int _unique_round_keys_item_39;
  @ffi.Uint64()
  int _unique_round_keys_item_40;
  @ffi.Uint64()
  int _unique_round_keys_item_41;
  @ffi.Uint64()
  int _unique_round_keys_item_42;
  @ffi.Uint64()
  int _unique_round_keys_item_43;
  @ffi.Uint64()
  int _unique_round_keys_item_44;
  @ffi.Uint64()
  int _unique_round_keys_item_45;
  @ffi.Uint64()
  int _unique_round_keys_item_46;
  @ffi.Uint64()
  int _unique_round_keys_item_47;

  /// Helper for array `round_keys`.
  ArrayHelper_AVDES_round_keys_level0 get round_keys =>
      ArrayHelper_AVDES_round_keys_level0(this, [3, 16], 0, 0);
  @ffi.Int32()
  int triple_des;
}

/// Helper for array `round_keys` in struct `AVDES`.
class ArrayHelper_AVDES_round_keys_level0 {
  final AVDES _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVDES_round_keys_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVDES_round_keys_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVDES_round_keys_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `round_keys` in struct `AVDES`.
class ArrayHelper_AVDES_round_keys_level1 {
  final AVDES _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVDES_round_keys_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_round_keys_item_0;
      case 1:
        return _struct._unique_round_keys_item_1;
      case 2:
        return _struct._unique_round_keys_item_2;
      case 3:
        return _struct._unique_round_keys_item_3;
      case 4:
        return _struct._unique_round_keys_item_4;
      case 5:
        return _struct._unique_round_keys_item_5;
      case 6:
        return _struct._unique_round_keys_item_6;
      case 7:
        return _struct._unique_round_keys_item_7;
      case 8:
        return _struct._unique_round_keys_item_8;
      case 9:
        return _struct._unique_round_keys_item_9;
      case 10:
        return _struct._unique_round_keys_item_10;
      case 11:
        return _struct._unique_round_keys_item_11;
      case 12:
        return _struct._unique_round_keys_item_12;
      case 13:
        return _struct._unique_round_keys_item_13;
      case 14:
        return _struct._unique_round_keys_item_14;
      case 15:
        return _struct._unique_round_keys_item_15;
      case 16:
        return _struct._unique_round_keys_item_16;
      case 17:
        return _struct._unique_round_keys_item_17;
      case 18:
        return _struct._unique_round_keys_item_18;
      case 19:
        return _struct._unique_round_keys_item_19;
      case 20:
        return _struct._unique_round_keys_item_20;
      case 21:
        return _struct._unique_round_keys_item_21;
      case 22:
        return _struct._unique_round_keys_item_22;
      case 23:
        return _struct._unique_round_keys_item_23;
      case 24:
        return _struct._unique_round_keys_item_24;
      case 25:
        return _struct._unique_round_keys_item_25;
      case 26:
        return _struct._unique_round_keys_item_26;
      case 27:
        return _struct._unique_round_keys_item_27;
      case 28:
        return _struct._unique_round_keys_item_28;
      case 29:
        return _struct._unique_round_keys_item_29;
      case 30:
        return _struct._unique_round_keys_item_30;
      case 31:
        return _struct._unique_round_keys_item_31;
      case 32:
        return _struct._unique_round_keys_item_32;
      case 33:
        return _struct._unique_round_keys_item_33;
      case 34:
        return _struct._unique_round_keys_item_34;
      case 35:
        return _struct._unique_round_keys_item_35;
      case 36:
        return _struct._unique_round_keys_item_36;
      case 37:
        return _struct._unique_round_keys_item_37;
      case 38:
        return _struct._unique_round_keys_item_38;
      case 39:
        return _struct._unique_round_keys_item_39;
      case 40:
        return _struct._unique_round_keys_item_40;
      case 41:
        return _struct._unique_round_keys_item_41;
      case 42:
        return _struct._unique_round_keys_item_42;
      case 43:
        return _struct._unique_round_keys_item_43;
      case 44:
        return _struct._unique_round_keys_item_44;
      case 45:
        return _struct._unique_round_keys_item_45;
      case 46:
        return _struct._unique_round_keys_item_46;
      case 47:
        return _struct._unique_round_keys_item_47;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_round_keys_item_0 = value;
        break;
      case 1:
        _struct._unique_round_keys_item_1 = value;
        break;
      case 2:
        _struct._unique_round_keys_item_2 = value;
        break;
      case 3:
        _struct._unique_round_keys_item_3 = value;
        break;
      case 4:
        _struct._unique_round_keys_item_4 = value;
        break;
      case 5:
        _struct._unique_round_keys_item_5 = value;
        break;
      case 6:
        _struct._unique_round_keys_item_6 = value;
        break;
      case 7:
        _struct._unique_round_keys_item_7 = value;
        break;
      case 8:
        _struct._unique_round_keys_item_8 = value;
        break;
      case 9:
        _struct._unique_round_keys_item_9 = value;
        break;
      case 10:
        _struct._unique_round_keys_item_10 = value;
        break;
      case 11:
        _struct._unique_round_keys_item_11 = value;
        break;
      case 12:
        _struct._unique_round_keys_item_12 = value;
        break;
      case 13:
        _struct._unique_round_keys_item_13 = value;
        break;
      case 14:
        _struct._unique_round_keys_item_14 = value;
        break;
      case 15:
        _struct._unique_round_keys_item_15 = value;
        break;
      case 16:
        _struct._unique_round_keys_item_16 = value;
        break;
      case 17:
        _struct._unique_round_keys_item_17 = value;
        break;
      case 18:
        _struct._unique_round_keys_item_18 = value;
        break;
      case 19:
        _struct._unique_round_keys_item_19 = value;
        break;
      case 20:
        _struct._unique_round_keys_item_20 = value;
        break;
      case 21:
        _struct._unique_round_keys_item_21 = value;
        break;
      case 22:
        _struct._unique_round_keys_item_22 = value;
        break;
      case 23:
        _struct._unique_round_keys_item_23 = value;
        break;
      case 24:
        _struct._unique_round_keys_item_24 = value;
        break;
      case 25:
        _struct._unique_round_keys_item_25 = value;
        break;
      case 26:
        _struct._unique_round_keys_item_26 = value;
        break;
      case 27:
        _struct._unique_round_keys_item_27 = value;
        break;
      case 28:
        _struct._unique_round_keys_item_28 = value;
        break;
      case 29:
        _struct._unique_round_keys_item_29 = value;
        break;
      case 30:
        _struct._unique_round_keys_item_30 = value;
        break;
      case 31:
        _struct._unique_round_keys_item_31 = value;
        break;
      case 32:
        _struct._unique_round_keys_item_32 = value;
        break;
      case 33:
        _struct._unique_round_keys_item_33 = value;
        break;
      case 34:
        _struct._unique_round_keys_item_34 = value;
        break;
      case 35:
        _struct._unique_round_keys_item_35 = value;
        break;
      case 36:
        _struct._unique_round_keys_item_36 = value;
        break;
      case 37:
        _struct._unique_round_keys_item_37 = value;
        break;
      case 38:
        _struct._unique_round_keys_item_38 = value;
        break;
      case 39:
        _struct._unique_round_keys_item_39 = value;
        break;
      case 40:
        _struct._unique_round_keys_item_40 = value;
        break;
      case 41:
        _struct._unique_round_keys_item_41 = value;
        break;
      case 42:
        _struct._unique_round_keys_item_42 = value;
        break;
      case 43:
        _struct._unique_round_keys_item_43 = value;
        break;
      case 44:
        _struct._unique_round_keys_item_44 = value;
        break;
      case 45:
        _struct._unique_round_keys_item_45 = value;
        break;
      case 46:
        _struct._unique_round_keys_item_46 = value;
        break;
      case 47:
        _struct._unique_round_keys_item_47 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class AVDOVIDecoderConfigurationRecord extends ffi.Struct {
  @ffi.Uint8()
  int dv_version_major;

  @ffi.Uint8()
  int dv_version_minor;

  @ffi.Uint8()
  int dv_profile;

  @ffi.Uint8()
  int dv_level;

  @ffi.Uint8()
  int rpu_present_flag;

  @ffi.Uint8()
  int el_present_flag;

  @ffi.Uint8()
  int bl_present_flag;

  @ffi.Uint8()
  int dv_bl_signal_compatibility_id;
}

/// Possible downmix types.
abstract class AVDownmixType {
  /// < Not indicated.
  static const int AV_DOWNMIX_TYPE_UNKNOWN = 0;

  /// < Lo/Ro 2-channel downmix (Stereo).
  static const int AV_DOWNMIX_TYPE_LORO = 1;

  /// < Lt/Rt 2-channel downmix, Dolby Surround compatible.
  static const int AV_DOWNMIX_TYPE_LTRT = 2;

  /// < Lt/Rt 2-channel downmix, Dolby Pro Logic II compatible.
  static const int AV_DOWNMIX_TYPE_DPLII = 3;

  /// < Number of downmix types. Not part of ABI.
  static const int AV_DOWNMIX_TYPE_NB = 4;
}

/// This structure describes optional metadata relevant to a downmix procedure.
///
/// All fields are set by the decoder to the value indicated in the audio
/// bitstream (if present), or to a "sane" default otherwise.
class AVDownmixInfo extends ffi.Struct {
  /// Type of downmix preferred by the mastering engineer.
  @ffi.Int32()
  int preferred_downmix_type;

  /// Absolute scale factor representing the nominal level of the center
  /// channel during a regular downmix.
  @ffi.Double()
  double center_mix_level;

  /// Absolute scale factor representing the nominal level of the center
  /// channel during an Lt/Rt compatible downmix.
  @ffi.Double()
  double center_mix_level_ltrt;

  /// Absolute scale factor representing the nominal level of the surround
  /// channels during a regular downmix.
  @ffi.Double()
  double surround_mix_level;

  /// Absolute scale factor representing the nominal level of the surround
  /// channels during an Lt/Rt compatible downmix.
  @ffi.Double()
  double surround_mix_level_ltrt;

  /// Absolute scale factor representing the level at which the LFE data is
  /// mixed into L/R channels during downmixing.
  @ffi.Double()
  double lfe_mix_level;
}

class AVSubsampleEncryptionInfo extends ffi.Struct {
  /// The number of bytes that are clear.
  @ffi.Uint32()
  int bytes_of_clear_data;

  /// The number of bytes that are protected.  If using pattern encryption,
  /// the pattern applies to only the protected bytes; if not using pattern
  /// encryption, all these bytes are encrypted.
  @ffi.Uint32()
  int bytes_of_protected_data;
}

/// This describes encryption info for a packet.  This contains frame-specific
/// info for how to decrypt the packet before passing it to the decoder.
///
/// The size of this struct is not part of the public ABI.
class AVEncryptionInfo extends ffi.Struct {
  /// The fourcc encryption scheme, in big-endian byte order.
  @ffi.Uint32()
  int scheme;

  /// Only used for pattern encryption.  This is the number of 16-byte blocks
  /// that are encrypted.
  @ffi.Uint32()
  int crypt_byte_block;

  /// Only used for pattern encryption.  This is the number of 16-byte blocks
  /// that are clear.
  @ffi.Uint32()
  int skip_byte_block;

  /// The ID of the key used to encrypt the packet.  This should always be
  /// 16 bytes long, but may be changed in the future.
  ffi.Pointer<ffi.Uint8> key_id;

  @ffi.Uint32()
  int key_id_size;

  /// The initialization vector.  This may have been zero-filled to be the
  /// correct block size.  This should always be 16 bytes long, but may be
  /// changed in the future.
  ffi.Pointer<ffi.Uint8> iv;

  @ffi.Uint32()
  int iv_size;

  /// An array of subsample encryption info specifying how parts of the sample
  /// are encrypted.  If there are no subsamples, then the whole sample is
  /// encrypted.
  ffi.Pointer<AVSubsampleEncryptionInfo> subsamples;

  @ffi.Uint32()
  int subsample_count;
}

/// This describes info used to initialize an encryption key system.
///
/// The size of this struct is not part of the public ABI.
class AVEncryptionInitInfo extends ffi.Struct {
  /// A unique identifier for the key system this is for, can be NULL if it
  /// is not known.  This should always be 16 bytes, but may change in the
  /// future.
  ffi.Pointer<ffi.Uint8> system_id;

  @ffi.Uint32()
  int system_id_size;

  /// An array of key IDs this initialization data is for.  All IDs are the
  /// same length.  Can be NULL if there are no known key IDs.
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> key_ids;

  /// The number of key IDs.
  @ffi.Uint32()
  int num_key_ids;

  /// The number of bytes in each key ID.  This should always be 16, but may
  /// change in the future.
  @ffi.Uint32()
  int key_id_size;

  /// Key-system specific initialization data.  This data is copied directly
  /// from the file and the format depends on the specific key system.  This
  /// can be NULL if there is no initialization data; in that case, there
  /// will be at least one key ID.
  ffi.Pointer<ffi.Uint8> data;

  @ffi.Uint32()
  int data_size;

  /// An optional pointer to the next initialization info in the list.
  ffi.Pointer<AVEncryptionInitInfo> next;
}

class AVExpr extends ffi.Struct {}

abstract class AVFilmGrainParamsType {
  static const int AV_FILM_GRAIN_PARAMS_NONE = 0;

  /// The union is valid when interpreted as AVFilmGrainAOMParams (codec.aom)
  static const int AV_FILM_GRAIN_PARAMS_AV1 = 1;
}

/// This structure describes how to handle film grain synthesis for AOM codecs.
///
/// @note The struct must be allocated as part of AVFilmGrainParams using
/// av_film_grain_params_alloc(). Its size is not a part of the public ABI.
class AVFilmGrainAOMParams extends ffi.Struct {
  /// Number of points, and the scale and value for each point of the
  /// piecewise linear scaling function for the uma plane.
  @ffi.Int32()
  int num_y_points;

  @ffi.Uint8()
  int _unique_y_points_item_0;
  @ffi.Uint8()
  int _unique_y_points_item_1;
  @ffi.Uint8()
  int _unique_y_points_item_2;
  @ffi.Uint8()
  int _unique_y_points_item_3;
  @ffi.Uint8()
  int _unique_y_points_item_4;
  @ffi.Uint8()
  int _unique_y_points_item_5;
  @ffi.Uint8()
  int _unique_y_points_item_6;
  @ffi.Uint8()
  int _unique_y_points_item_7;
  @ffi.Uint8()
  int _unique_y_points_item_8;
  @ffi.Uint8()
  int _unique_y_points_item_9;
  @ffi.Uint8()
  int _unique_y_points_item_10;
  @ffi.Uint8()
  int _unique_y_points_item_11;
  @ffi.Uint8()
  int _unique_y_points_item_12;
  @ffi.Uint8()
  int _unique_y_points_item_13;
  @ffi.Uint8()
  int _unique_y_points_item_14;
  @ffi.Uint8()
  int _unique_y_points_item_15;
  @ffi.Uint8()
  int _unique_y_points_item_16;
  @ffi.Uint8()
  int _unique_y_points_item_17;
  @ffi.Uint8()
  int _unique_y_points_item_18;
  @ffi.Uint8()
  int _unique_y_points_item_19;
  @ffi.Uint8()
  int _unique_y_points_item_20;
  @ffi.Uint8()
  int _unique_y_points_item_21;
  @ffi.Uint8()
  int _unique_y_points_item_22;
  @ffi.Uint8()
  int _unique_y_points_item_23;
  @ffi.Uint8()
  int _unique_y_points_item_24;
  @ffi.Uint8()
  int _unique_y_points_item_25;
  @ffi.Uint8()
  int _unique_y_points_item_26;
  @ffi.Uint8()
  int _unique_y_points_item_27;

  /// Helper for array `y_points`.
  ArrayHelper_AVFilmGrainAOMParams_y_points_level0 get y_points =>
      ArrayHelper_AVFilmGrainAOMParams_y_points_level0(this, [14, 2], 0, 0);

  /// Signals whether to derive the chroma scaling function from the luma.
  /// Not equivalent to copying the luma values and scales.
  @ffi.Int32()
  int chroma_scaling_from_luma;

  @ffi.Int32()
  int _unique_num_uv_points_item_0;
  @ffi.Int32()
  int _unique_num_uv_points_item_1;

  /// Helper for array `num_uv_points`.
  ArrayHelper_AVFilmGrainAOMParams_num_uv_points_level0 get num_uv_points =>
      ArrayHelper_AVFilmGrainAOMParams_num_uv_points_level0(this, [2], 0, 0);
  @ffi.Uint8()
  int _unique_uv_points_item_0;
  @ffi.Uint8()
  int _unique_uv_points_item_1;
  @ffi.Uint8()
  int _unique_uv_points_item_2;
  @ffi.Uint8()
  int _unique_uv_points_item_3;
  @ffi.Uint8()
  int _unique_uv_points_item_4;
  @ffi.Uint8()
  int _unique_uv_points_item_5;
  @ffi.Uint8()
  int _unique_uv_points_item_6;
  @ffi.Uint8()
  int _unique_uv_points_item_7;
  @ffi.Uint8()
  int _unique_uv_points_item_8;
  @ffi.Uint8()
  int _unique_uv_points_item_9;
  @ffi.Uint8()
  int _unique_uv_points_item_10;
  @ffi.Uint8()
  int _unique_uv_points_item_11;
  @ffi.Uint8()
  int _unique_uv_points_item_12;
  @ffi.Uint8()
  int _unique_uv_points_item_13;
  @ffi.Uint8()
  int _unique_uv_points_item_14;
  @ffi.Uint8()
  int _unique_uv_points_item_15;
  @ffi.Uint8()
  int _unique_uv_points_item_16;
  @ffi.Uint8()
  int _unique_uv_points_item_17;
  @ffi.Uint8()
  int _unique_uv_points_item_18;
  @ffi.Uint8()
  int _unique_uv_points_item_19;
  @ffi.Uint8()
  int _unique_uv_points_item_20;
  @ffi.Uint8()
  int _unique_uv_points_item_21;
  @ffi.Uint8()
  int _unique_uv_points_item_22;
  @ffi.Uint8()
  int _unique_uv_points_item_23;
  @ffi.Uint8()
  int _unique_uv_points_item_24;
  @ffi.Uint8()
  int _unique_uv_points_item_25;
  @ffi.Uint8()
  int _unique_uv_points_item_26;
  @ffi.Uint8()
  int _unique_uv_points_item_27;
  @ffi.Uint8()
  int _unique_uv_points_item_28;
  @ffi.Uint8()
  int _unique_uv_points_item_29;
  @ffi.Uint8()
  int _unique_uv_points_item_30;
  @ffi.Uint8()
  int _unique_uv_points_item_31;
  @ffi.Uint8()
  int _unique_uv_points_item_32;
  @ffi.Uint8()
  int _unique_uv_points_item_33;
  @ffi.Uint8()
  int _unique_uv_points_item_34;
  @ffi.Uint8()
  int _unique_uv_points_item_35;
  @ffi.Uint8()
  int _unique_uv_points_item_36;
  @ffi.Uint8()
  int _unique_uv_points_item_37;
  @ffi.Uint8()
  int _unique_uv_points_item_38;
  @ffi.Uint8()
  int _unique_uv_points_item_39;

  /// Helper for array `uv_points`.
  ArrayHelper_AVFilmGrainAOMParams_uv_points_level0 get uv_points =>
      ArrayHelper_AVFilmGrainAOMParams_uv_points_level0(this, [2, 10, 2], 0, 0);

  /// Specifies the shift applied to the chroma components. For AV1, its within
  /// [8; 11] and determines the range and quantization of the film grain.
  @ffi.Int32()
  int scaling_shift;

  /// Specifies the auto-regression lag.
  @ffi.Int32()
  int ar_coeff_lag;

  @ffi.Int8()
  int _unique_ar_coeffs_y_item_0;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_1;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_2;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_3;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_4;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_5;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_6;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_7;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_8;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_9;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_10;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_11;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_12;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_13;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_14;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_15;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_16;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_17;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_18;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_19;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_20;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_21;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_22;
  @ffi.Int8()
  int _unique_ar_coeffs_y_item_23;

  /// Helper for array `ar_coeffs_y`.
  ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_y_level0 get ar_coeffs_y =>
      ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_y_level0(this, [24], 0, 0);
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_0;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_1;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_2;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_3;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_4;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_5;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_6;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_7;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_8;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_9;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_10;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_11;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_12;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_13;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_14;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_15;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_16;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_17;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_18;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_19;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_20;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_21;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_22;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_23;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_24;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_25;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_26;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_27;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_28;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_29;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_30;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_31;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_32;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_33;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_34;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_35;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_36;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_37;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_38;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_39;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_40;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_41;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_42;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_43;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_44;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_45;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_46;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_47;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_48;
  @ffi.Int8()
  int _unique_ar_coeffs_uv_item_49;

  /// Helper for array `ar_coeffs_uv`.
  ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level0 get ar_coeffs_uv =>
      ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level0(this, [2, 25], 0, 0);

  /// Specifies the range of the auto-regressive coefficients. Values of 6,
  /// 7, 8 and so on represent a range of [-2, 2), [-1, 1), [-0.5, 0.5) and
  /// so on. For AV1 must be between 6 and 9.
  @ffi.Int32()
  int ar_coeff_shift;

  /// Signals the down shift applied to the generated gaussian numbers during
  /// synthesis.
  @ffi.Int32()
  int grain_scale_shift;

  @ffi.Int32()
  int _unique_uv_mult_item_0;
  @ffi.Int32()
  int _unique_uv_mult_item_1;

  /// Helper for array `uv_mult`.
  ArrayHelper_AVFilmGrainAOMParams_uv_mult_level0 get uv_mult =>
      ArrayHelper_AVFilmGrainAOMParams_uv_mult_level0(this, [2], 0, 0);
  @ffi.Int32()
  int _unique_uv_mult_luma_item_0;
  @ffi.Int32()
  int _unique_uv_mult_luma_item_1;

  /// Helper for array `uv_mult_luma`.
  ArrayHelper_AVFilmGrainAOMParams_uv_mult_luma_level0 get uv_mult_luma =>
      ArrayHelper_AVFilmGrainAOMParams_uv_mult_luma_level0(this, [2], 0, 0);
  @ffi.Int32()
  int _unique_uv_offset_item_0;
  @ffi.Int32()
  int _unique_uv_offset_item_1;

  /// Helper for array `uv_offset`.
  ArrayHelper_AVFilmGrainAOMParams_uv_offset_level0 get uv_offset =>
      ArrayHelper_AVFilmGrainAOMParams_uv_offset_level0(this, [2], 0, 0);

  /// Signals whether to overlap film grain blocks.
  @ffi.Int32()
  int overlap_flag;

  /// Signals to clip to limited color levels after film grain application.
  @ffi.Int32()
  int limit_output_range;
}

/// Helper for array `y_points` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_y_points_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_y_points_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVFilmGrainAOMParams_y_points_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVFilmGrainAOMParams_y_points_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `y_points` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_y_points_level1 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_y_points_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_y_points_item_0;
      case 1:
        return _struct._unique_y_points_item_1;
      case 2:
        return _struct._unique_y_points_item_2;
      case 3:
        return _struct._unique_y_points_item_3;
      case 4:
        return _struct._unique_y_points_item_4;
      case 5:
        return _struct._unique_y_points_item_5;
      case 6:
        return _struct._unique_y_points_item_6;
      case 7:
        return _struct._unique_y_points_item_7;
      case 8:
        return _struct._unique_y_points_item_8;
      case 9:
        return _struct._unique_y_points_item_9;
      case 10:
        return _struct._unique_y_points_item_10;
      case 11:
        return _struct._unique_y_points_item_11;
      case 12:
        return _struct._unique_y_points_item_12;
      case 13:
        return _struct._unique_y_points_item_13;
      case 14:
        return _struct._unique_y_points_item_14;
      case 15:
        return _struct._unique_y_points_item_15;
      case 16:
        return _struct._unique_y_points_item_16;
      case 17:
        return _struct._unique_y_points_item_17;
      case 18:
        return _struct._unique_y_points_item_18;
      case 19:
        return _struct._unique_y_points_item_19;
      case 20:
        return _struct._unique_y_points_item_20;
      case 21:
        return _struct._unique_y_points_item_21;
      case 22:
        return _struct._unique_y_points_item_22;
      case 23:
        return _struct._unique_y_points_item_23;
      case 24:
        return _struct._unique_y_points_item_24;
      case 25:
        return _struct._unique_y_points_item_25;
      case 26:
        return _struct._unique_y_points_item_26;
      case 27:
        return _struct._unique_y_points_item_27;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_y_points_item_0 = value;
        break;
      case 1:
        _struct._unique_y_points_item_1 = value;
        break;
      case 2:
        _struct._unique_y_points_item_2 = value;
        break;
      case 3:
        _struct._unique_y_points_item_3 = value;
        break;
      case 4:
        _struct._unique_y_points_item_4 = value;
        break;
      case 5:
        _struct._unique_y_points_item_5 = value;
        break;
      case 6:
        _struct._unique_y_points_item_6 = value;
        break;
      case 7:
        _struct._unique_y_points_item_7 = value;
        break;
      case 8:
        _struct._unique_y_points_item_8 = value;
        break;
      case 9:
        _struct._unique_y_points_item_9 = value;
        break;
      case 10:
        _struct._unique_y_points_item_10 = value;
        break;
      case 11:
        _struct._unique_y_points_item_11 = value;
        break;
      case 12:
        _struct._unique_y_points_item_12 = value;
        break;
      case 13:
        _struct._unique_y_points_item_13 = value;
        break;
      case 14:
        _struct._unique_y_points_item_14 = value;
        break;
      case 15:
        _struct._unique_y_points_item_15 = value;
        break;
      case 16:
        _struct._unique_y_points_item_16 = value;
        break;
      case 17:
        _struct._unique_y_points_item_17 = value;
        break;
      case 18:
        _struct._unique_y_points_item_18 = value;
        break;
      case 19:
        _struct._unique_y_points_item_19 = value;
        break;
      case 20:
        _struct._unique_y_points_item_20 = value;
        break;
      case 21:
        _struct._unique_y_points_item_21 = value;
        break;
      case 22:
        _struct._unique_y_points_item_22 = value;
        break;
      case 23:
        _struct._unique_y_points_item_23 = value;
        break;
      case 24:
        _struct._unique_y_points_item_24 = value;
        break;
      case 25:
        _struct._unique_y_points_item_25 = value;
        break;
      case 26:
        _struct._unique_y_points_item_26 = value;
        break;
      case 27:
        _struct._unique_y_points_item_27 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `num_uv_points` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_num_uv_points_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_num_uv_points_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_num_uv_points_item_0;
      case 1:
        return _struct._unique_num_uv_points_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_num_uv_points_item_0 = value;
        break;
      case 1:
        _struct._unique_num_uv_points_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `uv_points` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_uv_points_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_uv_points_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVFilmGrainAOMParams_uv_points_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVFilmGrainAOMParams_uv_points_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `uv_points` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_uv_points_level1 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_uv_points_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVFilmGrainAOMParams_uv_points_level2 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVFilmGrainAOMParams_uv_points_level2(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `uv_points` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_uv_points_level2 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_uv_points_level2(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_uv_points_item_0;
      case 1:
        return _struct._unique_uv_points_item_1;
      case 2:
        return _struct._unique_uv_points_item_2;
      case 3:
        return _struct._unique_uv_points_item_3;
      case 4:
        return _struct._unique_uv_points_item_4;
      case 5:
        return _struct._unique_uv_points_item_5;
      case 6:
        return _struct._unique_uv_points_item_6;
      case 7:
        return _struct._unique_uv_points_item_7;
      case 8:
        return _struct._unique_uv_points_item_8;
      case 9:
        return _struct._unique_uv_points_item_9;
      case 10:
        return _struct._unique_uv_points_item_10;
      case 11:
        return _struct._unique_uv_points_item_11;
      case 12:
        return _struct._unique_uv_points_item_12;
      case 13:
        return _struct._unique_uv_points_item_13;
      case 14:
        return _struct._unique_uv_points_item_14;
      case 15:
        return _struct._unique_uv_points_item_15;
      case 16:
        return _struct._unique_uv_points_item_16;
      case 17:
        return _struct._unique_uv_points_item_17;
      case 18:
        return _struct._unique_uv_points_item_18;
      case 19:
        return _struct._unique_uv_points_item_19;
      case 20:
        return _struct._unique_uv_points_item_20;
      case 21:
        return _struct._unique_uv_points_item_21;
      case 22:
        return _struct._unique_uv_points_item_22;
      case 23:
        return _struct._unique_uv_points_item_23;
      case 24:
        return _struct._unique_uv_points_item_24;
      case 25:
        return _struct._unique_uv_points_item_25;
      case 26:
        return _struct._unique_uv_points_item_26;
      case 27:
        return _struct._unique_uv_points_item_27;
      case 28:
        return _struct._unique_uv_points_item_28;
      case 29:
        return _struct._unique_uv_points_item_29;
      case 30:
        return _struct._unique_uv_points_item_30;
      case 31:
        return _struct._unique_uv_points_item_31;
      case 32:
        return _struct._unique_uv_points_item_32;
      case 33:
        return _struct._unique_uv_points_item_33;
      case 34:
        return _struct._unique_uv_points_item_34;
      case 35:
        return _struct._unique_uv_points_item_35;
      case 36:
        return _struct._unique_uv_points_item_36;
      case 37:
        return _struct._unique_uv_points_item_37;
      case 38:
        return _struct._unique_uv_points_item_38;
      case 39:
        return _struct._unique_uv_points_item_39;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_uv_points_item_0 = value;
        break;
      case 1:
        _struct._unique_uv_points_item_1 = value;
        break;
      case 2:
        _struct._unique_uv_points_item_2 = value;
        break;
      case 3:
        _struct._unique_uv_points_item_3 = value;
        break;
      case 4:
        _struct._unique_uv_points_item_4 = value;
        break;
      case 5:
        _struct._unique_uv_points_item_5 = value;
        break;
      case 6:
        _struct._unique_uv_points_item_6 = value;
        break;
      case 7:
        _struct._unique_uv_points_item_7 = value;
        break;
      case 8:
        _struct._unique_uv_points_item_8 = value;
        break;
      case 9:
        _struct._unique_uv_points_item_9 = value;
        break;
      case 10:
        _struct._unique_uv_points_item_10 = value;
        break;
      case 11:
        _struct._unique_uv_points_item_11 = value;
        break;
      case 12:
        _struct._unique_uv_points_item_12 = value;
        break;
      case 13:
        _struct._unique_uv_points_item_13 = value;
        break;
      case 14:
        _struct._unique_uv_points_item_14 = value;
        break;
      case 15:
        _struct._unique_uv_points_item_15 = value;
        break;
      case 16:
        _struct._unique_uv_points_item_16 = value;
        break;
      case 17:
        _struct._unique_uv_points_item_17 = value;
        break;
      case 18:
        _struct._unique_uv_points_item_18 = value;
        break;
      case 19:
        _struct._unique_uv_points_item_19 = value;
        break;
      case 20:
        _struct._unique_uv_points_item_20 = value;
        break;
      case 21:
        _struct._unique_uv_points_item_21 = value;
        break;
      case 22:
        _struct._unique_uv_points_item_22 = value;
        break;
      case 23:
        _struct._unique_uv_points_item_23 = value;
        break;
      case 24:
        _struct._unique_uv_points_item_24 = value;
        break;
      case 25:
        _struct._unique_uv_points_item_25 = value;
        break;
      case 26:
        _struct._unique_uv_points_item_26 = value;
        break;
      case 27:
        _struct._unique_uv_points_item_27 = value;
        break;
      case 28:
        _struct._unique_uv_points_item_28 = value;
        break;
      case 29:
        _struct._unique_uv_points_item_29 = value;
        break;
      case 30:
        _struct._unique_uv_points_item_30 = value;
        break;
      case 31:
        _struct._unique_uv_points_item_31 = value;
        break;
      case 32:
        _struct._unique_uv_points_item_32 = value;
        break;
      case 33:
        _struct._unique_uv_points_item_33 = value;
        break;
      case 34:
        _struct._unique_uv_points_item_34 = value;
        break;
      case 35:
        _struct._unique_uv_points_item_35 = value;
        break;
      case 36:
        _struct._unique_uv_points_item_36 = value;
        break;
      case 37:
        _struct._unique_uv_points_item_37 = value;
        break;
      case 38:
        _struct._unique_uv_points_item_38 = value;
        break;
      case 39:
        _struct._unique_uv_points_item_39 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `ar_coeffs_y` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_y_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_y_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_ar_coeffs_y_item_0;
      case 1:
        return _struct._unique_ar_coeffs_y_item_1;
      case 2:
        return _struct._unique_ar_coeffs_y_item_2;
      case 3:
        return _struct._unique_ar_coeffs_y_item_3;
      case 4:
        return _struct._unique_ar_coeffs_y_item_4;
      case 5:
        return _struct._unique_ar_coeffs_y_item_5;
      case 6:
        return _struct._unique_ar_coeffs_y_item_6;
      case 7:
        return _struct._unique_ar_coeffs_y_item_7;
      case 8:
        return _struct._unique_ar_coeffs_y_item_8;
      case 9:
        return _struct._unique_ar_coeffs_y_item_9;
      case 10:
        return _struct._unique_ar_coeffs_y_item_10;
      case 11:
        return _struct._unique_ar_coeffs_y_item_11;
      case 12:
        return _struct._unique_ar_coeffs_y_item_12;
      case 13:
        return _struct._unique_ar_coeffs_y_item_13;
      case 14:
        return _struct._unique_ar_coeffs_y_item_14;
      case 15:
        return _struct._unique_ar_coeffs_y_item_15;
      case 16:
        return _struct._unique_ar_coeffs_y_item_16;
      case 17:
        return _struct._unique_ar_coeffs_y_item_17;
      case 18:
        return _struct._unique_ar_coeffs_y_item_18;
      case 19:
        return _struct._unique_ar_coeffs_y_item_19;
      case 20:
        return _struct._unique_ar_coeffs_y_item_20;
      case 21:
        return _struct._unique_ar_coeffs_y_item_21;
      case 22:
        return _struct._unique_ar_coeffs_y_item_22;
      case 23:
        return _struct._unique_ar_coeffs_y_item_23;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_ar_coeffs_y_item_0 = value;
        break;
      case 1:
        _struct._unique_ar_coeffs_y_item_1 = value;
        break;
      case 2:
        _struct._unique_ar_coeffs_y_item_2 = value;
        break;
      case 3:
        _struct._unique_ar_coeffs_y_item_3 = value;
        break;
      case 4:
        _struct._unique_ar_coeffs_y_item_4 = value;
        break;
      case 5:
        _struct._unique_ar_coeffs_y_item_5 = value;
        break;
      case 6:
        _struct._unique_ar_coeffs_y_item_6 = value;
        break;
      case 7:
        _struct._unique_ar_coeffs_y_item_7 = value;
        break;
      case 8:
        _struct._unique_ar_coeffs_y_item_8 = value;
        break;
      case 9:
        _struct._unique_ar_coeffs_y_item_9 = value;
        break;
      case 10:
        _struct._unique_ar_coeffs_y_item_10 = value;
        break;
      case 11:
        _struct._unique_ar_coeffs_y_item_11 = value;
        break;
      case 12:
        _struct._unique_ar_coeffs_y_item_12 = value;
        break;
      case 13:
        _struct._unique_ar_coeffs_y_item_13 = value;
        break;
      case 14:
        _struct._unique_ar_coeffs_y_item_14 = value;
        break;
      case 15:
        _struct._unique_ar_coeffs_y_item_15 = value;
        break;
      case 16:
        _struct._unique_ar_coeffs_y_item_16 = value;
        break;
      case 17:
        _struct._unique_ar_coeffs_y_item_17 = value;
        break;
      case 18:
        _struct._unique_ar_coeffs_y_item_18 = value;
        break;
      case 19:
        _struct._unique_ar_coeffs_y_item_19 = value;
        break;
      case 20:
        _struct._unique_ar_coeffs_y_item_20 = value;
        break;
      case 21:
        _struct._unique_ar_coeffs_y_item_21 = value;
        break;
      case 22:
        _struct._unique_ar_coeffs_y_item_22 = value;
        break;
      case 23:
        _struct._unique_ar_coeffs_y_item_23 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `ar_coeffs_uv` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `ar_coeffs_uv` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level1 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_ar_coeffs_uv_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_ar_coeffs_uv_item_0;
      case 1:
        return _struct._unique_ar_coeffs_uv_item_1;
      case 2:
        return _struct._unique_ar_coeffs_uv_item_2;
      case 3:
        return _struct._unique_ar_coeffs_uv_item_3;
      case 4:
        return _struct._unique_ar_coeffs_uv_item_4;
      case 5:
        return _struct._unique_ar_coeffs_uv_item_5;
      case 6:
        return _struct._unique_ar_coeffs_uv_item_6;
      case 7:
        return _struct._unique_ar_coeffs_uv_item_7;
      case 8:
        return _struct._unique_ar_coeffs_uv_item_8;
      case 9:
        return _struct._unique_ar_coeffs_uv_item_9;
      case 10:
        return _struct._unique_ar_coeffs_uv_item_10;
      case 11:
        return _struct._unique_ar_coeffs_uv_item_11;
      case 12:
        return _struct._unique_ar_coeffs_uv_item_12;
      case 13:
        return _struct._unique_ar_coeffs_uv_item_13;
      case 14:
        return _struct._unique_ar_coeffs_uv_item_14;
      case 15:
        return _struct._unique_ar_coeffs_uv_item_15;
      case 16:
        return _struct._unique_ar_coeffs_uv_item_16;
      case 17:
        return _struct._unique_ar_coeffs_uv_item_17;
      case 18:
        return _struct._unique_ar_coeffs_uv_item_18;
      case 19:
        return _struct._unique_ar_coeffs_uv_item_19;
      case 20:
        return _struct._unique_ar_coeffs_uv_item_20;
      case 21:
        return _struct._unique_ar_coeffs_uv_item_21;
      case 22:
        return _struct._unique_ar_coeffs_uv_item_22;
      case 23:
        return _struct._unique_ar_coeffs_uv_item_23;
      case 24:
        return _struct._unique_ar_coeffs_uv_item_24;
      case 25:
        return _struct._unique_ar_coeffs_uv_item_25;
      case 26:
        return _struct._unique_ar_coeffs_uv_item_26;
      case 27:
        return _struct._unique_ar_coeffs_uv_item_27;
      case 28:
        return _struct._unique_ar_coeffs_uv_item_28;
      case 29:
        return _struct._unique_ar_coeffs_uv_item_29;
      case 30:
        return _struct._unique_ar_coeffs_uv_item_30;
      case 31:
        return _struct._unique_ar_coeffs_uv_item_31;
      case 32:
        return _struct._unique_ar_coeffs_uv_item_32;
      case 33:
        return _struct._unique_ar_coeffs_uv_item_33;
      case 34:
        return _struct._unique_ar_coeffs_uv_item_34;
      case 35:
        return _struct._unique_ar_coeffs_uv_item_35;
      case 36:
        return _struct._unique_ar_coeffs_uv_item_36;
      case 37:
        return _struct._unique_ar_coeffs_uv_item_37;
      case 38:
        return _struct._unique_ar_coeffs_uv_item_38;
      case 39:
        return _struct._unique_ar_coeffs_uv_item_39;
      case 40:
        return _struct._unique_ar_coeffs_uv_item_40;
      case 41:
        return _struct._unique_ar_coeffs_uv_item_41;
      case 42:
        return _struct._unique_ar_coeffs_uv_item_42;
      case 43:
        return _struct._unique_ar_coeffs_uv_item_43;
      case 44:
        return _struct._unique_ar_coeffs_uv_item_44;
      case 45:
        return _struct._unique_ar_coeffs_uv_item_45;
      case 46:
        return _struct._unique_ar_coeffs_uv_item_46;
      case 47:
        return _struct._unique_ar_coeffs_uv_item_47;
      case 48:
        return _struct._unique_ar_coeffs_uv_item_48;
      case 49:
        return _struct._unique_ar_coeffs_uv_item_49;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_ar_coeffs_uv_item_0 = value;
        break;
      case 1:
        _struct._unique_ar_coeffs_uv_item_1 = value;
        break;
      case 2:
        _struct._unique_ar_coeffs_uv_item_2 = value;
        break;
      case 3:
        _struct._unique_ar_coeffs_uv_item_3 = value;
        break;
      case 4:
        _struct._unique_ar_coeffs_uv_item_4 = value;
        break;
      case 5:
        _struct._unique_ar_coeffs_uv_item_5 = value;
        break;
      case 6:
        _struct._unique_ar_coeffs_uv_item_6 = value;
        break;
      case 7:
        _struct._unique_ar_coeffs_uv_item_7 = value;
        break;
      case 8:
        _struct._unique_ar_coeffs_uv_item_8 = value;
        break;
      case 9:
        _struct._unique_ar_coeffs_uv_item_9 = value;
        break;
      case 10:
        _struct._unique_ar_coeffs_uv_item_10 = value;
        break;
      case 11:
        _struct._unique_ar_coeffs_uv_item_11 = value;
        break;
      case 12:
        _struct._unique_ar_coeffs_uv_item_12 = value;
        break;
      case 13:
        _struct._unique_ar_coeffs_uv_item_13 = value;
        break;
      case 14:
        _struct._unique_ar_coeffs_uv_item_14 = value;
        break;
      case 15:
        _struct._unique_ar_coeffs_uv_item_15 = value;
        break;
      case 16:
        _struct._unique_ar_coeffs_uv_item_16 = value;
        break;
      case 17:
        _struct._unique_ar_coeffs_uv_item_17 = value;
        break;
      case 18:
        _struct._unique_ar_coeffs_uv_item_18 = value;
        break;
      case 19:
        _struct._unique_ar_coeffs_uv_item_19 = value;
        break;
      case 20:
        _struct._unique_ar_coeffs_uv_item_20 = value;
        break;
      case 21:
        _struct._unique_ar_coeffs_uv_item_21 = value;
        break;
      case 22:
        _struct._unique_ar_coeffs_uv_item_22 = value;
        break;
      case 23:
        _struct._unique_ar_coeffs_uv_item_23 = value;
        break;
      case 24:
        _struct._unique_ar_coeffs_uv_item_24 = value;
        break;
      case 25:
        _struct._unique_ar_coeffs_uv_item_25 = value;
        break;
      case 26:
        _struct._unique_ar_coeffs_uv_item_26 = value;
        break;
      case 27:
        _struct._unique_ar_coeffs_uv_item_27 = value;
        break;
      case 28:
        _struct._unique_ar_coeffs_uv_item_28 = value;
        break;
      case 29:
        _struct._unique_ar_coeffs_uv_item_29 = value;
        break;
      case 30:
        _struct._unique_ar_coeffs_uv_item_30 = value;
        break;
      case 31:
        _struct._unique_ar_coeffs_uv_item_31 = value;
        break;
      case 32:
        _struct._unique_ar_coeffs_uv_item_32 = value;
        break;
      case 33:
        _struct._unique_ar_coeffs_uv_item_33 = value;
        break;
      case 34:
        _struct._unique_ar_coeffs_uv_item_34 = value;
        break;
      case 35:
        _struct._unique_ar_coeffs_uv_item_35 = value;
        break;
      case 36:
        _struct._unique_ar_coeffs_uv_item_36 = value;
        break;
      case 37:
        _struct._unique_ar_coeffs_uv_item_37 = value;
        break;
      case 38:
        _struct._unique_ar_coeffs_uv_item_38 = value;
        break;
      case 39:
        _struct._unique_ar_coeffs_uv_item_39 = value;
        break;
      case 40:
        _struct._unique_ar_coeffs_uv_item_40 = value;
        break;
      case 41:
        _struct._unique_ar_coeffs_uv_item_41 = value;
        break;
      case 42:
        _struct._unique_ar_coeffs_uv_item_42 = value;
        break;
      case 43:
        _struct._unique_ar_coeffs_uv_item_43 = value;
        break;
      case 44:
        _struct._unique_ar_coeffs_uv_item_44 = value;
        break;
      case 45:
        _struct._unique_ar_coeffs_uv_item_45 = value;
        break;
      case 46:
        _struct._unique_ar_coeffs_uv_item_46 = value;
        break;
      case 47:
        _struct._unique_ar_coeffs_uv_item_47 = value;
        break;
      case 48:
        _struct._unique_ar_coeffs_uv_item_48 = value;
        break;
      case 49:
        _struct._unique_ar_coeffs_uv_item_49 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `uv_mult` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_uv_mult_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_uv_mult_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_uv_mult_item_0;
      case 1:
        return _struct._unique_uv_mult_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_uv_mult_item_0 = value;
        break;
      case 1:
        _struct._unique_uv_mult_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `uv_mult_luma` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_uv_mult_luma_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_uv_mult_luma_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_uv_mult_luma_item_0;
      case 1:
        return _struct._unique_uv_mult_luma_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_uv_mult_luma_item_0 = value;
        break;
      case 1:
        _struct._unique_uv_mult_luma_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `uv_offset` in struct `AVFilmGrainAOMParams`.
class ArrayHelper_AVFilmGrainAOMParams_uv_offset_level0 {
  final AVFilmGrainAOMParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVFilmGrainAOMParams_uv_offset_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_uv_offset_item_0;
      case 1:
        return _struct._unique_uv_offset_item_1;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_uv_offset_item_0 = value;
        break;
      case 1:
        _struct._unique_uv_offset_item_1 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// This structure describes how to handle film grain synthesis in video
/// for specific codecs. Must be present on every frame where film grain is
/// meant to be synthesised for correct presentation.
///
/// @note The struct must be allocated with av_film_grain_params_alloc() and
/// its size is not a part of the public ABI.
class AVFilmGrainParams extends ffi.Struct {}

/// @example ffhash.c
/// This example is a simple command line application that takes one or more
/// arguments. It demonstrates a typical use of the hashing API with allocation,
/// initialization, updating, and finalizing.
class AVHashContext extends ffi.Struct {}

/// Option for overlapping elliptical pixel selectors in an image.
abstract class AVHDRPlusOverlapProcessOption {
  static const int AV_HDR_PLUS_OVERLAP_PROCESS_WEIGHTED_AVERAGING = 0;
  static const int AV_HDR_PLUS_OVERLAP_PROCESS_LAYERING = 1;
}

/// Represents the percentile at a specific percentage in
/// a distribution.
class AVHDRPlusPercentile extends ffi.Struct {}

/// Color transform parameters at a processing window in a dynamic metadata for
/// SMPTE 2094-40.
class AVHDRPlusColorTransformParams extends ffi.Struct {}

/// This struct represents dynamic metadata for color volume transform -
/// application 4 of SMPTE 2094-40:2016 standard.
///
/// To be used as payload of a AVFrameSideData or AVPacketSideData with the
/// appropriate type.
///
/// @note The struct should be allocated with
/// av_dynamic_hdr_plus_alloc() and its size is not a part of
/// the public ABI.
class AVDynamicHDRPlus extends ffi.Struct {}

/// @defgroup lavu_hmac HMAC
/// @ingroup lavu_crypto
/// @{
abstract class AVHMACType {
  static const int AV_HMAC_MD5 = 0;
  static const int AV_HMAC_SHA1 = 1;
  static const int AV_HMAC_SHA224 = 2;
  static const int AV_HMAC_SHA256 = 3;
  static const int AV_HMAC_SHA384 = 4;
  static const int AV_HMAC_SHA512 = 5;
}

class AVHMAC extends ffi.Struct {}

class AVCUDADeviceContextInternal extends ffi.Struct {}

/// This struct is allocated as AVHWDeviceContext.hwctx
class AVCUDADeviceContext extends ffi.Struct {
  @ffi.Int32()
  int cuda_ctx;

  @ffi.Int32()
  int stream;

  ffi.Pointer<AVCUDADeviceContextInternal> internal;
}

/// This struct is allocated as AVHWDeviceContext.hwctx
class AVD3D11VADeviceContext extends ffi.Struct {
  /// Device used for texture creation and access. This can also be used to
  /// set the libavcodec decoding device.
  ///
  /// Must be set by the user. This is the only mandatory field - the other
  /// device context fields are set from this and are available for convenience.
  ///
  /// Deallocating the AVHWDeviceContext will always release this interface,
  /// and it does not matter whether it was user-allocated.
  ffi.Pointer<ffi.Int32> device;

  /// If unset, this will be set from the device field on init.
  ///
  /// Deallocating the AVHWDeviceContext will always release this interface,
  /// and it does not matter whether it was user-allocated.
  ffi.Pointer<ffi.Int32> device_context;

  /// If unset, this will be set from the device field on init.
  ///
  /// Deallocating the AVHWDeviceContext will always release this interface,
  /// and it does not matter whether it was user-allocated.
  ffi.Pointer<ffi.Int32> video_device;

  /// If unset, this will be set from the device_context field on init.
  ///
  /// Deallocating the AVHWDeviceContext will always release this interface,
  /// and it does not matter whether it was user-allocated.
  ffi.Pointer<ffi.Int32> video_context;

  /// Callbacks for locking. They protect accesses to device_context and
  /// video_context calls. They also protect access to the internal staging
  /// texture (for av_hwframe_transfer_data() calls). They do NOT protect
  /// access to hwcontext or decoder state in general.
  ///
  /// If unset on init, the hwcontext implementation will set them to use an
  /// internal mutex.
  ///
  /// The underlying lock must be recursive. lock_ctx is for free use by the
  /// locking implementation.
  ffi.Pointer<ffi.NativeFunction<_typedefC_102>> lock;

  ffi.Pointer<ffi.NativeFunction<_typedefC_103>> unlock;

  ffi.Pointer<ffi.Void> lock_ctx;
}

/// D3D11 frame descriptor for pool allocation.
///
/// In user-allocated pools, AVHWFramesContext.pool must return AVBufferRefs
/// with the data pointer pointing at an object of this type describing the
/// planes of the frame.
///
/// This has no use outside of custom allocation, and AVFrame AVBufferRef do not
/// necessarily point to an instance of this struct.
class AVD3D11FrameDescriptor extends ffi.Struct {
  /// The texture in which the frame is located. The reference count is
  /// managed by the AVBufferRef, and destroying the reference will release
  /// the interface.
  ///
  /// Normally stored in AVFrame.data[0].
  ffi.Pointer<ffi.Int32> texture;

  /// The index into the array texture element representing the frame, or 0
  /// if the texture is not an array texture.
  ///
  /// Normally stored in AVFrame.data[1] (cast from intptr_t).
  @ffi.IntPtr()
  int index;
}

/// This struct is allocated as AVHWFramesContext.hwctx
class AVD3D11VAFramesContext extends ffi.Struct {
  /// The canonical texture used for pool allocation. If this is set to NULL
  /// on init, the hwframes implementation will allocate and set an array
  /// texture if initial_pool_size > 0.
  ///
  /// The only situation when the API user should set this is:
  /// - the user wants to do manual pool allocation (setting
  /// AVHWFramesContext.pool), instead of letting AVHWFramesContext
  /// allocate the pool
  /// - of an array texture
  /// - and wants it to use it for decoding
  /// - this has to be done before calling av_hwframe_ctx_init()
  ///
  /// Deallocating the AVHWFramesContext will always release this interface,
  /// and it does not matter whether it was user-allocated.
  ///
  /// This is in particular used by the libavcodec D3D11VA hwaccel, which
  /// requires a single array texture. It will create ID3D11VideoDecoderOutputView
  /// objects for each array texture element on decoder initialization.
  ffi.Pointer<ffi.Int32> texture;

  /// D3D11_TEXTURE2D_DESC.BindFlags used for texture creation. The user must
  /// at least set D3D11_BIND_DECODER if the frames context is to be used for
  /// video decoding.
  /// This field is ignored/invalid if a user-allocated texture is provided.
  @ffi.Int32()
  int BindFlags;

  /// D3D11_TEXTURE2D_DESC.MiscFlags used for texture creation.
  /// This field is ignored/invalid if a user-allocated texture is provided.
  @ffi.Int32()
  int MiscFlags;
}

/// DRM object descriptor.
///
/// Describes a single DRM object, addressing it as a PRIME file
/// descriptor.
class AVDRMObjectDescriptor extends ffi.Struct {
  /// DRM PRIME fd for the object.
  @ffi.Int32()
  int fd;

  /// Total size of the object.
  ///
  /// (This includes any parts not which do not contain image data.)
  @ffi.Uint64()
  int size;

  /// Format modifier applied to the object (DRM_FORMAT_MOD_*).
  ///
  /// If the format modifier is unknown then this should be set to
  /// DRM_FORMAT_MOD_INVALID.
  @ffi.Uint64()
  int format_modifier;
}

/// DRM plane descriptor.
///
/// Describes a single plane of a layer, which is contained within
/// a single object.
class AVDRMPlaneDescriptor extends ffi.Struct {
  /// Index of the object containing this plane in the objects
  /// array of the enclosing frame descriptor.
  @ffi.Int32()
  int object_index;

  /// Offset within that object of this plane.
  @ffi.Int64()
  int offset;

  /// Pitch (linesize) of this plane.
  @ffi.Int64()
  int pitch;
}

/// DRM layer descriptor.
///
/// Describes a single layer within a frame.  This has the structure
/// defined by its format, and will contain one or more planes.
class AVDRMLayerDescriptor extends ffi.Struct {}

/// DRM frame descriptor.
///
/// This is used as the data pointer for AV_PIX_FMT_DRM_PRIME frames.
/// It is also used by user-allocated frame pools - allocating in
/// AVHWFramesContext.pool must return AVBufferRefs which contain
/// an object of this type.
///
/// The fields of this structure should be set such it can be
/// imported directly by EGL using the EGL_EXT_image_dma_buf_import
/// and EGL_EXT_image_dma_buf_import_modifiers extensions.
/// (Note that the exact layout of a particular format may vary between
/// platforms - we only specify that the same platform should be able
/// to import it.)
///
/// The total number of planes must not exceed AV_DRM_MAX_PLANES, and
/// the order of the planes by increasing layer index followed by
/// increasing plane index must be the same as the order which would
/// be used for the data pointers in the equivalent software format.
class AVDRMFrameDescriptor extends ffi.Struct {}

/// DRM device.
///
/// Allocated as AVHWDeviceContext.hwctx.
class AVDRMDeviceContext extends ffi.Struct {
  /// File descriptor of DRM device.
  ///
  /// This is used as the device to create frames on, and may also be
  /// used in some derivation and mapping operations.
  ///
  /// If no device is required, set to -1.
  @ffi.Int32()
  int fd;
}

/// This struct is allocated as AVHWDeviceContext.hwctx
class AVDXVA2DeviceContext extends ffi.Struct {
  ffi.Pointer<ffi.Int32> devmgr;
}

/// This struct is allocated as AVHWFramesContext.hwctx
class AVDXVA2FramesContext extends ffi.Struct {
  /// The surface type (e.g. DXVA2_VideoProcessorRenderTarget or
  /// DXVA2_VideoDecoderRenderTarget). Must be set by the caller.
  @ffi.Int32()
  int surface_type;

  /// The surface pool. When an external pool is not provided by the caller,
  /// this will be managed (allocated and filled on init, freed on uninit) by
  /// libavutil.
  ffi.Pointer<ffi.Pointer<ffi.Int32>> surfaces;

  @ffi.Int32()
  int nb_surfaces;

  /// Certain drivers require the decoder to be destroyed before the surfaces.
  /// To allow internally managed pools to work properly in such cases, this
  /// field is provided.
  ///
  /// If it is non-NULL, libavutil will call IDirectXVideoDecoder_Release() on
  /// it just before the internal surface pool is freed.
  ///
  /// This is for convenience only. Some code uses other methods to manage the
  /// decoder reference.
  ffi.Pointer<ffi.Int32> decoder_to_release;
}

/// MediaCodec details.
///
/// Allocated as AVHWDeviceContext.hwctx
class AVMediaCodecDeviceContext extends ffi.Struct {
  /// android/view/Surface handle, to be filled by the user.
  ///
  /// This is the default surface used by decoders on this device.
  ffi.Pointer<ffi.Void> surface;
}

/// OpenCL frame descriptor for pool allocation.
///
/// In user-allocated pools, AVHWFramesContext.pool must return AVBufferRefs
/// with the data pointer pointing at an object of this type describing the
/// planes of the frame.
class AVOpenCLFrameDescriptor extends ffi.Struct {
  /// Number of planes in the frame.
  @ffi.Int32()
  int nb_planes;

  @ffi.Int32()
  int _unique_planes_item_0;
  @ffi.Int32()
  int _unique_planes_item_1;
  @ffi.Int32()
  int _unique_planes_item_2;
  @ffi.Int32()
  int _unique_planes_item_3;
  @ffi.Int32()
  int _unique_planes_item_4;
  @ffi.Int32()
  int _unique_planes_item_5;
  @ffi.Int32()
  int _unique_planes_item_6;
  @ffi.Int32()
  int _unique_planes_item_7;

  /// Helper for array `planes`.
  ArrayHelper_AVOpenCLFrameDescriptor_planes_level0 get planes =>
      ArrayHelper_AVOpenCLFrameDescriptor_planes_level0(this, [8], 0, 0);
}

/// Helper for array `planes` in struct `AVOpenCLFrameDescriptor`.
class ArrayHelper_AVOpenCLFrameDescriptor_planes_level0 {
  final AVOpenCLFrameDescriptor _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVOpenCLFrameDescriptor_planes_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_planes_item_0;
      case 1:
        return _struct._unique_planes_item_1;
      case 2:
        return _struct._unique_planes_item_2;
      case 3:
        return _struct._unique_planes_item_3;
      case 4:
        return _struct._unique_planes_item_4;
      case 5:
        return _struct._unique_planes_item_5;
      case 6:
        return _struct._unique_planes_item_6;
      case 7:
        return _struct._unique_planes_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_planes_item_0 = value;
        break;
      case 1:
        _struct._unique_planes_item_1 = value;
        break;
      case 2:
        _struct._unique_planes_item_2 = value;
        break;
      case 3:
        _struct._unique_planes_item_3 = value;
        break;
      case 4:
        _struct._unique_planes_item_4 = value;
        break;
      case 5:
        _struct._unique_planes_item_5 = value;
        break;
      case 6:
        _struct._unique_planes_item_6 = value;
        break;
      case 7:
        _struct._unique_planes_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// OpenCL device details.
///
/// Allocated as AVHWDeviceContext.hwctx
class AVOpenCLDeviceContext extends ffi.Struct {
  /// The primary device ID of the device.  If multiple OpenCL devices
  /// are associated with the context then this is the one which will
  /// be used for all operations internal to FFmpeg.
  @ffi.Int32()
  int device_id;

  /// The OpenCL context which will contain all operations and frames on
  /// this device.
  @ffi.Int32()
  int context;

  /// The default command queue for this device, which will be used by all
  /// frames contexts which do not have their own command queue.  If not
  /// intialised by the user, a default queue will be created on the
  /// primary device.
  @ffi.Int32()
  int command_queue;
}

/// OpenCL-specific data associated with a frame pool.
///
/// Allocated as AVHWFramesContext.hwctx.
class AVOpenCLFramesContext extends ffi.Struct {
  /// The command queue used for internal asynchronous operations on this
  /// device (av_hwframe_transfer_data(), av_hwframe_map()).
  ///
  /// If this is not set, the command queue from the associated device is
  /// used instead.
  @ffi.Int32()
  int command_queue;
}

/// This struct is allocated as AVHWDeviceContext.hwctx
class AVQSVDeviceContext extends ffi.Struct {
  @ffi.Int32()
  int session;
}

/// This struct is allocated as AVHWFramesContext.hwctx
class AVQSVFramesContext extends ffi.Struct {
  ffi.Pointer<ffi.Int32> surfaces;

  @ffi.Int32()
  int nb_surfaces;

  /// A combination of MFX_MEMTYPE_* describing the frame pool.
  @ffi.Int32()
  int frame_type;
}

/// VAAPI connection details.
///
/// Allocated as AVHWDeviceContext.hwctx
class AVVAAPIDeviceContext extends ffi.Struct {
  /// The VADisplay handle, to be filled by the user.
  @ffi.Int32()
  int display;

  /// Driver quirks to apply - this is filled by av_hwdevice_ctx_init(),
  /// with reference to a table of known drivers, unless the
  /// AV_VAAPI_DRIVER_QUIRK_USER_SET bit is already present.  The user
  /// may need to refer to this field when performing any later
  /// operations using VAAPI with the same VADisplay.
  @ffi.Uint32()
  int driver_quirks;
}

/// VAAPI-specific data associated with a frame pool.
///
/// Allocated as AVHWFramesContext.hwctx.
class AVVAAPIFramesContext extends ffi.Struct {
  /// Set by the user to apply surface attributes to all surfaces in
  /// the frame pool.  If null, default settings are used.
  ffi.Pointer<ffi.Int32> attributes;

  @ffi.Int32()
  int nb_attributes;

  /// The surfaces IDs of all surfaces in the pool after creation.
  /// Only valid if AVHWFramesContext.initial_pool_size was positive.
  /// These are intended to be used as the render_targets arguments to
  /// vaCreateContext().
  ffi.Pointer<ffi.Int32> surface_ids;

  @ffi.Int32()
  int nb_surfaces;
}

/// VAAPI hardware pipeline configuration details.
///
/// Allocated with av_hwdevice_hwconfig_alloc().
class AVVAAPIHWConfig extends ffi.Struct {
  /// ID of a VAAPI pipeline configuration.
  @ffi.Int32()
  int config_id;
}

/// This struct is allocated as AVHWDeviceContext.hwctx
class AVVDPAUDeviceContext extends ffi.Struct {
  @ffi.Int32()
  int device;

  ffi.Pointer<ffi.Int32> get_proc_address;
}

/// Main Vulkan context, allocated as AVHWDeviceContext.hwctx.
/// All of these can be set before init to change what the context uses
class AVVulkanDeviceContext extends ffi.Struct {
  /// Custom memory allocator, else NULL
  ffi.Pointer<ffi.Int32> alloc;

  /// Vulkan instance. Must be at least version 1.1.
  @ffi.Int32()
  int inst;

  /// Physical device
  @ffi.Int32()
  int phys_dev;

  /// Active device
  @ffi.Int32()
  int act_dev;

  /// Queue family index for graphics
  /// @note av_hwdevice_create() will set all 3 queue indices if unset
  /// If there is no dedicated queue for compute or transfer operations,
  /// they will be set to the graphics queue index which can handle both.
  /// nb_graphics_queues indicates how many queues were enabled for the
  /// graphics queue (must be at least 1)
  @ffi.Int32()
  int queue_family_index;

  @ffi.Int32()
  int nb_graphics_queues;

  /// Queue family index to use for transfer operations, and the amount of queues
  /// enabled. In case there is no dedicated transfer queue, nb_tx_queues
  /// must be 0 and queue_family_tx_index must be the same as either the graphics
  /// queue or the compute queue, if available.
  @ffi.Int32()
  int queue_family_tx_index;

  @ffi.Int32()
  int nb_tx_queues;

  /// Queue family index for compute ops, and the amount of queues enabled.
  /// In case there are no dedicated compute queues, nb_comp_queues must be
  /// 0 and its queue family index must be set to the graphics queue.
  @ffi.Int32()
  int queue_family_comp_index;

  @ffi.Int32()
  int nb_comp_queues;

  /// Enabled instance extensions.
  /// If supplying your own device context, set this to an array of strings, with
  /// each entry containing the specified Vulkan extension string to enable.
  /// Duplicates are possible and accepted.
  /// If no extensions are enabled, set these fields to NULL, and 0 respectively.
  ffi.Pointer<ffi.Pointer<ffi.Int8>> enabled_inst_extensions;

  @ffi.Int32()
  int nb_enabled_inst_extensions;

  /// Enabled device extensions. By default, VK_KHR_external_memory_fd,
  /// VK_EXT_external_memory_dma_buf, VK_EXT_image_drm_format_modifier,
  /// VK_KHR_external_semaphore_fd and VK_EXT_external_memory_host are enabled if found.
  /// If supplying your own device context, these fields takes the same format as
  /// the above fields, with the same conditions that duplicates are possible
  /// and accepted, and that NULL and 0 respectively means no extensions are enabled.
  ffi.Pointer<ffi.Pointer<ffi.Int8>> enabled_dev_extensions;

  @ffi.Int32()
  int nb_enabled_dev_extensions;

  /// This structure should be set to the set of features that present and enabled
  /// during device creation. When a device is created by FFmpeg, it will default to
  /// enabling all that are present of the shaderImageGatherExtended,
  /// fragmentStoresAndAtomics, shaderInt64 and vertexPipelineStoresAndAtomics features.
  @ffi.Int32()
  int device_features;
}

/// Allocated as AVHWFramesContext.hwctx, used to set pool-specific options
class AVVulkanFramesContext extends ffi.Struct {
  /// Controls the tiling of allocated frames.
  @ffi.Int32()
  int tiling;

  /// Defines extra usage of output frames. If left as 0, the following bits
  /// are set: TRANSFER_SRC, TRANSFER_DST. SAMPLED and STORAGE.
  @ffi.Int32()
  int usage;

  /// Extension data for image creation.
  ffi.Pointer<ffi.Void> create_pnext;

  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_0;
  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_1;
  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_2;
  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_3;
  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_4;
  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_5;
  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_6;
  ffi.Pointer<ffi.Void> _unique_alloc_pnext_item_7;

  /// Helper for array `alloc_pnext`.
  ArrayHelper_AVVulkanFramesContext_alloc_pnext_level0 get alloc_pnext =>
      ArrayHelper_AVVulkanFramesContext_alloc_pnext_level0(this, [8], 0, 0);
}

/// Helper for array `alloc_pnext` in struct `AVVulkanFramesContext`.
class ArrayHelper_AVVulkanFramesContext_alloc_pnext_level0 {
  final AVVulkanFramesContext _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVulkanFramesContext_alloc_pnext_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ffi.Pointer<ffi.Void> operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_alloc_pnext_item_0;
      case 1:
        return _struct._unique_alloc_pnext_item_1;
      case 2:
        return _struct._unique_alloc_pnext_item_2;
      case 3:
        return _struct._unique_alloc_pnext_item_3;
      case 4:
        return _struct._unique_alloc_pnext_item_4;
      case 5:
        return _struct._unique_alloc_pnext_item_5;
      case 6:
        return _struct._unique_alloc_pnext_item_6;
      case 7:
        return _struct._unique_alloc_pnext_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, ffi.Pointer<ffi.Void> value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_alloc_pnext_item_0 = value;
        break;
      case 1:
        _struct._unique_alloc_pnext_item_1 = value;
        break;
      case 2:
        _struct._unique_alloc_pnext_item_2 = value;
        break;
      case 3:
        _struct._unique_alloc_pnext_item_3 = value;
        break;
      case 4:
        _struct._unique_alloc_pnext_item_4 = value;
        break;
      case 5:
        _struct._unique_alloc_pnext_item_5 = value;
        break;
      case 6:
        _struct._unique_alloc_pnext_item_6 = value;
        break;
      case 7:
        _struct._unique_alloc_pnext_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class AVVkFrameInternal extends ffi.Struct {}

class AVVkFrame extends ffi.Struct {
  @ffi.Int32()
  int _unique_img_item_0;
  @ffi.Int32()
  int _unique_img_item_1;
  @ffi.Int32()
  int _unique_img_item_2;
  @ffi.Int32()
  int _unique_img_item_3;
  @ffi.Int32()
  int _unique_img_item_4;
  @ffi.Int32()
  int _unique_img_item_5;
  @ffi.Int32()
  int _unique_img_item_6;
  @ffi.Int32()
  int _unique_img_item_7;

  /// Helper for array `img`.
  ArrayHelper_AVVkFrame_img_level0 get img =>
      ArrayHelper_AVVkFrame_img_level0(this, [8], 0, 0);

  /// The same tiling must be used for all images in the frame.
  @ffi.Int32()
  int tiling;

  @ffi.Int32()
  int _unique_mem_item_0;
  @ffi.Int32()
  int _unique_mem_item_1;
  @ffi.Int32()
  int _unique_mem_item_2;
  @ffi.Int32()
  int _unique_mem_item_3;
  @ffi.Int32()
  int _unique_mem_item_4;
  @ffi.Int32()
  int _unique_mem_item_5;
  @ffi.Int32()
  int _unique_mem_item_6;
  @ffi.Int32()
  int _unique_mem_item_7;

  /// Helper for array `mem`.
  ArrayHelper_AVVkFrame_mem_level0 get mem =>
      ArrayHelper_AVVkFrame_mem_level0(this, [8], 0, 0);
  @ffi.Uint64()
  int _unique_size_item_0;
  @ffi.Uint64()
  int _unique_size_item_1;
  @ffi.Uint64()
  int _unique_size_item_2;
  @ffi.Uint64()
  int _unique_size_item_3;
  @ffi.Uint64()
  int _unique_size_item_4;
  @ffi.Uint64()
  int _unique_size_item_5;
  @ffi.Uint64()
  int _unique_size_item_6;
  @ffi.Uint64()
  int _unique_size_item_7;

  /// Helper for array `size`.
  ArrayHelper_AVVkFrame_size_level0 get size =>
      ArrayHelper_AVVkFrame_size_level0(this, [8], 0, 0);

  /// OR'd flags for all memory allocated
  @ffi.Int32()
  int flags;

  @ffi.Int32()
  int _unique_access_item_0;
  @ffi.Int32()
  int _unique_access_item_1;
  @ffi.Int32()
  int _unique_access_item_2;
  @ffi.Int32()
  int _unique_access_item_3;
  @ffi.Int32()
  int _unique_access_item_4;
  @ffi.Int32()
  int _unique_access_item_5;
  @ffi.Int32()
  int _unique_access_item_6;
  @ffi.Int32()
  int _unique_access_item_7;

  /// Helper for array `access`.
  ArrayHelper_AVVkFrame_access_level0 get access =>
      ArrayHelper_AVVkFrame_access_level0(this, [8], 0, 0);
  @ffi.Int32()
  int _unique_layout_item_0;
  @ffi.Int32()
  int _unique_layout_item_1;
  @ffi.Int32()
  int _unique_layout_item_2;
  @ffi.Int32()
  int _unique_layout_item_3;
  @ffi.Int32()
  int _unique_layout_item_4;
  @ffi.Int32()
  int _unique_layout_item_5;
  @ffi.Int32()
  int _unique_layout_item_6;
  @ffi.Int32()
  int _unique_layout_item_7;

  /// Helper for array `layout`.
  ArrayHelper_AVVkFrame_layout_level0 get layout =>
      ArrayHelper_AVVkFrame_layout_level0(this, [8], 0, 0);
  @ffi.Int32()
  int _unique_sem_item_0;
  @ffi.Int32()
  int _unique_sem_item_1;
  @ffi.Int32()
  int _unique_sem_item_2;
  @ffi.Int32()
  int _unique_sem_item_3;
  @ffi.Int32()
  int _unique_sem_item_4;
  @ffi.Int32()
  int _unique_sem_item_5;
  @ffi.Int32()
  int _unique_sem_item_6;
  @ffi.Int32()
  int _unique_sem_item_7;

  /// Helper for array `sem`.
  ArrayHelper_AVVkFrame_sem_level0 get sem =>
      ArrayHelper_AVVkFrame_sem_level0(this, [8], 0, 0);

  /// Internal data.
  ffi.Pointer<AVVkFrameInternal> internal;
}

/// Helper for array `img` in struct `AVVkFrame`.
class ArrayHelper_AVVkFrame_img_level0 {
  final AVVkFrame _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVkFrame_img_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_img_item_0;
      case 1:
        return _struct._unique_img_item_1;
      case 2:
        return _struct._unique_img_item_2;
      case 3:
        return _struct._unique_img_item_3;
      case 4:
        return _struct._unique_img_item_4;
      case 5:
        return _struct._unique_img_item_5;
      case 6:
        return _struct._unique_img_item_6;
      case 7:
        return _struct._unique_img_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_img_item_0 = value;
        break;
      case 1:
        _struct._unique_img_item_1 = value;
        break;
      case 2:
        _struct._unique_img_item_2 = value;
        break;
      case 3:
        _struct._unique_img_item_3 = value;
        break;
      case 4:
        _struct._unique_img_item_4 = value;
        break;
      case 5:
        _struct._unique_img_item_5 = value;
        break;
      case 6:
        _struct._unique_img_item_6 = value;
        break;
      case 7:
        _struct._unique_img_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `mem` in struct `AVVkFrame`.
class ArrayHelper_AVVkFrame_mem_level0 {
  final AVVkFrame _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVkFrame_mem_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_mem_item_0;
      case 1:
        return _struct._unique_mem_item_1;
      case 2:
        return _struct._unique_mem_item_2;
      case 3:
        return _struct._unique_mem_item_3;
      case 4:
        return _struct._unique_mem_item_4;
      case 5:
        return _struct._unique_mem_item_5;
      case 6:
        return _struct._unique_mem_item_6;
      case 7:
        return _struct._unique_mem_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_mem_item_0 = value;
        break;
      case 1:
        _struct._unique_mem_item_1 = value;
        break;
      case 2:
        _struct._unique_mem_item_2 = value;
        break;
      case 3:
        _struct._unique_mem_item_3 = value;
        break;
      case 4:
        _struct._unique_mem_item_4 = value;
        break;
      case 5:
        _struct._unique_mem_item_5 = value;
        break;
      case 6:
        _struct._unique_mem_item_6 = value;
        break;
      case 7:
        _struct._unique_mem_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `size` in struct `AVVkFrame`.
class ArrayHelper_AVVkFrame_size_level0 {
  final AVVkFrame _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVkFrame_size_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_size_item_0;
      case 1:
        return _struct._unique_size_item_1;
      case 2:
        return _struct._unique_size_item_2;
      case 3:
        return _struct._unique_size_item_3;
      case 4:
        return _struct._unique_size_item_4;
      case 5:
        return _struct._unique_size_item_5;
      case 6:
        return _struct._unique_size_item_6;
      case 7:
        return _struct._unique_size_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_size_item_0 = value;
        break;
      case 1:
        _struct._unique_size_item_1 = value;
        break;
      case 2:
        _struct._unique_size_item_2 = value;
        break;
      case 3:
        _struct._unique_size_item_3 = value;
        break;
      case 4:
        _struct._unique_size_item_4 = value;
        break;
      case 5:
        _struct._unique_size_item_5 = value;
        break;
      case 6:
        _struct._unique_size_item_6 = value;
        break;
      case 7:
        _struct._unique_size_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `access` in struct `AVVkFrame`.
class ArrayHelper_AVVkFrame_access_level0 {
  final AVVkFrame _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVkFrame_access_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_access_item_0;
      case 1:
        return _struct._unique_access_item_1;
      case 2:
        return _struct._unique_access_item_2;
      case 3:
        return _struct._unique_access_item_3;
      case 4:
        return _struct._unique_access_item_4;
      case 5:
        return _struct._unique_access_item_5;
      case 6:
        return _struct._unique_access_item_6;
      case 7:
        return _struct._unique_access_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_access_item_0 = value;
        break;
      case 1:
        _struct._unique_access_item_1 = value;
        break;
      case 2:
        _struct._unique_access_item_2 = value;
        break;
      case 3:
        _struct._unique_access_item_3 = value;
        break;
      case 4:
        _struct._unique_access_item_4 = value;
        break;
      case 5:
        _struct._unique_access_item_5 = value;
        break;
      case 6:
        _struct._unique_access_item_6 = value;
        break;
      case 7:
        _struct._unique_access_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `layout` in struct `AVVkFrame`.
class ArrayHelper_AVVkFrame_layout_level0 {
  final AVVkFrame _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVkFrame_layout_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_layout_item_0;
      case 1:
        return _struct._unique_layout_item_1;
      case 2:
        return _struct._unique_layout_item_2;
      case 3:
        return _struct._unique_layout_item_3;
      case 4:
        return _struct._unique_layout_item_4;
      case 5:
        return _struct._unique_layout_item_5;
      case 6:
        return _struct._unique_layout_item_6;
      case 7:
        return _struct._unique_layout_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_layout_item_0 = value;
        break;
      case 1:
        _struct._unique_layout_item_1 = value;
        break;
      case 2:
        _struct._unique_layout_item_2 = value;
        break;
      case 3:
        _struct._unique_layout_item_3 = value;
        break;
      case 4:
        _struct._unique_layout_item_4 = value;
        break;
      case 5:
        _struct._unique_layout_item_5 = value;
        break;
      case 6:
        _struct._unique_layout_item_6 = value;
        break;
      case 7:
        _struct._unique_layout_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Helper for array `sem` in struct `AVVkFrame`.
class ArrayHelper_AVVkFrame_sem_level0 {
  final AVVkFrame _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVkFrame_sem_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_sem_item_0;
      case 1:
        return _struct._unique_sem_item_1;
      case 2:
        return _struct._unique_sem_item_2;
      case 3:
        return _struct._unique_sem_item_3;
      case 4:
        return _struct._unique_sem_item_4;
      case 5:
        return _struct._unique_sem_item_5;
      case 6:
        return _struct._unique_sem_item_6;
      case 7:
        return _struct._unique_sem_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_sem_item_0 = value;
        break;
      case 1:
        _struct._unique_sem_item_1 = value;
        break;
      case 2:
        _struct._unique_sem_item_2 = value;
        break;
      case 3:
        _struct._unique_sem_item_3 = value;
        break;
      case 4:
        _struct._unique_sem_item_4 = value;
        break;
      case 5:
        _struct._unique_sem_item_5 = value;
        break;
      case 6:
        _struct._unique_sem_item_6 = value;
        break;
      case 7:
        _struct._unique_sem_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

class AVComponentDescriptor extends ffi.Struct {
  /// Which of the 4 planes contains the component.
  @ffi.Int32()
  int plane;

  /// Number of elements between 2 horizontally consecutive pixels.
  /// Elements are bits for bitstream formats, bytes otherwise.
  @ffi.Int32()
  int step;

  /// Number of elements before the component of the first pixel.
  /// Elements are bits for bitstream formats, bytes otherwise.
  @ffi.Int32()
  int offset;

  /// Number of least significant bits that must be shifted away
  /// to get the value.
  @ffi.Int32()
  int shift;

  /// Number of bits in the component.
  @ffi.Int32()
  int depth;

  /// deprecated, use step instead
  @ffi.Int32()
  int step_minus1;

  /// deprecated, use depth instead
  @ffi.Int32()
  int depth_minus1;

  /// deprecated, use offset instead
  @ffi.Int32()
  int offset_plus1;
}

/// Descriptor that unambiguously describes how the bits of a pixel are
/// stored in the up to 4 data planes of an image. It also stores the
/// subsampling factors and number of components.
///
/// @note This is separate of the colorspace (RGB, YCbCr, YPbPr, JPEG-style YUV
/// and all the YUV variants) AVPixFmtDescriptor just stores how values
/// are stored not what these values represent.
class AVPixFmtDescriptor extends ffi.Struct {}

/// Context structure for the Lagged Fibonacci PRNG.
/// The exact layout, types and content of this struct may change and should
/// not be accessed directly. Only its sizeof() is guranteed to stay the same
/// to allow easy instanciation.
class AVLFG extends ffi.Struct {
  @ffi.Uint32()
  int _unique_state_item_0;
  @ffi.Uint32()
  int _unique_state_item_1;
  @ffi.Uint32()
  int _unique_state_item_2;
  @ffi.Uint32()
  int _unique_state_item_3;
  @ffi.Uint32()
  int _unique_state_item_4;
  @ffi.Uint32()
  int _unique_state_item_5;
  @ffi.Uint32()
  int _unique_state_item_6;
  @ffi.Uint32()
  int _unique_state_item_7;
  @ffi.Uint32()
  int _unique_state_item_8;
  @ffi.Uint32()
  int _unique_state_item_9;
  @ffi.Uint32()
  int _unique_state_item_10;
  @ffi.Uint32()
  int _unique_state_item_11;
  @ffi.Uint32()
  int _unique_state_item_12;
  @ffi.Uint32()
  int _unique_state_item_13;
  @ffi.Uint32()
  int _unique_state_item_14;
  @ffi.Uint32()
  int _unique_state_item_15;
  @ffi.Uint32()
  int _unique_state_item_16;
  @ffi.Uint32()
  int _unique_state_item_17;
  @ffi.Uint32()
  int _unique_state_item_18;
  @ffi.Uint32()
  int _unique_state_item_19;
  @ffi.Uint32()
  int _unique_state_item_20;
  @ffi.Uint32()
  int _unique_state_item_21;
  @ffi.Uint32()
  int _unique_state_item_22;
  @ffi.Uint32()
  int _unique_state_item_23;
  @ffi.Uint32()
  int _unique_state_item_24;
  @ffi.Uint32()
  int _unique_state_item_25;
  @ffi.Uint32()
  int _unique_state_item_26;
  @ffi.Uint32()
  int _unique_state_item_27;
  @ffi.Uint32()
  int _unique_state_item_28;
  @ffi.Uint32()
  int _unique_state_item_29;
  @ffi.Uint32()
  int _unique_state_item_30;
  @ffi.Uint32()
  int _unique_state_item_31;
  @ffi.Uint32()
  int _unique_state_item_32;
  @ffi.Uint32()
  int _unique_state_item_33;
  @ffi.Uint32()
  int _unique_state_item_34;
  @ffi.Uint32()
  int _unique_state_item_35;
  @ffi.Uint32()
  int _unique_state_item_36;
  @ffi.Uint32()
  int _unique_state_item_37;
  @ffi.Uint32()
  int _unique_state_item_38;
  @ffi.Uint32()
  int _unique_state_item_39;
  @ffi.Uint32()
  int _unique_state_item_40;
  @ffi.Uint32()
  int _unique_state_item_41;
  @ffi.Uint32()
  int _unique_state_item_42;
  @ffi.Uint32()
  int _unique_state_item_43;
  @ffi.Uint32()
  int _unique_state_item_44;
  @ffi.Uint32()
  int _unique_state_item_45;
  @ffi.Uint32()
  int _unique_state_item_46;
  @ffi.Uint32()
  int _unique_state_item_47;
  @ffi.Uint32()
  int _unique_state_item_48;
  @ffi.Uint32()
  int _unique_state_item_49;
  @ffi.Uint32()
  int _unique_state_item_50;
  @ffi.Uint32()
  int _unique_state_item_51;
  @ffi.Uint32()
  int _unique_state_item_52;
  @ffi.Uint32()
  int _unique_state_item_53;
  @ffi.Uint32()
  int _unique_state_item_54;
  @ffi.Uint32()
  int _unique_state_item_55;
  @ffi.Uint32()
  int _unique_state_item_56;
  @ffi.Uint32()
  int _unique_state_item_57;
  @ffi.Uint32()
  int _unique_state_item_58;
  @ffi.Uint32()
  int _unique_state_item_59;
  @ffi.Uint32()
  int _unique_state_item_60;
  @ffi.Uint32()
  int _unique_state_item_61;
  @ffi.Uint32()
  int _unique_state_item_62;
  @ffi.Uint32()
  int _unique_state_item_63;

  /// Helper for array `state`.
  ArrayHelper_AVLFG_state_level0 get state =>
      ArrayHelper_AVLFG_state_level0(this, [64], 0, 0);
  @ffi.Int32()
  int index;
}

/// Helper for array `state` in struct `AVLFG`.
class ArrayHelper_AVLFG_state_level0 {
  final AVLFG _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVLFG_state_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_state_item_0;
      case 1:
        return _struct._unique_state_item_1;
      case 2:
        return _struct._unique_state_item_2;
      case 3:
        return _struct._unique_state_item_3;
      case 4:
        return _struct._unique_state_item_4;
      case 5:
        return _struct._unique_state_item_5;
      case 6:
        return _struct._unique_state_item_6;
      case 7:
        return _struct._unique_state_item_7;
      case 8:
        return _struct._unique_state_item_8;
      case 9:
        return _struct._unique_state_item_9;
      case 10:
        return _struct._unique_state_item_10;
      case 11:
        return _struct._unique_state_item_11;
      case 12:
        return _struct._unique_state_item_12;
      case 13:
        return _struct._unique_state_item_13;
      case 14:
        return _struct._unique_state_item_14;
      case 15:
        return _struct._unique_state_item_15;
      case 16:
        return _struct._unique_state_item_16;
      case 17:
        return _struct._unique_state_item_17;
      case 18:
        return _struct._unique_state_item_18;
      case 19:
        return _struct._unique_state_item_19;
      case 20:
        return _struct._unique_state_item_20;
      case 21:
        return _struct._unique_state_item_21;
      case 22:
        return _struct._unique_state_item_22;
      case 23:
        return _struct._unique_state_item_23;
      case 24:
        return _struct._unique_state_item_24;
      case 25:
        return _struct._unique_state_item_25;
      case 26:
        return _struct._unique_state_item_26;
      case 27:
        return _struct._unique_state_item_27;
      case 28:
        return _struct._unique_state_item_28;
      case 29:
        return _struct._unique_state_item_29;
      case 30:
        return _struct._unique_state_item_30;
      case 31:
        return _struct._unique_state_item_31;
      case 32:
        return _struct._unique_state_item_32;
      case 33:
        return _struct._unique_state_item_33;
      case 34:
        return _struct._unique_state_item_34;
      case 35:
        return _struct._unique_state_item_35;
      case 36:
        return _struct._unique_state_item_36;
      case 37:
        return _struct._unique_state_item_37;
      case 38:
        return _struct._unique_state_item_38;
      case 39:
        return _struct._unique_state_item_39;
      case 40:
        return _struct._unique_state_item_40;
      case 41:
        return _struct._unique_state_item_41;
      case 42:
        return _struct._unique_state_item_42;
      case 43:
        return _struct._unique_state_item_43;
      case 44:
        return _struct._unique_state_item_44;
      case 45:
        return _struct._unique_state_item_45;
      case 46:
        return _struct._unique_state_item_46;
      case 47:
        return _struct._unique_state_item_47;
      case 48:
        return _struct._unique_state_item_48;
      case 49:
        return _struct._unique_state_item_49;
      case 50:
        return _struct._unique_state_item_50;
      case 51:
        return _struct._unique_state_item_51;
      case 52:
        return _struct._unique_state_item_52;
      case 53:
        return _struct._unique_state_item_53;
      case 54:
        return _struct._unique_state_item_54;
      case 55:
        return _struct._unique_state_item_55;
      case 56:
        return _struct._unique_state_item_56;
      case 57:
        return _struct._unique_state_item_57;
      case 58:
        return _struct._unique_state_item_58;
      case 59:
        return _struct._unique_state_item_59;
      case 60:
        return _struct._unique_state_item_60;
      case 61:
        return _struct._unique_state_item_61;
      case 62:
        return _struct._unique_state_item_62;
      case 63:
        return _struct._unique_state_item_63;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_state_item_0 = value;
        break;
      case 1:
        _struct._unique_state_item_1 = value;
        break;
      case 2:
        _struct._unique_state_item_2 = value;
        break;
      case 3:
        _struct._unique_state_item_3 = value;
        break;
      case 4:
        _struct._unique_state_item_4 = value;
        break;
      case 5:
        _struct._unique_state_item_5 = value;
        break;
      case 6:
        _struct._unique_state_item_6 = value;
        break;
      case 7:
        _struct._unique_state_item_7 = value;
        break;
      case 8:
        _struct._unique_state_item_8 = value;
        break;
      case 9:
        _struct._unique_state_item_9 = value;
        break;
      case 10:
        _struct._unique_state_item_10 = value;
        break;
      case 11:
        _struct._unique_state_item_11 = value;
        break;
      case 12:
        _struct._unique_state_item_12 = value;
        break;
      case 13:
        _struct._unique_state_item_13 = value;
        break;
      case 14:
        _struct._unique_state_item_14 = value;
        break;
      case 15:
        _struct._unique_state_item_15 = value;
        break;
      case 16:
        _struct._unique_state_item_16 = value;
        break;
      case 17:
        _struct._unique_state_item_17 = value;
        break;
      case 18:
        _struct._unique_state_item_18 = value;
        break;
      case 19:
        _struct._unique_state_item_19 = value;
        break;
      case 20:
        _struct._unique_state_item_20 = value;
        break;
      case 21:
        _struct._unique_state_item_21 = value;
        break;
      case 22:
        _struct._unique_state_item_22 = value;
        break;
      case 23:
        _struct._unique_state_item_23 = value;
        break;
      case 24:
        _struct._unique_state_item_24 = value;
        break;
      case 25:
        _struct._unique_state_item_25 = value;
        break;
      case 26:
        _struct._unique_state_item_26 = value;
        break;
      case 27:
        _struct._unique_state_item_27 = value;
        break;
      case 28:
        _struct._unique_state_item_28 = value;
        break;
      case 29:
        _struct._unique_state_item_29 = value;
        break;
      case 30:
        _struct._unique_state_item_30 = value;
        break;
      case 31:
        _struct._unique_state_item_31 = value;
        break;
      case 32:
        _struct._unique_state_item_32 = value;
        break;
      case 33:
        _struct._unique_state_item_33 = value;
        break;
      case 34:
        _struct._unique_state_item_34 = value;
        break;
      case 35:
        _struct._unique_state_item_35 = value;
        break;
      case 36:
        _struct._unique_state_item_36 = value;
        break;
      case 37:
        _struct._unique_state_item_37 = value;
        break;
      case 38:
        _struct._unique_state_item_38 = value;
        break;
      case 39:
        _struct._unique_state_item_39 = value;
        break;
      case 40:
        _struct._unique_state_item_40 = value;
        break;
      case 41:
        _struct._unique_state_item_41 = value;
        break;
      case 42:
        _struct._unique_state_item_42 = value;
        break;
      case 43:
        _struct._unique_state_item_43 = value;
        break;
      case 44:
        _struct._unique_state_item_44 = value;
        break;
      case 45:
        _struct._unique_state_item_45 = value;
        break;
      case 46:
        _struct._unique_state_item_46 = value;
        break;
      case 47:
        _struct._unique_state_item_47 = value;
        break;
      case 48:
        _struct._unique_state_item_48 = value;
        break;
      case 49:
        _struct._unique_state_item_49 = value;
        break;
      case 50:
        _struct._unique_state_item_50 = value;
        break;
      case 51:
        _struct._unique_state_item_51 = value;
        break;
      case 52:
        _struct._unique_state_item_52 = value;
        break;
      case 53:
        _struct._unique_state_item_53 = value;
        break;
      case 54:
        _struct._unique_state_item_54 = value;
        break;
      case 55:
        _struct._unique_state_item_55 = value;
        break;
      case 56:
        _struct._unique_state_item_56 = value;
        break;
      case 57:
        _struct._unique_state_item_57 = value;
        break;
      case 58:
        _struct._unique_state_item_58 = value;
        break;
      case 59:
        _struct._unique_state_item_59 = value;
        break;
      case 60:
        _struct._unique_state_item_60 = value;
        break;
      case 61:
        _struct._unique_state_item_61 = value;
        break;
      case 62:
        _struct._unique_state_item_62 = value;
        break;
      case 63:
        _struct._unique_state_item_63 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Mastering display metadata capable of representing the color volume of
/// the display used to master the content (SMPTE 2086:2014).
///
/// To be used as payload of a AVFrameSideData or AVPacketSideData with the
/// appropriate type.
///
/// @note The struct should be allocated with av_mastering_display_metadata_alloc()
/// and its size is not a part of the public ABI.
class AVMasteringDisplayMetadata extends ffi.Struct {}

/// Content light level needed by to transmit HDR over HDMI (CTA-861.3).
///
/// To be used as payload of a AVFrameSideData or AVPacketSideData with the
/// appropriate type.
///
/// @note The struct should be allocated with av_content_light_metadata_alloc()
/// and its size is not a part of the public ABI.
class AVContentLightMetadata extends ffi.Struct {
  /// Max content light level (cd/m^2).
  @ffi.Uint32()
  int MaxCLL;

  /// Max average light level per frame (cd/m^2).
  @ffi.Uint32()
  int MaxFALL;
}

class AVMD5 extends ffi.Struct {}

class AVMotionVector extends ffi.Struct {
  /// Where the current macroblock comes from; negative value when it comes
  /// from the past, positive value when it comes from the future.
  /// XXX: set exact relative ref frame reference instead of a +/- 1 "direction".
  @ffi.Int32()
  int source;

  /// Width and height of the block.
  @ffi.Uint8()
  int w;

  @ffi.Uint8()
  int h;

  /// Absolute source position. Can be outside the frame area.
  @ffi.Int16()
  int src_x;

  @ffi.Int16()
  int src_y;

  /// Absolute destination position. Can be outside the frame area.
  @ffi.Int16()
  int dst_x;

  @ffi.Int16()
  int dst_y;

  /// Extra flag information.
  /// Currently unused.
  @ffi.Uint64()
  int flags;

  /// Motion vector
  /// src_x = dst_x + motion_x / motion_scale
  /// src_y = dst_y + motion_y / motion_scale
  @ffi.Int32()
  int motion_x;

  @ffi.Int32()
  int motion_y;

  @ffi.Uint16()
  int motion_scale;
}

class AVMurMur3 extends ffi.Struct {}

/// @defgroup lavu_rc4 RC4
/// @ingroup lavu_crypto
/// @{
class AVRC4 extends ffi.Struct {
  @ffi.Uint8()
  int _unique_state_item_0;
  @ffi.Uint8()
  int _unique_state_item_1;
  @ffi.Uint8()
  int _unique_state_item_2;
  @ffi.Uint8()
  int _unique_state_item_3;
  @ffi.Uint8()
  int _unique_state_item_4;
  @ffi.Uint8()
  int _unique_state_item_5;
  @ffi.Uint8()
  int _unique_state_item_6;
  @ffi.Uint8()
  int _unique_state_item_7;
  @ffi.Uint8()
  int _unique_state_item_8;
  @ffi.Uint8()
  int _unique_state_item_9;
  @ffi.Uint8()
  int _unique_state_item_10;
  @ffi.Uint8()
  int _unique_state_item_11;
  @ffi.Uint8()
  int _unique_state_item_12;
  @ffi.Uint8()
  int _unique_state_item_13;
  @ffi.Uint8()
  int _unique_state_item_14;
  @ffi.Uint8()
  int _unique_state_item_15;
  @ffi.Uint8()
  int _unique_state_item_16;
  @ffi.Uint8()
  int _unique_state_item_17;
  @ffi.Uint8()
  int _unique_state_item_18;
  @ffi.Uint8()
  int _unique_state_item_19;
  @ffi.Uint8()
  int _unique_state_item_20;
  @ffi.Uint8()
  int _unique_state_item_21;
  @ffi.Uint8()
  int _unique_state_item_22;
  @ffi.Uint8()
  int _unique_state_item_23;
  @ffi.Uint8()
  int _unique_state_item_24;
  @ffi.Uint8()
  int _unique_state_item_25;
  @ffi.Uint8()
  int _unique_state_item_26;
  @ffi.Uint8()
  int _unique_state_item_27;
  @ffi.Uint8()
  int _unique_state_item_28;
  @ffi.Uint8()
  int _unique_state_item_29;
  @ffi.Uint8()
  int _unique_state_item_30;
  @ffi.Uint8()
  int _unique_state_item_31;
  @ffi.Uint8()
  int _unique_state_item_32;
  @ffi.Uint8()
  int _unique_state_item_33;
  @ffi.Uint8()
  int _unique_state_item_34;
  @ffi.Uint8()
  int _unique_state_item_35;
  @ffi.Uint8()
  int _unique_state_item_36;
  @ffi.Uint8()
  int _unique_state_item_37;
  @ffi.Uint8()
  int _unique_state_item_38;
  @ffi.Uint8()
  int _unique_state_item_39;
  @ffi.Uint8()
  int _unique_state_item_40;
  @ffi.Uint8()
  int _unique_state_item_41;
  @ffi.Uint8()
  int _unique_state_item_42;
  @ffi.Uint8()
  int _unique_state_item_43;
  @ffi.Uint8()
  int _unique_state_item_44;
  @ffi.Uint8()
  int _unique_state_item_45;
  @ffi.Uint8()
  int _unique_state_item_46;
  @ffi.Uint8()
  int _unique_state_item_47;
  @ffi.Uint8()
  int _unique_state_item_48;
  @ffi.Uint8()
  int _unique_state_item_49;
  @ffi.Uint8()
  int _unique_state_item_50;
  @ffi.Uint8()
  int _unique_state_item_51;
  @ffi.Uint8()
  int _unique_state_item_52;
  @ffi.Uint8()
  int _unique_state_item_53;
  @ffi.Uint8()
  int _unique_state_item_54;
  @ffi.Uint8()
  int _unique_state_item_55;
  @ffi.Uint8()
  int _unique_state_item_56;
  @ffi.Uint8()
  int _unique_state_item_57;
  @ffi.Uint8()
  int _unique_state_item_58;
  @ffi.Uint8()
  int _unique_state_item_59;
  @ffi.Uint8()
  int _unique_state_item_60;
  @ffi.Uint8()
  int _unique_state_item_61;
  @ffi.Uint8()
  int _unique_state_item_62;
  @ffi.Uint8()
  int _unique_state_item_63;
  @ffi.Uint8()
  int _unique_state_item_64;
  @ffi.Uint8()
  int _unique_state_item_65;
  @ffi.Uint8()
  int _unique_state_item_66;
  @ffi.Uint8()
  int _unique_state_item_67;
  @ffi.Uint8()
  int _unique_state_item_68;
  @ffi.Uint8()
  int _unique_state_item_69;
  @ffi.Uint8()
  int _unique_state_item_70;
  @ffi.Uint8()
  int _unique_state_item_71;
  @ffi.Uint8()
  int _unique_state_item_72;
  @ffi.Uint8()
  int _unique_state_item_73;
  @ffi.Uint8()
  int _unique_state_item_74;
  @ffi.Uint8()
  int _unique_state_item_75;
  @ffi.Uint8()
  int _unique_state_item_76;
  @ffi.Uint8()
  int _unique_state_item_77;
  @ffi.Uint8()
  int _unique_state_item_78;
  @ffi.Uint8()
  int _unique_state_item_79;
  @ffi.Uint8()
  int _unique_state_item_80;
  @ffi.Uint8()
  int _unique_state_item_81;
  @ffi.Uint8()
  int _unique_state_item_82;
  @ffi.Uint8()
  int _unique_state_item_83;
  @ffi.Uint8()
  int _unique_state_item_84;
  @ffi.Uint8()
  int _unique_state_item_85;
  @ffi.Uint8()
  int _unique_state_item_86;
  @ffi.Uint8()
  int _unique_state_item_87;
  @ffi.Uint8()
  int _unique_state_item_88;
  @ffi.Uint8()
  int _unique_state_item_89;
  @ffi.Uint8()
  int _unique_state_item_90;
  @ffi.Uint8()
  int _unique_state_item_91;
  @ffi.Uint8()
  int _unique_state_item_92;
  @ffi.Uint8()
  int _unique_state_item_93;
  @ffi.Uint8()
  int _unique_state_item_94;
  @ffi.Uint8()
  int _unique_state_item_95;
  @ffi.Uint8()
  int _unique_state_item_96;
  @ffi.Uint8()
  int _unique_state_item_97;
  @ffi.Uint8()
  int _unique_state_item_98;
  @ffi.Uint8()
  int _unique_state_item_99;
  @ffi.Uint8()
  int _unique_state_item_100;
  @ffi.Uint8()
  int _unique_state_item_101;
  @ffi.Uint8()
  int _unique_state_item_102;
  @ffi.Uint8()
  int _unique_state_item_103;
  @ffi.Uint8()
  int _unique_state_item_104;
  @ffi.Uint8()
  int _unique_state_item_105;
  @ffi.Uint8()
  int _unique_state_item_106;
  @ffi.Uint8()
  int _unique_state_item_107;
  @ffi.Uint8()
  int _unique_state_item_108;
  @ffi.Uint8()
  int _unique_state_item_109;
  @ffi.Uint8()
  int _unique_state_item_110;
  @ffi.Uint8()
  int _unique_state_item_111;
  @ffi.Uint8()
  int _unique_state_item_112;
  @ffi.Uint8()
  int _unique_state_item_113;
  @ffi.Uint8()
  int _unique_state_item_114;
  @ffi.Uint8()
  int _unique_state_item_115;
  @ffi.Uint8()
  int _unique_state_item_116;
  @ffi.Uint8()
  int _unique_state_item_117;
  @ffi.Uint8()
  int _unique_state_item_118;
  @ffi.Uint8()
  int _unique_state_item_119;
  @ffi.Uint8()
  int _unique_state_item_120;
  @ffi.Uint8()
  int _unique_state_item_121;
  @ffi.Uint8()
  int _unique_state_item_122;
  @ffi.Uint8()
  int _unique_state_item_123;
  @ffi.Uint8()
  int _unique_state_item_124;
  @ffi.Uint8()
  int _unique_state_item_125;
  @ffi.Uint8()
  int _unique_state_item_126;
  @ffi.Uint8()
  int _unique_state_item_127;
  @ffi.Uint8()
  int _unique_state_item_128;
  @ffi.Uint8()
  int _unique_state_item_129;
  @ffi.Uint8()
  int _unique_state_item_130;
  @ffi.Uint8()
  int _unique_state_item_131;
  @ffi.Uint8()
  int _unique_state_item_132;
  @ffi.Uint8()
  int _unique_state_item_133;
  @ffi.Uint8()
  int _unique_state_item_134;
  @ffi.Uint8()
  int _unique_state_item_135;
  @ffi.Uint8()
  int _unique_state_item_136;
  @ffi.Uint8()
  int _unique_state_item_137;
  @ffi.Uint8()
  int _unique_state_item_138;
  @ffi.Uint8()
  int _unique_state_item_139;
  @ffi.Uint8()
  int _unique_state_item_140;
  @ffi.Uint8()
  int _unique_state_item_141;
  @ffi.Uint8()
  int _unique_state_item_142;
  @ffi.Uint8()
  int _unique_state_item_143;
  @ffi.Uint8()
  int _unique_state_item_144;
  @ffi.Uint8()
  int _unique_state_item_145;
  @ffi.Uint8()
  int _unique_state_item_146;
  @ffi.Uint8()
  int _unique_state_item_147;
  @ffi.Uint8()
  int _unique_state_item_148;
  @ffi.Uint8()
  int _unique_state_item_149;
  @ffi.Uint8()
  int _unique_state_item_150;
  @ffi.Uint8()
  int _unique_state_item_151;
  @ffi.Uint8()
  int _unique_state_item_152;
  @ffi.Uint8()
  int _unique_state_item_153;
  @ffi.Uint8()
  int _unique_state_item_154;
  @ffi.Uint8()
  int _unique_state_item_155;
  @ffi.Uint8()
  int _unique_state_item_156;
  @ffi.Uint8()
  int _unique_state_item_157;
  @ffi.Uint8()
  int _unique_state_item_158;
  @ffi.Uint8()
  int _unique_state_item_159;
  @ffi.Uint8()
  int _unique_state_item_160;
  @ffi.Uint8()
  int _unique_state_item_161;
  @ffi.Uint8()
  int _unique_state_item_162;
  @ffi.Uint8()
  int _unique_state_item_163;
  @ffi.Uint8()
  int _unique_state_item_164;
  @ffi.Uint8()
  int _unique_state_item_165;
  @ffi.Uint8()
  int _unique_state_item_166;
  @ffi.Uint8()
  int _unique_state_item_167;
  @ffi.Uint8()
  int _unique_state_item_168;
  @ffi.Uint8()
  int _unique_state_item_169;
  @ffi.Uint8()
  int _unique_state_item_170;
  @ffi.Uint8()
  int _unique_state_item_171;
  @ffi.Uint8()
  int _unique_state_item_172;
  @ffi.Uint8()
  int _unique_state_item_173;
  @ffi.Uint8()
  int _unique_state_item_174;
  @ffi.Uint8()
  int _unique_state_item_175;
  @ffi.Uint8()
  int _unique_state_item_176;
  @ffi.Uint8()
  int _unique_state_item_177;
  @ffi.Uint8()
  int _unique_state_item_178;
  @ffi.Uint8()
  int _unique_state_item_179;
  @ffi.Uint8()
  int _unique_state_item_180;
  @ffi.Uint8()
  int _unique_state_item_181;
  @ffi.Uint8()
  int _unique_state_item_182;
  @ffi.Uint8()
  int _unique_state_item_183;
  @ffi.Uint8()
  int _unique_state_item_184;
  @ffi.Uint8()
  int _unique_state_item_185;
  @ffi.Uint8()
  int _unique_state_item_186;
  @ffi.Uint8()
  int _unique_state_item_187;
  @ffi.Uint8()
  int _unique_state_item_188;
  @ffi.Uint8()
  int _unique_state_item_189;
  @ffi.Uint8()
  int _unique_state_item_190;
  @ffi.Uint8()
  int _unique_state_item_191;
  @ffi.Uint8()
  int _unique_state_item_192;
  @ffi.Uint8()
  int _unique_state_item_193;
  @ffi.Uint8()
  int _unique_state_item_194;
  @ffi.Uint8()
  int _unique_state_item_195;
  @ffi.Uint8()
  int _unique_state_item_196;
  @ffi.Uint8()
  int _unique_state_item_197;
  @ffi.Uint8()
  int _unique_state_item_198;
  @ffi.Uint8()
  int _unique_state_item_199;
  @ffi.Uint8()
  int _unique_state_item_200;
  @ffi.Uint8()
  int _unique_state_item_201;
  @ffi.Uint8()
  int _unique_state_item_202;
  @ffi.Uint8()
  int _unique_state_item_203;
  @ffi.Uint8()
  int _unique_state_item_204;
  @ffi.Uint8()
  int _unique_state_item_205;
  @ffi.Uint8()
  int _unique_state_item_206;
  @ffi.Uint8()
  int _unique_state_item_207;
  @ffi.Uint8()
  int _unique_state_item_208;
  @ffi.Uint8()
  int _unique_state_item_209;
  @ffi.Uint8()
  int _unique_state_item_210;
  @ffi.Uint8()
  int _unique_state_item_211;
  @ffi.Uint8()
  int _unique_state_item_212;
  @ffi.Uint8()
  int _unique_state_item_213;
  @ffi.Uint8()
  int _unique_state_item_214;
  @ffi.Uint8()
  int _unique_state_item_215;
  @ffi.Uint8()
  int _unique_state_item_216;
  @ffi.Uint8()
  int _unique_state_item_217;
  @ffi.Uint8()
  int _unique_state_item_218;
  @ffi.Uint8()
  int _unique_state_item_219;
  @ffi.Uint8()
  int _unique_state_item_220;
  @ffi.Uint8()
  int _unique_state_item_221;
  @ffi.Uint8()
  int _unique_state_item_222;
  @ffi.Uint8()
  int _unique_state_item_223;
  @ffi.Uint8()
  int _unique_state_item_224;
  @ffi.Uint8()
  int _unique_state_item_225;
  @ffi.Uint8()
  int _unique_state_item_226;
  @ffi.Uint8()
  int _unique_state_item_227;
  @ffi.Uint8()
  int _unique_state_item_228;
  @ffi.Uint8()
  int _unique_state_item_229;
  @ffi.Uint8()
  int _unique_state_item_230;
  @ffi.Uint8()
  int _unique_state_item_231;
  @ffi.Uint8()
  int _unique_state_item_232;
  @ffi.Uint8()
  int _unique_state_item_233;
  @ffi.Uint8()
  int _unique_state_item_234;
  @ffi.Uint8()
  int _unique_state_item_235;
  @ffi.Uint8()
  int _unique_state_item_236;
  @ffi.Uint8()
  int _unique_state_item_237;
  @ffi.Uint8()
  int _unique_state_item_238;
  @ffi.Uint8()
  int _unique_state_item_239;
  @ffi.Uint8()
  int _unique_state_item_240;
  @ffi.Uint8()
  int _unique_state_item_241;
  @ffi.Uint8()
  int _unique_state_item_242;
  @ffi.Uint8()
  int _unique_state_item_243;
  @ffi.Uint8()
  int _unique_state_item_244;
  @ffi.Uint8()
  int _unique_state_item_245;
  @ffi.Uint8()
  int _unique_state_item_246;
  @ffi.Uint8()
  int _unique_state_item_247;
  @ffi.Uint8()
  int _unique_state_item_248;
  @ffi.Uint8()
  int _unique_state_item_249;
  @ffi.Uint8()
  int _unique_state_item_250;
  @ffi.Uint8()
  int _unique_state_item_251;
  @ffi.Uint8()
  int _unique_state_item_252;
  @ffi.Uint8()
  int _unique_state_item_253;
  @ffi.Uint8()
  int _unique_state_item_254;
  @ffi.Uint8()
  int _unique_state_item_255;

  /// Helper for array `state`.
  ArrayHelper_AVRC4_state_level0 get state =>
      ArrayHelper_AVRC4_state_level0(this, [256], 0, 0);
  @ffi.Int32()
  int x;

  @ffi.Int32()
  int y;
}

/// Helper for array `state` in struct `AVRC4`.
class ArrayHelper_AVRC4_state_level0 {
  final AVRC4 _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVRC4_state_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_state_item_0;
      case 1:
        return _struct._unique_state_item_1;
      case 2:
        return _struct._unique_state_item_2;
      case 3:
        return _struct._unique_state_item_3;
      case 4:
        return _struct._unique_state_item_4;
      case 5:
        return _struct._unique_state_item_5;
      case 6:
        return _struct._unique_state_item_6;
      case 7:
        return _struct._unique_state_item_7;
      case 8:
        return _struct._unique_state_item_8;
      case 9:
        return _struct._unique_state_item_9;
      case 10:
        return _struct._unique_state_item_10;
      case 11:
        return _struct._unique_state_item_11;
      case 12:
        return _struct._unique_state_item_12;
      case 13:
        return _struct._unique_state_item_13;
      case 14:
        return _struct._unique_state_item_14;
      case 15:
        return _struct._unique_state_item_15;
      case 16:
        return _struct._unique_state_item_16;
      case 17:
        return _struct._unique_state_item_17;
      case 18:
        return _struct._unique_state_item_18;
      case 19:
        return _struct._unique_state_item_19;
      case 20:
        return _struct._unique_state_item_20;
      case 21:
        return _struct._unique_state_item_21;
      case 22:
        return _struct._unique_state_item_22;
      case 23:
        return _struct._unique_state_item_23;
      case 24:
        return _struct._unique_state_item_24;
      case 25:
        return _struct._unique_state_item_25;
      case 26:
        return _struct._unique_state_item_26;
      case 27:
        return _struct._unique_state_item_27;
      case 28:
        return _struct._unique_state_item_28;
      case 29:
        return _struct._unique_state_item_29;
      case 30:
        return _struct._unique_state_item_30;
      case 31:
        return _struct._unique_state_item_31;
      case 32:
        return _struct._unique_state_item_32;
      case 33:
        return _struct._unique_state_item_33;
      case 34:
        return _struct._unique_state_item_34;
      case 35:
        return _struct._unique_state_item_35;
      case 36:
        return _struct._unique_state_item_36;
      case 37:
        return _struct._unique_state_item_37;
      case 38:
        return _struct._unique_state_item_38;
      case 39:
        return _struct._unique_state_item_39;
      case 40:
        return _struct._unique_state_item_40;
      case 41:
        return _struct._unique_state_item_41;
      case 42:
        return _struct._unique_state_item_42;
      case 43:
        return _struct._unique_state_item_43;
      case 44:
        return _struct._unique_state_item_44;
      case 45:
        return _struct._unique_state_item_45;
      case 46:
        return _struct._unique_state_item_46;
      case 47:
        return _struct._unique_state_item_47;
      case 48:
        return _struct._unique_state_item_48;
      case 49:
        return _struct._unique_state_item_49;
      case 50:
        return _struct._unique_state_item_50;
      case 51:
        return _struct._unique_state_item_51;
      case 52:
        return _struct._unique_state_item_52;
      case 53:
        return _struct._unique_state_item_53;
      case 54:
        return _struct._unique_state_item_54;
      case 55:
        return _struct._unique_state_item_55;
      case 56:
        return _struct._unique_state_item_56;
      case 57:
        return _struct._unique_state_item_57;
      case 58:
        return _struct._unique_state_item_58;
      case 59:
        return _struct._unique_state_item_59;
      case 60:
        return _struct._unique_state_item_60;
      case 61:
        return _struct._unique_state_item_61;
      case 62:
        return _struct._unique_state_item_62;
      case 63:
        return _struct._unique_state_item_63;
      case 64:
        return _struct._unique_state_item_64;
      case 65:
        return _struct._unique_state_item_65;
      case 66:
        return _struct._unique_state_item_66;
      case 67:
        return _struct._unique_state_item_67;
      case 68:
        return _struct._unique_state_item_68;
      case 69:
        return _struct._unique_state_item_69;
      case 70:
        return _struct._unique_state_item_70;
      case 71:
        return _struct._unique_state_item_71;
      case 72:
        return _struct._unique_state_item_72;
      case 73:
        return _struct._unique_state_item_73;
      case 74:
        return _struct._unique_state_item_74;
      case 75:
        return _struct._unique_state_item_75;
      case 76:
        return _struct._unique_state_item_76;
      case 77:
        return _struct._unique_state_item_77;
      case 78:
        return _struct._unique_state_item_78;
      case 79:
        return _struct._unique_state_item_79;
      case 80:
        return _struct._unique_state_item_80;
      case 81:
        return _struct._unique_state_item_81;
      case 82:
        return _struct._unique_state_item_82;
      case 83:
        return _struct._unique_state_item_83;
      case 84:
        return _struct._unique_state_item_84;
      case 85:
        return _struct._unique_state_item_85;
      case 86:
        return _struct._unique_state_item_86;
      case 87:
        return _struct._unique_state_item_87;
      case 88:
        return _struct._unique_state_item_88;
      case 89:
        return _struct._unique_state_item_89;
      case 90:
        return _struct._unique_state_item_90;
      case 91:
        return _struct._unique_state_item_91;
      case 92:
        return _struct._unique_state_item_92;
      case 93:
        return _struct._unique_state_item_93;
      case 94:
        return _struct._unique_state_item_94;
      case 95:
        return _struct._unique_state_item_95;
      case 96:
        return _struct._unique_state_item_96;
      case 97:
        return _struct._unique_state_item_97;
      case 98:
        return _struct._unique_state_item_98;
      case 99:
        return _struct._unique_state_item_99;
      case 100:
        return _struct._unique_state_item_100;
      case 101:
        return _struct._unique_state_item_101;
      case 102:
        return _struct._unique_state_item_102;
      case 103:
        return _struct._unique_state_item_103;
      case 104:
        return _struct._unique_state_item_104;
      case 105:
        return _struct._unique_state_item_105;
      case 106:
        return _struct._unique_state_item_106;
      case 107:
        return _struct._unique_state_item_107;
      case 108:
        return _struct._unique_state_item_108;
      case 109:
        return _struct._unique_state_item_109;
      case 110:
        return _struct._unique_state_item_110;
      case 111:
        return _struct._unique_state_item_111;
      case 112:
        return _struct._unique_state_item_112;
      case 113:
        return _struct._unique_state_item_113;
      case 114:
        return _struct._unique_state_item_114;
      case 115:
        return _struct._unique_state_item_115;
      case 116:
        return _struct._unique_state_item_116;
      case 117:
        return _struct._unique_state_item_117;
      case 118:
        return _struct._unique_state_item_118;
      case 119:
        return _struct._unique_state_item_119;
      case 120:
        return _struct._unique_state_item_120;
      case 121:
        return _struct._unique_state_item_121;
      case 122:
        return _struct._unique_state_item_122;
      case 123:
        return _struct._unique_state_item_123;
      case 124:
        return _struct._unique_state_item_124;
      case 125:
        return _struct._unique_state_item_125;
      case 126:
        return _struct._unique_state_item_126;
      case 127:
        return _struct._unique_state_item_127;
      case 128:
        return _struct._unique_state_item_128;
      case 129:
        return _struct._unique_state_item_129;
      case 130:
        return _struct._unique_state_item_130;
      case 131:
        return _struct._unique_state_item_131;
      case 132:
        return _struct._unique_state_item_132;
      case 133:
        return _struct._unique_state_item_133;
      case 134:
        return _struct._unique_state_item_134;
      case 135:
        return _struct._unique_state_item_135;
      case 136:
        return _struct._unique_state_item_136;
      case 137:
        return _struct._unique_state_item_137;
      case 138:
        return _struct._unique_state_item_138;
      case 139:
        return _struct._unique_state_item_139;
      case 140:
        return _struct._unique_state_item_140;
      case 141:
        return _struct._unique_state_item_141;
      case 142:
        return _struct._unique_state_item_142;
      case 143:
        return _struct._unique_state_item_143;
      case 144:
        return _struct._unique_state_item_144;
      case 145:
        return _struct._unique_state_item_145;
      case 146:
        return _struct._unique_state_item_146;
      case 147:
        return _struct._unique_state_item_147;
      case 148:
        return _struct._unique_state_item_148;
      case 149:
        return _struct._unique_state_item_149;
      case 150:
        return _struct._unique_state_item_150;
      case 151:
        return _struct._unique_state_item_151;
      case 152:
        return _struct._unique_state_item_152;
      case 153:
        return _struct._unique_state_item_153;
      case 154:
        return _struct._unique_state_item_154;
      case 155:
        return _struct._unique_state_item_155;
      case 156:
        return _struct._unique_state_item_156;
      case 157:
        return _struct._unique_state_item_157;
      case 158:
        return _struct._unique_state_item_158;
      case 159:
        return _struct._unique_state_item_159;
      case 160:
        return _struct._unique_state_item_160;
      case 161:
        return _struct._unique_state_item_161;
      case 162:
        return _struct._unique_state_item_162;
      case 163:
        return _struct._unique_state_item_163;
      case 164:
        return _struct._unique_state_item_164;
      case 165:
        return _struct._unique_state_item_165;
      case 166:
        return _struct._unique_state_item_166;
      case 167:
        return _struct._unique_state_item_167;
      case 168:
        return _struct._unique_state_item_168;
      case 169:
        return _struct._unique_state_item_169;
      case 170:
        return _struct._unique_state_item_170;
      case 171:
        return _struct._unique_state_item_171;
      case 172:
        return _struct._unique_state_item_172;
      case 173:
        return _struct._unique_state_item_173;
      case 174:
        return _struct._unique_state_item_174;
      case 175:
        return _struct._unique_state_item_175;
      case 176:
        return _struct._unique_state_item_176;
      case 177:
        return _struct._unique_state_item_177;
      case 178:
        return _struct._unique_state_item_178;
      case 179:
        return _struct._unique_state_item_179;
      case 180:
        return _struct._unique_state_item_180;
      case 181:
        return _struct._unique_state_item_181;
      case 182:
        return _struct._unique_state_item_182;
      case 183:
        return _struct._unique_state_item_183;
      case 184:
        return _struct._unique_state_item_184;
      case 185:
        return _struct._unique_state_item_185;
      case 186:
        return _struct._unique_state_item_186;
      case 187:
        return _struct._unique_state_item_187;
      case 188:
        return _struct._unique_state_item_188;
      case 189:
        return _struct._unique_state_item_189;
      case 190:
        return _struct._unique_state_item_190;
      case 191:
        return _struct._unique_state_item_191;
      case 192:
        return _struct._unique_state_item_192;
      case 193:
        return _struct._unique_state_item_193;
      case 194:
        return _struct._unique_state_item_194;
      case 195:
        return _struct._unique_state_item_195;
      case 196:
        return _struct._unique_state_item_196;
      case 197:
        return _struct._unique_state_item_197;
      case 198:
        return _struct._unique_state_item_198;
      case 199:
        return _struct._unique_state_item_199;
      case 200:
        return _struct._unique_state_item_200;
      case 201:
        return _struct._unique_state_item_201;
      case 202:
        return _struct._unique_state_item_202;
      case 203:
        return _struct._unique_state_item_203;
      case 204:
        return _struct._unique_state_item_204;
      case 205:
        return _struct._unique_state_item_205;
      case 206:
        return _struct._unique_state_item_206;
      case 207:
        return _struct._unique_state_item_207;
      case 208:
        return _struct._unique_state_item_208;
      case 209:
        return _struct._unique_state_item_209;
      case 210:
        return _struct._unique_state_item_210;
      case 211:
        return _struct._unique_state_item_211;
      case 212:
        return _struct._unique_state_item_212;
      case 213:
        return _struct._unique_state_item_213;
      case 214:
        return _struct._unique_state_item_214;
      case 215:
        return _struct._unique_state_item_215;
      case 216:
        return _struct._unique_state_item_216;
      case 217:
        return _struct._unique_state_item_217;
      case 218:
        return _struct._unique_state_item_218;
      case 219:
        return _struct._unique_state_item_219;
      case 220:
        return _struct._unique_state_item_220;
      case 221:
        return _struct._unique_state_item_221;
      case 222:
        return _struct._unique_state_item_222;
      case 223:
        return _struct._unique_state_item_223;
      case 224:
        return _struct._unique_state_item_224;
      case 225:
        return _struct._unique_state_item_225;
      case 226:
        return _struct._unique_state_item_226;
      case 227:
        return _struct._unique_state_item_227;
      case 228:
        return _struct._unique_state_item_228;
      case 229:
        return _struct._unique_state_item_229;
      case 230:
        return _struct._unique_state_item_230;
      case 231:
        return _struct._unique_state_item_231;
      case 232:
        return _struct._unique_state_item_232;
      case 233:
        return _struct._unique_state_item_233;
      case 234:
        return _struct._unique_state_item_234;
      case 235:
        return _struct._unique_state_item_235;
      case 236:
        return _struct._unique_state_item_236;
      case 237:
        return _struct._unique_state_item_237;
      case 238:
        return _struct._unique_state_item_238;
      case 239:
        return _struct._unique_state_item_239;
      case 240:
        return _struct._unique_state_item_240;
      case 241:
        return _struct._unique_state_item_241;
      case 242:
        return _struct._unique_state_item_242;
      case 243:
        return _struct._unique_state_item_243;
      case 244:
        return _struct._unique_state_item_244;
      case 245:
        return _struct._unique_state_item_245;
      case 246:
        return _struct._unique_state_item_246;
      case 247:
        return _struct._unique_state_item_247;
      case 248:
        return _struct._unique_state_item_248;
      case 249:
        return _struct._unique_state_item_249;
      case 250:
        return _struct._unique_state_item_250;
      case 251:
        return _struct._unique_state_item_251;
      case 252:
        return _struct._unique_state_item_252;
      case 253:
        return _struct._unique_state_item_253;
      case 254:
        return _struct._unique_state_item_254;
      case 255:
        return _struct._unique_state_item_255;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_state_item_0 = value;
        break;
      case 1:
        _struct._unique_state_item_1 = value;
        break;
      case 2:
        _struct._unique_state_item_2 = value;
        break;
      case 3:
        _struct._unique_state_item_3 = value;
        break;
      case 4:
        _struct._unique_state_item_4 = value;
        break;
      case 5:
        _struct._unique_state_item_5 = value;
        break;
      case 6:
        _struct._unique_state_item_6 = value;
        break;
      case 7:
        _struct._unique_state_item_7 = value;
        break;
      case 8:
        _struct._unique_state_item_8 = value;
        break;
      case 9:
        _struct._unique_state_item_9 = value;
        break;
      case 10:
        _struct._unique_state_item_10 = value;
        break;
      case 11:
        _struct._unique_state_item_11 = value;
        break;
      case 12:
        _struct._unique_state_item_12 = value;
        break;
      case 13:
        _struct._unique_state_item_13 = value;
        break;
      case 14:
        _struct._unique_state_item_14 = value;
        break;
      case 15:
        _struct._unique_state_item_15 = value;
        break;
      case 16:
        _struct._unique_state_item_16 = value;
        break;
      case 17:
        _struct._unique_state_item_17 = value;
        break;
      case 18:
        _struct._unique_state_item_18 = value;
        break;
      case 19:
        _struct._unique_state_item_19 = value;
        break;
      case 20:
        _struct._unique_state_item_20 = value;
        break;
      case 21:
        _struct._unique_state_item_21 = value;
        break;
      case 22:
        _struct._unique_state_item_22 = value;
        break;
      case 23:
        _struct._unique_state_item_23 = value;
        break;
      case 24:
        _struct._unique_state_item_24 = value;
        break;
      case 25:
        _struct._unique_state_item_25 = value;
        break;
      case 26:
        _struct._unique_state_item_26 = value;
        break;
      case 27:
        _struct._unique_state_item_27 = value;
        break;
      case 28:
        _struct._unique_state_item_28 = value;
        break;
      case 29:
        _struct._unique_state_item_29 = value;
        break;
      case 30:
        _struct._unique_state_item_30 = value;
        break;
      case 31:
        _struct._unique_state_item_31 = value;
        break;
      case 32:
        _struct._unique_state_item_32 = value;
        break;
      case 33:
        _struct._unique_state_item_33 = value;
        break;
      case 34:
        _struct._unique_state_item_34 = value;
        break;
      case 35:
        _struct._unique_state_item_35 = value;
        break;
      case 36:
        _struct._unique_state_item_36 = value;
        break;
      case 37:
        _struct._unique_state_item_37 = value;
        break;
      case 38:
        _struct._unique_state_item_38 = value;
        break;
      case 39:
        _struct._unique_state_item_39 = value;
        break;
      case 40:
        _struct._unique_state_item_40 = value;
        break;
      case 41:
        _struct._unique_state_item_41 = value;
        break;
      case 42:
        _struct._unique_state_item_42 = value;
        break;
      case 43:
        _struct._unique_state_item_43 = value;
        break;
      case 44:
        _struct._unique_state_item_44 = value;
        break;
      case 45:
        _struct._unique_state_item_45 = value;
        break;
      case 46:
        _struct._unique_state_item_46 = value;
        break;
      case 47:
        _struct._unique_state_item_47 = value;
        break;
      case 48:
        _struct._unique_state_item_48 = value;
        break;
      case 49:
        _struct._unique_state_item_49 = value;
        break;
      case 50:
        _struct._unique_state_item_50 = value;
        break;
      case 51:
        _struct._unique_state_item_51 = value;
        break;
      case 52:
        _struct._unique_state_item_52 = value;
        break;
      case 53:
        _struct._unique_state_item_53 = value;
        break;
      case 54:
        _struct._unique_state_item_54 = value;
        break;
      case 55:
        _struct._unique_state_item_55 = value;
        break;
      case 56:
        _struct._unique_state_item_56 = value;
        break;
      case 57:
        _struct._unique_state_item_57 = value;
        break;
      case 58:
        _struct._unique_state_item_58 = value;
        break;
      case 59:
        _struct._unique_state_item_59 = value;
        break;
      case 60:
        _struct._unique_state_item_60 = value;
        break;
      case 61:
        _struct._unique_state_item_61 = value;
        break;
      case 62:
        _struct._unique_state_item_62 = value;
        break;
      case 63:
        _struct._unique_state_item_63 = value;
        break;
      case 64:
        _struct._unique_state_item_64 = value;
        break;
      case 65:
        _struct._unique_state_item_65 = value;
        break;
      case 66:
        _struct._unique_state_item_66 = value;
        break;
      case 67:
        _struct._unique_state_item_67 = value;
        break;
      case 68:
        _struct._unique_state_item_68 = value;
        break;
      case 69:
        _struct._unique_state_item_69 = value;
        break;
      case 70:
        _struct._unique_state_item_70 = value;
        break;
      case 71:
        _struct._unique_state_item_71 = value;
        break;
      case 72:
        _struct._unique_state_item_72 = value;
        break;
      case 73:
        _struct._unique_state_item_73 = value;
        break;
      case 74:
        _struct._unique_state_item_74 = value;
        break;
      case 75:
        _struct._unique_state_item_75 = value;
        break;
      case 76:
        _struct._unique_state_item_76 = value;
        break;
      case 77:
        _struct._unique_state_item_77 = value;
        break;
      case 78:
        _struct._unique_state_item_78 = value;
        break;
      case 79:
        _struct._unique_state_item_79 = value;
        break;
      case 80:
        _struct._unique_state_item_80 = value;
        break;
      case 81:
        _struct._unique_state_item_81 = value;
        break;
      case 82:
        _struct._unique_state_item_82 = value;
        break;
      case 83:
        _struct._unique_state_item_83 = value;
        break;
      case 84:
        _struct._unique_state_item_84 = value;
        break;
      case 85:
        _struct._unique_state_item_85 = value;
        break;
      case 86:
        _struct._unique_state_item_86 = value;
        break;
      case 87:
        _struct._unique_state_item_87 = value;
        break;
      case 88:
        _struct._unique_state_item_88 = value;
        break;
      case 89:
        _struct._unique_state_item_89 = value;
        break;
      case 90:
        _struct._unique_state_item_90 = value;
        break;
      case 91:
        _struct._unique_state_item_91 = value;
        break;
      case 92:
        _struct._unique_state_item_92 = value;
        break;
      case 93:
        _struct._unique_state_item_93 = value;
        break;
      case 94:
        _struct._unique_state_item_94 = value;
        break;
      case 95:
        _struct._unique_state_item_95 = value;
        break;
      case 96:
        _struct._unique_state_item_96 = value;
        break;
      case 97:
        _struct._unique_state_item_97 = value;
        break;
      case 98:
        _struct._unique_state_item_98 = value;
        break;
      case 99:
        _struct._unique_state_item_99 = value;
        break;
      case 100:
        _struct._unique_state_item_100 = value;
        break;
      case 101:
        _struct._unique_state_item_101 = value;
        break;
      case 102:
        _struct._unique_state_item_102 = value;
        break;
      case 103:
        _struct._unique_state_item_103 = value;
        break;
      case 104:
        _struct._unique_state_item_104 = value;
        break;
      case 105:
        _struct._unique_state_item_105 = value;
        break;
      case 106:
        _struct._unique_state_item_106 = value;
        break;
      case 107:
        _struct._unique_state_item_107 = value;
        break;
      case 108:
        _struct._unique_state_item_108 = value;
        break;
      case 109:
        _struct._unique_state_item_109 = value;
        break;
      case 110:
        _struct._unique_state_item_110 = value;
        break;
      case 111:
        _struct._unique_state_item_111 = value;
        break;
      case 112:
        _struct._unique_state_item_112 = value;
        break;
      case 113:
        _struct._unique_state_item_113 = value;
        break;
      case 114:
        _struct._unique_state_item_114 = value;
        break;
      case 115:
        _struct._unique_state_item_115 = value;
        break;
      case 116:
        _struct._unique_state_item_116 = value;
        break;
      case 117:
        _struct._unique_state_item_117 = value;
        break;
      case 118:
        _struct._unique_state_item_118 = value;
        break;
      case 119:
        _struct._unique_state_item_119 = value;
        break;
      case 120:
        _struct._unique_state_item_120 = value;
        break;
      case 121:
        _struct._unique_state_item_121 = value;
        break;
      case 122:
        _struct._unique_state_item_122 = value;
        break;
      case 123:
        _struct._unique_state_item_123 = value;
        break;
      case 124:
        _struct._unique_state_item_124 = value;
        break;
      case 125:
        _struct._unique_state_item_125 = value;
        break;
      case 126:
        _struct._unique_state_item_126 = value;
        break;
      case 127:
        _struct._unique_state_item_127 = value;
        break;
      case 128:
        _struct._unique_state_item_128 = value;
        break;
      case 129:
        _struct._unique_state_item_129 = value;
        break;
      case 130:
        _struct._unique_state_item_130 = value;
        break;
      case 131:
        _struct._unique_state_item_131 = value;
        break;
      case 132:
        _struct._unique_state_item_132 = value;
        break;
      case 133:
        _struct._unique_state_item_133 = value;
        break;
      case 134:
        _struct._unique_state_item_134 = value;
        break;
      case 135:
        _struct._unique_state_item_135 = value;
        break;
      case 136:
        _struct._unique_state_item_136 = value;
        break;
      case 137:
        _struct._unique_state_item_137 = value;
        break;
      case 138:
        _struct._unique_state_item_138 = value;
        break;
      case 139:
        _struct._unique_state_item_139 = value;
        break;
      case 140:
        _struct._unique_state_item_140 = value;
        break;
      case 141:
        _struct._unique_state_item_141 = value;
        break;
      case 142:
        _struct._unique_state_item_142 = value;
        break;
      case 143:
        _struct._unique_state_item_143 = value;
        break;
      case 144:
        _struct._unique_state_item_144 = value;
        break;
      case 145:
        _struct._unique_state_item_145 = value;
        break;
      case 146:
        _struct._unique_state_item_146 = value;
        break;
      case 147:
        _struct._unique_state_item_147 = value;
        break;
      case 148:
        _struct._unique_state_item_148 = value;
        break;
      case 149:
        _struct._unique_state_item_149 = value;
        break;
      case 150:
        _struct._unique_state_item_150 = value;
        break;
      case 151:
        _struct._unique_state_item_151 = value;
        break;
      case 152:
        _struct._unique_state_item_152 = value;
        break;
      case 153:
        _struct._unique_state_item_153 = value;
        break;
      case 154:
        _struct._unique_state_item_154 = value;
        break;
      case 155:
        _struct._unique_state_item_155 = value;
        break;
      case 156:
        _struct._unique_state_item_156 = value;
        break;
      case 157:
        _struct._unique_state_item_157 = value;
        break;
      case 158:
        _struct._unique_state_item_158 = value;
        break;
      case 159:
        _struct._unique_state_item_159 = value;
        break;
      case 160:
        _struct._unique_state_item_160 = value;
        break;
      case 161:
        _struct._unique_state_item_161 = value;
        break;
      case 162:
        _struct._unique_state_item_162 = value;
        break;
      case 163:
        _struct._unique_state_item_163 = value;
        break;
      case 164:
        _struct._unique_state_item_164 = value;
        break;
      case 165:
        _struct._unique_state_item_165 = value;
        break;
      case 166:
        _struct._unique_state_item_166 = value;
        break;
      case 167:
        _struct._unique_state_item_167 = value;
        break;
      case 168:
        _struct._unique_state_item_168 = value;
        break;
      case 169:
        _struct._unique_state_item_169 = value;
        break;
      case 170:
        _struct._unique_state_item_170 = value;
        break;
      case 171:
        _struct._unique_state_item_171 = value;
        break;
      case 172:
        _struct._unique_state_item_172 = value;
        break;
      case 173:
        _struct._unique_state_item_173 = value;
        break;
      case 174:
        _struct._unique_state_item_174 = value;
        break;
      case 175:
        _struct._unique_state_item_175 = value;
        break;
      case 176:
        _struct._unique_state_item_176 = value;
        break;
      case 177:
        _struct._unique_state_item_177 = value;
        break;
      case 178:
        _struct._unique_state_item_178 = value;
        break;
      case 179:
        _struct._unique_state_item_179 = value;
        break;
      case 180:
        _struct._unique_state_item_180 = value;
        break;
      case 181:
        _struct._unique_state_item_181 = value;
        break;
      case 182:
        _struct._unique_state_item_182 = value;
        break;
      case 183:
        _struct._unique_state_item_183 = value;
        break;
      case 184:
        _struct._unique_state_item_184 = value;
        break;
      case 185:
        _struct._unique_state_item_185 = value;
        break;
      case 186:
        _struct._unique_state_item_186 = value;
        break;
      case 187:
        _struct._unique_state_item_187 = value;
        break;
      case 188:
        _struct._unique_state_item_188 = value;
        break;
      case 189:
        _struct._unique_state_item_189 = value;
        break;
      case 190:
        _struct._unique_state_item_190 = value;
        break;
      case 191:
        _struct._unique_state_item_191 = value;
        break;
      case 192:
        _struct._unique_state_item_192 = value;
        break;
      case 193:
        _struct._unique_state_item_193 = value;
        break;
      case 194:
        _struct._unique_state_item_194 = value;
        break;
      case 195:
        _struct._unique_state_item_195 = value;
        break;
      case 196:
        _struct._unique_state_item_196 = value;
        break;
      case 197:
        _struct._unique_state_item_197 = value;
        break;
      case 198:
        _struct._unique_state_item_198 = value;
        break;
      case 199:
        _struct._unique_state_item_199 = value;
        break;
      case 200:
        _struct._unique_state_item_200 = value;
        break;
      case 201:
        _struct._unique_state_item_201 = value;
        break;
      case 202:
        _struct._unique_state_item_202 = value;
        break;
      case 203:
        _struct._unique_state_item_203 = value;
        break;
      case 204:
        _struct._unique_state_item_204 = value;
        break;
      case 205:
        _struct._unique_state_item_205 = value;
        break;
      case 206:
        _struct._unique_state_item_206 = value;
        break;
      case 207:
        _struct._unique_state_item_207 = value;
        break;
      case 208:
        _struct._unique_state_item_208 = value;
        break;
      case 209:
        _struct._unique_state_item_209 = value;
        break;
      case 210:
        _struct._unique_state_item_210 = value;
        break;
      case 211:
        _struct._unique_state_item_211 = value;
        break;
      case 212:
        _struct._unique_state_item_212 = value;
        break;
      case 213:
        _struct._unique_state_item_213 = value;
        break;
      case 214:
        _struct._unique_state_item_214 = value;
        break;
      case 215:
        _struct._unique_state_item_215 = value;
        break;
      case 216:
        _struct._unique_state_item_216 = value;
        break;
      case 217:
        _struct._unique_state_item_217 = value;
        break;
      case 218:
        _struct._unique_state_item_218 = value;
        break;
      case 219:
        _struct._unique_state_item_219 = value;
        break;
      case 220:
        _struct._unique_state_item_220 = value;
        break;
      case 221:
        _struct._unique_state_item_221 = value;
        break;
      case 222:
        _struct._unique_state_item_222 = value;
        break;
      case 223:
        _struct._unique_state_item_223 = value;
        break;
      case 224:
        _struct._unique_state_item_224 = value;
        break;
      case 225:
        _struct._unique_state_item_225 = value;
        break;
      case 226:
        _struct._unique_state_item_226 = value;
        break;
      case 227:
        _struct._unique_state_item_227 = value;
        break;
      case 228:
        _struct._unique_state_item_228 = value;
        break;
      case 229:
        _struct._unique_state_item_229 = value;
        break;
      case 230:
        _struct._unique_state_item_230 = value;
        break;
      case 231:
        _struct._unique_state_item_231 = value;
        break;
      case 232:
        _struct._unique_state_item_232 = value;
        break;
      case 233:
        _struct._unique_state_item_233 = value;
        break;
      case 234:
        _struct._unique_state_item_234 = value;
        break;
      case 235:
        _struct._unique_state_item_235 = value;
        break;
      case 236:
        _struct._unique_state_item_236 = value;
        break;
      case 237:
        _struct._unique_state_item_237 = value;
        break;
      case 238:
        _struct._unique_state_item_238 = value;
        break;
      case 239:
        _struct._unique_state_item_239 = value;
        break;
      case 240:
        _struct._unique_state_item_240 = value;
        break;
      case 241:
        _struct._unique_state_item_241 = value;
        break;
      case 242:
        _struct._unique_state_item_242 = value;
        break;
      case 243:
        _struct._unique_state_item_243 = value;
        break;
      case 244:
        _struct._unique_state_item_244 = value;
        break;
      case 245:
        _struct._unique_state_item_245 = value;
        break;
      case 246:
        _struct._unique_state_item_246 = value;
        break;
      case 247:
        _struct._unique_state_item_247 = value;
        break;
      case 248:
        _struct._unique_state_item_248 = value;
        break;
      case 249:
        _struct._unique_state_item_249 = value;
        break;
      case 250:
        _struct._unique_state_item_250 = value;
        break;
      case 251:
        _struct._unique_state_item_251 = value;
        break;
      case 252:
        _struct._unique_state_item_252 = value;
        break;
      case 253:
        _struct._unique_state_item_253 = value;
        break;
      case 254:
        _struct._unique_state_item_254 = value;
        break;
      case 255:
        _struct._unique_state_item_255 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// ReplayGain information (see
/// http://wiki.hydrogenaudio.org/index.php?title=ReplayGain_1.0_specification).
/// The size of this struct is a part of the public ABI.
class AVReplayGain extends ffi.Struct {
  /// Track replay gain in microbels (divide by 100000 to get the value in dB).
  /// Should be set to INT32_MIN when unknown.
  @ffi.Int32()
  int track_gain;

  /// Peak track amplitude, with 100000 representing full scale (but values
  /// may overflow). 0 when unknown.
  @ffi.Uint32()
  int track_peak;

  /// Same as track_gain, but for the whole album.
  @ffi.Int32()
  int album_gain;

  /// Same as track_peak, but for the whole album,
  @ffi.Uint32()
  int album_peak;
}

class AVRIPEMD extends ffi.Struct {}

class AVSHA extends ffi.Struct {}

class AVSHA512 extends ffi.Struct {}

/// Projection of the video surface(s) on a sphere.
abstract class AVSphericalProjection {
  /// Video represents a sphere mapped on a flat surface using
  /// equirectangular projection.
  static const int AV_SPHERICAL_EQUIRECTANGULAR = 0;

  /// Video frame is split into 6 faces of a cube, and arranged on a
  /// 3x2 layout. Faces are oriented upwards for the front, left, right,
  /// and back faces. The up face is oriented so the top of the face is
  /// forwards and the down face is oriented so the top of the face is
  /// to the back.
  static const int AV_SPHERICAL_CUBEMAP = 1;

  /// Video represents a portion of a sphere mapped on a flat surface
  /// using equirectangular projection. The @ref bounding fields indicate
  /// the position of the current video in a larger surface.
  static const int AV_SPHERICAL_EQUIRECTANGULAR_TILE = 2;
}

/// This structure describes how to handle spherical videos, outlining
/// information about projection, initial layout, and any other view modifier.
///
/// @note The struct must be allocated with av_spherical_alloc() and
/// its size is not a part of the public ABI.
class AVSphericalMapping extends ffi.Struct {
  /// Projection type.
  @ffi.Int32()
  int projection;

  /// ///< Rotation around the up vector [-180, 180].
  @ffi.Int32()
  int yaw;

  /// ///< Rotation around the right vector [-90, 90].
  @ffi.Int32()
  int pitch;

  /// ///< Rotation around the forward vector [-180, 180].
  @ffi.Int32()
  int roll;

  /// ///< Distance from the left edge
  @ffi.Uint32()
  int bound_left;

  /// ///< Distance from the top edge
  @ffi.Uint32()
  int bound_top;

  /// ///< Distance from the right edge
  @ffi.Uint32()
  int bound_right;

  /// ///< Distance from the bottom edge
  @ffi.Uint32()
  int bound_bottom;

  /// Number of pixels to pad from the edge of each cube face.
  ///
  /// @note This value is valid for only for the cubemap projection type
  /// (@ref AV_SPHERICAL_CUBEMAP), and should be ignored in all other
  /// cases.
  @ffi.Uint32()
  int padding;
}

/// List of possible 3D Types
abstract class AVStereo3DType {
  /// Video is not stereoscopic (and metadata has to be there).
  static const int AV_STEREO3D_2D = 0;

  /// Views are next to each other.
  ///
  /// @code{.unparsed}
  /// LLLLRRRR
  /// LLLLRRRR
  /// LLLLRRRR
  /// ...
  /// @endcode
  static const int AV_STEREO3D_SIDEBYSIDE = 1;

  /// Views are on top of each other.
  ///
  /// @code{.unparsed}
  /// LLLLLLLL
  /// LLLLLLLL
  /// RRRRRRRR
  /// RRRRRRRR
  /// @endcode
  static const int AV_STEREO3D_TOPBOTTOM = 2;

  /// Views are alternated temporally.
  ///
  /// @code{.unparsed}
  /// frame0   frame1   frame2   ...
  /// LLLLLLLL RRRRRRRR LLLLLLLL
  /// LLLLLLLL RRRRRRRR LLLLLLLL
  /// LLLLLLLL RRRRRRRR LLLLLLLL
  /// ...      ...      ...
  /// @endcode
  static const int AV_STEREO3D_FRAMESEQUENCE = 3;

  /// Views are packed in a checkerboard-like structure per pixel.
  ///
  /// @code{.unparsed}
  /// LRLRLRLR
  /// RLRLRLRL
  /// LRLRLRLR
  /// ...
  /// @endcode
  static const int AV_STEREO3D_CHECKERBOARD = 4;

  /// Views are next to each other, but when upscaling
  /// apply a checkerboard pattern.
  ///
  /// @code{.unparsed}
  /// LLLLRRRR          L L L L    R R R R
  /// LLLLRRRR    =>     L L L L  R R R R
  /// LLLLRRRR          L L L L    R R R R
  /// LLLLRRRR           L L L L  R R R R
  /// @endcode
  static const int AV_STEREO3D_SIDEBYSIDE_QUINCUNX = 5;

  /// Views are packed per line, as if interlaced.
  ///
  /// @code{.unparsed}
  /// LLLLLLLL
  /// RRRRRRRR
  /// LLLLLLLL
  /// ...
  /// @endcode
  static const int AV_STEREO3D_LINES = 6;

  /// Views are packed per column.
  ///
  /// @code{.unparsed}
  /// LRLRLRLR
  /// LRLRLRLR
  /// LRLRLRLR
  /// ...
  /// @endcode
  static const int AV_STEREO3D_COLUMNS = 7;
}

/// List of possible view types.
abstract class AVStereo3DView {
  /// Frame contains two packed views.
  static const int AV_STEREO3D_VIEW_PACKED = 0;

  /// Frame contains only the left view.
  static const int AV_STEREO3D_VIEW_LEFT = 1;

  /// Frame contains only the right view.
  static const int AV_STEREO3D_VIEW_RIGHT = 2;
}

/// Stereo 3D type: this structure describes how two videos are packed
/// within a single video surface, with additional information as needed.
///
/// @note The struct must be allocated with av_stereo3d_alloc() and
/// its size is not a part of the public ABI.
class AVStereo3D extends ffi.Struct {
  /// How views are packed within the video.
  @ffi.Int32()
  int type;

  /// Additional information about the frame packing.
  @ffi.Int32()
  int flags;

  /// Determines which views are packed.
  @ffi.Int32()
  int view;
}

class AVTEA extends ffi.Struct {}

class AVThreadMessageQueue extends ffi.Struct {}

abstract class AVThreadMessageFlags {
  /// Perform non-blocking operation.
  /// If this flag is set, send and recv operations are non-blocking and
  /// return AVERROR(EAGAIN) immediately if they can not proceed.
  static const int AV_THREAD_MESSAGE_NONBLOCK = 1;
}

abstract class AVTimecodeFlag {
  /// ///< timecode is drop frame
  static const int AV_TIMECODE_FLAG_DROPFRAME = 1;

  /// ///< timecode wraps after 24 hours
  static const int AV_TIMECODE_FLAG_24HOURSMAX = 2;

  /// ///< negative time values are allowed
  static const int AV_TIMECODE_FLAG_ALLOWNEGATIVE = 4;
}

class AVTimecode extends ffi.Struct {}

/// @addtogroup lavu_tree AVTree
/// @ingroup lavu_data
///
/// Low-complexity tree container
///
/// Insertion, removal, finding equal, largest which is smaller than and
/// smallest which is larger than, all have O(log n) worst-case complexity.
/// @{
class AVTreeNode extends ffi.Struct {}

class AVTWOFISH extends ffi.Struct {}

class AVTXContext extends ffi.Struct {}

class AVComplexFloat extends ffi.Struct {
  @ffi.Float()
  double re;

  @ffi.Float()
  double im;
}

class AVComplexDouble extends ffi.Struct {
  @ffi.Double()
  double re;

  @ffi.Double()
  double im;
}

class AVComplexInt32 extends ffi.Struct {
  @ffi.Int32()
  int re;

  @ffi.Int32()
  int im;
}

abstract class AVTXType {
  /// Standard complex to complex FFT with sample data type AVComplexFloat.
  /// Output is not 1/len normalized. Scaling currently unsupported.
  /// The stride parameter is ignored.
  static const int AV_TX_FLOAT_FFT = 0;

  /// Standard MDCT with sample data type of float and a scale type of
  /// float. Length is the frame size, not the window size (which is 2x frame)
  /// For forward transforms, the stride specifies the spacing between each
  /// sample in the output array in bytes. The input must be a flat array.
  /// For inverse transforms, the stride specifies the spacing between each
  /// sample in the input array in bytes. The output will be a flat array.
  /// Stride must be a non-zero multiple of sizeof(float).
  /// NOTE: the inverse transform is half-length, meaning the output will not
  /// contain redundant data. This is what most codecs work with.
  static const int AV_TX_FLOAT_MDCT = 1;

  /// Same as AV_TX_FLOAT_FFT with a data type of AVComplexDouble.
  static const int AV_TX_DOUBLE_FFT = 2;

  /// Same as AV_TX_FLOAT_MDCT with data and scale type of double.
  /// Stride must be a non-zero multiple of sizeof(double).
  static const int AV_TX_DOUBLE_MDCT = 3;

  /// Same as AV_TX_FLOAT_FFT with a data type of AVComplexInt32.
  static const int AV_TX_INT32_FFT = 4;

  /// Same as AV_TX_FLOAT_MDCT with data type of int32_t and scale type of float.
  /// Only scale values less than or equal to 1.0 are supported.
  /// Stride must be a non-zero multiple of sizeof(int32_t).
  static const int AV_TX_INT32_MDCT = 5;
}

abstract class AVVideoEncParamsType {
  static const int AV_VIDEO_ENC_PARAMS_NONE = -1;

  /// VP9 stores:
  /// - per-frame base (luma AC) quantizer index, exported as AVVideoEncParams.qp
  /// - deltas for luma DC, chroma AC and chroma DC, exported in the
  /// corresponding entries in AVVideoEncParams.delta_qp
  /// - per-segment delta, exported as for each block as AVVideoBlockParams.delta_qp
  ///
  /// To compute the resulting quantizer index for a block:
  /// - for luma AC, add the base qp and the per-block delta_qp, saturating to
  /// unsigned 8-bit.
  /// - for luma DC and chroma AC/DC, add the corresponding
  /// AVVideoBlockParams.delta_qp to the luma AC index, again saturating to
  /// unsigned 8-bit.
  static const int AV_VIDEO_ENC_PARAMS_VP9 = 0;

  /// H.264 stores:
  /// - in PPS (per-picture):
  /// * initial QP_Y (luma) value, exported as AVVideoEncParams.qp
  /// * delta(s) for chroma QP values (same for both, or each separately),
  /// exported as in the corresponding entries in AVVideoEncParams.delta_qp
  /// - per-slice QP delta, not exported directly, added to the per-MB value
  /// - per-MB delta; not exported directly; the final per-MB quantizer
  /// parameter - QP_Y - minus the value in AVVideoEncParams.qp is exported
  /// as AVVideoBlockParams.qp_delta.
  static const int AV_VIDEO_ENC_PARAMS_H264 = 1;
  static const int AV_VIDEO_ENC_PARAMS_MPEG2 = 2;
}

/// Video encoding parameters for a given frame. This struct is allocated along
/// with an optional array of per-block AVVideoBlockParams descriptors.
/// Must be allocated with av_video_enc_params_alloc().
class AVVideoEncParams extends ffi.Struct {
  /// Number of blocks in the array.
  ///
  /// May be 0, in which case no per-block information is present. In this case
  /// the values of blocks_offset / block_size are unspecified and should not
  /// be accessed.
  @ffi.Uint32()
  int nb_blocks;

  /// Offset in bytes from the beginning of this structure at which the array
  /// of blocks starts.
  @ffi.Uint64()
  int blocks_offset;

  @ffi.Uint64()
  int block_size;

  /// Type of the parameters (the codec they are used with).
  @ffi.Int32()
  int type;

  /// Base quantisation parameter for the frame. The final quantiser for a
  /// given block in a given plane is obtained from this value, possibly
  /// combined with {@code delta_qp} and the per-block delta in a manner
  /// documented for each type.
  @ffi.Int32()
  int qp;

  @ffi.Int32()
  int _unique_delta_qp_item_0;
  @ffi.Int32()
  int _unique_delta_qp_item_1;
  @ffi.Int32()
  int _unique_delta_qp_item_2;
  @ffi.Int32()
  int _unique_delta_qp_item_3;
  @ffi.Int32()
  int _unique_delta_qp_item_4;
  @ffi.Int32()
  int _unique_delta_qp_item_5;
  @ffi.Int32()
  int _unique_delta_qp_item_6;
  @ffi.Int32()
  int _unique_delta_qp_item_7;

  /// Helper for array `delta_qp`.
  ArrayHelper_AVVideoEncParams_delta_qp_level0 get delta_qp =>
      ArrayHelper_AVVideoEncParams_delta_qp_level0(this, [4, 2], 0, 0);
}

/// Helper for array `delta_qp` in struct `AVVideoEncParams`.
class ArrayHelper_AVVideoEncParams_delta_qp_level0 {
  final AVVideoEncParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVideoEncParams_delta_qp_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  ArrayHelper_AVVideoEncParams_delta_qp_level1 operator [](int index) {
    _checkBounds(index);
    var offset = index;
    for (var i = level + 1; i < dimensions.length; i++) {
      offset *= dimensions[i];
    }
    return ArrayHelper_AVVideoEncParams_delta_qp_level1(
        _struct, dimensions, level + 1, _absoluteIndex + offset);
  }
}

/// Helper for array `delta_qp` in struct `AVVideoEncParams`.
class ArrayHelper_AVVideoEncParams_delta_qp_level1 {
  final AVVideoEncParams _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVVideoEncParams_delta_qp_level1(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_delta_qp_item_0;
      case 1:
        return _struct._unique_delta_qp_item_1;
      case 2:
        return _struct._unique_delta_qp_item_2;
      case 3:
        return _struct._unique_delta_qp_item_3;
      case 4:
        return _struct._unique_delta_qp_item_4;
      case 5:
        return _struct._unique_delta_qp_item_5;
      case 6:
        return _struct._unique_delta_qp_item_6;
      case 7:
        return _struct._unique_delta_qp_item_7;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_delta_qp_item_0 = value;
        break;
      case 1:
        _struct._unique_delta_qp_item_1 = value;
        break;
      case 2:
        _struct._unique_delta_qp_item_2 = value;
        break;
      case 3:
        _struct._unique_delta_qp_item_3 = value;
        break;
      case 4:
        _struct._unique_delta_qp_item_4 = value;
        break;
      case 5:
        _struct._unique_delta_qp_item_5 = value;
        break;
      case 6:
        _struct._unique_delta_qp_item_6 = value;
        break;
      case 7:
        _struct._unique_delta_qp_item_7 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Data structure for storing block-level encoding information.
/// It is allocated as a part of AVVideoEncParams and should be retrieved with
/// av_video_enc_params_block().
///
/// sizeof(AVVideoBlockParams) is not a part of the ABI and new fields may be
/// added to it.
class AVVideoBlockParams extends ffi.Struct {
  /// Distance in luma pixels from the top-left corner of the visible frame
  /// to the top-left corner of the block.
  /// Can be negative if top/right padding is present on the coded frame.
  @ffi.Int32()
  int src_x;

  @ffi.Int32()
  int src_y;

  /// Width and height of the block in luma pixels.
  @ffi.Int32()
  int w;

  @ffi.Int32()
  int h;

  /// Difference between this block's final quantization parameter and the
  /// corresponding per-frame value.
  @ffi.Int32()
  int delta_qp;
}

/// @file
/// @brief Public header for libavutil XTEA algorithm
/// @defgroup lavu_xtea XTEA
/// @ingroup lavu_crypto
/// @{
class AVXTEA extends ffi.Struct {
  @ffi.Uint32()
  int _unique_key_item_0;
  @ffi.Uint32()
  int _unique_key_item_1;
  @ffi.Uint32()
  int _unique_key_item_2;
  @ffi.Uint32()
  int _unique_key_item_3;
  @ffi.Uint32()
  int _unique_key_item_4;
  @ffi.Uint32()
  int _unique_key_item_5;
  @ffi.Uint32()
  int _unique_key_item_6;
  @ffi.Uint32()
  int _unique_key_item_7;
  @ffi.Uint32()
  int _unique_key_item_8;
  @ffi.Uint32()
  int _unique_key_item_9;
  @ffi.Uint32()
  int _unique_key_item_10;
  @ffi.Uint32()
  int _unique_key_item_11;
  @ffi.Uint32()
  int _unique_key_item_12;
  @ffi.Uint32()
  int _unique_key_item_13;
  @ffi.Uint32()
  int _unique_key_item_14;
  @ffi.Uint32()
  int _unique_key_item_15;

  /// Helper for array `key`.
  ArrayHelper_AVXTEA_key_level0 get key =>
      ArrayHelper_AVXTEA_key_level0(this, [16], 0, 0);
}

/// Helper for array `key` in struct `AVXTEA`.
class ArrayHelper_AVXTEA_key_level0 {
  final AVXTEA _struct;
  final List<int> dimensions;
  final int level;
  final int _absoluteIndex;
  int get length => dimensions[level];
  ArrayHelper_AVXTEA_key_level0(
      this._struct, this.dimensions, this.level, this._absoluteIndex);
  void _checkBounds(int index) {
    if (index >= length || index < 0) {
      throw RangeError(
          'Dimension $level: index not in range 0..${length} exclusive.');
    }
  }

  int operator [](int index) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        return _struct._unique_key_item_0;
      case 1:
        return _struct._unique_key_item_1;
      case 2:
        return _struct._unique_key_item_2;
      case 3:
        return _struct._unique_key_item_3;
      case 4:
        return _struct._unique_key_item_4;
      case 5:
        return _struct._unique_key_item_5;
      case 6:
        return _struct._unique_key_item_6;
      case 7:
        return _struct._unique_key_item_7;
      case 8:
        return _struct._unique_key_item_8;
      case 9:
        return _struct._unique_key_item_9;
      case 10:
        return _struct._unique_key_item_10;
      case 11:
        return _struct._unique_key_item_11;
      case 12:
        return _struct._unique_key_item_12;
      case 13:
        return _struct._unique_key_item_13;
      case 14:
        return _struct._unique_key_item_14;
      case 15:
        return _struct._unique_key_item_15;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }

  void operator []=(int index, int value) {
    _checkBounds(index);
    switch (_absoluteIndex + index) {
      case 0:
        _struct._unique_key_item_0 = value;
        break;
      case 1:
        _struct._unique_key_item_1 = value;
        break;
      case 2:
        _struct._unique_key_item_2 = value;
        break;
      case 3:
        _struct._unique_key_item_3 = value;
        break;
      case 4:
        _struct._unique_key_item_4 = value;
        break;
      case 5:
        _struct._unique_key_item_5 = value;
        break;
      case 6:
        _struct._unique_key_item_6 = value;
        break;
      case 7:
        _struct._unique_key_item_7 = value;
        break;
      case 8:
        _struct._unique_key_item_8 = value;
        break;
      case 9:
        _struct._unique_key_item_9 = value;
        break;
      case 10:
        _struct._unique_key_item_10 = value;
        break;
      case 11:
        _struct._unique_key_item_11 = value;
        break;
      case 12:
        _struct._unique_key_item_12 = value;
        break;
      case 13:
        _struct._unique_key_item_13 = value;
        break;
      case 14:
        _struct._unique_key_item_14 = value;
        break;
      case 15:
        _struct._unique_key_item_15 = value;
        break;
      default:
        throw Exception('Invalid Array Helper generated.');
    }
  }
}

/// Dithering algorithms
abstract class SwrDitherType {
  static const int SWR_DITHER_NONE = 0;
  static const int SWR_DITHER_RECTANGULAR = 1;
  static const int SWR_DITHER_TRIANGULAR = 2;
  static const int SWR_DITHER_TRIANGULAR_HIGHPASS = 3;

  /// ///< not part of API/ABI
  static const int SWR_DITHER_NS = 64;
  static const int SWR_DITHER_NS_LIPSHITZ = 65;
  static const int SWR_DITHER_NS_F_WEIGHTED = 66;
  static const int SWR_DITHER_NS_MODIFIED_E_WEIGHTED = 67;
  static const int SWR_DITHER_NS_IMPROVED_E_WEIGHTED = 68;
  static const int SWR_DITHER_NS_SHIBATA = 69;
  static const int SWR_DITHER_NS_LOW_SHIBATA = 70;
  static const int SWR_DITHER_NS_HIGH_SHIBATA = 71;

  /// ///< not part of API/ABI
  static const int SWR_DITHER_NB = 72;
}

/// Resampling Engines
abstract class SwrEngine {
  /// < SW Resampler
  static const int SWR_ENGINE_SWR = 0;

  /// < SoX Resampler
  static const int SWR_ENGINE_SOXR = 1;

  /// ///< not part of API/ABI
  static const int SWR_ENGINE_NB = 2;
}

/// Resampling Filter Types
abstract class SwrFilterType {
  /// < Cubic
  static const int SWR_FILTER_TYPE_CUBIC = 0;

  /// < Blackman Nuttall windowed sinc
  static const int SWR_FILTER_TYPE_BLACKMAN_NUTTALL = 1;

  /// < Kaiser windowed sinc
  static const int SWR_FILTER_TYPE_KAISER = 2;
}

class SwrContext extends ffi.Struct {}

class SwsVector extends ffi.Struct {
  /// ///< pointer to the list of coefficients
  ffi.Pointer<ffi.Double> coeff;

  /// ///< number of coefficients in the vector
  @ffi.Int32()
  int length;
}

class SwsFilter extends ffi.Struct {
  ffi.Pointer<SwsVector> lumH;

  ffi.Pointer<SwsVector> lumV;

  ffi.Pointer<SwsVector> chrH;

  ffi.Pointer<SwsVector> chrV;
}

class SwsContext extends ffi.Struct {}

const int FP_NAN = 0;

const int FP_INFINITE = 1;

const int FP_ZERO = 2;

const int FP_SUBNORMAL = 3;

const int FP_NORMAL = 4;

const int AV_FRAME_CROP_UNALIGNED = 1;

const int AV_HWFRAME_MAP_READ = 1;

const int AV_HWFRAME_MAP_WRITE = 2;

const int AV_HWFRAME_MAP_OVERWRITE = 4;

const int AV_HWFRAME_MAP_DIRECT = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8;

const int FP_NAN_1 = 0;

const int FP_INFINITE_1 = 1;

const int FP_ZERO_1 = 2;

const int FP_SUBNORMAL_1 = 3;

const int FP_NORMAL_1 = 4;

const int AV_OPT_FLAG_IMPLICIT_KEY = 1;

const int FP_NAN_2 = 0;

const int FP_INFINITE_2 = 1;

const int FP_ZERO_2 = 2;

const int FP_SUBNORMAL_2 = 3;

const int FP_NORMAL_2 = 4;

const int FP_NAN_3 = 0;

const int FP_INFINITE_3 = 1;

const int FP_ZERO_3 = 2;

const int FP_SUBNORMAL_3 = 3;

const int FP_NORMAL_3 = 4;

const int AV_FRAME_CROP_UNALIGNED_1 = 1;

const int AV_HWFRAME_MAP_READ_1 = 1;

const int AV_HWFRAME_MAP_WRITE_1 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_1 = 4;

const int AV_HWFRAME_MAP_DIRECT_1 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_1 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_1 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_1 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_1 = 8;

const int FP_NAN_4 = 0;

const int FP_INFINITE_4 = 1;

const int FP_ZERO_4 = 2;

const int FP_SUBNORMAL_4 = 3;

const int FP_NORMAL_4 = 4;

const int FP_NAN_5 = 0;

const int FP_INFINITE_5 = 1;

const int FP_ZERO_5 = 2;

const int FP_SUBNORMAL_5 = 3;

const int FP_NORMAL_5 = 4;

const int FP_NAN_6 = 0;

const int FP_INFINITE_6 = 1;

const int FP_ZERO_6 = 2;

const int FP_SUBNORMAL_6 = 3;

const int FP_NORMAL_6 = 4;

const int FP_NAN_7 = 0;

const int FP_INFINITE_7 = 1;

const int FP_ZERO_7 = 2;

const int FP_SUBNORMAL_7 = 3;

const int FP_NORMAL_7 = 4;

const int AV_FRAME_CROP_UNALIGNED_2 = 1;

const int AV_HWFRAME_MAP_READ_2 = 1;

const int AV_HWFRAME_MAP_WRITE_2 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_2 = 4;

const int AV_HWFRAME_MAP_DIRECT_2 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_2 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_2 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_2 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_2 = 8;

const int FP_NAN_8 = 0;

const int FP_INFINITE_8 = 1;

const int FP_ZERO_8 = 2;

const int FP_SUBNORMAL_8 = 3;

const int FP_NORMAL_8 = 4;

const int AV_FRAME_CROP_UNALIGNED_3 = 1;

const int AV_HWFRAME_MAP_READ_3 = 1;

const int AV_HWFRAME_MAP_WRITE_3 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_3 = 4;

const int AV_HWFRAME_MAP_DIRECT_3 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_3 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_3 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_3 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_3 = 8;

const int FP_NAN_9 = 0;

const int FP_INFINITE_9 = 1;

const int FP_ZERO_9 = 2;

const int FP_SUBNORMAL_9 = 3;

const int FP_NORMAL_9 = 4;

const int AV_FRAME_CROP_UNALIGNED_4 = 1;

const int AV_HWFRAME_MAP_READ_4 = 1;

const int AV_HWFRAME_MAP_WRITE_4 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_4 = 4;

const int AV_HWFRAME_MAP_DIRECT_4 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_4 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_4 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_4 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_4 = 8;

const int FP_NAN_10 = 0;

const int FP_INFINITE_10 = 1;

const int FP_ZERO_10 = 2;

const int FP_SUBNORMAL_10 = 3;

const int FP_NORMAL_10 = 4;

const int AV_FRAME_CROP_UNALIGNED_5 = 1;

const int AV_HWFRAME_MAP_READ_5 = 1;

const int AV_HWFRAME_MAP_WRITE_5 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_5 = 4;

const int AV_HWFRAME_MAP_DIRECT_5 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_5 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_5 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_5 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_5 = 8;

const int FP_NAN_11 = 0;

const int FP_INFINITE_11 = 1;

const int FP_ZERO_11 = 2;

const int FP_SUBNORMAL_11 = 3;

const int FP_NORMAL_11 = 4;

const int AV_FRAME_CROP_UNALIGNED_6 = 1;

const int AV_HWFRAME_MAP_READ_6 = 1;

const int AV_HWFRAME_MAP_WRITE_6 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_6 = 4;

const int AV_HWFRAME_MAP_DIRECT_6 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_6 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_6 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_6 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_6 = 8;

const int FP_NAN_12 = 0;

const int FP_INFINITE_12 = 1;

const int FP_ZERO_12 = 2;

const int FP_SUBNORMAL_12 = 3;

const int FP_NORMAL_12 = 4;

const int AV_FRAME_CROP_UNALIGNED_7 = 1;

const int AV_HWFRAME_MAP_READ_7 = 1;

const int AV_HWFRAME_MAP_WRITE_7 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_7 = 4;

const int AV_HWFRAME_MAP_DIRECT_7 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_7 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_7 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_7 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_7 = 8;

const int FP_NAN_13 = 0;

const int FP_INFINITE_13 = 1;

const int FP_ZERO_13 = 2;

const int FP_SUBNORMAL_13 = 3;

const int FP_NORMAL_13 = 4;

const int AV_OPT_FLAG_IMPLICIT_KEY_1 = 1;

const int AV_FRAME_CROP_UNALIGNED_8 = 1;

const int AV_HWFRAME_MAP_READ_8 = 1;

const int AV_HWFRAME_MAP_WRITE_8 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_8 = 4;

const int AV_HWFRAME_MAP_DIRECT_8 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_8 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_8 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_8 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_8 = 8;

const int FP_NAN_14 = 0;

const int FP_INFINITE_14 = 1;

const int FP_ZERO_14 = 2;

const int FP_SUBNORMAL_14 = 3;

const int FP_NORMAL_14 = 4;

const int AV_FRAME_CROP_UNALIGNED_9 = 1;

const int AVFILTER_AUTO_CONVERT_ALL = 0;

const int AVFILTER_AUTO_CONVERT_NONE = -1;

const int FP_NAN_15 = 0;

const int FP_INFINITE_15 = 1;

const int FP_ZERO_15 = 2;

const int FP_SUBNORMAL_15 = 3;

const int FP_NORMAL_15 = 4;

const int AV_FRAME_CROP_UNALIGNED_10 = 1;

const int AVFILTER_AUTO_CONVERT_ALL_1 = 0;

const int AVFILTER_AUTO_CONVERT_NONE_1 = -1;

const int FP_NAN_16 = 0;

const int FP_INFINITE_16 = 1;

const int FP_ZERO_16 = 2;

const int FP_SUBNORMAL_16 = 3;

const int FP_NORMAL_16 = 4;

const int AV_FRAME_CROP_UNALIGNED_11 = 1;

const int AVFILTER_AUTO_CONVERT_ALL_2 = 0;

const int AVFILTER_AUTO_CONVERT_NONE_2 = -1;

const int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1;

const int AV_BUFFERSRC_FLAG_PUSH = 4;

const int AV_BUFFERSRC_FLAG_KEEP_REF = 8;

const int FP_NAN_17 = 0;

const int FP_INFINITE_17 = 1;

const int FP_ZERO_17 = 2;

const int FP_SUBNORMAL_17 = 3;

const int FP_NORMAL_17 = 4;

const int AV_FRAME_CROP_UNALIGNED_12 = 1;

const int AV_HWFRAME_MAP_READ_9 = 1;

const int AV_HWFRAME_MAP_WRITE_9 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_9 = 4;

const int AV_HWFRAME_MAP_DIRECT_9 = 8;

const int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX_9 = 1;

const int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX_9 = 2;

const int AV_CODEC_HW_CONFIG_METHOD_INTERNAL_9 = 4;

const int AV_CODEC_HW_CONFIG_METHOD_AD_HOC_9 = 8;

const int FP_NAN_18 = 0;

const int FP_INFINITE_18 = 1;

const int FP_ZERO_18 = 2;

const int FP_SUBNORMAL_18 = 3;

const int FP_NORMAL_18 = 4;

const int FP_NAN_19 = 0;

const int FP_INFINITE_19 = 1;

const int FP_ZERO_19 = 2;

const int FP_SUBNORMAL_19 = 3;

const int FP_NORMAL_19 = 4;

const int FP_NAN_20 = 0;

const int FP_INFINITE_20 = 1;

const int FP_ZERO_20 = 2;

const int FP_SUBNORMAL_20 = 3;

const int FP_NORMAL_20 = 4;

const int FP_NAN_21 = 0;

const int FP_INFINITE_21 = 1;

const int FP_ZERO_21 = 2;

const int FP_SUBNORMAL_21 = 3;

const int FP_NORMAL_21 = 4;

const int FP_NAN_22 = 0;

const int FP_INFINITE_22 = 1;

const int FP_ZERO_22 = 2;

const int FP_SUBNORMAL_22 = 3;

const int FP_NORMAL_22 = 4;

const int FP_NAN_23 = 0;

const int FP_INFINITE_23 = 1;

const int FP_ZERO_23 = 2;

const int FP_SUBNORMAL_23 = 3;

const int FP_NORMAL_23 = 4;

const int FP_NAN_24 = 0;

const int FP_INFINITE_24 = 1;

const int FP_ZERO_24 = 2;

const int FP_SUBNORMAL_24 = 3;

const int FP_NORMAL_24 = 4;

const int AV_FRAME_CROP_UNALIGNED_13 = 1;

const int FP_NAN_25 = 0;

const int FP_INFINITE_25 = 1;

const int FP_ZERO_25 = 2;

const int FP_SUBNORMAL_25 = 3;

const int FP_NORMAL_25 = 4;

const int FP_NAN_26 = 0;

const int FP_INFINITE_26 = 1;

const int FP_ZERO_26 = 2;

const int FP_SUBNORMAL_26 = 3;

const int FP_NORMAL_26 = 4;

const int FP_NAN_27 = 0;

const int FP_INFINITE_27 = 1;

const int FP_ZERO_27 = 2;

const int FP_SUBNORMAL_27 = 3;

const int FP_NORMAL_27 = 4;

const int FP_NAN_28 = 0;

const int FP_INFINITE_28 = 1;

const int FP_ZERO_28 = 2;

const int FP_SUBNORMAL_28 = 3;

const int FP_NORMAL_28 = 4;

const int AV_FRAME_CROP_UNALIGNED_14 = 1;

const int FP_NAN_29 = 0;

const int FP_INFINITE_29 = 1;

const int FP_ZERO_29 = 2;

const int FP_SUBNORMAL_29 = 3;

const int FP_NORMAL_29 = 4;

const int AV_FRAME_CROP_UNALIGNED_15 = 1;

const int FP_NAN_30 = 0;

const int FP_INFINITE_30 = 1;

const int FP_ZERO_30 = 2;

const int FP_SUBNORMAL_30 = 3;

const int FP_NORMAL_30 = 4;

const int AV_FRAME_CROP_UNALIGNED_16 = 1;

const int FP_NAN_31 = 0;

const int FP_INFINITE_31 = 1;

const int FP_ZERO_31 = 2;

const int FP_SUBNORMAL_31 = 3;

const int FP_NORMAL_31 = 4;

const int AV_FRAME_CROP_UNALIGNED_17 = 1;

const int AV_HWFRAME_MAP_READ_10 = 1;

const int AV_HWFRAME_MAP_WRITE_10 = 2;

const int AV_HWFRAME_MAP_OVERWRITE_10 = 4;

const int AV_HWFRAME_MAP_DIRECT_10 = 8;

const int AV_DRM_MAX_PLANES = 4;

const int FP_NAN_32 = 0;

const int FP_INFINITE_32 = 1;

const int FP_ZERO_32 = 2;

const int FP_SUBNORMAL_32 = 3;

const int FP_NORMAL_32 = 4;

const int AV_FRAME_CROP_UNALIGNED_18 = 1;

const int AV_VAAPI_DRIVER_QUIRK_USER_SET = 1;

const int AV_VAAPI_DRIVER_QUIRK_RENDER_PARAM_BUFFERS = 2;

const int AV_VAAPI_DRIVER_QUIRK_ATTRIB_MEMTYPE = 4;

const int AV_VAAPI_DRIVER_QUIRK_SURFACE_ATTRIBUTES = 8;

const int FP_NAN_33 = 0;

const int FP_INFINITE_33 = 1;

const int FP_ZERO_33 = 2;

const int FP_SUBNORMAL_33 = 3;

const int FP_NORMAL_33 = 4;

const int AV_FRAME_CROP_UNALIGNED_19 = 1;

const int FP_NAN_34 = 0;

const int FP_INFINITE_34 = 1;

const int FP_ZERO_34 = 2;

const int FP_SUBNORMAL_34 = 3;

const int FP_NORMAL_34 = 4;

const int FP_NAN_35 = 0;

const int FP_INFINITE_35 = 1;

const int FP_ZERO_35 = 2;

const int FP_SUBNORMAL_35 = 3;

const int FP_NORMAL_35 = 4;

const int FP_NAN_36 = 0;

const int FP_INFINITE_36 = 1;

const int FP_ZERO_36 = 2;

const int FP_SUBNORMAL_36 = 3;

const int FP_NORMAL_36 = 4;

const int AV_FRAME_CROP_UNALIGNED_20 = 1;

const int FP_NAN_37 = 0;

const int FP_INFINITE_37 = 1;

const int FP_ZERO_37 = 2;

const int FP_SUBNORMAL_37 = 3;

const int FP_NORMAL_37 = 4;

const int FP_NAN_38 = 0;

const int FP_INFINITE_38 = 1;

const int FP_ZERO_38 = 2;

const int FP_SUBNORMAL_38 = 3;

const int FP_NORMAL_38 = 4;

const int FP_NAN_39 = 0;

const int FP_INFINITE_39 = 1;

const int FP_ZERO_39 = 2;

const int FP_SUBNORMAL_39 = 3;

const int FP_NORMAL_39 = 4;

const int AV_OPT_FLAG_IMPLICIT_KEY_2 = 1;

const int FP_NAN_40 = 0;

const int FP_INFINITE_40 = 1;

const int FP_ZERO_40 = 2;

const int FP_SUBNORMAL_40 = 3;

const int FP_NORMAL_40 = 4;

const int FP_NAN_41 = 0;

const int FP_INFINITE_41 = 1;

const int FP_ZERO_41 = 2;

const int FP_SUBNORMAL_41 = 3;

const int FP_NORMAL_41 = 4;

const int FP_NAN_42 = 0;

const int FP_INFINITE_42 = 1;

const int FP_ZERO_42 = 2;

const int FP_SUBNORMAL_42 = 3;

const int FP_NORMAL_42 = 4;

const int AV_FRAME_CROP_UNALIGNED_21 = 1;

const int FP_NAN_43 = 0;

const int FP_INFINITE_43 = 1;

const int FP_ZERO_43 = 2;

const int FP_SUBNORMAL_43 = 3;

const int FP_NORMAL_43 = 4;

const int FP_NAN_44 = 0;

const int FP_INFINITE_44 = 1;

const int FP_ZERO_44 = 2;

const int FP_SUBNORMAL_44 = 3;

const int FP_NORMAL_44 = 4;

const int AV_FRAME_CROP_UNALIGNED_22 = 1;

const int FP_NAN_45 = 0;

const int FP_INFINITE_45 = 1;

const int FP_ZERO_45 = 2;

const int FP_SUBNORMAL_45 = 3;

const int FP_NORMAL_45 = 4;

const int FP_NAN_46 = 0;

const int FP_INFINITE_46 = 1;

const int FP_ZERO_46 = 2;

const int FP_SUBNORMAL_46 = 3;

const int FP_NORMAL_46 = 4;

const int FP_NAN_47 = 0;

const int FP_INFINITE_47 = 1;

const int FP_ZERO_47 = 2;

const int FP_SUBNORMAL_47 = 3;

const int FP_NORMAL_47 = 4;

const int AV_FRAME_CROP_UNALIGNED_23 = 1;

const int FP_NAN_48 = 0;

const int FP_INFINITE_48 = 1;

const int FP_ZERO_48 = 2;

const int FP_SUBNORMAL_48 = 3;

const int FP_NORMAL_48 = 4;

const int FP_NAN_49 = 0;

const int FP_INFINITE_49 = 1;

const int FP_ZERO_49 = 2;

const int FP_SUBNORMAL_49 = 3;

const int FP_NORMAL_49 = 4;

const int NULL = 0;

const int _STDINT_H = 1;

const int _FEATURES_H = 1;

const int _DEFAULT_SOURCE = 1;

const int __GLIBC_USE_ISOC2X = 1;

const int __USE_ISOC11 = 1;

const int __USE_ISOC99 = 1;

const int __USE_ISOC95 = 1;

const int _POSIX_SOURCE = 1;

const int _POSIX_C_SOURCE = 200809;

const int __USE_POSIX = 1;

const int __USE_POSIX2 = 1;

const int __USE_POSIX199309 = 1;

const int __USE_POSIX199506 = 1;

const int __USE_XOPEN2K = 1;

const int __USE_XOPEN2K8 = 1;

const int _ATFILE_SOURCE = 1;

const int __USE_MISC = 1;

const int __USE_ATFILE = 1;

const int __USE_FORTIFY_LEVEL = 0;

const int __GLIBC_USE_DEPRECATED_GETS = 0;

const int __GLIBC_USE_DEPRECATED_SCANF = 0;

const int _STDC_PREDEF_H = 1;

const int __STDC_IEC_559__ = 1;

const int __STDC_IEC_559_COMPLEX__ = 1;

const int __STDC_ISO_10646__ = 201706;

const int __GNU_LIBRARY__ = 6;

const int __GLIBC__ = 2;

const int __GLIBC_MINOR__ = 31;

const int _SYS_CDEFS_H = 1;

const int __glibc_c99_flexarr_available = 1;

const int __WORDSIZE = 64;

const int __WORDSIZE_TIME64_COMPAT32 = 1;

const int __SYSCALL_WORDSIZE = 64;

const int __LONG_DOUBLE_USES_FLOAT128 = 0;

const int __HAVE_GENERIC_SELECTION = 0;

const int __GLIBC_USE_LIB_EXT2 = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT = 1;

const int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT = 1;

const int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = 1;

const int __GLIBC_USE_IEC_60559_TYPES_EXT = 1;

const int _BITS_TYPES_H = 1;

const int __TIMESIZE = 64;

const int _BITS_TYPESIZES_H = 1;

const int __OFF_T_MATCHES_OFF64_T = 1;

const int __INO_T_MATCHES_INO64_T = 1;

const int __RLIM_T_MATCHES_RLIM64_T = 1;

const int __STATFS_MATCHES_STATFS64 = 1;

const int __FD_SETSIZE = 1024;

const int _BITS_TIME64_H = 1;

const int _BITS_WCHAR_H = 1;

const int __WCHAR_MAX = 2147483647;

const int __WCHAR_MIN = -2147483648;

const int _BITS_STDINT_INTN_H = 1;

const int _BITS_STDINT_UINTN_H = 1;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -9223372036854775808;

const int INT_FAST32_MIN = -9223372036854775808;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 9223372036854775807;

const int INT_FAST32_MAX = 9223372036854775807;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = -1;

const int UINT_FAST32_MAX = -1;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MIN = -9223372036854775808;

const int INTPTR_MAX = 9223372036854775807;

const int UINTPTR_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int SIZE_MAX = -1;

const int WCHAR_MIN = -2147483648;

const int WCHAR_MAX = 2147483647;

const int WINT_MIN = 0;

const int WINT_MAX = 4294967295;

const int AV_AAC_ADTS_HEADER_SIZE = 7;

const int _ERRNO_H = 1;

const int _BITS_ERRNO_H = 1;

const int EPERM = 1;

const int ENOENT = 2;

const int ESRCH = 3;

const int EINTR = 4;

const int EIO = 5;

const int ENXIO = 6;

const int E2BIG = 7;

const int ENOEXEC = 8;

const int EBADF = 9;

const int ECHILD = 10;

const int EAGAIN = 11;

const int ENOMEM = 12;

const int EACCES = 13;

const int EFAULT = 14;

const int ENOTBLK = 15;

const int EBUSY = 16;

const int EEXIST = 17;

const int EXDEV = 18;

const int ENODEV = 19;

const int ENOTDIR = 20;

const int EISDIR = 21;

const int EINVAL = 22;

const int ENFILE = 23;

const int EMFILE = 24;

const int ENOTTY = 25;

const int ETXTBSY = 26;

const int EFBIG = 27;

const int ENOSPC = 28;

const int ESPIPE = 29;

const int EROFS = 30;

const int EMLINK = 31;

const int EPIPE = 32;

const int EDOM = 33;

const int ERANGE = 34;

const int EDEADLK = 35;

const int ENAMETOOLONG = 36;

const int ENOLCK = 37;

const int ENOSYS = 38;

const int ENOTEMPTY = 39;

const int ELOOP = 40;

const int EWOULDBLOCK = 11;

const int ENOMSG = 42;

const int EIDRM = 43;

const int ECHRNG = 44;

const int EL2NSYNC = 45;

const int EL3HLT = 46;

const int EL3RST = 47;

const int ELNRNG = 48;

const int EUNATCH = 49;

const int ENOCSI = 50;

const int EL2HLT = 51;

const int EBADE = 52;

const int EBADR = 53;

const int EXFULL = 54;

const int ENOANO = 55;

const int EBADRQC = 56;

const int EBADSLT = 57;

const int EDEADLOCK = 35;

const int EBFONT = 59;

const int ENOSTR = 60;

const int ENODATA = 61;

const int ETIME = 62;

const int ENOSR = 63;

const int ENONET = 64;

const int ENOPKG = 65;

const int EREMOTE = 66;

const int ENOLINK = 67;

const int EADV = 68;

const int ESRMNT = 69;

const int ECOMM = 70;

const int EPROTO = 71;

const int EMULTIHOP = 72;

const int EDOTDOT = 73;

const int EBADMSG = 74;

const int EOVERFLOW = 75;

const int ENOTUNIQ = 76;

const int EBADFD = 77;

const int EREMCHG = 78;

const int ELIBACC = 79;

const int ELIBBAD = 80;

const int ELIBSCN = 81;

const int ELIBMAX = 82;

const int ELIBEXEC = 83;

const int EILSEQ = 84;

const int ERESTART = 85;

const int ESTRPIPE = 86;

const int EUSERS = 87;

const int ENOTSOCK = 88;

const int EDESTADDRREQ = 89;

const int EMSGSIZE = 90;

const int EPROTOTYPE = 91;

const int ENOPROTOOPT = 92;

const int EPROTONOSUPPORT = 93;

const int ESOCKTNOSUPPORT = 94;

const int EOPNOTSUPP = 95;

const int EPFNOSUPPORT = 96;

const int EAFNOSUPPORT = 97;

const int EADDRINUSE = 98;

const int EADDRNOTAVAIL = 99;

const int ENETDOWN = 100;

const int ENETUNREACH = 101;

const int ENETRESET = 102;

const int ECONNABORTED = 103;

const int ECONNRESET = 104;

const int ENOBUFS = 105;

const int EISCONN = 106;

const int ENOTCONN = 107;

const int ESHUTDOWN = 108;

const int ETOOMANYREFS = 109;

const int ETIMEDOUT = 110;

const int ECONNREFUSED = 111;

const int EHOSTDOWN = 112;

const int EHOSTUNREACH = 113;

const int EALREADY = 114;

const int EINPROGRESS = 115;

const int ESTALE = 116;

const int EUCLEAN = 117;

const int ENOTNAM = 118;

const int ENAVAIL = 119;

const int EISNAM = 120;

const int EREMOTEIO = 121;

const int EDQUOT = 122;

const int ENOMEDIUM = 123;

const int EMEDIUMTYPE = 124;

const int ECANCELED = 125;

const int ENOKEY = 126;

const int EKEYEXPIRED = 127;

const int EKEYREVOKED = 128;

const int EKEYREJECTED = 129;

const int EOWNERDEAD = 130;

const int ENOTRECOVERABLE = 131;

const int ERFKILL = 132;

const int EHWPOISON = 133;

const int ENOTSUP = 95;

const int FF_LAMBDA_SHIFT = 7;

const int FF_LAMBDA_SCALE = 128;

const int FF_QP2LAMBDA = 118;

const int FF_LAMBDA_MAX = 32767;

const int FF_QUALITY_SCALE = 128;

const int AV_NOPTS_VALUE = -9223372036854775808;

const int AV_TIME_BASE = 1000000;

const int _INTTYPES_H = 1;

const int ____gwchar_t_defined = 1;

const String __PRI64_PREFIX = 'l';

const String __PRIPTR_PREFIX = 'l';

const String PRId8 = 'd';

const String PRId16 = 'd';

const String PRId32 = 'd';

const String PRId64 = 'ld';

const String PRIdLEAST8 = 'd';

const String PRIdLEAST16 = 'd';

const String PRIdLEAST32 = 'd';

const String PRIdLEAST64 = 'ld';

const String PRIdFAST8 = 'd';

const String PRIdFAST16 = 'ld';

const String PRIdFAST32 = 'ld';

const String PRIdFAST64 = 'ld';

const String PRIi8 = 'i';

const String PRIi16 = 'i';

const String PRIi32 = 'i';

const String PRIi64 = 'li';

const String PRIiLEAST8 = 'i';

const String PRIiLEAST16 = 'i';

const String PRIiLEAST32 = 'i';

const String PRIiLEAST64 = 'li';

const String PRIiFAST8 = 'i';

const String PRIiFAST16 = 'li';

const String PRIiFAST32 = 'li';

const String PRIiFAST64 = 'li';

const String PRIo8 = 'o';

const String PRIo16 = 'o';

const String PRIo32 = 'o';

const String PRIo64 = 'lo';

const String PRIoLEAST8 = 'o';

const String PRIoLEAST16 = 'o';

const String PRIoLEAST32 = 'o';

const String PRIoLEAST64 = 'lo';

const String PRIoFAST8 = 'o';

const String PRIoFAST16 = 'lo';

const String PRIoFAST32 = 'lo';

const String PRIoFAST64 = 'lo';

const String PRIu8 = 'u';

const String PRIu16 = 'u';

const String PRIu32 = 'u';

const String PRIu64 = 'lu';

const String PRIuLEAST8 = 'u';

const String PRIuLEAST16 = 'u';

const String PRIuLEAST32 = 'u';

const String PRIuLEAST64 = 'lu';

const String PRIuFAST8 = 'u';

const String PRIuFAST16 = 'lu';

const String PRIuFAST32 = 'lu';

const String PRIuFAST64 = 'lu';

const String PRIx8 = 'x';

const String PRIx16 = 'x';

const String PRIx32 = 'x';

const String PRIx64 = 'lx';

const String PRIxLEAST8 = 'x';

const String PRIxLEAST16 = 'x';

const String PRIxLEAST32 = 'x';

const String PRIxLEAST64 = 'lx';

const String PRIxFAST8 = 'x';

const String PRIxFAST16 = 'lx';

const String PRIxFAST32 = 'lx';

const String PRIxFAST64 = 'lx';

const String PRIX8 = 'X';

const String PRIX16 = 'X';

const String PRIX32 = 'X';

const String PRIX64 = 'lX';

const String PRIXLEAST8 = 'X';

const String PRIXLEAST16 = 'X';

const String PRIXLEAST32 = 'X';

const String PRIXLEAST64 = 'lX';

const String PRIXFAST8 = 'X';

const String PRIXFAST16 = 'lX';

const String PRIXFAST32 = 'lX';

const String PRIXFAST64 = 'lX';

const String PRIdMAX = 'ld';

const String PRIiMAX = 'li';

const String PRIoMAX = 'lo';

const String PRIuMAX = 'lu';

const String PRIxMAX = 'lx';

const String PRIXMAX = 'lX';

const String PRIdPTR = 'ld';

const String PRIiPTR = 'li';

const String PRIoPTR = 'lo';

const String PRIuPTR = 'lu';

const String PRIxPTR = 'lx';

const String PRIXPTR = 'lX';

const String SCNd8 = 'hhd';

const String SCNd16 = 'hd';

const String SCNd32 = 'd';

const String SCNd64 = 'ld';

const String SCNdLEAST8 = 'hhd';

const String SCNdLEAST16 = 'hd';

const String SCNdLEAST32 = 'd';

const String SCNdLEAST64 = 'ld';

const String SCNdFAST8 = 'hhd';

const String SCNdFAST16 = 'ld';

const String SCNdFAST32 = 'ld';

const String SCNdFAST64 = 'ld';

const String SCNi8 = 'hhi';

const String SCNi16 = 'hi';

const String SCNi32 = 'i';

const String SCNi64 = 'li';

const String SCNiLEAST8 = 'hhi';

const String SCNiLEAST16 = 'hi';

const String SCNiLEAST32 = 'i';

const String SCNiLEAST64 = 'li';

const String SCNiFAST8 = 'hhi';

const String SCNiFAST16 = 'li';

const String SCNiFAST32 = 'li';

const String SCNiFAST64 = 'li';

const String SCNu8 = 'hhu';

const String SCNu16 = 'hu';

const String SCNu32 = 'u';

const String SCNu64 = 'lu';

const String SCNuLEAST8 = 'hhu';

const String SCNuLEAST16 = 'hu';

const String SCNuLEAST32 = 'u';

const String SCNuLEAST64 = 'lu';

const String SCNuFAST8 = 'hhu';

const String SCNuFAST16 = 'lu';

const String SCNuFAST32 = 'lu';

const String SCNuFAST64 = 'lu';

const String SCNo8 = 'hho';

const String SCNo16 = 'ho';

const String SCNo32 = 'o';

const String SCNo64 = 'lo';

const String SCNoLEAST8 = 'hho';

const String SCNoLEAST16 = 'ho';

const String SCNoLEAST32 = 'o';

const String SCNoLEAST64 = 'lo';

const String SCNoFAST8 = 'hho';

const String SCNoFAST16 = 'lo';

const String SCNoFAST32 = 'lo';

const String SCNoFAST64 = 'lo';

const String SCNx8 = 'hhx';

const String SCNx16 = 'hx';

const String SCNx32 = 'x';

const String SCNx64 = 'lx';

const String SCNxLEAST8 = 'hhx';

const String SCNxLEAST16 = 'hx';

const String SCNxLEAST32 = 'x';

const String SCNxLEAST64 = 'lx';

const String SCNxFAST8 = 'hhx';

const String SCNxFAST16 = 'lx';

const String SCNxFAST32 = 'lx';

const String SCNxFAST64 = 'lx';

const String SCNdMAX = 'ld';

const String SCNiMAX = 'li';

const String SCNoMAX = 'lo';

const String SCNuMAX = 'lu';

const String SCNxMAX = 'lx';

const String SCNdPTR = 'ld';

const String SCNiPTR = 'li';

const String SCNoPTR = 'lo';

const String SCNuPTR = 'lu';

const String SCNxPTR = 'lx';

const int _LIBC_LIMITS_H_ = 1;

const int MB_LEN_MAX = 16;

const int LLONG_MIN = -9223372036854775808;

const int LLONG_MAX = 9223372036854775807;

const int ULLONG_MAX = -1;

const int _BITS_POSIX1_LIM_H = 1;

const int _POSIX_AIO_LISTIO_MAX = 2;

const int _POSIX_AIO_MAX = 1;

const int _POSIX_ARG_MAX = 4096;

const int _POSIX_CHILD_MAX = 25;

const int _POSIX_DELAYTIMER_MAX = 32;

const int _POSIX_HOST_NAME_MAX = 255;

const int _POSIX_LINK_MAX = 8;

const int _POSIX_LOGIN_NAME_MAX = 9;

const int _POSIX_MAX_CANON = 255;

const int _POSIX_MAX_INPUT = 255;

const int _POSIX_MQ_OPEN_MAX = 8;

const int _POSIX_MQ_PRIO_MAX = 32;

const int _POSIX_NAME_MAX = 14;

const int _POSIX_NGROUPS_MAX = 8;

const int _POSIX_OPEN_MAX = 20;

const int _POSIX_PATH_MAX = 256;

const int _POSIX_PIPE_BUF = 512;

const int _POSIX_RE_DUP_MAX = 255;

const int _POSIX_RTSIG_MAX = 8;

const int _POSIX_SEM_NSEMS_MAX = 256;

const int _POSIX_SEM_VALUE_MAX = 32767;

const int _POSIX_SIGQUEUE_MAX = 32;

const int _POSIX_SSIZE_MAX = 32767;

const int _POSIX_STREAM_MAX = 8;

const int _POSIX_SYMLINK_MAX = 255;

const int _POSIX_SYMLOOP_MAX = 8;

const int _POSIX_TIMER_MAX = 32;

const int _POSIX_TTY_NAME_MAX = 9;

const int _POSIX_TZNAME_MAX = 6;

const int _POSIX_CLOCKRES_MIN = 20000000;

const int NGROUPS_MAX = 65536;

const int MAX_CANON = 255;

const int MAX_INPUT = 255;

const int NAME_MAX = 255;

const int PATH_MAX = 4096;

const int PIPE_BUF = 4096;

const int XATTR_NAME_MAX = 255;

const int XATTR_SIZE_MAX = 65536;

const int XATTR_LIST_MAX = 65536;

const int RTSIG_MAX = 32;

const int _POSIX_THREAD_KEYS_MAX = 128;

const int PTHREAD_KEYS_MAX = 1024;

const int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = 4;

const int PTHREAD_DESTRUCTOR_ITERATIONS = 4;

const int _POSIX_THREAD_THREADS_MAX = 64;

const int AIO_PRIO_DELTA_MAX = 20;

const int PTHREAD_STACK_MIN = 16384;

const int DELAYTIMER_MAX = 2147483647;

const int TTY_NAME_MAX = 32;

const int LOGIN_NAME_MAX = 256;

const int HOST_NAME_MAX = 64;

const int MQ_PRIO_MAX = 32768;

const int SEM_VALUE_MAX = 2147483647;

const int SSIZE_MAX = 9223372036854775807;

const int _BITS_POSIX2_LIM_H = 1;

const int _POSIX2_BC_BASE_MAX = 99;

const int _POSIX2_BC_DIM_MAX = 2048;

const int _POSIX2_BC_SCALE_MAX = 99;

const int _POSIX2_BC_STRING_MAX = 1000;

const int _POSIX2_COLL_WEIGHTS_MAX = 2;

const int _POSIX2_EXPR_NEST_MAX = 32;

const int _POSIX2_LINE_MAX = 2048;

const int _POSIX2_RE_DUP_MAX = 255;

const int _POSIX2_CHARCLASS_NAME_MAX = 14;

const int BC_BASE_MAX = 99;

const int BC_DIM_MAX = 2048;

const int BC_SCALE_MAX = 99;

const int BC_STRING_MAX = 1000;

const int COLL_WEIGHTS_MAX = 255;

const int EXPR_NEST_MAX = 32;

const int LINE_MAX = 2048;

const int CHARCLASS_NAME_MAX = 2048;

const int RE_DUP_MAX = 32767;

const int SCHAR_MAX = 127;

const int SHRT_MAX = 32767;

const int INT_MAX = 2147483647;

const int LONG_MAX = 9223372036854775807;

const int SCHAR_MIN = -128;

const int SHRT_MIN = -32768;

const int INT_MIN = -2147483648;

const int LONG_MIN = -9223372036854775808;

const int UCHAR_MAX = 255;

const int USHRT_MAX = 65535;

const int UINT_MAX = 4294967295;

const int ULONG_MAX = -1;

const int CHAR_BIT = 8;

const int CHAR_MIN = -128;

const int CHAR_MAX = 127;

const int _MATH_H = 1;

const int _BITS_LIBM_SIMD_DECL_STUBS_H = 1;

const int __HAVE_FLOAT128 = 0;

const int __HAVE_DISTINCT_FLOAT128 = 0;

const int __HAVE_FLOAT64X = 1;

const int __HAVE_FLOAT64X_LONG_DOUBLE = 1;

const int __HAVE_FLOAT16 = 0;

const int __HAVE_FLOAT32 = 1;

const int __HAVE_FLOAT64 = 1;

const int __HAVE_FLOAT32X = 1;

const int __HAVE_FLOAT128X = 0;

const int __HAVE_DISTINCT_FLOAT16 = 0;

const int __HAVE_DISTINCT_FLOAT32 = 0;

const int __HAVE_DISTINCT_FLOAT64 = 0;

const int __HAVE_DISTINCT_FLOAT32X = 0;

const int __HAVE_DISTINCT_FLOAT64X = 0;

const int __HAVE_DISTINCT_FLOAT128X = 0;

const int __HAVE_FLOAT128_UNLIKE_LDBL = 0;

const int __HAVE_FLOATN_NOT_TYPEDEF = 0;

const double HUGE_VAL = double.infinity;

const double HUGE_VALF = double.infinity;

const double HUGE_VALL = double.infinity;

const double INFINITY = double.infinity;

const double NAN = double.nan;

const int __GLIBC_FLT_EVAL_METHOD = 0;

const int __FP_LOGB0_IS_MIN = 1;

const int __FP_LOGBNAN_IS_MIN = 1;

const int FP_ILOGB0 = -2147483648;

const int FP_ILOGBNAN = -2147483648;

const int __MATH_DECLARE_LDOUBLE = 1;

const int FP_NAN_50 = 0;

const int FP_INFINITE_50 = 1;

const int FP_ZERO_50 = 2;

const int FP_SUBNORMAL_50 = 3;

const int FP_NORMAL_50 = 4;

const int MATH_ERRNO = 1;

const int MATH_ERREXCEPT = 2;

const int math_errhandling = 3;

const double M_E = 2.718281828459045;

const double M_LOG2E = 1.4426950408889634;

const double M_LOG10E = 0.4342944819032518;

const double M_LN2 = 0.6931471805599453;

const double M_LN10 = 2.302585092994046;

const double M_PI = 3.141592653589793;

const double M_PI_2 = 1.5707963267948966;

const double M_PI_4 = 0.7853981633974483;

const double M_1_PI = 0.3183098861837907;

const double M_2_PI = 0.6366197723675814;

const double M_2_SQRTPI = 1.1283791670955126;

const double M_SQRT2 = 1.4142135623730951;

const double M_SQRT1_2 = 0.7071067811865476;

const int _STDIO_H = 1;

const int __GNUC_VA_LIST = 1;

const int _____fpos_t_defined = 1;

const int ____mbstate_t_defined = 1;

const int _____fpos64_t_defined = 1;

const int ____FILE_defined = 1;

const int __FILE_defined = 1;

const int __struct_FILE_defined = 1;

const int _IO_EOF_SEEN = 16;

const int _IO_ERR_SEEN = 32;

const int _IO_USER_LOCK = 32768;

const int _IOFBF = 0;

const int _IOLBF = 1;

const int _IONBF = 2;

const int BUFSIZ = 8192;

const int EOF = -1;

const int SEEK_SET = 0;

const int SEEK_CUR = 1;

const int SEEK_END = 2;

const String P_tmpdir = '/tmp';

const int _BITS_STDIO_LIM_H = 1;

const int L_tmpnam = 20;

const int TMP_MAX = 238328;

const int FILENAME_MAX = 4096;

const int L_ctermid = 9;

const int FOPEN_MAX = 16;

const int _STDLIB_H = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WSTOPPED = 2;

const int WEXITED = 4;

const int WCONTINUED = 8;

const int WNOWAIT = 16777216;

const int __WNOTHREAD = 536870912;

const int __WALL = 1073741824;

const int __WCLONE = 2147483648;

const int __ENUM_IDTYPE_T = 1;

const int __W_CONTINUED = 65535;

const int __WCOREFLAG = 128;

const int __ldiv_t_defined = 1;

const int __lldiv_t_defined = 1;

const int RAND_MAX = 2147483647;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int _SYS_TYPES_H = 1;

const int __clock_t_defined = 1;

const int __clockid_t_defined = 1;

const int __time_t_defined = 1;

const int __timer_t_defined = 1;

const int __BIT_TYPES_DEFINED__ = 1;

const int _ENDIAN_H = 1;

const int _BITS_ENDIAN_H = 1;

const int __LITTLE_ENDIAN = 1234;

const int __BIG_ENDIAN = 4321;

const int __PDP_ENDIAN = 3412;

const int _BITS_ENDIANNESS_H = 1;

const int __BYTE_ORDER = 1234;

const int __FLOAT_WORD_ORDER = 1234;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int BYTE_ORDER = 1234;

const int _BITS_BYTESWAP_H = 1;

const int _BITS_UINTN_IDENTITY_H = 1;

const int _SYS_SELECT_H = 1;

const String __FD_ZERO_STOS = 'stosq';

const int __sigset_t_defined = 1;

const int _SIGSET_NWORDS = 16;

const int __timeval_defined = 1;

const int _STRUCT_TIMESPEC = 1;

const int __NFDBITS = 64;

const int FD_SETSIZE = 1024;

const int NFDBITS = 64;

const int _BITS_PTHREADTYPES_COMMON_H = 1;

const int _THREAD_SHARED_TYPES_H = 1;

const int _BITS_PTHREADTYPES_ARCH_H = 1;

const int __SIZEOF_PTHREAD_MUTEX_T = 40;

const int __SIZEOF_PTHREAD_ATTR_T = 56;

const int __SIZEOF_PTHREAD_RWLOCK_T = 56;

const int __SIZEOF_PTHREAD_BARRIER_T = 32;

const int __SIZEOF_PTHREAD_MUTEXATTR_T = 4;

const int __SIZEOF_PTHREAD_COND_T = 48;

const int __SIZEOF_PTHREAD_CONDATTR_T = 4;

const int __SIZEOF_PTHREAD_RWLOCKATTR_T = 8;

const int __SIZEOF_PTHREAD_BARRIERATTR_T = 4;

const int _THREAD_MUTEX_INTERNAL_H = 1;

const int __PTHREAD_MUTEX_HAVE_PREV = 1;

const int __PTHREAD_RWLOCK_ELISION_EXTRA = 0;

const int __have_pthread_attr_t = 1;

const int _ALLOCA_H = 1;

const int _STRING_H = 1;

const int _BITS_TYPES_LOCALE_T_H = 1;

const int _BITS_TYPES___LOCALE_T_H = 1;

const int _STRINGS_H = 1;

const int LIBAVUTIL_VERSION_MAJOR = 56;

const int LIBAVUTIL_VERSION_MINOR = 64;

const int LIBAVUTIL_VERSION_MICRO = 100;

const int LIBAVUTIL_VERSION_INT = 3686500;

const int LIBAVUTIL_BUILD = 3686500;

const String LIBAVUTIL_IDENT = 'Lavu56.64.100';

const int FF_API_VAAPI = 1;

const int FF_API_FRAME_QP = 1;

const int FF_API_PLUS1_MINUS1 = 1;

const int FF_API_ERROR_FRAME = 1;

const int FF_API_PKT_PTS = 1;

const int FF_API_CRYPTO_SIZE_T = 1;

const int FF_API_FRAME_GET_SET = 1;

const int FF_API_PSEUDOPAL = 1;

const int FF_API_CHILD_CLASS_NEXT = 1;

const int FF_API_D2STR = 1;

const int FF_API_DECLARE_ALIGNED = 1;

const int AV_HAVE_BIGENDIAN = 0;

const int AV_HAVE_FAST_UNALIGNED = 1;

const int AVERROR_BSF_NOT_FOUND = -1179861752;

const int AVERROR_BUG = -558323010;

const int AVERROR_BUFFER_TOO_SMALL = -1397118274;

const int AVERROR_DECODER_NOT_FOUND = -1128613112;

const int AVERROR_DEMUXER_NOT_FOUND = -1296385272;

const int AVERROR_ENCODER_NOT_FOUND = -1129203192;

const int AVERROR_EOF = -541478725;

const int AVERROR_EXIT = -1414092869;

const int AVERROR_EXTERNAL = -542398533;

const int AVERROR_FILTER_NOT_FOUND = -1279870712;

const int AVERROR_INVALIDDATA = -1094995529;

const int AVERROR_MUXER_NOT_FOUND = -1481985528;

const int AVERROR_OPTION_NOT_FOUND = -1414549496;

const int AVERROR_PATCHWELCOME = -1163346256;

const int AVERROR_PROTOCOL_NOT_FOUND = -1330794744;

const int AVERROR_STREAM_NOT_FOUND = -1381258232;

const int AVERROR_BUG2 = -541545794;

const int AVERROR_UNKNOWN = -1313558101;

const int AVERROR_EXPERIMENTAL = -733130664;

const int AVERROR_INPUT_CHANGED = -1668179713;

const int AVERROR_OUTPUT_CHANGED = -1668179714;

const int AVERROR_HTTP_BAD_REQUEST = -808465656;

const int AVERROR_HTTP_UNAUTHORIZED = -825242872;

const int AVERROR_HTTP_FORBIDDEN = -858797304;

const int AVERROR_HTTP_NOT_FOUND = -875574520;

const int AVERROR_HTTP_OTHER_4XX = -1482175736;

const int AVERROR_HTTP_SERVER_ERROR = -1482175992;

const int AV_ERROR_MAX_STRING_SIZE = 64;

const double M_LOG2_10 = 3.321928094887362;

const double M_PHI = 1.618033988749895;

const int AV_LOG_QUIET = -8;

const int AV_LOG_PANIC = 0;

const int AV_LOG_FATAL = 8;

const int AV_LOG_ERROR = 16;

const int AV_LOG_WARNING = 24;

const int AV_LOG_INFO = 32;

const int AV_LOG_VERBOSE = 40;

const int AV_LOG_DEBUG = 48;

const int AV_LOG_TRACE = 56;

const int AV_LOG_MAX_OFFSET = 64;

const int AV_LOG_SKIP_REPEATED = 1;

const int AV_LOG_PRINT_LEVEL = 2;

const int AVPALETTE_SIZE = 1024;

const int AVPALETTE_COUNT = 256;

const int AV_PIX_FMT_RGB32 = 28;

const int AV_PIX_FMT_RGB32_1 = 27;

const int AV_PIX_FMT_BGR32 = 26;

const int AV_PIX_FMT_BGR32_1 = 25;

const int AV_PIX_FMT_0RGB32 = 123;

const int AV_PIX_FMT_0BGR32 = 121;

const int AV_PIX_FMT_GRAY9 = 176;

const int AV_PIX_FMT_GRAY10 = 171;

const int AV_PIX_FMT_GRAY12 = 169;

const int AV_PIX_FMT_GRAY14 = 184;

const int AV_PIX_FMT_GRAY16 = 30;

const int AV_PIX_FMT_YA16 = 112;

const int AV_PIX_FMT_RGB48 = 35;

const int AV_PIX_FMT_RGB565 = 37;

const int AV_PIX_FMT_RGB555 = 39;

const int AV_PIX_FMT_RGB444 = 54;

const int AV_PIX_FMT_RGBA64 = 107;

const int AV_PIX_FMT_BGR48 = 60;

const int AV_PIX_FMT_BGR565 = 41;

const int AV_PIX_FMT_BGR555 = 43;

const int AV_PIX_FMT_BGR444 = 56;

const int AV_PIX_FMT_BGRA64 = 109;

const int AV_PIX_FMT_YUV420P9 = 62;

const int AV_PIX_FMT_YUV422P9 = 72;

const int AV_PIX_FMT_YUV444P9 = 68;

const int AV_PIX_FMT_YUV420P10 = 64;

const int AV_PIX_FMT_YUV422P10 = 66;

const int AV_PIX_FMT_YUV440P10 = 154;

const int AV_PIX_FMT_YUV444P10 = 70;

const int AV_PIX_FMT_YUV420P12 = 125;

const int AV_PIX_FMT_YUV422P12 = 129;

const int AV_PIX_FMT_YUV440P12 = 156;

const int AV_PIX_FMT_YUV444P12 = 133;

const int AV_PIX_FMT_YUV420P14 = 127;

const int AV_PIX_FMT_YUV422P14 = 131;

const int AV_PIX_FMT_YUV444P14 = 135;

const int AV_PIX_FMT_YUV420P16 = 47;

const int AV_PIX_FMT_YUV422P16 = 49;

const int AV_PIX_FMT_YUV444P16 = 51;

const int AV_PIX_FMT_GBRP9 = 75;

const int AV_PIX_FMT_GBRP10 = 77;

const int AV_PIX_FMT_GBRP12 = 137;

const int AV_PIX_FMT_GBRP14 = 139;

const int AV_PIX_FMT_GBRP16 = 79;

const int AV_PIX_FMT_GBRAP10 = 166;

const int AV_PIX_FMT_GBRAP12 = 164;

const int AV_PIX_FMT_GBRAP16 = 115;

const int AV_PIX_FMT_BAYER_BGGR16 = 145;

const int AV_PIX_FMT_BAYER_RGGB16 = 147;

const int AV_PIX_FMT_BAYER_GBRG16 = 149;

const int AV_PIX_FMT_BAYER_GRBG16 = 151;

const int AV_PIX_FMT_GBRPF32 = 178;

const int AV_PIX_FMT_GBRAPF32 = 180;

const int AV_PIX_FMT_GRAYF32 = 186;

const int AV_PIX_FMT_YUVA420P9 = 83;

const int AV_PIX_FMT_YUVA422P9 = 85;

const int AV_PIX_FMT_YUVA444P9 = 87;

const int AV_PIX_FMT_YUVA420P10 = 89;

const int AV_PIX_FMT_YUVA422P10 = 91;

const int AV_PIX_FMT_YUVA444P10 = 93;

const int AV_PIX_FMT_YUVA422P12 = 188;

const int AV_PIX_FMT_YUVA444P12 = 190;

const int AV_PIX_FMT_YUVA420P16 = 95;

const int AV_PIX_FMT_YUVA422P16 = 97;

const int AV_PIX_FMT_YUVA444P16 = 99;

const int AV_PIX_FMT_XYZ12 = 101;

const int AV_PIX_FMT_NV20 = 104;

const int AV_PIX_FMT_AYUV64 = 158;

const int AV_PIX_FMT_P010 = 161;

const int AV_PIX_FMT_P016 = 172;

const int AV_PIX_FMT_Y210 = 195;

const int AV_PIX_FMT_X2RGB10 = 196;

const int AV_FOURCC_MAX_STRING_SIZE = 32;

const int AV_BUFFER_FLAG_READONLY = 1;

const int AV_CPU_FLAG_FORCE = 2147483648;

const int AV_CPU_FLAG_MMX = 1;

const int AV_CPU_FLAG_MMXEXT = 2;

const int AV_CPU_FLAG_MMX2 = 2;

const int AV_CPU_FLAG_3DNOW = 4;

const int AV_CPU_FLAG_SSE = 8;

const int AV_CPU_FLAG_SSE2 = 16;

const int AV_CPU_FLAG_SSE2SLOW = 1073741824;

const int AV_CPU_FLAG_3DNOWEXT = 32;

const int AV_CPU_FLAG_SSE3 = 64;

const int AV_CPU_FLAG_SSE3SLOW = 536870912;

const int AV_CPU_FLAG_SSSE3 = 128;

const int AV_CPU_FLAG_SSSE3SLOW = 67108864;

const int AV_CPU_FLAG_ATOM = 268435456;

const int AV_CPU_FLAG_SSE4 = 256;

const int AV_CPU_FLAG_SSE42 = 512;

const int AV_CPU_FLAG_AESNI = 524288;

const int AV_CPU_FLAG_AVX = 16384;

const int AV_CPU_FLAG_AVXSLOW = 134217728;

const int AV_CPU_FLAG_XOP = 1024;

const int AV_CPU_FLAG_FMA4 = 2048;

const int AV_CPU_FLAG_CMOV = 4096;

const int AV_CPU_FLAG_AVX2 = 32768;

const int AV_CPU_FLAG_FMA3 = 65536;

const int AV_CPU_FLAG_BMI1 = 131072;

const int AV_CPU_FLAG_BMI2 = 262144;

const int AV_CPU_FLAG_AVX512 = 1048576;

const int AV_CPU_FLAG_ALTIVEC = 1;

const int AV_CPU_FLAG_VSX = 2;

const int AV_CPU_FLAG_POWER8 = 4;

const int AV_CPU_FLAG_ARMV5TE = 1;

const int AV_CPU_FLAG_ARMV6 = 2;

const int AV_CPU_FLAG_ARMV6T2 = 4;

const int AV_CPU_FLAG_VFP = 8;

const int AV_CPU_FLAG_VFPV3 = 16;

const int AV_CPU_FLAG_NEON = 32;

const int AV_CPU_FLAG_ARMV8 = 64;

const int AV_CPU_FLAG_VFP_VM = 128;

const int AV_CPU_FLAG_SETEND = 65536;

const int AV_CPU_FLAG_MMI = 1;

const int AV_CPU_FLAG_MSA = 2;

const int AV_CH_FRONT_LEFT = 1;

const int AV_CH_FRONT_RIGHT = 2;

const int AV_CH_FRONT_CENTER = 4;

const int AV_CH_LOW_FREQUENCY = 8;

const int AV_CH_BACK_LEFT = 16;

const int AV_CH_BACK_RIGHT = 32;

const int AV_CH_FRONT_LEFT_OF_CENTER = 64;

const int AV_CH_FRONT_RIGHT_OF_CENTER = 128;

const int AV_CH_BACK_CENTER = 256;

const int AV_CH_SIDE_LEFT = 512;

const int AV_CH_SIDE_RIGHT = 1024;

const int AV_CH_TOP_CENTER = 2048;

const int AV_CH_TOP_FRONT_LEFT = 4096;

const int AV_CH_TOP_FRONT_CENTER = 8192;

const int AV_CH_TOP_FRONT_RIGHT = 16384;

const int AV_CH_TOP_BACK_LEFT = 32768;

const int AV_CH_TOP_BACK_CENTER = 65536;

const int AV_CH_TOP_BACK_RIGHT = 131072;

const int AV_CH_STEREO_LEFT = 536870912;

const int AV_CH_STEREO_RIGHT = 1073741824;

const int AV_CH_WIDE_LEFT = 2147483648;

const int AV_CH_WIDE_RIGHT = 4294967296;

const int AV_CH_SURROUND_DIRECT_LEFT = 8589934592;

const int AV_CH_SURROUND_DIRECT_RIGHT = 17179869184;

const int AV_CH_LOW_FREQUENCY_2 = 34359738368;

const int AV_CH_TOP_SIDE_LEFT = 68719476736;

const int AV_CH_TOP_SIDE_RIGHT = 137438953472;

const int AV_CH_BOTTOM_FRONT_CENTER = 274877906944;

const int AV_CH_BOTTOM_FRONT_LEFT = 549755813888;

const int AV_CH_BOTTOM_FRONT_RIGHT = 1099511627776;

const int AV_CH_LAYOUT_NATIVE = -9223372036854775808;

const int AV_CH_LAYOUT_MONO = 4;

const int AV_CH_LAYOUT_STEREO = 3;

const int AV_CH_LAYOUT_2POINT1 = 11;

const int AV_CH_LAYOUT_2_1 = 259;

const int AV_CH_LAYOUT_SURROUND = 7;

const int AV_CH_LAYOUT_3POINT1 = 15;

const int AV_CH_LAYOUT_4POINT0 = 263;

const int AV_CH_LAYOUT_4POINT1 = 271;

const int AV_CH_LAYOUT_2_2 = 1539;

const int AV_CH_LAYOUT_QUAD = 51;

const int AV_CH_LAYOUT_5POINT0 = 1543;

const int AV_CH_LAYOUT_5POINT1 = 1551;

const int AV_CH_LAYOUT_5POINT0_BACK = 55;

const int AV_CH_LAYOUT_5POINT1_BACK = 63;

const int AV_CH_LAYOUT_6POINT0 = 1799;

const int AV_CH_LAYOUT_6POINT0_FRONT = 1731;

const int AV_CH_LAYOUT_HEXAGONAL = 311;

const int AV_CH_LAYOUT_6POINT1 = 1807;

const int AV_CH_LAYOUT_6POINT1_BACK = 319;

const int AV_CH_LAYOUT_6POINT1_FRONT = 1739;

const int AV_CH_LAYOUT_7POINT0 = 1591;

const int AV_CH_LAYOUT_7POINT0_FRONT = 1735;

const int AV_CH_LAYOUT_7POINT1 = 1599;

const int AV_CH_LAYOUT_7POINT1_WIDE = 1743;

const int AV_CH_LAYOUT_7POINT1_WIDE_BACK = 255;

const int AV_CH_LAYOUT_OCTAGONAL = 1847;

const int AV_CH_LAYOUT_HEXADECAGONAL = 6442710839;

const int AV_CH_LAYOUT_STEREO_DOWNMIX = 1610612736;

const int AV_CH_LAYOUT_22POINT2 = 2164663779327;

const int AV_DICT_MATCH_CASE = 1;

const int AV_DICT_IGNORE_SUFFIX = 2;

const int AV_DICT_DONT_STRDUP_KEY = 4;

const int AV_DICT_DONT_STRDUP_VAL = 8;

const int AV_DICT_DONT_OVERWRITE = 16;

const int AV_DICT_APPEND = 32;

const int AV_DICT_MULTIKEY = 64;

const int AV_NUM_DATA_POINTERS = 8;

const int AV_FRAME_FLAG_CORRUPT = 1;

const int AV_FRAME_FLAG_DISCARD = 4;

const int FF_DECODE_ERROR_INVALID_BITSTREAM = 1;

const int FF_DECODE_ERROR_MISSING_REFERENCE = 2;

const int FF_DECODE_ERROR_CONCEALMENT_ACTIVE = 4;

const int FF_DECODE_ERROR_DECODE_SLICES = 8;

const int AV_CODEC_ID_IFF_BYTERUN1 = 136;

const int AV_CODEC_ID_H265 = 173;

const int AV_CODEC_ID_H266 = 196;

const int LIBAVCODEC_VERSION_MAJOR = 58;

const int LIBAVCODEC_VERSION_MINOR = 119;

const int LIBAVCODEC_VERSION_MICRO = 100;

const int LIBAVCODEC_VERSION_INT = 3831652;

const int LIBAVCODEC_BUILD = 3831652;

const String LIBAVCODEC_IDENT = 'Lavc58.119.100';

const int FF_API_LOWRES = 1;

const int FF_API_AVCTX_TIMEBASE = 1;

const int FF_API_CODED_FRAME = 1;

const int FF_API_SIDEDATA_ONLY_PKT = 1;

const int FF_API_VDPAU_PROFILE = 1;

const int FF_API_CONVERGENCE_DURATION = 1;

const int FF_API_AVPICTURE = 1;

const int FF_API_AVPACKET_OLD_API = 1;

const int FF_API_RTP_CALLBACK = 1;

const int FF_API_VBV_DELAY = 1;

const int FF_API_CODER_TYPE = 1;

const int FF_API_STAT_BITS = 1;

const int FF_API_PRIVATE_OPT = 1;

const int FF_API_ASS_TIMING = 1;

const int FF_API_OLD_BSF = 1;

const int FF_API_COPY_CONTEXT = 1;

const int FF_API_GET_CONTEXT_DEFAULTS = 1;

const int FF_API_NVENC_OLD_NAME = 1;

const int FF_API_STRUCT_VAAPI_CONTEXT = 1;

const int FF_API_MERGE_SD_API = 1;

const int FF_API_TAG_STRING = 1;

const int FF_API_GETCHROMA = 1;

const int FF_API_CODEC_GET_SET = 1;

const int FF_API_USER_VISIBLE_AVHWACCEL = 1;

const int FF_API_LOCKMGR = 1;

const int FF_API_NEXT = 1;

const int FF_API_UNSANITIZED_BITRATES = 1;

const int FF_API_OPENH264_SLICE_MODE = 1;

const int FF_API_OPENH264_CABAC = 1;

const int FF_API_UNUSED_CODEC_CAPS = 1;

const int FF_API_AVPRIV_PUT_BITS = 1;

const int FF_API_OLD_ENCDEC = 1;

const int FF_API_THREAD_SAFE_CALLBACKS = 1;

const int FF_API_DEBUG_MV = 1;

const int AV_PKT_DATA_QUALITY_FACTOR = 8;

const int AV_PKT_FLAG_KEY = 1;

const int AV_PKT_FLAG_CORRUPT = 2;

const int AV_PKT_FLAG_DISCARD = 4;

const int AV_PKT_FLAG_TRUSTED = 8;

const int AV_PKT_FLAG_DISPOSABLE = 16;

const int AV_CODEC_CAP_DRAW_HORIZ_BAND = 1;

const int AV_CODEC_CAP_DR1 = 2;

const int AV_CODEC_CAP_TRUNCATED = 8;

const int AV_CODEC_CAP_DELAY = 32;

const int AV_CODEC_CAP_SMALL_LAST_FRAME = 64;

const int AV_CODEC_CAP_SUBFRAMES = 256;

const int AV_CODEC_CAP_EXPERIMENTAL = 512;

const int AV_CODEC_CAP_CHANNEL_CONF = 1024;

const int AV_CODEC_CAP_FRAME_THREADS = 4096;

const int AV_CODEC_CAP_SLICE_THREADS = 8192;

const int AV_CODEC_CAP_PARAM_CHANGE = 16384;

const int AV_CODEC_CAP_AUTO_THREADS = 32768;

const int AV_CODEC_CAP_VARIABLE_FRAME_SIZE = 65536;

const int AV_CODEC_CAP_AVOID_PROBING = 131072;

const int AV_CODEC_CAP_INTRA_ONLY = 1073741824;

const int AV_CODEC_CAP_LOSSLESS = 2147483648;

const int AV_CODEC_CAP_HARDWARE = 262144;

const int AV_CODEC_CAP_HYBRID = 524288;

const int AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE = 1048576;

const int AV_CODEC_CAP_ENCODER_FLUSH = 2097152;

const int AV_CODEC_PROP_INTRA_ONLY = 1;

const int AV_CODEC_PROP_LOSSY = 2;

const int AV_CODEC_PROP_LOSSLESS = 4;

const int AV_CODEC_PROP_REORDER = 8;

const int AV_CODEC_PROP_BITMAP_SUB = 65536;

const int AV_CODEC_PROP_TEXT_SUB = 131072;

const int AV_INPUT_BUFFER_PADDING_SIZE = 64;

const int AV_INPUT_BUFFER_MIN_SIZE = 16384;

const int AV_CODEC_FLAG_UNALIGNED = 1;

const int AV_CODEC_FLAG_QSCALE = 2;

const int AV_CODEC_FLAG_4MV = 4;

const int AV_CODEC_FLAG_OUTPUT_CORRUPT = 8;

const int AV_CODEC_FLAG_QPEL = 16;

const int AV_CODEC_FLAG_DROPCHANGED = 32;

const int AV_CODEC_FLAG_PASS1 = 512;

const int AV_CODEC_FLAG_PASS2 = 1024;

const int AV_CODEC_FLAG_LOOP_FILTER = 2048;

const int AV_CODEC_FLAG_GRAY = 8192;

const int AV_CODEC_FLAG_PSNR = 32768;

const int AV_CODEC_FLAG_TRUNCATED = 65536;

const int AV_CODEC_FLAG_INTERLACED_DCT = 262144;

const int AV_CODEC_FLAG_LOW_DELAY = 524288;

const int AV_CODEC_FLAG_GLOBAL_HEADER = 4194304;

const int AV_CODEC_FLAG_BITEXACT = 8388608;

const int AV_CODEC_FLAG_AC_PRED = 16777216;

const int AV_CODEC_FLAG_INTERLACED_ME = 536870912;

const int AV_CODEC_FLAG_CLOSED_GOP = 2147483648;

const int AV_CODEC_FLAG2_FAST = 1;

const int AV_CODEC_FLAG2_NO_OUTPUT = 4;

const int AV_CODEC_FLAG2_LOCAL_HEADER = 8;

const int AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = 8192;

const int AV_CODEC_FLAG2_CHUNKS = 32768;

const int AV_CODEC_FLAG2_IGNORE_CROP = 65536;

const int AV_CODEC_FLAG2_SHOW_ALL = 4194304;

const int AV_CODEC_FLAG2_EXPORT_MVS = 268435456;

const int AV_CODEC_FLAG2_SKIP_MANUAL = 536870912;

const int AV_CODEC_FLAG2_RO_FLUSH_NOOP = 1073741824;

const int AV_CODEC_EXPORT_DATA_MVS = 1;

const int AV_CODEC_EXPORT_DATA_PRFT = 2;

const int AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS = 4;

const int AV_CODEC_EXPORT_DATA_FILM_GRAIN = 8;

const int AV_GET_BUFFER_FLAG_REF = 1;

const int FF_COMPRESSION_DEFAULT = -1;

const int FF_PRED_LEFT = 0;

const int FF_PRED_PLANE = 1;

const int FF_PRED_MEDIAN = 2;

const int FF_CMP_SAD = 0;

const int FF_CMP_SSE = 1;

const int FF_CMP_SATD = 2;

const int FF_CMP_DCT = 3;

const int FF_CMP_PSNR = 4;

const int FF_CMP_BIT = 5;

const int FF_CMP_RD = 6;

const int FF_CMP_ZERO = 7;

const int FF_CMP_VSAD = 8;

const int FF_CMP_VSSE = 9;

const int FF_CMP_NSSE = 10;

const int FF_CMP_W53 = 11;

const int FF_CMP_W97 = 12;

const int FF_CMP_DCTMAX = 13;

const int FF_CMP_DCT264 = 14;

const int FF_CMP_MEDIAN_SAD = 15;

const int FF_CMP_CHROMA = 256;

const int SLICE_FLAG_CODED_ORDER = 1;

const int SLICE_FLAG_ALLOW_FIELD = 2;

const int SLICE_FLAG_ALLOW_PLANE = 4;

const int FF_MB_DECISION_SIMPLE = 0;

const int FF_MB_DECISION_BITS = 1;

const int FF_MB_DECISION_RD = 2;

const int FF_CODER_TYPE_VLC = 0;

const int FF_CODER_TYPE_AC = 1;

const int FF_CODER_TYPE_RAW = 2;

const int FF_CODER_TYPE_RLE = 3;

const int FF_BUG_AUTODETECT = 1;

const int FF_BUG_XVID_ILACE = 4;

const int FF_BUG_UMP4 = 8;

const int FF_BUG_NO_PADDING = 16;

const int FF_BUG_AMV = 32;

const int FF_BUG_QPEL_CHROMA = 64;

const int FF_BUG_STD_QPEL = 128;

const int FF_BUG_QPEL_CHROMA2 = 256;

const int FF_BUG_DIRECT_BLOCKSIZE = 512;

const int FF_BUG_EDGE = 1024;

const int FF_BUG_HPEL_CHROMA = 2048;

const int FF_BUG_DC_CLIP = 4096;

const int FF_BUG_MS = 8192;

const int FF_BUG_TRUNCATED = 16384;

const int FF_BUG_IEDGE = 32768;

const int FF_COMPLIANCE_VERY_STRICT = 2;

const int FF_COMPLIANCE_STRICT = 1;

const int FF_COMPLIANCE_NORMAL = 0;

const int FF_COMPLIANCE_UNOFFICIAL = -1;

const int FF_COMPLIANCE_EXPERIMENTAL = -2;

const int FF_EC_GUESS_MVS = 1;

const int FF_EC_DEBLOCK = 2;

const int FF_EC_FAVOR_INTER = 256;

const int FF_DEBUG_PICT_INFO = 1;

const int FF_DEBUG_RC = 2;

const int FF_DEBUG_BITSTREAM = 4;

const int FF_DEBUG_MB_TYPE = 8;

const int FF_DEBUG_QP = 16;

const int FF_DEBUG_DCT_COEFF = 64;

const int FF_DEBUG_SKIP = 128;

const int FF_DEBUG_STARTCODE = 256;

const int FF_DEBUG_ER = 1024;

const int FF_DEBUG_MMCO = 2048;

const int FF_DEBUG_BUGS = 4096;

const int FF_DEBUG_BUFFERS = 32768;

const int FF_DEBUG_THREADS = 65536;

const int FF_DEBUG_GREEN_MD = 8388608;

const int FF_DEBUG_NOMC = 16777216;

const int AV_EF_CRCCHECK = 1;

const int AV_EF_BITSTREAM = 2;

const int AV_EF_BUFFER = 4;

const int AV_EF_EXPLODE = 8;

const int AV_EF_IGNORE_ERR = 32768;

const int AV_EF_CAREFUL = 65536;

const int AV_EF_COMPLIANT = 131072;

const int AV_EF_AGGRESSIVE = 262144;

const int FF_DCT_AUTO = 0;

const int FF_DCT_FASTINT = 1;

const int FF_DCT_INT = 2;

const int FF_DCT_MMX = 3;

const int FF_DCT_ALTIVEC = 5;

const int FF_DCT_FAAN = 6;

const int FF_IDCT_AUTO = 0;

const int FF_IDCT_INT = 1;

const int FF_IDCT_SIMPLE = 2;

const int FF_IDCT_SIMPLEMMX = 3;

const int FF_IDCT_ARM = 7;

const int FF_IDCT_ALTIVEC = 8;

const int FF_IDCT_SIMPLEARM = 10;

const int FF_IDCT_XVID = 14;

const int FF_IDCT_SIMPLEARMV5TE = 16;

const int FF_IDCT_SIMPLEARMV6 = 17;

const int FF_IDCT_FAAN = 20;

const int FF_IDCT_SIMPLENEON = 22;

const int FF_IDCT_NONE = 24;

const int FF_IDCT_SIMPLEAUTO = 128;

const int FF_THREAD_FRAME = 1;

const int FF_THREAD_SLICE = 2;

const int FF_PROFILE_UNKNOWN = -99;

const int FF_PROFILE_RESERVED = -100;

const int FF_PROFILE_AAC_MAIN = 0;

const int FF_PROFILE_AAC_LOW = 1;

const int FF_PROFILE_AAC_SSR = 2;

const int FF_PROFILE_AAC_LTP = 3;

const int FF_PROFILE_AAC_HE = 4;

const int FF_PROFILE_AAC_HE_V2 = 28;

const int FF_PROFILE_AAC_LD = 22;

const int FF_PROFILE_AAC_ELD = 38;

const int FF_PROFILE_MPEG2_AAC_LOW = 128;

const int FF_PROFILE_MPEG2_AAC_HE = 131;

const int FF_PROFILE_DNXHD = 0;

const int FF_PROFILE_DNXHR_LB = 1;

const int FF_PROFILE_DNXHR_SQ = 2;

const int FF_PROFILE_DNXHR_HQ = 3;

const int FF_PROFILE_DNXHR_HQX = 4;

const int FF_PROFILE_DNXHR_444 = 5;

const int FF_PROFILE_DTS = 20;

const int FF_PROFILE_DTS_ES = 30;

const int FF_PROFILE_DTS_96_24 = 40;

const int FF_PROFILE_DTS_HD_HRA = 50;

const int FF_PROFILE_DTS_HD_MA = 60;

const int FF_PROFILE_DTS_EXPRESS = 70;

const int FF_PROFILE_MPEG2_422 = 0;

const int FF_PROFILE_MPEG2_HIGH = 1;

const int FF_PROFILE_MPEG2_SS = 2;

const int FF_PROFILE_MPEG2_SNR_SCALABLE = 3;

const int FF_PROFILE_MPEG2_MAIN = 4;

const int FF_PROFILE_MPEG2_SIMPLE = 5;

const int FF_PROFILE_H264_CONSTRAINED = 512;

const int FF_PROFILE_H264_INTRA = 2048;

const int FF_PROFILE_H264_BASELINE = 66;

const int FF_PROFILE_H264_CONSTRAINED_BASELINE = 578;

const int FF_PROFILE_H264_MAIN = 77;

const int FF_PROFILE_H264_EXTENDED = 88;

const int FF_PROFILE_H264_HIGH = 100;

const int FF_PROFILE_H264_HIGH_10 = 110;

const int FF_PROFILE_H264_HIGH_10_INTRA = 2158;

const int FF_PROFILE_H264_MULTIVIEW_HIGH = 118;

const int FF_PROFILE_H264_HIGH_422 = 122;

const int FF_PROFILE_H264_HIGH_422_INTRA = 2170;

const int FF_PROFILE_H264_STEREO_HIGH = 128;

const int FF_PROFILE_H264_HIGH_444 = 144;

const int FF_PROFILE_H264_HIGH_444_PREDICTIVE = 244;

const int FF_PROFILE_H264_HIGH_444_INTRA = 2292;

const int FF_PROFILE_H264_CAVLC_444 = 44;

const int FF_PROFILE_VC1_SIMPLE = 0;

const int FF_PROFILE_VC1_MAIN = 1;

const int FF_PROFILE_VC1_COMPLEX = 2;

const int FF_PROFILE_VC1_ADVANCED = 3;

const int FF_PROFILE_MPEG4_SIMPLE = 0;

const int FF_PROFILE_MPEG4_SIMPLE_SCALABLE = 1;

const int FF_PROFILE_MPEG4_CORE = 2;

const int FF_PROFILE_MPEG4_MAIN = 3;

const int FF_PROFILE_MPEG4_N_BIT = 4;

const int FF_PROFILE_MPEG4_SCALABLE_TEXTURE = 5;

const int FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6;

const int FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7;

const int FF_PROFILE_MPEG4_HYBRID = 8;

const int FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9;

const int FF_PROFILE_MPEG4_CORE_SCALABLE = 10;

const int FF_PROFILE_MPEG4_ADVANCED_CODING = 11;

const int FF_PROFILE_MPEG4_ADVANCED_CORE = 12;

const int FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13;

const int FF_PROFILE_MPEG4_SIMPLE_STUDIO = 14;

const int FF_PROFILE_MPEG4_ADVANCED_SIMPLE = 15;

const int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = 1;

const int FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = 2;

const int FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 32768;

const int FF_PROFILE_JPEG2000_DCINEMA_2K = 3;

const int FF_PROFILE_JPEG2000_DCINEMA_4K = 4;

const int FF_PROFILE_VP9_0 = 0;

const int FF_PROFILE_VP9_1 = 1;

const int FF_PROFILE_VP9_2 = 2;

const int FF_PROFILE_VP9_3 = 3;

const int FF_PROFILE_HEVC_MAIN = 1;

const int FF_PROFILE_HEVC_MAIN_10 = 2;

const int FF_PROFILE_HEVC_MAIN_STILL_PICTURE = 3;

const int FF_PROFILE_HEVC_REXT = 4;

const int FF_PROFILE_VVC_MAIN_10 = 1;

const int FF_PROFILE_VVC_MAIN_10_444 = 33;

const int FF_PROFILE_AV1_MAIN = 0;

const int FF_PROFILE_AV1_HIGH = 1;

const int FF_PROFILE_AV1_PROFESSIONAL = 2;

const int FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = 192;

const int FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 193;

const int FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = 194;

const int FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS = 195;

const int FF_PROFILE_MJPEG_JPEG_LS = 247;

const int FF_PROFILE_SBC_MSBC = 1;

const int FF_PROFILE_PRORES_PROXY = 0;

const int FF_PROFILE_PRORES_LT = 1;

const int FF_PROFILE_PRORES_STANDARD = 2;

const int FF_PROFILE_PRORES_HQ = 3;

const int FF_PROFILE_PRORES_4444 = 4;

const int FF_PROFILE_PRORES_XQ = 5;

const int FF_PROFILE_ARIB_PROFILE_A = 0;

const int FF_PROFILE_ARIB_PROFILE_C = 1;

const int FF_PROFILE_KLVA_SYNC = 0;

const int FF_PROFILE_KLVA_ASYNC = 1;

const int FF_LEVEL_UNKNOWN = -99;

const int FF_SUB_CHARENC_MODE_DO_NOTHING = -1;

const int FF_SUB_CHARENC_MODE_AUTOMATIC = 0;

const int FF_SUB_CHARENC_MODE_PRE_DECODER = 1;

const int FF_SUB_CHARENC_MODE_IGNORE = 2;

const int FF_DEBUG_VIS_MV_P_FOR = 1;

const int FF_DEBUG_VIS_MV_B_FOR = 2;

const int FF_DEBUG_VIS_MV_B_BACK = 4;

const int FF_CODEC_PROPERTY_LOSSLESS = 1;

const int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = 2;

const int FF_SUB_TEXT_FMT_ASS = 0;

const int FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS = 1;

const int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = 512;

const int AV_HWACCEL_FLAG_IGNORE_LEVEL = 1;

const int AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = 2;

const int AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = 4;

const int AV_SUBTITLE_FLAG_FORCED = 1;

const int AV_PARSER_PTS_NB = 4;

const int PARSER_FLAG_COMPLETE_FRAMES = 1;

const int PARSER_FLAG_ONCE = 2;

const int PARSER_FLAG_FETCHED_OFFSET = 4;

const int PARSER_FLAG_USE_CODEC_TS = 4096;

const int AV_OPT_FLAG_ENCODING_PARAM = 1;

const int AV_OPT_FLAG_DECODING_PARAM = 2;

const int AV_OPT_FLAG_AUDIO_PARAM = 8;

const int AV_OPT_FLAG_VIDEO_PARAM = 16;

const int AV_OPT_FLAG_SUBTITLE_PARAM = 32;

const int AV_OPT_FLAG_EXPORT = 64;

const int AV_OPT_FLAG_READONLY = 128;

const int AV_OPT_FLAG_BSF_PARAM = 256;

const int AV_OPT_FLAG_RUNTIME_PARAM = 32768;

const int AV_OPT_FLAG_FILTERING_PARAM = 65536;

const int AV_OPT_FLAG_DEPRECATED = 131072;

const int AV_OPT_FLAG_CHILD_CONSTS = 262144;

const int AV_OPT_SEARCH_CHILDREN = 1;

const int AV_OPT_SEARCH_FAKE_OBJ = 2;

const int AV_OPT_ALLOW_NULL = 4;

const int AV_OPT_MULTI_COMPONENT_RANGE = 4096;

const int AV_OPT_SERIALIZE_SKIP_DEFAULTS = 1;

const int AV_OPT_SERIALIZE_OPT_FLAGS_EXACT = 2;

const int _WIN32_WINNT = 1538;

const int FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG = 1;

const int FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO = 2;

const int MAX_DWT_LEVELS = 5;

const int DV_PROFILE_BYTES = 480;

const int VORBIS_FLAG_HEADER = 1;

const int VORBIS_FLAG_COMMENT = 2;

const int VORBIS_FLAG_SETUP = 4;

const int X_PROTOCOL = 11;

const int X_PROTOCOL_REVISION = 0;

const int None = 0;

const int ParentRelative = 1;

const int CopyFromParent = 0;

const int PointerWindow = 0;

const int InputFocus = 1;

const int PointerRoot = 1;

const int AnyPropertyType = 0;

const int AnyKey = 0;

const int AnyButton = 0;

const int AllTemporary = 0;

const int CurrentTime = 0;

const int NoSymbol = 0;

const int NoEventMask = 0;

const int KeyPressMask = 1;

const int KeyReleaseMask = 2;

const int ButtonPressMask = 4;

const int ButtonReleaseMask = 8;

const int EnterWindowMask = 16;

const int LeaveWindowMask = 32;

const int PointerMotionMask = 64;

const int PointerMotionHintMask = 128;

const int Button1MotionMask = 256;

const int Button2MotionMask = 512;

const int Button3MotionMask = 1024;

const int Button4MotionMask = 2048;

const int Button5MotionMask = 4096;

const int ButtonMotionMask = 8192;

const int KeymapStateMask = 16384;

const int ExposureMask = 32768;

const int VisibilityChangeMask = 65536;

const int StructureNotifyMask = 131072;

const int ResizeRedirectMask = 262144;

const int SubstructureNotifyMask = 524288;

const int SubstructureRedirectMask = 1048576;

const int FocusChangeMask = 2097152;

const int PropertyChangeMask = 4194304;

const int ColormapChangeMask = 8388608;

const int OwnerGrabButtonMask = 16777216;

const int KeyPress = 2;

const int KeyRelease = 3;

const int ButtonPress = 4;

const int ButtonRelease = 5;

const int MotionNotify = 6;

const int EnterNotify = 7;

const int LeaveNotify = 8;

const int FocusIn = 9;

const int FocusOut = 10;

const int KeymapNotify = 11;

const int Expose = 12;

const int GraphicsExpose = 13;

const int NoExpose = 14;

const int VisibilityNotify = 15;

const int CreateNotify = 16;

const int DestroyNotify = 17;

const int UnmapNotify = 18;

const int MapNotify = 19;

const int MapRequest = 20;

const int ReparentNotify = 21;

const int ConfigureNotify = 22;

const int ConfigureRequest = 23;

const int GravityNotify = 24;

const int ResizeRequest = 25;

const int CirculateNotify = 26;

const int CirculateRequest = 27;

const int PropertyNotify = 28;

const int SelectionClear = 29;

const int SelectionRequest = 30;

const int SelectionNotify = 31;

const int ColormapNotify = 32;

const int ClientMessage = 33;

const int MappingNotify = 34;

const int GenericEvent = 35;

const int LASTEvent = 36;

const int ShiftMask = 1;

const int LockMask = 2;

const int ControlMask = 4;

const int Mod1Mask = 8;

const int Mod2Mask = 16;

const int Mod3Mask = 32;

const int Mod4Mask = 64;

const int Mod5Mask = 128;

const int ShiftMapIndex = 0;

const int LockMapIndex = 1;

const int ControlMapIndex = 2;

const int Mod1MapIndex = 3;

const int Mod2MapIndex = 4;

const int Mod3MapIndex = 5;

const int Mod4MapIndex = 6;

const int Mod5MapIndex = 7;

const int Button1Mask = 256;

const int Button2Mask = 512;

const int Button3Mask = 1024;

const int Button4Mask = 2048;

const int Button5Mask = 4096;

const int AnyModifier = 32768;

const int Button1 = 1;

const int Button2 = 2;

const int Button3 = 3;

const int Button4 = 4;

const int Button5 = 5;

const int NotifyNormal = 0;

const int NotifyGrab = 1;

const int NotifyUngrab = 2;

const int NotifyWhileGrabbed = 3;

const int NotifyHint = 1;

const int NotifyAncestor = 0;

const int NotifyVirtual = 1;

const int NotifyInferior = 2;

const int NotifyNonlinear = 3;

const int NotifyNonlinearVirtual = 4;

const int NotifyPointer = 5;

const int NotifyPointerRoot = 6;

const int NotifyDetailNone = 7;

const int VisibilityUnobscured = 0;

const int VisibilityPartiallyObscured = 1;

const int VisibilityFullyObscured = 2;

const int PlaceOnTop = 0;

const int PlaceOnBottom = 1;

const int FamilyInternet = 0;

const int FamilyDECnet = 1;

const int FamilyChaos = 2;

const int FamilyInternet6 = 6;

const int FamilyServerInterpreted = 5;

const int PropertyNewValue = 0;

const int PropertyDelete = 1;

const int ColormapUninstalled = 0;

const int ColormapInstalled = 1;

const int GrabModeSync = 0;

const int GrabModeAsync = 1;

const int GrabSuccess = 0;

const int AlreadyGrabbed = 1;

const int GrabInvalidTime = 2;

const int GrabNotViewable = 3;

const int GrabFrozen = 4;

const int AsyncPointer = 0;

const int SyncPointer = 1;

const int ReplayPointer = 2;

const int AsyncKeyboard = 3;

const int SyncKeyboard = 4;

const int ReplayKeyboard = 5;

const int AsyncBoth = 6;

const int SyncBoth = 7;

const int RevertToNone = 0;

const int RevertToPointerRoot = 1;

const int RevertToParent = 2;

const int Success = 0;

const int BadRequest = 1;

const int BadValue = 2;

const int BadWindow = 3;

const int BadPixmap = 4;

const int BadAtom = 5;

const int BadCursor = 6;

const int BadFont = 7;

const int BadMatch = 8;

const int BadDrawable = 9;

const int BadAccess = 10;

const int BadAlloc = 11;

const int BadColor = 12;

const int BadGC = 13;

const int BadIDChoice = 14;

const int BadName = 15;

const int BadLength = 16;

const int BadImplementation = 17;

const int FirstExtensionError = 128;

const int LastExtensionError = 255;

const int InputOutput = 1;

const int InputOnly = 2;

const int CWBackPixmap = 1;

const int CWBackPixel = 2;

const int CWBorderPixmap = 4;

const int CWBorderPixel = 8;

const int CWBitGravity = 16;

const int CWWinGravity = 32;

const int CWBackingStore = 64;

const int CWBackingPlanes = 128;

const int CWBackingPixel = 256;

const int CWOverrideRedirect = 512;

const int CWSaveUnder = 1024;

const int CWEventMask = 2048;

const int CWDontPropagate = 4096;

const int CWColormap = 8192;

const int CWCursor = 16384;

const int CWX = 1;

const int CWY = 2;

const int CWWidth = 4;

const int CWHeight = 8;

const int CWBorderWidth = 16;

const int CWSibling = 32;

const int CWStackMode = 64;

const int ForgetGravity = 0;

const int NorthWestGravity = 1;

const int NorthGravity = 2;

const int NorthEastGravity = 3;

const int WestGravity = 4;

const int CenterGravity = 5;

const int EastGravity = 6;

const int SouthWestGravity = 7;

const int SouthGravity = 8;

const int SouthEastGravity = 9;

const int StaticGravity = 10;

const int UnmapGravity = 0;

const int NotUseful = 0;

const int WhenMapped = 1;

const int Always = 2;

const int IsUnmapped = 0;

const int IsUnviewable = 1;

const int IsViewable = 2;

const int SetModeInsert = 0;

const int SetModeDelete = 1;

const int DestroyAll = 0;

const int RetainPermanent = 1;

const int RetainTemporary = 2;

const int Above = 0;

const int Below = 1;

const int TopIf = 2;

const int BottomIf = 3;

const int Opposite = 4;

const int RaiseLowest = 0;

const int LowerHighest = 1;

const int PropModeReplace = 0;

const int PropModePrepend = 1;

const int PropModeAppend = 2;

const int GXclear = 0;

const int GXand = 1;

const int GXandReverse = 2;

const int GXcopy = 3;

const int GXandInverted = 4;

const int GXnoop = 5;

const int GXxor = 6;

const int GXor = 7;

const int GXnor = 8;

const int GXequiv = 9;

const int GXinvert = 10;

const int GXorReverse = 11;

const int GXcopyInverted = 12;

const int GXorInverted = 13;

const int GXnand = 14;

const int GXset = 15;

const int LineSolid = 0;

const int LineOnOffDash = 1;

const int LineDoubleDash = 2;

const int CapNotLast = 0;

const int CapButt = 1;

const int CapRound = 2;

const int CapProjecting = 3;

const int JoinMiter = 0;

const int JoinRound = 1;

const int JoinBevel = 2;

const int FillSolid = 0;

const int FillTiled = 1;

const int FillStippled = 2;

const int FillOpaqueStippled = 3;

const int EvenOddRule = 0;

const int WindingRule = 1;

const int ClipByChildren = 0;

const int IncludeInferiors = 1;

const int Unsorted = 0;

const int YSorted = 1;

const int YXSorted = 2;

const int YXBanded = 3;

const int CoordModeOrigin = 0;

const int CoordModePrevious = 1;

const int Complex = 0;

const int Nonconvex = 1;

const int Convex = 2;

const int ArcChord = 0;

const int ArcPieSlice = 1;

const int GCFunction = 1;

const int GCPlaneMask = 2;

const int GCForeground = 4;

const int GCBackground = 8;

const int GCLineWidth = 16;

const int GCLineStyle = 32;

const int GCCapStyle = 64;

const int GCJoinStyle = 128;

const int GCFillStyle = 256;

const int GCFillRule = 512;

const int GCTile = 1024;

const int GCStipple = 2048;

const int GCTileStipXOrigin = 4096;

const int GCTileStipYOrigin = 8192;

const int GCFont = 16384;

const int GCSubwindowMode = 32768;

const int GCGraphicsExposures = 65536;

const int GCClipXOrigin = 131072;

const int GCClipYOrigin = 262144;

const int GCClipMask = 524288;

const int GCDashOffset = 1048576;

const int GCDashList = 2097152;

const int GCArcMode = 4194304;

const int GCLastBit = 22;

const int FontLeftToRight = 0;

const int FontRightToLeft = 1;

const int FontChange = 255;

const int XYBitmap = 0;

const int XYPixmap = 1;

const int ZPixmap = 2;

const int AllocNone = 0;

const int AllocAll = 1;

const int DoRed = 1;

const int DoGreen = 2;

const int DoBlue = 4;

const int CursorShape = 0;

const int TileShape = 1;

const int StippleShape = 2;

const int AutoRepeatModeOff = 0;

const int AutoRepeatModeOn = 1;

const int AutoRepeatModeDefault = 2;

const int LedModeOff = 0;

const int LedModeOn = 1;

const int KBKeyClickPercent = 1;

const int KBBellPercent = 2;

const int KBBellPitch = 4;

const int KBBellDuration = 8;

const int KBLed = 16;

const int KBLedMode = 32;

const int KBKey = 64;

const int KBAutoRepeatMode = 128;

const int MappingSuccess = 0;

const int MappingBusy = 1;

const int MappingFailed = 2;

const int MappingModifier = 0;

const int MappingKeyboard = 1;

const int MappingPointer = 2;

const int DontPreferBlanking = 0;

const int PreferBlanking = 1;

const int DefaultBlanking = 2;

const int DisableScreenSaver = 0;

const int DisableScreenInterval = 0;

const int DontAllowExposures = 0;

const int AllowExposures = 1;

const int DefaultExposures = 2;

const int ScreenSaverReset = 0;

const int ScreenSaverActive = 1;

const int HostInsert = 0;

const int HostDelete = 1;

const int EnableAccess = 1;

const int DisableAccess = 0;

const int StaticGray = 0;

const int GrayScale = 1;

const int StaticColor = 2;

const int PseudoColor = 3;

const int TrueColor = 4;

const int DirectColor = 5;

const int LSBFirst = 0;

const int MSBFirst = 1;

const String XvName = 'XVideo';

const int XvVersion = 2;

const int XvRevision = 2;

const int XvNone = 0;

const int XvInput = 0;

const int XvOutput = 1;

const int XvInputMask = 1;

const int XvOutputMask = 2;

const int XvVideoMask = 4;

const int XvStillMask = 8;

const int XvImageMask = 16;

const int XvPixmapMask = 65536;

const int XvWindowMask = 131072;

const int XvGettable = 1;

const int XvSettable = 2;

const int XvRGB = 0;

const int XvYUV = 1;

const int XvPacked = 0;

const int XvPlanar = 1;

const int XvTopToBottom = 0;

const int XvBottomToTop = 1;

const int XvVideoNotify = 0;

const int XvPortNotify = 1;

const int XvNumEvents = 2;

const int XvStarted = 0;

const int XvStopped = 1;

const int XvBusy = 2;

const int XvPreempted = 3;

const int XvHardError = 4;

const int XvLastReason = 4;

const int XvNumReasons = 5;

const int XvStartedMask = 1;

const int XvStoppedMask = 2;

const int XvBusyMask = 4;

const int XvPreemptedMask = 8;

const int XvHardErrorMask = 16;

const int XvAnyReasonMask = 31;

const int XvNoReasonMask = 0;

const int XvBadPort = 0;

const int XvBadEncoding = 1;

const int XvBadControl = 2;

const int XvNumErrors = 3;

const int XvBadExtension = 1;

const int XvAlreadyGrabbed = 2;

const int XvInvalidTime = 3;

const int XvBadReply = 4;

const int XvBadAlloc = 5;

const String XvMCName = 'XVideo-MotionCompensation';

const int XvMCNumEvents = 0;

const int XvMCNumErrors = 3;

const int XvMCVersion = 1;

const int XvMCRevision = 1;

const int XvMCBadContext = 0;

const int XvMCBadSurface = 1;

const int XvMCBadSubpicture = 2;

const int XVMC_CHROMA_FORMAT_420 = 1;

const int XVMC_CHROMA_FORMAT_422 = 2;

const int XVMC_CHROMA_FORMAT_444 = 3;

const int XVMC_OVERLAID_SURFACE = 1;

const int XVMC_BACKEND_SUBPICTURE = 2;

const int XVMC_SUBPICTURE_INDEPENDENT_SCALING = 4;

const int XVMC_INTRA_UNSIGNED = 8;

const int XVMC_MOCOMP = 0;

const int XVMC_IDCT = 65536;

const int XVMC_MPEG_1 = 1;

const int XVMC_MPEG_2 = 2;

const int XVMC_H263 = 3;

const int XVMC_MPEG_4 = 4;

const int XVMC_MB_TYPE_MOTION_FORWARD = 2;

const int XVMC_MB_TYPE_MOTION_BACKWARD = 4;

const int XVMC_MB_TYPE_PATTERN = 8;

const int XVMC_MB_TYPE_INTRA = 16;

const int XVMC_PREDICTION_FIELD = 1;

const int XVMC_PREDICTION_FRAME = 2;

const int XVMC_PREDICTION_DUAL_PRIME = 3;

const int XVMC_PREDICTION_16x8 = 2;

const int XVMC_PREDICTION_4MV = 4;

const int XVMC_SELECT_FIRST_FORWARD = 1;

const int XVMC_SELECT_FIRST_BACKWARD = 2;

const int XVMC_SELECT_SECOND_FORWARD = 4;

const int XVMC_SELECT_SECOND_BACKWARD = 8;

const int XVMC_DCT_TYPE_FRAME = 0;

const int XVMC_DCT_TYPE_FIELD = 1;

const int XVMC_TOP_FIELD = 1;

const int XVMC_BOTTOM_FIELD = 2;

const int XVMC_FRAME_PICTURE = 3;

const int XVMC_SECOND_FIELD = 4;

const int XVMC_DIRECT = 1;

const int XVMC_RENDERING = 1;

const int XVMC_DISPLAYING = 2;

const int AV_XVMC_ID = 499585472;

const int LIBAVDEVICE_VERSION_MAJOR = 58;

const int LIBAVDEVICE_VERSION_MINOR = 11;

const int LIBAVDEVICE_VERSION_MICRO = 103;

const int LIBAVDEVICE_VERSION_INT = 3804007;

const int LIBAVDEVICE_BUILD = 3804007;

const String LIBAVDEVICE_IDENT = 'Lavd58.11.103';

const int _TIME_H = 1;

const int _BITS_TIME_H = 1;

const int CLOCKS_PER_SEC = 1000000;

const int CLOCK_REALTIME = 0;

const int CLOCK_MONOTONIC = 1;

const int CLOCK_PROCESS_CPUTIME_ID = 2;

const int CLOCK_THREAD_CPUTIME_ID = 3;

const int CLOCK_MONOTONIC_RAW = 4;

const int CLOCK_REALTIME_COARSE = 5;

const int CLOCK_MONOTONIC_COARSE = 6;

const int CLOCK_BOOTTIME = 7;

const int CLOCK_REALTIME_ALARM = 8;

const int CLOCK_BOOTTIME_ALARM = 9;

const int CLOCK_TAI = 11;

const int TIMER_ABSTIME = 1;

const int __struct_tm_defined = 1;

const int __itimerspec_defined = 1;

const int TIME_UTC = 1;

const int LIBAVFORMAT_VERSION_MAJOR = 58;

const int LIBAVFORMAT_VERSION_MINOR = 65;

const int LIBAVFORMAT_VERSION_MICRO = 101;

const int LIBAVFORMAT_VERSION_INT = 3817829;

const int LIBAVFORMAT_BUILD = 3817829;

const String LIBAVFORMAT_IDENT = 'Lavf58.65.101';

const int FF_API_COMPUTE_PKT_FIELDS2 = 1;

const int FF_API_OLD_OPEN_CALLBACKS = 1;

const int FF_API_LAVF_AVCTX = 1;

const int FF_API_HTTP_USER_AGENT = 1;

const int FF_API_HLS_WRAP = 1;

const int FF_API_HLS_USE_LOCALTIME = 1;

const int FF_API_LAVF_KEEPSIDE_FLAG = 1;

const int FF_API_OLD_ROTATE_API = 1;

const int FF_API_FORMAT_GET_SET = 1;

const int FF_API_OLD_AVIO_EOF_0 = 1;

const int FF_API_LAVF_FFSERVER = 1;

const int FF_API_FORMAT_FILENAME = 1;

const int FF_API_OLD_RTSP_OPTIONS = 1;

const int FF_API_DASH_MIN_SEG_DURATION = 1;

const int FF_API_LAVF_MP4A_LATM = 1;

const int FF_API_AVIOFORMAT = 1;

const int FF_API_R_FRAME_RATE = 1;

const int AVIO_SEEKABLE_NORMAL = 1;

const int AVIO_SEEKABLE_TIME = 2;

const int AVSEEK_SIZE = 65536;

const int AVSEEK_FORCE = 131072;

const int AVIO_FLAG_READ = 1;

const int AVIO_FLAG_WRITE = 2;

const int AVIO_FLAG_READ_WRITE = 3;

const int AVIO_FLAG_NONBLOCK = 8;

const int AVIO_FLAG_DIRECT = 32768;

const int AVPROBE_SCORE_RETRY = 25;

const int AVPROBE_SCORE_STREAM_RETRY = 24;

const int AVPROBE_SCORE_EXTENSION = 50;

const int AVPROBE_SCORE_MIME = 75;

const int AVPROBE_SCORE_MAX = 100;

const int AVPROBE_PADDING_SIZE = 32;

const int AVFMT_NOFILE = 1;

const int AVFMT_NEEDNUMBER = 2;

const int AVFMT_SHOW_IDS = 8;

const int AVFMT_GLOBALHEADER = 64;

const int AVFMT_NOTIMESTAMPS = 128;

const int AVFMT_GENERIC_INDEX = 256;

const int AVFMT_TS_DISCONT = 512;

const int AVFMT_VARIABLE_FPS = 1024;

const int AVFMT_NODIMENSIONS = 2048;

const int AVFMT_NOSTREAMS = 4096;

const int AVFMT_NOBINSEARCH = 8192;

const int AVFMT_NOGENSEARCH = 16384;

const int AVFMT_NO_BYTE_SEEK = 32768;

const int AVFMT_ALLOW_FLUSH = 65536;

const int AVFMT_TS_NONSTRICT = 131072;

const int AVFMT_TS_NEGATIVE = 262144;

const int AVFMT_SEEK_TO_PTS = 67108864;

const int AVINDEX_KEYFRAME = 1;

const int AVINDEX_DISCARD_FRAME = 2;

const int AV_DISPOSITION_DEFAULT = 1;

const int AV_DISPOSITION_DUB = 2;

const int AV_DISPOSITION_ORIGINAL = 4;

const int AV_DISPOSITION_COMMENT = 8;

const int AV_DISPOSITION_LYRICS = 16;

const int AV_DISPOSITION_KARAOKE = 32;

const int AV_DISPOSITION_FORCED = 64;

const int AV_DISPOSITION_HEARING_IMPAIRED = 128;

const int AV_DISPOSITION_VISUAL_IMPAIRED = 256;

const int AV_DISPOSITION_CLEAN_EFFECTS = 512;

const int AV_DISPOSITION_ATTACHED_PIC = 1024;

const int AV_DISPOSITION_TIMED_THUMBNAILS = 2048;

const int AV_DISPOSITION_CAPTIONS = 65536;

const int AV_DISPOSITION_DESCRIPTIONS = 131072;

const int AV_DISPOSITION_METADATA = 262144;

const int AV_DISPOSITION_DEPENDENT = 524288;

const int AV_DISPOSITION_STILL_IMAGE = 1048576;

const int AV_PTS_WRAP_IGNORE = 0;

const int AV_PTS_WRAP_ADD_OFFSET = 1;

const int AV_PTS_WRAP_SUB_OFFSET = -1;

const int AVSTREAM_EVENT_FLAG_METADATA_UPDATED = 1;

const int AVSTREAM_EVENT_FLAG_NEW_PACKETS = 2;

const int AV_PROGRAM_RUNNING = 1;

const int AVFMTCTX_NOHEADER = 1;

const int AVFMTCTX_UNSEEKABLE = 2;

const int AVFMT_FLAG_GENPTS = 1;

const int AVFMT_FLAG_IGNIDX = 2;

const int AVFMT_FLAG_NONBLOCK = 4;

const int AVFMT_FLAG_IGNDTS = 8;

const int AVFMT_FLAG_NOFILLIN = 16;

const int AVFMT_FLAG_NOPARSE = 32;

const int AVFMT_FLAG_NOBUFFER = 64;

const int AVFMT_FLAG_CUSTOM_IO = 128;

const int AVFMT_FLAG_DISCARD_CORRUPT = 256;

const int AVFMT_FLAG_FLUSH_PACKETS = 512;

const int AVFMT_FLAG_BITEXACT = 1024;

const int AVFMT_FLAG_MP4A_LATM = 32768;

const int AVFMT_FLAG_SORT_DTS = 65536;

const int AVFMT_FLAG_PRIV_OPT = 131072;

const int AVFMT_FLAG_KEEP_SIDE_DATA = 262144;

const int AVFMT_FLAG_FAST_SEEK = 524288;

const int AVFMT_FLAG_SHORTEST = 1048576;

const int AVFMT_FLAG_AUTO_BSF = 2097152;

const int FF_FDEBUG_TS = 1;

const int AVFMT_EVENT_FLAG_METADATA_UPDATED = 1;

const int AVFMT_AVOID_NEG_TS_AUTO = -1;

const int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = 1;

const int AVFMT_AVOID_NEG_TS_MAKE_ZERO = 2;

const int AVSEEK_FLAG_BACKWARD = 1;

const int AVSEEK_FLAG_BYTE = 2;

const int AVSEEK_FLAG_ANY = 4;

const int AVSEEK_FLAG_FRAME = 8;

const int AVSTREAM_INIT_IN_WRITE_HEADER = 0;

const int AVSTREAM_INIT_IN_INIT_OUTPUT = 1;

const int AV_FRAME_FILENAME_FLAGS_MULTIPLE = 1;

const int LIBAVFILTER_VERSION_MAJOR = 7;

const int LIBAVFILTER_VERSION_MINOR = 100;

const int LIBAVFILTER_VERSION_MICRO = 100;

const int LIBAVFILTER_VERSION_INT = 484452;

const int LIBAVFILTER_BUILD = 484452;

const String LIBAVFILTER_IDENT = 'Lavfi7.100.100';

const int FF_API_OLD_FILTER_OPTS_ERROR = 1;

const int FF_API_LAVR_OPTS = 1;

const int FF_API_FILTER_GET_SET = 1;

const int FF_API_SWS_PARAM_OPTION = 1;

const int AVFILTER_FLAG_DYNAMIC_INPUTS = 1;

const int AVFILTER_FLAG_DYNAMIC_OUTPUTS = 2;

const int AVFILTER_FLAG_SLICE_THREADS = 4;

const int AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = 65536;

const int AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = 131072;

const int AVFILTER_FLAG_SUPPORT_TIMELINE = 196608;

const int AVFILTER_THREAD_SLICE = 1;

const int AVFILTER_CMD_FLAG_ONE = 1;

const int AVFILTER_CMD_FLAG_FAST = 2;

const int AV_BUFFERSINK_FLAG_PEEK = 1;

const int AV_BUFFERSINK_FLAG_NO_REQUEST = 2;

const int AES_CTR_KEY_SIZE = 16;

const int AES_CTR_IV_SIZE = 8;

const int AV_ESCAPE_FLAG_WHITESPACE = 1;

const int AV_ESCAPE_FLAG_STRICT = 2;

const int AV_UTF8_FLAG_ACCEPT_INVALID_BIG_CODES = 1;

const int AV_UTF8_FLAG_ACCEPT_NON_CHARACTERS = 2;

const int AV_UTF8_FLAG_ACCEPT_SURROGATES = 4;

const int AV_UTF8_FLAG_EXCLUDE_XML_INVALID_CONTROL_CODES = 8;

const int AV_UTF8_FLAG_ACCEPT_ALL = 7;

const int AV_BF_ROUNDS = 16;

const int AV_BPRINT_SIZE_UNLIMITED = 4294967295;

const int AV_BPRINT_SIZE_AUTOMATIC = 1;

const int AV_BPRINT_SIZE_COUNT_ONLY = 0;

const String FFMPEG_VERSION = 'N-100872-gd8b2fae3c7';

const int AV_HASH_MAX_SIZE = 64;

const int AV_CUDA_USE_PRIMARY_CONTEXT = 1;

const int AV_PIX_FMT_FLAG_BE = 1;

const int AV_PIX_FMT_FLAG_PAL = 2;

const int AV_PIX_FMT_FLAG_BITSTREAM = 4;

const int AV_PIX_FMT_FLAG_HWACCEL = 8;

const int AV_PIX_FMT_FLAG_PLANAR = 16;

const int AV_PIX_FMT_FLAG_RGB = 32;

const int AV_PIX_FMT_FLAG_PSEUDOPAL = 64;

const int AV_PIX_FMT_FLAG_ALPHA = 128;

const int AV_PIX_FMT_FLAG_BAYER = 256;

const int AV_PIX_FMT_FLAG_FLOAT = 512;

const int FF_LOSS_RESOLUTION = 1;

const int FF_LOSS_DEPTH = 2;

const int FF_LOSS_COLORSPACE = 4;

const int FF_LOSS_ALPHA = 8;

const int FF_LOSS_COLORQUANT = 16;

const int FF_LOSS_CHROMA = 32;

const int AV_LZO_INPUT_DEPLETED = 1;

const int AV_LZO_OUTPUT_FULL = 2;

const int AV_LZO_INVALID_BACKPTR = 4;

const int AV_LZO_ERROR = 8;

const int AV_LZO_INPUT_PADDING = 8;

const int AV_LZO_OUTPUT_PADDING = 12;

const int AV_STEREO3D_FLAG_INVERT = 1;

const int AV_TIMECODE_STR_SIZE = 23;

const int AV_TS_MAX_STRING_SIZE = 32;

const int LIBPOSTPROC_VERSION_MAJOR = 55;

const int LIBPOSTPROC_VERSION_MINOR = 8;

const int LIBPOSTPROC_VERSION_MICRO = 100;

const int LIBPOSTPROC_VERSION_INT = 3606628;

const int LIBPOSTPROC_BUILD = 3606628;

const String LIBPOSTPROC_IDENT = 'postproc55.8.100';

const int PP_QUALITY_MAX = 6;

const int PP_CPU_CAPS_MMX = 2147483648;

const int PP_CPU_CAPS_MMX2 = 536870912;

const int PP_CPU_CAPS_3DNOW = 1073741824;

const int PP_CPU_CAPS_ALTIVEC = 268435456;

const int PP_CPU_CAPS_AUTO = 524288;

const int PP_FORMAT = 8;

const int PP_FORMAT_420 = 25;

const int PP_FORMAT_422 = 9;

const int PP_FORMAT_411 = 10;

const int PP_FORMAT_444 = 8;

const int PP_FORMAT_440 = 24;

const int PP_PICT_TYPE_QP2 = 16;

const int LIBSWRESAMPLE_VERSION_MAJOR = 3;

const int LIBSWRESAMPLE_VERSION_MINOR = 8;

const int LIBSWRESAMPLE_VERSION_MICRO = 100;

const int LIBSWRESAMPLE_VERSION_INT = 198756;

const int LIBSWRESAMPLE_BUILD = 198756;

const String LIBSWRESAMPLE_IDENT = 'SwR3.8.100';

const int SWR_FLAG_RESAMPLE = 1;

const int LIBSWSCALE_VERSION_MAJOR = 5;

const int LIBSWSCALE_VERSION_MINOR = 8;

const int LIBSWSCALE_VERSION_MICRO = 100;

const int LIBSWSCALE_VERSION_INT = 329828;

const int LIBSWSCALE_BUILD = 329828;

const String LIBSWSCALE_IDENT = 'SwS5.8.100';

const int FF_API_SWS_VECTOR = 1;

const int SWS_FAST_BILINEAR = 1;

const int SWS_BILINEAR = 2;

const int SWS_BICUBIC = 4;

const int SWS_X = 8;

const int SWS_POINT = 16;

const int SWS_AREA = 32;

const int SWS_BICUBLIN = 64;

const int SWS_GAUSS = 128;

const int SWS_SINC = 256;

const int SWS_LANCZOS = 512;

const int SWS_SPLINE = 1024;

const int SWS_SRC_V_CHR_DROP_MASK = 196608;

const int SWS_SRC_V_CHR_DROP_SHIFT = 16;

const int SWS_PARAM_DEFAULT = 123456;

const int SWS_PRINT_INFO = 4096;

const int SWS_FULL_CHR_H_INT = 8192;

const int SWS_FULL_CHR_H_INP = 16384;

const int SWS_DIRECT_BGR = 32768;

const int SWS_ACCURATE_RND = 262144;

const int SWS_BITEXACT = 524288;

const int SWS_ERROR_DIFFUSION = 8388608;

const double SWS_MAX_REDUCE_CUTOFF = 0.002;

const int SWS_CS_ITU709 = 1;

const int SWS_CS_FCC = 4;

const int SWS_CS_ITU601 = 5;

const int SWS_CS_ITU624 = 5;

const int SWS_CS_SMPTE170M = 5;

const int SWS_CS_SMPTE240M = 7;

const int SWS_CS_DEFAULT = 5;

const int SWS_CS_BT2020 = 9;

typedef _c_av_ac3_parse_header = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Uint64 size,
  ffi.Pointer<ffi.Uint8> bitstream_id,
  ffi.Pointer<ffi.Uint16> frame_size,
);

typedef _dart_av_ac3_parse_header = int Function(
  ffi.Pointer<ffi.Uint8> buf,
  int size,
  ffi.Pointer<ffi.Uint8> bitstream_id,
  ffi.Pointer<ffi.Uint16> frame_size,
);

typedef _c_av_adts_header_parse = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Pointer<ffi.Uint32> samples,
  ffi.Pointer<ffi.Uint8> frames,
);

typedef _dart_av_adts_header_parse = int Function(
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Pointer<ffi.Uint32> samples,
  ffi.Pointer<ffi.Uint8> frames,
);

typedef _c_avutil_version = ffi.Uint32 Function();

typedef _dart_avutil_version = int Function();

typedef _c_av_version_info = ffi.Pointer<ffi.Int8> Function();

typedef _dart_av_version_info = ffi.Pointer<ffi.Int8> Function();

typedef _c_avutil_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avutil_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _c_avutil_license = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avutil_license = ffi.Pointer<ffi.Int8> Function();

typedef _c_av_get_media_type_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 media_type,
);

typedef _dart_av_get_media_type_string = ffi.Pointer<ffi.Int8> Function(
  int media_type,
);

typedef _c_av_get_picture_type_char = ffi.Int8 Function(
  ffi.Int32 pict_type,
);

typedef _dart_av_get_picture_type_char = int Function(
  int pict_type,
);

typedef _c_av_log2 = ffi.Int32 Function(
  ffi.Uint32 v,
);

typedef _dart_av_log2 = int Function(
  int v,
);

typedef _c_av_log2_16bit = ffi.Int32 Function(
  ffi.Uint32 v,
);

typedef _dart_av_log2_16bit = int Function(
  int v,
);

typedef _c_av_clip_c = ffi.Int32 Function(
  ffi.Int32 a,
  ffi.Int32 amin,
  ffi.Int32 amax,
);

typedef _dart_av_clip_c = int Function(
  int a,
  int amin,
  int amax,
);

typedef _c_av_clip64_c = ffi.Int64 Function(
  ffi.Int64 a,
  ffi.Int64 amin,
  ffi.Int64 amax,
);

typedef _dart_av_clip64_c = int Function(
  int a,
  int amin,
  int amax,
);

typedef _c_av_clip_uint8_c = ffi.Uint8 Function(
  ffi.Int32 a,
);

typedef _dart_av_clip_uint8_c = int Function(
  int a,
);

typedef _c_av_clip_int8_c = ffi.Int8 Function(
  ffi.Int32 a,
);

typedef _dart_av_clip_int8_c = int Function(
  int a,
);

typedef _c_av_clip_uint16_c = ffi.Uint16 Function(
  ffi.Int32 a,
);

typedef _dart_av_clip_uint16_c = int Function(
  int a,
);

typedef _c_av_clip_int16_c = ffi.Int16 Function(
  ffi.Int32 a,
);

typedef _dart_av_clip_int16_c = int Function(
  int a,
);

typedef _c_av_clipl_int32_c = ffi.Int32 Function(
  ffi.Int64 a,
);

typedef _dart_av_clipl_int32_c = int Function(
  int a,
);

typedef _c_av_clip_intp2_c = ffi.Int32 Function(
  ffi.Int32 a,
  ffi.Int32 p,
);

typedef _dart_av_clip_intp2_c = int Function(
  int a,
  int p,
);

typedef _c_av_clip_uintp2_c = ffi.Uint32 Function(
  ffi.Int32 a,
  ffi.Int32 p,
);

typedef _dart_av_clip_uintp2_c = int Function(
  int a,
  int p,
);

typedef _c_av_mod_uintp2_c = ffi.Uint32 Function(
  ffi.Uint32 a,
  ffi.Uint32 p,
);

typedef _dart_av_mod_uintp2_c = int Function(
  int a,
  int p,
);

typedef _c_av_sat_add32_c = ffi.Int32 Function(
  ffi.Int32 a,
  ffi.Int32 b,
);

typedef _dart_av_sat_add32_c = int Function(
  int a,
  int b,
);

typedef _c_av_sat_dadd32_c = ffi.Int32 Function(
  ffi.Int32 a,
  ffi.Int32 b,
);

typedef _dart_av_sat_dadd32_c = int Function(
  int a,
  int b,
);

typedef _c_av_sat_sub32_c = ffi.Int32 Function(
  ffi.Int32 a,
  ffi.Int32 b,
);

typedef _dart_av_sat_sub32_c = int Function(
  int a,
  int b,
);

typedef _c_av_sat_dsub32_c = ffi.Int32 Function(
  ffi.Int32 a,
  ffi.Int32 b,
);

typedef _dart_av_sat_dsub32_c = int Function(
  int a,
  int b,
);

typedef _c_av_sat_add64_c = ffi.Int64 Function(
  ffi.Int64 a,
  ffi.Int64 b,
);

typedef _dart_av_sat_add64_c = int Function(
  int a,
  int b,
);

typedef _c_av_sat_sub64_c = ffi.Int64 Function(
  ffi.Int64 a,
  ffi.Int64 b,
);

typedef _dart_av_sat_sub64_c = int Function(
  int a,
  int b,
);

typedef _c_av_clipf_c = ffi.Float Function(
  ffi.Float a,
  ffi.Float amin,
  ffi.Float amax,
);

typedef _dart_av_clipf_c = double Function(
  double a,
  double amin,
  double amax,
);

typedef _c_av_clipd_c = ffi.Double Function(
  ffi.Double a,
  ffi.Double amin,
  ffi.Double amax,
);

typedef _dart_av_clipd_c = double Function(
  double a,
  double amin,
  double amax,
);

typedef _c_av_ceil_log2_c = ffi.Int32 Function(
  ffi.Int32 x,
);

typedef _dart_av_ceil_log2_c = int Function(
  int x,
);

typedef _c_av_popcount_c = ffi.Int32 Function(
  ffi.Uint32 x,
);

typedef _dart_av_popcount_c = int Function(
  int x,
);

typedef _c_av_popcount64_c = ffi.Int32 Function(
  ffi.Uint64 x,
);

typedef _dart_av_popcount64_c = int Function(
  int x,
);

typedef _c_av_parity_c = ffi.Int32 Function(
  ffi.Uint32 v,
);

typedef _dart_av_parity_c = int Function(
  int v,
);

typedef _c_av_strerror = ffi.Int32 Function(
  ffi.Int32 errnum,
  ffi.Pointer<ffi.Int8> errbuf,
  ffi.Uint64 errbuf_size,
);

typedef _dart_av_strerror = int Function(
  int errnum,
  ffi.Pointer<ffi.Int8> errbuf,
  int errbuf_size,
);

typedef _c_av_make_error_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> errbuf,
  ffi.Uint64 errbuf_size,
  ffi.Int32 errnum,
);

typedef _dart_av_make_error_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> errbuf,
  int errbuf_size,
  int errnum,
);

typedef _c_av_malloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 size,
);

typedef _dart_av_malloc = ffi.Pointer<ffi.Void> Function(
  int size,
);

typedef _c_av_mallocz = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 size,
);

typedef _dart_av_mallocz = ffi.Pointer<ffi.Void> Function(
  int size,
);

typedef _c_av_malloc_array = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
);

typedef _dart_av_malloc_array = ffi.Pointer<ffi.Void> Function(
  int nmemb,
  int size,
);

typedef _c_av_mallocz_array = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
);

typedef _dart_av_mallocz_array = ffi.Pointer<ffi.Void> Function(
  int nmemb,
  int size,
);

typedef _c_av_calloc = ffi.Pointer<ffi.Void> Function(
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
);

typedef _dart_av_calloc = ffi.Pointer<ffi.Void> Function(
  int nmemb,
  int size,
);

typedef _c_av_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 size,
);

typedef _dart_av_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  int size,
);

typedef _c_av_reallocp = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 size,
);

typedef _dart_av_reallocp = int Function(
  ffi.Pointer<ffi.Void> ptr,
  int size,
);

typedef _c_av_realloc_f = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 nelem,
  ffi.Uint64 elsize,
);

typedef _dart_av_realloc_f = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  int nelem,
  int elsize,
);

typedef _c_av_realloc_array = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
);

typedef _dart_av_realloc_array = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  int nmemb,
  int size,
);

typedef _c_av_reallocp_array = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
);

typedef _dart_av_reallocp_array = int Function(
  ffi.Pointer<ffi.Void> ptr,
  int nmemb,
  int size,
);

typedef _c_av_fast_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  ffi.Uint64 min_size,
);

typedef _dart_av_fast_realloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  int min_size,
);

typedef _c_av_fast_malloc = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  ffi.Uint64 min_size,
);

typedef _dart_av_fast_malloc = void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  int min_size,
);

typedef _c_av_fast_mallocz = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  ffi.Uint64 min_size,
);

typedef _dart_av_fast_mallocz = void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  int min_size,
);

typedef _c_av_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_av_free = void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_av_freep = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_av_freep = void Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_av_strdup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s,
);

typedef _dart_av_strdup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s,
);

typedef _c_av_strndup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s,
  ffi.Uint64 len,
);

typedef _dart_av_strndup = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s,
  int len,
);

typedef _c_av_memdup = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> p,
  ffi.Uint64 size,
);

typedef _dart_av_memdup = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> p,
  int size,
);

typedef _c_av_memcpy_backptr = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Int32 back,
  ffi.Int32 cnt,
);

typedef _dart_av_memcpy_backptr = void Function(
  ffi.Pointer<ffi.Uint8> dst,
  int back,
  int cnt,
);

typedef _c_av_dynarray_add = ffi.Void Function(
  ffi.Pointer<ffi.Void> tab_ptr,
  ffi.Pointer<ffi.Int32> nb_ptr,
  ffi.Pointer<ffi.Void> elem,
);

typedef _dart_av_dynarray_add = void Function(
  ffi.Pointer<ffi.Void> tab_ptr,
  ffi.Pointer<ffi.Int32> nb_ptr,
  ffi.Pointer<ffi.Void> elem,
);

typedef _c_av_dynarray_add_nofree = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> tab_ptr,
  ffi.Pointer<ffi.Int32> nb_ptr,
  ffi.Pointer<ffi.Void> elem,
);

typedef _dart_av_dynarray_add_nofree = int Function(
  ffi.Pointer<ffi.Void> tab_ptr,
  ffi.Pointer<ffi.Int32> nb_ptr,
  ffi.Pointer<ffi.Void> elem,
);

typedef _c_av_dynarray2_add = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> tab_ptr,
  ffi.Pointer<ffi.Int32> nb_ptr,
  ffi.Uint64 elem_size,
  ffi.Pointer<ffi.Uint8> elem_data,
);

typedef _dart_av_dynarray2_add = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> tab_ptr,
  ffi.Pointer<ffi.Int32> nb_ptr,
  int elem_size,
  ffi.Pointer<ffi.Uint8> elem_data,
);

typedef _c_av_size_mult = ffi.Int32 Function(
  ffi.Uint64 a,
  ffi.Uint64 b,
  ffi.Pointer<ffi.Uint64> r,
);

typedef _dart_av_size_mult = int Function(
  int a,
  int b,
  ffi.Pointer<ffi.Uint64> r,
);

typedef _c_av_max_alloc = ffi.Void Function(
  ffi.Uint64 max,
);

typedef _dart_av_max_alloc = void Function(
  int max,
);

typedef _c_av_reduce = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> dst_num,
  ffi.Pointer<ffi.Int32> dst_den,
  ffi.Int64 num,
  ffi.Int64 den,
  ffi.Int64 max,
);

typedef _dart_av_reduce = int Function(
  ffi.Pointer<ffi.Int32> dst_num,
  ffi.Pointer<ffi.Int32> dst_den,
  int num,
  int den,
  int max,
);

typedef _c_av_int2float = ffi.Float Function(
  ffi.Uint32 i,
);

typedef _dart_av_int2float = double Function(
  int i,
);

typedef _c_av_float2int = ffi.Uint32 Function(
  ffi.Float f,
);

typedef _dart_av_float2int = int Function(
  double f,
);

typedef _c_av_int2double = ffi.Double Function(
  ffi.Uint64 i,
);

typedef _dart_av_int2double = double Function(
  int i,
);

typedef _c_av_double2int = ffi.Uint64 Function(
  ffi.Double f,
);

typedef _dart_av_double2int = int Function(
  double f,
);

typedef _c_av_gcd = ffi.Int64 Function(
  ffi.Int64 a,
  ffi.Int64 b,
);

typedef _dart_av_gcd = int Function(
  int a,
  int b,
);

typedef _c_av_rescale = ffi.Int64 Function(
  ffi.Int64 a,
  ffi.Int64 b,
  ffi.Int64 c,
);

typedef _dart_av_rescale = int Function(
  int a,
  int b,
  int c,
);

typedef _c_av_rescale_rnd = ffi.Int64 Function(
  ffi.Int64 a,
  ffi.Int64 b,
  ffi.Int64 c,
  ffi.Int32 rnd,
);

typedef _dart_av_rescale_rnd = int Function(
  int a,
  int b,
  int c,
  int rnd,
);

typedef _c_av_compare_mod = ffi.Int64 Function(
  ffi.Uint64 a,
  ffi.Uint64 b,
  ffi.Uint64 mod,
);

typedef _dart_av_compare_mod = int Function(
  int a,
  int b,
  int mod,
);

typedef _c_av_log = ffi.Void Function(
  ffi.Pointer<ffi.Void> avcl,
  ffi.Int32 level,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_av_log = void Function(
  ffi.Pointer<ffi.Void> avcl,
  int level,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_av_log_once = ffi.Void Function(
  ffi.Pointer<ffi.Void> avcl,
  ffi.Int32 initial_level,
  ffi.Int32 subsequent_level,
  ffi.Pointer<ffi.Int32> state,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_av_log_once = void Function(
  ffi.Pointer<ffi.Void> avcl,
  int initial_level,
  int subsequent_level,
  ffi.Pointer<ffi.Int32> state,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_av_vlog = ffi.Void Function(
  ffi.Pointer<ffi.Void> avcl,
  ffi.Int32 level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
);

typedef _dart_av_vlog = void Function(
  ffi.Pointer<ffi.Void> avcl,
  int level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
);

typedef _c_av_log_get_level = ffi.Int32 Function();

typedef _dart_av_log_get_level = int Function();

typedef _c_av_log_set_level = ffi.Void Function(
  ffi.Int32 level,
);

typedef _dart_av_log_set_level = void Function(
  int level,
);

typedef _typedefC_7 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<__va_list_tag>,
);

typedef _c_av_log_set_callback = ffi.Void Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_7>> callback,
);

typedef _dart_av_log_set_callback = void Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_7>> callback,
);

typedef _c_av_log_default_callback = ffi.Void Function(
  ffi.Pointer<ffi.Void> avcl,
  ffi.Int32 level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
);

typedef _dart_av_log_default_callback = void Function(
  ffi.Pointer<ffi.Void> avcl,
  int level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
);

typedef _c_av_default_item_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> ctx,
);

typedef _dart_av_default_item_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void> ctx,
);

typedef _c_av_default_get_category = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _dart_av_default_get_category = int Function(
  ffi.Pointer<ffi.Void> ptr,
);

typedef _c_av_log_format_line = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Int32 level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
  ffi.Pointer<ffi.Int8> line,
  ffi.Int32 line_size,
  ffi.Pointer<ffi.Int32> print_prefix,
);

typedef _dart_av_log_format_line = void Function(
  ffi.Pointer<ffi.Void> ptr,
  int level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
  ffi.Pointer<ffi.Int8> line,
  int line_size,
  ffi.Pointer<ffi.Int32> print_prefix,
);

typedef _c_av_log_format_line2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Int32 level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
  ffi.Pointer<ffi.Int8> line,
  ffi.Int32 line_size,
  ffi.Pointer<ffi.Int32> print_prefix,
);

typedef _dart_av_log_format_line2 = int Function(
  ffi.Pointer<ffi.Void> ptr,
  int level,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl,
  ffi.Pointer<ffi.Int8> line,
  int line_size,
  ffi.Pointer<ffi.Int32> print_prefix,
);

typedef _c_av_log_set_flags = ffi.Void Function(
  ffi.Int32 arg,
);

typedef _dart_av_log_set_flags = void Function(
  int arg,
);

typedef _c_av_log_get_flags = ffi.Int32 Function();

typedef _dart_av_log_get_flags = int Function();

typedef _c_av_x_if_null = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> p,
  ffi.Pointer<ffi.Void> x,
);

typedef _dart_av_x_if_null = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> p,
  ffi.Pointer<ffi.Void> x,
);

typedef _c_av_int_list_length_for_size = ffi.Uint32 Function(
  ffi.Uint32 elsize,
  ffi.Pointer<ffi.Void> list,
  ffi.Uint64 term,
);

typedef _dart_av_int_list_length_for_size = int Function(
  int elsize,
  ffi.Pointer<ffi.Void> list,
  int term,
);

typedef _c_av_fopen_utf8 = ffi.Pointer<_IO_FILE> Function(
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> mode,
);

typedef _dart_av_fopen_utf8 = ffi.Pointer<_IO_FILE> Function(
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> mode,
);

typedef _c_av_fourcc_make_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Uint32 fourcc,
);

typedef _dart_av_fourcc_make_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  int fourcc,
);

typedef _c_av_get_sample_fmt_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 sample_fmt,
);

typedef _dart_av_get_sample_fmt_name = ffi.Pointer<ffi.Int8> Function(
  int sample_fmt,
);

typedef _c_av_get_sample_fmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_get_sample_fmt = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_get_alt_sample_fmt = ffi.Int32 Function(
  ffi.Int32 sample_fmt,
  ffi.Int32 planar,
);

typedef _dart_av_get_alt_sample_fmt = int Function(
  int sample_fmt,
  int planar,
);

typedef _c_av_get_packed_sample_fmt = ffi.Int32 Function(
  ffi.Int32 sample_fmt,
);

typedef _dart_av_get_packed_sample_fmt = int Function(
  int sample_fmt,
);

typedef _c_av_get_planar_sample_fmt = ffi.Int32 Function(
  ffi.Int32 sample_fmt,
);

typedef _dart_av_get_planar_sample_fmt = int Function(
  int sample_fmt,
);

typedef _c_av_get_sample_fmt_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buf_size,
  ffi.Int32 sample_fmt,
);

typedef _dart_av_get_sample_fmt_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  int buf_size,
  int sample_fmt,
);

typedef _c_av_get_bytes_per_sample = ffi.Int32 Function(
  ffi.Int32 sample_fmt,
);

typedef _dart_av_get_bytes_per_sample = int Function(
  int sample_fmt,
);

typedef _c_av_sample_fmt_is_planar = ffi.Int32 Function(
  ffi.Int32 sample_fmt,
);

typedef _dart_av_sample_fmt_is_planar = int Function(
  int sample_fmt,
);

typedef _c_av_samples_get_buffer_size = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Int32 nb_channels,
  ffi.Int32 nb_samples,
  ffi.Int32 sample_fmt,
  ffi.Int32 align,
);

typedef _dart_av_samples_get_buffer_size = int Function(
  ffi.Pointer<ffi.Int32> linesize,
  int nb_channels,
  int nb_samples,
  int sample_fmt,
  int align,
);

typedef _c_av_samples_fill_arrays = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 nb_channels,
  ffi.Int32 nb_samples,
  ffi.Int32 sample_fmt,
  ffi.Int32 align,
);

typedef _dart_av_samples_fill_arrays = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<ffi.Uint8> buf,
  int nb_channels,
  int nb_samples,
  int sample_fmt,
  int align,
);

typedef _c_av_samples_alloc = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Int32 nb_channels,
  ffi.Int32 nb_samples,
  ffi.Int32 sample_fmt,
  ffi.Int32 align,
);

typedef _dart_av_samples_alloc = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
  ffi.Pointer<ffi.Int32> linesize,
  int nb_channels,
  int nb_samples,
  int sample_fmt,
  int align,
);

typedef _c_av_samples_alloc_array_and_samples = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>> audio_data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Int32 nb_channels,
  ffi.Int32 nb_samples,
  ffi.Int32 sample_fmt,
  ffi.Int32 align,
);

typedef _dart_av_samples_alloc_array_and_samples = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>> audio_data,
  ffi.Pointer<ffi.Int32> linesize,
  int nb_channels,
  int nb_samples,
  int sample_fmt,
  int align,
);

typedef _c_av_samples_copy = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src,
  ffi.Int32 dst_offset,
  ffi.Int32 src_offset,
  ffi.Int32 nb_samples,
  ffi.Int32 nb_channels,
  ffi.Int32 sample_fmt,
);

typedef _dart_av_samples_copy = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src,
  int dst_offset,
  int src_offset,
  int nb_samples,
  int nb_channels,
  int sample_fmt,
);

typedef _c_av_samples_set_silence = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
  ffi.Int32 offset,
  ffi.Int32 nb_samples,
  ffi.Int32 nb_channels,
  ffi.Int32 sample_fmt,
);

typedef _dart_av_samples_set_silence = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> audio_data,
  int offset,
  int nb_samples,
  int nb_channels,
  int sample_fmt,
);

typedef _c_av_buffer_alloc = ffi.Pointer<AVBufferRef> Function(
  ffi.Int32 size,
);

typedef _dart_av_buffer_alloc = ffi.Pointer<AVBufferRef> Function(
  int size,
);

typedef _c_av_buffer_allocz = ffi.Pointer<AVBufferRef> Function(
  ffi.Int32 size,
);

typedef _dart_av_buffer_allocz = ffi.Pointer<AVBufferRef> Function(
  int size,
);

typedef _typedefC_8 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Uint8>,
);

typedef _c_av_buffer_create = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_8>> free,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Int32 flags,
);

typedef _dart_av_buffer_create = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<ffi.Uint8> data,
  int size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_8>> free,
  ffi.Pointer<ffi.Void> opaque,
  int flags,
);

typedef _c_av_buffer_default_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.Uint8> data,
);

typedef _dart_av_buffer_default_free = void Function(
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.Uint8> data,
);

typedef _c_av_buffer_ref = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _dart_av_buffer_ref = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _c_av_buffer_unref = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
);

typedef _dart_av_buffer_unref = void Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
);

typedef _c_av_buffer_is_writable = ffi.Int32 Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _dart_av_buffer_is_writable = int Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _c_av_buffer_get_opaque = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _dart_av_buffer_get_opaque = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _c_av_buffer_get_ref_count = ffi.Int32 Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _dart_av_buffer_get_ref_count = int Function(
  ffi.Pointer<AVBufferRef> buf,
);

typedef _c_av_buffer_make_writable = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
);

typedef _dart_av_buffer_make_writable = int Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
);

typedef _c_av_buffer_realloc = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
  ffi.Int32 size,
);

typedef _dart_av_buffer_realloc = int Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> buf,
  int size,
);

typedef _c_av_buffer_replace = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> dst,
  ffi.Pointer<AVBufferRef> src,
);

typedef _dart_av_buffer_replace = int Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> dst,
  ffi.Pointer<AVBufferRef> src,
);

typedef _typedefC_9 = ffi.Pointer<AVBufferRef> Function(
  ffi.Int32,
);

typedef _c_av_buffer_pool_init = ffi.Pointer<AVBufferPool> Function(
  ffi.Int32 size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_9>> alloc,
);

typedef _dart_av_buffer_pool_init = ffi.Pointer<AVBufferPool> Function(
  int size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_9>> alloc,
);

typedef _typedefC_10 = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
);

typedef _typedefC_11 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c_av_buffer_pool_init2 = ffi.Pointer<AVBufferPool> Function(
  ffi.Int32 size,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.NativeFunction<_typedefC_10>> alloc,
  ffi.Pointer<ffi.NativeFunction<_typedefC_11>> pool_free,
);

typedef _dart_av_buffer_pool_init2 = ffi.Pointer<AVBufferPool> Function(
  int size,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.NativeFunction<_typedefC_10>> alloc,
  ffi.Pointer<ffi.NativeFunction<_typedefC_11>> pool_free,
);

typedef _c_av_buffer_pool_uninit = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVBufferPool>> pool,
);

typedef _dart_av_buffer_pool_uninit = void Function(
  ffi.Pointer<ffi.Pointer<AVBufferPool>> pool,
);

typedef _c_av_buffer_pool_get = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVBufferPool> pool,
);

typedef _dart_av_buffer_pool_get = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVBufferPool> pool,
);

typedef _c_av_buffer_pool_buffer_get_opaque = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVBufferRef> ref,
);

typedef _dart_av_buffer_pool_buffer_get_opaque = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVBufferRef> ref,
);

typedef _c_av_get_cpu_flags = ffi.Int32 Function();

typedef _dart_av_get_cpu_flags = int Function();

typedef _c_av_force_cpu_flags = ffi.Void Function(
  ffi.Int32 flags,
);

typedef _dart_av_force_cpu_flags = void Function(
  int flags,
);

typedef _c_av_set_cpu_flags_mask = ffi.Void Function(
  ffi.Int32 mask,
);

typedef _dart_av_set_cpu_flags_mask = void Function(
  int mask,
);

typedef _c_av_parse_cpu_flags = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> s,
);

typedef _dart_av_parse_cpu_flags = int Function(
  ffi.Pointer<ffi.Int8> s,
);

typedef _c_av_parse_cpu_caps = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint32> flags,
  ffi.Pointer<ffi.Int8> s,
);

typedef _dart_av_parse_cpu_caps = int Function(
  ffi.Pointer<ffi.Uint32> flags,
  ffi.Pointer<ffi.Int8> s,
);

typedef _c_av_cpu_count = ffi.Int32 Function();

typedef _dart_av_cpu_count = int Function();

typedef _c_av_cpu_max_align = ffi.Uint64 Function();

typedef _dart_av_cpu_max_align = int Function();

typedef _c_av_get_channel_layout = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_get_channel_layout = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_get_extended_channel_layout = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Uint64> channel_layout,
  ffi.Pointer<ffi.Int32> nb_channels,
);

typedef _dart_av_get_extended_channel_layout = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Uint64> channel_layout,
  ffi.Pointer<ffi.Int32> nb_channels,
);

typedef _c_av_get_channel_layout_string = ffi.Void Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buf_size,
  ffi.Int32 nb_channels,
  ffi.Uint64 channel_layout,
);

typedef _dart_av_get_channel_layout_string = void Function(
  ffi.Pointer<ffi.Int8> buf,
  int buf_size,
  int nb_channels,
  int channel_layout,
);

typedef _c_av_bprint_channel_layout = ffi.Void Function(
  ffi.Pointer<AVBPrint> bp,
  ffi.Int32 nb_channels,
  ffi.Uint64 channel_layout,
);

typedef _dart_av_bprint_channel_layout = void Function(
  ffi.Pointer<AVBPrint> bp,
  int nb_channels,
  int channel_layout,
);

typedef _c_av_get_channel_layout_nb_channels = ffi.Int32 Function(
  ffi.Uint64 channel_layout,
);

typedef _dart_av_get_channel_layout_nb_channels = int Function(
  int channel_layout,
);

typedef _c_av_get_default_channel_layout = ffi.Int64 Function(
  ffi.Int32 nb_channels,
);

typedef _dart_av_get_default_channel_layout = int Function(
  int nb_channels,
);

typedef _c_av_get_channel_layout_channel_index = ffi.Int32 Function(
  ffi.Uint64 channel_layout,
  ffi.Uint64 channel,
);

typedef _dart_av_get_channel_layout_channel_index = int Function(
  int channel_layout,
  int channel,
);

typedef _c_av_channel_layout_extract_channel = ffi.Uint64 Function(
  ffi.Uint64 channel_layout,
  ffi.Int32 index,
);

typedef _dart_av_channel_layout_extract_channel = int Function(
  int channel_layout,
  int index,
);

typedef _c_av_get_channel_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint64 channel,
);

typedef _dart_av_get_channel_name = ffi.Pointer<ffi.Int8> Function(
  int channel,
);

typedef _c_av_get_channel_description = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint64 channel,
);

typedef _dart_av_get_channel_description = ffi.Pointer<ffi.Int8> Function(
  int channel,
);

typedef _c_av_get_standard_channel_layout = ffi.Int32 Function(
  ffi.Uint32 index,
  ffi.Pointer<ffi.Uint64> layout,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> name,
);

typedef _dart_av_get_standard_channel_layout = int Function(
  int index,
  ffi.Pointer<ffi.Uint64> layout,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> name,
);

typedef _c_av_dict_get = ffi.Pointer<AVDictionaryEntry> Function(
  ffi.Pointer<AVDictionary> m,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<AVDictionaryEntry> prev,
  ffi.Int32 flags,
);

typedef _dart_av_dict_get = ffi.Pointer<AVDictionaryEntry> Function(
  ffi.Pointer<AVDictionary> m,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<AVDictionaryEntry> prev,
  int flags,
);

typedef _c_av_dict_count = ffi.Int32 Function(
  ffi.Pointer<AVDictionary> m,
);

typedef _dart_av_dict_count = int Function(
  ffi.Pointer<AVDictionary> m,
);

typedef _c_av_dict_set = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
  ffi.Int32 flags,
);

typedef _dart_av_dict_set = int Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
  ffi.Pointer<ffi.Int8> key,
  ffi.Pointer<ffi.Int8> value,
  int flags,
);

typedef _c_av_dict_set_int = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
  ffi.Pointer<ffi.Int8> key,
  ffi.Int64 value,
  ffi.Int32 flags,
);

typedef _dart_av_dict_set_int = int Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
  ffi.Pointer<ffi.Int8> key,
  int value,
  int flags,
);

typedef _c_av_dict_parse_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
  ffi.Int32 flags,
);

typedef _dart_av_dict_parse_string = int Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> pm,
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
  int flags,
);

typedef _c_av_dict_copy = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> dst,
  ffi.Pointer<AVDictionary> src,
  ffi.Int32 flags,
);

typedef _dart_av_dict_copy = int Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> dst,
  ffi.Pointer<AVDictionary> src,
  int flags,
);

typedef _c_av_dict_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> m,
);

typedef _dart_av_dict_free = void Function(
  ffi.Pointer<ffi.Pointer<AVDictionary>> m,
);

typedef _c_av_dict_get_string = ffi.Int32 Function(
  ffi.Pointer<AVDictionary> m,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> buffer,
  ffi.Int8 key_val_sep,
  ffi.Int8 pairs_sep,
);

typedef _dart_av_dict_get_string = int Function(
  ffi.Pointer<AVDictionary> m,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> buffer,
  int key_val_sep,
  int pairs_sep,
);

typedef _c_av_frame_get_best_effort_timestamp = ffi.Int64 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_best_effort_timestamp = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_best_effort_timestamp = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int64 val,
);

typedef _dart_av_frame_set_best_effort_timestamp = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_pkt_duration = ffi.Int64 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_pkt_duration = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_pkt_duration = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int64 val,
);

typedef _dart_av_frame_set_pkt_duration = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_pkt_pos = ffi.Int64 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_pkt_pos = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_pkt_pos = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int64 val,
);

typedef _dart_av_frame_set_pkt_pos = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_channel_layout = ffi.Int64 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_channel_layout = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_channel_layout = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int64 val,
);

typedef _dart_av_frame_set_channel_layout = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_channels = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_channels = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_channels = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 val,
);

typedef _dart_av_frame_set_channels = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_sample_rate = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_sample_rate = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_sample_rate = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 val,
);

typedef _dart_av_frame_set_sample_rate = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_metadata = ffi.Pointer<AVDictionary> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_metadata = ffi.Pointer<AVDictionary> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_metadata = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<AVDictionary> val,
);

typedef _dart_av_frame_set_metadata = void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<AVDictionary> val,
);

typedef _c_av_frame_get_decode_error_flags = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_decode_error_flags = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_decode_error_flags = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 val,
);

typedef _dart_av_frame_set_decode_error_flags = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_pkt_size = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_pkt_size = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_pkt_size = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 val,
);

typedef _dart_av_frame_set_pkt_size = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_qp_table = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVFrame> f,
  ffi.Pointer<ffi.Int32> stride,
  ffi.Pointer<ffi.Int32> type,
);

typedef _dart_av_frame_get_qp_table = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVFrame> f,
  ffi.Pointer<ffi.Int32> stride,
  ffi.Pointer<ffi.Int32> type,
);

typedef _c_av_frame_set_qp_table = ffi.Int32 Function(
  ffi.Pointer<AVFrame> f,
  ffi.Pointer<AVBufferRef> buf,
  ffi.Int32 stride,
  ffi.Int32 type,
);

typedef _dart_av_frame_set_qp_table = int Function(
  ffi.Pointer<AVFrame> f,
  ffi.Pointer<AVBufferRef> buf,
  int stride,
  int type,
);

typedef _c_av_frame_get_colorspace = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_colorspace = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_colorspace = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 val,
);

typedef _dart_av_frame_set_colorspace = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_frame_get_color_range = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_get_color_range = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_set_color_range = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 val,
);

typedef _dart_av_frame_set_color_range = void Function(
  ffi.Pointer<AVFrame> frame,
  int val,
);

typedef _c_av_get_colorspace_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 val,
);

typedef _dart_av_get_colorspace_name = ffi.Pointer<ffi.Int8> Function(
  int val,
);

typedef _c_av_frame_alloc = ffi.Pointer<AVFrame> Function();

typedef _dart_av_frame_alloc = ffi.Pointer<AVFrame> Function();

typedef _c_av_frame_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVFrame>> frame,
);

typedef _dart_av_frame_free = void Function(
  ffi.Pointer<ffi.Pointer<AVFrame>> frame,
);

typedef _c_av_frame_ref = ffi.Int32 Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _dart_av_frame_ref = int Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _c_av_frame_clone = ffi.Pointer<AVFrame> Function(
  ffi.Pointer<AVFrame> src,
);

typedef _dart_av_frame_clone = ffi.Pointer<AVFrame> Function(
  ffi.Pointer<AVFrame> src,
);

typedef _c_av_frame_unref = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_unref = void Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_move_ref = ffi.Void Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _dart_av_frame_move_ref = void Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _c_av_frame_get_buffer = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 align,
);

typedef _dart_av_frame_get_buffer = int Function(
  ffi.Pointer<AVFrame> frame,
  int align,
);

typedef _c_av_frame_is_writable = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_is_writable = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_make_writable = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_frame_make_writable = int Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_frame_copy = ffi.Int32 Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _dart_av_frame_copy = int Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _c_av_frame_copy_props = ffi.Int32 Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _dart_av_frame_copy_props = int Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
);

typedef _c_av_frame_get_plane_buffer = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 plane,
);

typedef _dart_av_frame_get_plane_buffer = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVFrame> frame,
  int plane,
);

typedef _c_av_frame_new_side_data = ffi.Pointer<AVFrameSideData> Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 type,
  ffi.Int32 size,
);

typedef _dart_av_frame_new_side_data = ffi.Pointer<AVFrameSideData> Function(
  ffi.Pointer<AVFrame> frame,
  int type,
  int size,
);

typedef _c_av_frame_new_side_data_from_buf = ffi.Pointer<AVFrameSideData>
    Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 type,
  ffi.Pointer<AVBufferRef> buf,
);

typedef _dart_av_frame_new_side_data_from_buf = ffi.Pointer<AVFrameSideData>
    Function(
  ffi.Pointer<AVFrame> frame,
  int type,
  ffi.Pointer<AVBufferRef> buf,
);

typedef _c_av_frame_get_side_data = ffi.Pointer<AVFrameSideData> Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 type,
);

typedef _dart_av_frame_get_side_data = ffi.Pointer<AVFrameSideData> Function(
  ffi.Pointer<AVFrame> frame,
  int type,
);

typedef _c_av_frame_remove_side_data = ffi.Void Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 type,
);

typedef _dart_av_frame_remove_side_data = void Function(
  ffi.Pointer<AVFrame> frame,
  int type,
);

typedef _c_av_frame_apply_cropping = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 flags,
);

typedef _dart_av_frame_apply_cropping = int Function(
  ffi.Pointer<AVFrame> frame,
  int flags,
);

typedef _c_av_frame_side_data_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 type,
);

typedef _dart_av_frame_side_data_name = ffi.Pointer<ffi.Int8> Function(
  int type,
);

typedef _c_av_hwdevice_find_type_by_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_hwdevice_find_type_by_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_hwdevice_get_type_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 type,
);

typedef _dart_av_hwdevice_get_type_name = ffi.Pointer<ffi.Int8> Function(
  int type,
);

typedef _c_av_hwdevice_iterate_types = ffi.Int32 Function(
  ffi.Int32 prev,
);

typedef _dart_av_hwdevice_iterate_types = int Function(
  int prev,
);

typedef _c_av_hwdevice_ctx_alloc = ffi.Pointer<AVBufferRef> Function(
  ffi.Int32 type,
);

typedef _dart_av_hwdevice_ctx_alloc = ffi.Pointer<AVBufferRef> Function(
  int type,
);

typedef _c_av_hwdevice_ctx_init = ffi.Int32 Function(
  ffi.Pointer<AVBufferRef> ref,
);

typedef _dart_av_hwdevice_ctx_init = int Function(
  ffi.Pointer<AVBufferRef> ref,
);

typedef _c_av_hwdevice_ctx_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> device_ctx,
  ffi.Int32 type,
  ffi.Pointer<ffi.Int8> device,
  ffi.Pointer<AVDictionary> opts,
  ffi.Int32 flags,
);

typedef _dart_av_hwdevice_ctx_create = int Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> device_ctx,
  int type,
  ffi.Pointer<ffi.Int8> device,
  ffi.Pointer<AVDictionary> opts,
  int flags,
);

typedef _c_av_hwdevice_ctx_create_derived = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
  ffi.Int32 type,
  ffi.Pointer<AVBufferRef> src_ctx,
  ffi.Int32 flags,
);

typedef _dart_av_hwdevice_ctx_create_derived = int Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
  int type,
  ffi.Pointer<AVBufferRef> src_ctx,
  int flags,
);

typedef _c_av_hwdevice_ctx_create_derived_opts = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
  ffi.Int32 type,
  ffi.Pointer<AVBufferRef> src_ctx,
  ffi.Pointer<AVDictionary> options,
  ffi.Int32 flags,
);

typedef _dart_av_hwdevice_ctx_create_derived_opts = int Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> dst_ctx,
  int type,
  ffi.Pointer<AVBufferRef> src_ctx,
  ffi.Pointer<AVDictionary> options,
  int flags,
);

typedef _c_av_hwframe_ctx_alloc = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVBufferRef> device_ctx,
);

typedef _dart_av_hwframe_ctx_alloc = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVBufferRef> device_ctx,
);

typedef _c_av_hwframe_ctx_init = ffi.Int32 Function(
  ffi.Pointer<AVBufferRef> ref,
);

typedef _dart_av_hwframe_ctx_init = int Function(
  ffi.Pointer<AVBufferRef> ref,
);

typedef _c_av_hwframe_get_buffer = ffi.Int32 Function(
  ffi.Pointer<AVBufferRef> hwframe_ctx,
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 flags,
);

typedef _dart_av_hwframe_get_buffer = int Function(
  ffi.Pointer<AVBufferRef> hwframe_ctx,
  ffi.Pointer<AVFrame> frame,
  int flags,
);

typedef _c_av_hwframe_transfer_data = ffi.Int32 Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
  ffi.Int32 flags,
);

typedef _dart_av_hwframe_transfer_data = int Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
  int flags,
);

typedef _c_av_hwframe_transfer_get_formats = ffi.Int32 Function(
  ffi.Pointer<AVBufferRef> hwframe_ctx,
  ffi.Int32 dir,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> formats,
  ffi.Int32 flags,
);

typedef _dart_av_hwframe_transfer_get_formats = int Function(
  ffi.Pointer<AVBufferRef> hwframe_ctx,
  int dir,
  ffi.Pointer<ffi.Pointer<ffi.Int32>> formats,
  int flags,
);

typedef _c_av_hwdevice_hwconfig_alloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVBufferRef> device_ctx,
);

typedef _dart_av_hwdevice_hwconfig_alloc = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVBufferRef> device_ctx,
);

typedef _c_av_hwdevice_get_hwframe_constraints
    = ffi.Pointer<AVHWFramesConstraints> Function(
  ffi.Pointer<AVBufferRef> ref,
  ffi.Pointer<ffi.Void> hwconfig,
);

typedef _dart_av_hwdevice_get_hwframe_constraints
    = ffi.Pointer<AVHWFramesConstraints> Function(
  ffi.Pointer<AVBufferRef> ref,
  ffi.Pointer<ffi.Void> hwconfig,
);

typedef _c_av_hwframe_constraints_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVHWFramesConstraints>> constraints,
);

typedef _dart_av_hwframe_constraints_free = void Function(
  ffi.Pointer<ffi.Pointer<AVHWFramesConstraints>> constraints,
);

typedef _c_av_hwframe_map = ffi.Int32 Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
  ffi.Int32 flags,
);

typedef _dart_av_hwframe_map = int Function(
  ffi.Pointer<AVFrame> dst,
  ffi.Pointer<AVFrame> src,
  int flags,
);

typedef _c_av_hwframe_ctx_create_derived = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> derived_frame_ctx,
  ffi.Int32 format,
  ffi.Pointer<AVBufferRef> derived_device_ctx,
  ffi.Pointer<AVBufferRef> source_frame_ctx,
  ffi.Int32 flags,
);

typedef _dart_av_hwframe_ctx_create_derived = int Function(
  ffi.Pointer<ffi.Pointer<AVBufferRef>> derived_frame_ctx,
  int format,
  ffi.Pointer<AVBufferRef> derived_device_ctx,
  ffi.Pointer<AVBufferRef> source_frame_ctx,
  int flags,
);

typedef _c_avcodec_get_type = ffi.Int32 Function(
  ffi.Int32 codec_id,
);

typedef _dart_avcodec_get_type = int Function(
  int codec_id,
);

typedef _c_avcodec_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 id,
);

typedef _dart_avcodec_get_name = ffi.Pointer<ffi.Int8> Function(
  int id,
);

typedef _c_avcodec_parameters_alloc = ffi.Pointer<AVCodecParameters> Function();

typedef _dart_avcodec_parameters_alloc = ffi.Pointer<AVCodecParameters>
    Function();

typedef _c_avcodec_parameters_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVCodecParameters>> par,
);

typedef _dart_avcodec_parameters_free = void Function(
  ffi.Pointer<ffi.Pointer<AVCodecParameters>> par,
);

typedef _c_avcodec_parameters_copy = ffi.Int32 Function(
  ffi.Pointer<AVCodecParameters> dst,
  ffi.Pointer<AVCodecParameters> src,
);

typedef _dart_avcodec_parameters_copy = int Function(
  ffi.Pointer<AVCodecParameters> dst,
  ffi.Pointer<AVCodecParameters> src,
);

typedef _c_av_packet_alloc = ffi.Pointer<AVPacket> Function();

typedef _dart_av_packet_alloc = ffi.Pointer<AVPacket> Function();

typedef _c_av_packet_clone = ffi.Pointer<AVPacket> Function(
  ffi.Pointer<AVPacket> src,
);

typedef _dart_av_packet_clone = ffi.Pointer<AVPacket> Function(
  ffi.Pointer<AVPacket> src,
);

typedef _c_av_packet_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVPacket>> pkt,
);

typedef _dart_av_packet_free = void Function(
  ffi.Pointer<ffi.Pointer<AVPacket>> pkt,
);

typedef _c_av_init_packet = ffi.Void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_init_packet = void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_new_packet = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 size,
);

typedef _dart_av_new_packet = int Function(
  ffi.Pointer<AVPacket> pkt,
  int size,
);

typedef _c_av_shrink_packet = ffi.Void Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 size,
);

typedef _dart_av_shrink_packet = void Function(
  ffi.Pointer<AVPacket> pkt,
  int size,
);

typedef _c_av_grow_packet = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 grow_by,
);

typedef _dart_av_grow_packet = int Function(
  ffi.Pointer<AVPacket> pkt,
  int grow_by,
);

typedef _c_av_packet_from_data = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 size,
);

typedef _dart_av_packet_from_data = int Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Pointer<ffi.Uint8> data,
  int size,
);

typedef _c_av_dup_packet = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_dup_packet = int Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_copy_packet = ffi.Int32 Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _dart_av_copy_packet = int Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _c_av_copy_packet_side_data = ffi.Int32 Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _dart_av_copy_packet_side_data = int Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _c_av_free_packet = ffi.Void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_free_packet = void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_packet_new_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 type,
  ffi.Int32 size,
);

typedef _dart_av_packet_new_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVPacket> pkt,
  int type,
  int size,
);

typedef _c_av_packet_add_side_data = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 type,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint64 size,
);

typedef _dart_av_packet_add_side_data = int Function(
  ffi.Pointer<AVPacket> pkt,
  int type,
  ffi.Pointer<ffi.Uint8> data,
  int size,
);

typedef _c_av_packet_shrink_side_data = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 type,
  ffi.Int32 size,
);

typedef _dart_av_packet_shrink_side_data = int Function(
  ffi.Pointer<AVPacket> pkt,
  int type,
  int size,
);

typedef _c_av_packet_get_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 type,
  ffi.Pointer<ffi.Int32> size,
);

typedef _dart_av_packet_get_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVPacket> pkt,
  int type,
  ffi.Pointer<ffi.Int32> size,
);

typedef _c_av_packet_merge_side_data = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_packet_merge_side_data = int Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_packet_split_side_data = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_packet_split_side_data = int Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_packet_side_data_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 type,
);

typedef _dart_av_packet_side_data_name = ffi.Pointer<ffi.Int8> Function(
  int type,
);

typedef _c_av_packet_pack_dictionary = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVDictionary> dict,
  ffi.Pointer<ffi.Int32> size,
);

typedef _dart_av_packet_pack_dictionary = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVDictionary> dict,
  ffi.Pointer<ffi.Int32> size,
);

typedef _c_av_packet_unpack_dictionary = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> data,
  ffi.Int32 size,
  ffi.Pointer<ffi.Pointer<AVDictionary>> dict,
);

typedef _dart_av_packet_unpack_dictionary = int Function(
  ffi.Pointer<ffi.Uint8> data,
  int size,
  ffi.Pointer<ffi.Pointer<AVDictionary>> dict,
);

typedef _c_av_packet_free_side_data = ffi.Void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_packet_free_side_data = void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_packet_ref = ffi.Int32 Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _dart_av_packet_ref = int Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _c_av_packet_unref = ffi.Void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_packet_unref = void Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_packet_move_ref = ffi.Void Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _dart_av_packet_move_ref = void Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _c_av_packet_copy_props = ffi.Int32 Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _dart_av_packet_copy_props = int Function(
  ffi.Pointer<AVPacket> dst,
  ffi.Pointer<AVPacket> src,
);

typedef _c_av_packet_make_refcounted = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_packet_make_refcounted = int Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_packet_make_writable = ffi.Int32 Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_packet_make_writable = int Function(
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_bsf_get_by_name = ffi.Pointer<AVBitStreamFilter> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_bsf_get_by_name = ffi.Pointer<AVBitStreamFilter> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_bsf_iterate = ffi.Pointer<AVBitStreamFilter> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _dart_av_bsf_iterate = ffi.Pointer<AVBitStreamFilter> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _c_av_bsf_alloc = ffi.Int32 Function(
  ffi.Pointer<AVBitStreamFilter> filter,
  ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
);

typedef _dart_av_bsf_alloc = int Function(
  ffi.Pointer<AVBitStreamFilter> filter,
  ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
);

typedef _c_av_bsf_init = ffi.Int32 Function(
  ffi.Pointer<AVBSFContext> ctx,
);

typedef _dart_av_bsf_init = int Function(
  ffi.Pointer<AVBSFContext> ctx,
);

typedef _c_av_bsf_send_packet = ffi.Int32 Function(
  ffi.Pointer<AVBSFContext> ctx,
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_bsf_send_packet = int Function(
  ffi.Pointer<AVBSFContext> ctx,
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_bsf_receive_packet = ffi.Int32 Function(
  ffi.Pointer<AVBSFContext> ctx,
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_bsf_receive_packet = int Function(
  ffi.Pointer<AVBSFContext> ctx,
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_bsf_flush = ffi.Void Function(
  ffi.Pointer<AVBSFContext> ctx,
);

typedef _dart_av_bsf_flush = void Function(
  ffi.Pointer<AVBSFContext> ctx,
);

typedef _c_av_bsf_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
);

typedef _dart_av_bsf_free = void Function(
  ffi.Pointer<ffi.Pointer<AVBSFContext>> ctx,
);

typedef _c_av_bsf_get_class = ffi.Pointer<AVClass> Function();

typedef _dart_av_bsf_get_class = ffi.Pointer<AVClass> Function();

typedef _c_av_bsf_list_alloc = ffi.Pointer<AVBSFList> Function();

typedef _dart_av_bsf_list_alloc = ffi.Pointer<AVBSFList> Function();

typedef _c_av_bsf_list_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
);

typedef _dart_av_bsf_list_free = void Function(
  ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
);

typedef _c_av_bsf_list_append = ffi.Int32 Function(
  ffi.Pointer<AVBSFList> lst,
  ffi.Pointer<AVBSFContext> bsf,
);

typedef _dart_av_bsf_list_append = int Function(
  ffi.Pointer<AVBSFList> lst,
  ffi.Pointer<AVBSFContext> bsf,
);

typedef _c_av_bsf_list_append2 = ffi.Int32 Function(
  ffi.Pointer<AVBSFList> lst,
  ffi.Pointer<ffi.Int8> bsf_name,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_av_bsf_list_append2 = int Function(
  ffi.Pointer<AVBSFList> lst,
  ffi.Pointer<ffi.Int8> bsf_name,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_av_bsf_list_finalize = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
  ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
);

typedef _dart_av_bsf_list_finalize = int Function(
  ffi.Pointer<ffi.Pointer<AVBSFList>> lst,
  ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
);

typedef _c_av_bsf_list_parse_str = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
);

typedef _dart_av_bsf_list_parse_str = int Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
);

typedef _c_av_bsf_get_null_filter = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
);

typedef _dart_av_bsf_get_null_filter = int Function(
  ffi.Pointer<ffi.Pointer<AVBSFContext>> bsf,
);

typedef _c_av_codec_iterate = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _dart_av_codec_iterate = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _c_avcodec_find_decoder = ffi.Pointer<AVCodec> Function(
  ffi.Int32 id,
);

typedef _dart_avcodec_find_decoder = ffi.Pointer<AVCodec> Function(
  int id,
);

typedef _c_avcodec_find_decoder_by_name = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_avcodec_find_decoder_by_name = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_avcodec_find_encoder = ffi.Pointer<AVCodec> Function(
  ffi.Int32 id,
);

typedef _dart_avcodec_find_encoder = ffi.Pointer<AVCodec> Function(
  int id,
);

typedef _c_avcodec_find_encoder_by_name = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_avcodec_find_encoder_by_name = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_codec_is_encoder = ffi.Int32 Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _dart_av_codec_is_encoder = int Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _c_av_codec_is_decoder = ffi.Int32 Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _dart_av_codec_is_decoder = int Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _c_avcodec_get_hw_config = ffi.Pointer<AVCodecHWConfig> Function(
  ffi.Pointer<AVCodec> codec,
  ffi.Int32 index,
);

typedef _dart_avcodec_get_hw_config = ffi.Pointer<AVCodecHWConfig> Function(
  ffi.Pointer<AVCodec> codec,
  int index,
);

typedef _c_avcodec_descriptor_get = ffi.Pointer<AVCodecDescriptor> Function(
  ffi.Int32 id,
);

typedef _dart_avcodec_descriptor_get = ffi.Pointer<AVCodecDescriptor> Function(
  int id,
);

typedef _c_avcodec_descriptor_next = ffi.Pointer<AVCodecDescriptor> Function(
  ffi.Pointer<AVCodecDescriptor> prev,
);

typedef _dart_avcodec_descriptor_next = ffi.Pointer<AVCodecDescriptor> Function(
  ffi.Pointer<AVCodecDescriptor> prev,
);

typedef _c_avcodec_descriptor_get_by_name = ffi.Pointer<AVCodecDescriptor>
    Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_avcodec_descriptor_get_by_name = ffi.Pointer<AVCodecDescriptor>
    Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_codec_get_codec_descriptor = ffi.Pointer<AVCodecDescriptor>
    Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_codec_get_codec_descriptor = ffi.Pointer<AVCodecDescriptor>
    Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_codec_set_codec_descriptor = ffi.Void Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVCodecDescriptor> desc,
);

typedef _dart_av_codec_set_codec_descriptor = void Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVCodecDescriptor> desc,
);

typedef _c_av_codec_get_codec_properties = ffi.Uint32 Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_codec_get_codec_properties = int Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_codec_get_lowres = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_codec_get_lowres = int Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_codec_set_lowres = ffi.Void Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Int32 val,
);

typedef _dart_av_codec_set_lowres = void Function(
  ffi.Pointer<AVCodecContext> avctx,
  int val,
);

typedef _c_av_codec_get_seek_preroll = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_codec_get_seek_preroll = int Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_codec_set_seek_preroll = ffi.Void Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Int32 val,
);

typedef _dart_av_codec_set_seek_preroll = void Function(
  ffi.Pointer<AVCodecContext> avctx,
  int val,
);

typedef _c_av_codec_get_chroma_intra_matrix = ffi.Pointer<ffi.Uint16> Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_codec_get_chroma_intra_matrix = ffi.Pointer<ffi.Uint16>
    Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_codec_set_chroma_intra_matrix = ffi.Void Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Uint16> val,
);

typedef _dart_av_codec_set_chroma_intra_matrix = void Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Uint16> val,
);

typedef _c_av_codec_get_max_lowres = ffi.Int32 Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _dart_av_codec_get_max_lowres = int Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _c_av_codec_next = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVCodec> c,
);

typedef _dart_av_codec_next = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVCodec> c,
);

typedef _c_avcodec_version = ffi.Uint32 Function();

typedef _dart_avcodec_version = int Function();

typedef _c_avcodec_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avcodec_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _c_avcodec_license = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avcodec_license = ffi.Pointer<ffi.Int8> Function();

typedef _c_avcodec_register = ffi.Void Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _dart_avcodec_register = void Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _c_avcodec_register_all = ffi.Void Function();

typedef _dart_avcodec_register_all = void Function();

typedef _c_avcodec_alloc_context3 = ffi.Pointer<AVCodecContext> Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _dart_avcodec_alloc_context3 = ffi.Pointer<AVCodecContext> Function(
  ffi.Pointer<AVCodec> codec,
);

typedef _c_avcodec_free_context = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVCodecContext>> avctx,
);

typedef _dart_avcodec_free_context = void Function(
  ffi.Pointer<ffi.Pointer<AVCodecContext>> avctx,
);

typedef _c_avcodec_get_context_defaults3 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<AVCodec> codec,
);

typedef _dart_avcodec_get_context_defaults3 = int Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<AVCodec> codec,
);

typedef _c_avcodec_get_class = ffi.Pointer<AVClass> Function();

typedef _dart_avcodec_get_class = ffi.Pointer<AVClass> Function();

typedef _c_avcodec_get_frame_class = ffi.Pointer<AVClass> Function();

typedef _dart_avcodec_get_frame_class = ffi.Pointer<AVClass> Function();

typedef _c_avcodec_get_subtitle_rect_class = ffi.Pointer<AVClass> Function();

typedef _dart_avcodec_get_subtitle_rect_class = ffi.Pointer<AVClass> Function();

typedef _c_avcodec_copy_context = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> dest,
  ffi.Pointer<AVCodecContext> src,
);

typedef _dart_avcodec_copy_context = int Function(
  ffi.Pointer<AVCodecContext> dest,
  ffi.Pointer<AVCodecContext> src,
);

typedef _c_avcodec_parameters_from_context = ffi.Int32 Function(
  ffi.Pointer<AVCodecParameters> par,
  ffi.Pointer<AVCodecContext> codec,
);

typedef _dart_avcodec_parameters_from_context = int Function(
  ffi.Pointer<AVCodecParameters> par,
  ffi.Pointer<AVCodecContext> codec,
);

typedef _c_avcodec_parameters_to_context = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> codec,
  ffi.Pointer<AVCodecParameters> par,
);

typedef _dart_avcodec_parameters_to_context = int Function(
  ffi.Pointer<AVCodecContext> codec,
  ffi.Pointer<AVCodecParameters> par,
);

typedef _c_avcodec_open2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVCodec> codec,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avcodec_open2 = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVCodec> codec,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_avcodec_close = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_avcodec_close = int Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_avsubtitle_free = ffi.Void Function(
  ffi.Pointer<AVSubtitle> sub,
);

typedef _dart_avsubtitle_free = void Function(
  ffi.Pointer<AVSubtitle> sub,
);

typedef _c_avcodec_default_get_buffer2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 flags,
);

typedef _dart_avcodec_default_get_buffer2 = int Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<AVFrame> frame,
  int flags,
);

typedef _c_avcodec_align_dimensions = ffi.Void Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<ffi.Int32> width,
  ffi.Pointer<ffi.Int32> height,
);

typedef _dart_avcodec_align_dimensions = void Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<ffi.Int32> width,
  ffi.Pointer<ffi.Int32> height,
);

typedef _c_avcodec_align_dimensions2 = ffi.Void Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<ffi.Int32> width,
  ffi.Pointer<ffi.Int32> height,
  ffi.Pointer<ffi.Int32> linesize_align,
);

typedef _dart_avcodec_align_dimensions2 = void Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<ffi.Int32> width,
  ffi.Pointer<ffi.Int32> height,
  ffi.Pointer<ffi.Int32> linesize_align,
);

typedef _c_avcodec_enum_to_chroma_pos = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> xpos,
  ffi.Pointer<ffi.Int32> ypos,
  ffi.Int32 pos,
);

typedef _dart_avcodec_enum_to_chroma_pos = int Function(
  ffi.Pointer<ffi.Int32> xpos,
  ffi.Pointer<ffi.Int32> ypos,
  int pos,
);

typedef _c_avcodec_chroma_pos_to_enum = ffi.Int32 Function(
  ffi.Int32 xpos,
  ffi.Int32 ypos,
);

typedef _dart_avcodec_chroma_pos_to_enum = int Function(
  int xpos,
  int ypos,
);

typedef _c_avcodec_decode_audio4 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<ffi.Int32> got_frame_ptr,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _dart_avcodec_decode_audio4 = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<ffi.Int32> got_frame_ptr,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _c_avcodec_decode_video2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> picture,
  ffi.Pointer<ffi.Int32> got_picture_ptr,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _dart_avcodec_decode_video2 = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> picture,
  ffi.Pointer<ffi.Int32> got_picture_ptr,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _c_avcodec_decode_subtitle2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVSubtitle> sub,
  ffi.Pointer<ffi.Int32> got_sub_ptr,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _dart_avcodec_decode_subtitle2 = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVSubtitle> sub,
  ffi.Pointer<ffi.Int32> got_sub_ptr,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _c_avcodec_send_packet = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _dart_avcodec_send_packet = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _c_avcodec_receive_frame = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_avcodec_receive_frame = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _c_avcodec_send_frame = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_avcodec_send_frame = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _c_avcodec_receive_packet = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _dart_avcodec_receive_packet = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
);

typedef _c_avcodec_get_hw_frames_parameters = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVBufferRef> device_ref,
  ffi.Int32 hw_pix_fmt,
  ffi.Pointer<ffi.Pointer<AVBufferRef>> out_frames_ref,
);

typedef _dart_avcodec_get_hw_frames_parameters = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVBufferRef> device_ref,
  int hw_pix_fmt,
  ffi.Pointer<ffi.Pointer<AVBufferRef>> out_frames_ref,
);

typedef _c_av_parser_iterate = ffi.Pointer<AVCodecParser> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _dart_av_parser_iterate = ffi.Pointer<AVCodecParser> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _c_av_parser_next = ffi.Pointer<AVCodecParser> Function(
  ffi.Pointer<AVCodecParser> c,
);

typedef _dart_av_parser_next = ffi.Pointer<AVCodecParser> Function(
  ffi.Pointer<AVCodecParser> c,
);

typedef _c_av_register_codec_parser = ffi.Void Function(
  ffi.Pointer<AVCodecParser> parser,
);

typedef _dart_av_register_codec_parser = void Function(
  ffi.Pointer<AVCodecParser> parser,
);

typedef _c_av_parser_init = ffi.Pointer<AVCodecParserContext> Function(
  ffi.Int32 codec_id,
);

typedef _dart_av_parser_init = ffi.Pointer<AVCodecParserContext> Function(
  int codec_id,
);

typedef _c_av_parser_parse2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecParserContext> s,
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
  ffi.Pointer<ffi.Int32> poutbuf_size,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 buf_size,
  ffi.Int64 pts,
  ffi.Int64 dts,
  ffi.Int64 pos,
);

typedef _dart_av_parser_parse2 = int Function(
  ffi.Pointer<AVCodecParserContext> s,
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
  ffi.Pointer<ffi.Int32> poutbuf_size,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
  int pts,
  int dts,
  int pos,
);

typedef _c_av_parser_change = ffi.Int32 Function(
  ffi.Pointer<AVCodecParserContext> s,
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
  ffi.Pointer<ffi.Int32> poutbuf_size,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 buf_size,
  ffi.Int32 keyframe,
);

typedef _dart_av_parser_change = int Function(
  ffi.Pointer<AVCodecParserContext> s,
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
  ffi.Pointer<ffi.Int32> poutbuf_size,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
  int keyframe,
);

typedef _c_av_parser_close = ffi.Void Function(
  ffi.Pointer<AVCodecParserContext> s,
);

typedef _dart_av_parser_close = void Function(
  ffi.Pointer<AVCodecParserContext> s,
);

typedef _c_avcodec_encode_audio2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<ffi.Int32> got_packet_ptr,
);

typedef _dart_avcodec_encode_audio2 = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<ffi.Int32> got_packet_ptr,
);

typedef _c_avcodec_encode_video2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<ffi.Int32> got_packet_ptr,
);

typedef _dart_avcodec_encode_video2 = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVPacket> avpkt,
  ffi.Pointer<AVFrame> frame,
  ffi.Pointer<ffi.Int32> got_packet_ptr,
);

typedef _c_avcodec_encode_subtitle = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 buf_size,
  ffi.Pointer<AVSubtitle> sub,
);

typedef _dart_avcodec_encode_subtitle = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
  ffi.Pointer<AVSubtitle> sub,
);

typedef _c_avpicture_alloc = ffi.Int32 Function(
  ffi.Pointer<AVPicture> picture,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_avpicture_alloc = int Function(
  ffi.Pointer<AVPicture> picture,
  int pix_fmt,
  int width,
  int height,
);

typedef _c_avpicture_free = ffi.Void Function(
  ffi.Pointer<AVPicture> picture,
);

typedef _dart_avpicture_free = void Function(
  ffi.Pointer<AVPicture> picture,
);

typedef _c_avpicture_fill = ffi.Int32 Function(
  ffi.Pointer<AVPicture> picture,
  ffi.Pointer<ffi.Uint8> ptr,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_avpicture_fill = int Function(
  ffi.Pointer<AVPicture> picture,
  ffi.Pointer<ffi.Uint8> ptr,
  int pix_fmt,
  int width,
  int height,
);

typedef _c_avpicture_layout = ffi.Int32 Function(
  ffi.Pointer<AVPicture> src,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Pointer<ffi.Uint8> dest,
  ffi.Int32 dest_size,
);

typedef _dart_avpicture_layout = int Function(
  ffi.Pointer<AVPicture> src,
  int pix_fmt,
  int width,
  int height,
  ffi.Pointer<ffi.Uint8> dest,
  int dest_size,
);

typedef _c_avpicture_get_size = ffi.Int32 Function(
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_avpicture_get_size = int Function(
  int pix_fmt,
  int width,
  int height,
);

typedef _c_av_picture_copy = ffi.Void Function(
  ffi.Pointer<AVPicture> dst,
  ffi.Pointer<AVPicture> src,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_av_picture_copy = void Function(
  ffi.Pointer<AVPicture> dst,
  ffi.Pointer<AVPicture> src,
  int pix_fmt,
  int width,
  int height,
);

typedef _c_av_picture_crop = ffi.Int32 Function(
  ffi.Pointer<AVPicture> dst,
  ffi.Pointer<AVPicture> src,
  ffi.Int32 pix_fmt,
  ffi.Int32 top_band,
  ffi.Int32 left_band,
);

typedef _dart_av_picture_crop = int Function(
  ffi.Pointer<AVPicture> dst,
  ffi.Pointer<AVPicture> src,
  int pix_fmt,
  int top_band,
  int left_band,
);

typedef _c_av_picture_pad = ffi.Int32 Function(
  ffi.Pointer<AVPicture> dst,
  ffi.Pointer<AVPicture> src,
  ffi.Int32 height,
  ffi.Int32 width,
  ffi.Int32 pix_fmt,
  ffi.Int32 padtop,
  ffi.Int32 padbottom,
  ffi.Int32 padleft,
  ffi.Int32 padright,
  ffi.Pointer<ffi.Int32> color,
);

typedef _dart_av_picture_pad = int Function(
  ffi.Pointer<AVPicture> dst,
  ffi.Pointer<AVPicture> src,
  int height,
  int width,
  int pix_fmt,
  int padtop,
  int padbottom,
  int padleft,
  int padright,
  ffi.Pointer<ffi.Int32> color,
);

typedef _c_avcodec_get_chroma_sub_sample = ffi.Void Function(
  ffi.Int32 pix_fmt,
  ffi.Pointer<ffi.Int32> h_shift,
  ffi.Pointer<ffi.Int32> v_shift,
);

typedef _dart_avcodec_get_chroma_sub_sample = void Function(
  int pix_fmt,
  ffi.Pointer<ffi.Int32> h_shift,
  ffi.Pointer<ffi.Int32> v_shift,
);

typedef _c_avcodec_pix_fmt_to_codec_tag = ffi.Uint32 Function(
  ffi.Int32 pix_fmt,
);

typedef _dart_avcodec_pix_fmt_to_codec_tag = int Function(
  int pix_fmt,
);

typedef _c_avcodec_get_pix_fmt_loss = ffi.Int32 Function(
  ffi.Int32 dst_pix_fmt,
  ffi.Int32 src_pix_fmt,
  ffi.Int32 has_alpha,
);

typedef _dart_avcodec_get_pix_fmt_loss = int Function(
  int dst_pix_fmt,
  int src_pix_fmt,
  int has_alpha,
);

typedef _c_avcodec_find_best_pix_fmt_of_list = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> pix_fmt_list,
  ffi.Int32 src_pix_fmt,
  ffi.Int32 has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _dart_avcodec_find_best_pix_fmt_of_list = int Function(
  ffi.Pointer<ffi.Int32> pix_fmt_list,
  int src_pix_fmt,
  int has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _c_avcodec_find_best_pix_fmt_of_2 = ffi.Int32 Function(
  ffi.Int32 dst_pix_fmt1,
  ffi.Int32 dst_pix_fmt2,
  ffi.Int32 src_pix_fmt,
  ffi.Int32 has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _dart_avcodec_find_best_pix_fmt_of_2 = int Function(
  int dst_pix_fmt1,
  int dst_pix_fmt2,
  int src_pix_fmt,
  int has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _c_avcodec_find_best_pix_fmt2 = ffi.Int32 Function(
  ffi.Int32 dst_pix_fmt1,
  ffi.Int32 dst_pix_fmt2,
  ffi.Int32 src_pix_fmt,
  ffi.Int32 has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _dart_avcodec_find_best_pix_fmt2 = int Function(
  int dst_pix_fmt1,
  int dst_pix_fmt2,
  int src_pix_fmt,
  int has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _c_avcodec_default_get_format = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<ffi.Int32> fmt,
);

typedef _dart_avcodec_default_get_format = int Function(
  ffi.Pointer<AVCodecContext> s,
  ffi.Pointer<ffi.Int32> fmt,
);

typedef _c_av_get_codec_tag_string = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Uint64 buf_size,
  ffi.Uint32 codec_tag,
);

typedef _dart_av_get_codec_tag_string = int Function(
  ffi.Pointer<ffi.Int8> buf,
  int buf_size,
  int codec_tag,
);

typedef _c_avcodec_string = ffi.Void Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buf_size,
  ffi.Pointer<AVCodecContext> enc,
  ffi.Int32 encode,
);

typedef _dart_avcodec_string = void Function(
  ffi.Pointer<ffi.Int8> buf,
  int buf_size,
  ffi.Pointer<AVCodecContext> enc,
  int encode,
);

typedef _c_av_get_profile_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVCodec> codec,
  ffi.Int32 profile,
);

typedef _dart_av_get_profile_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVCodec> codec,
  int profile,
);

typedef _c_avcodec_profile_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 codec_id,
  ffi.Int32 profile,
);

typedef _dart_avcodec_profile_name = ffi.Pointer<ffi.Int8> Function(
  int codec_id,
  int profile,
);

typedef _typedefC_41 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_avcodec_default_execute = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> c,
  ffi.Pointer<ffi.NativeFunction<_typedefC_41>> func,
  ffi.Pointer<ffi.Void> arg,
  ffi.Pointer<ffi.Int32> ret,
  ffi.Int32 count,
  ffi.Int32 size,
);

typedef _dart_avcodec_default_execute = int Function(
  ffi.Pointer<AVCodecContext> c,
  ffi.Pointer<ffi.NativeFunction<_typedefC_41>> func,
  ffi.Pointer<ffi.Void> arg,
  ffi.Pointer<ffi.Int32> ret,
  int count,
  int size,
);

typedef _typedefC_42 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
  ffi.Int32,
);

typedef _c_avcodec_default_execute2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> c,
  ffi.Pointer<ffi.NativeFunction<_typedefC_42>> func,
  ffi.Pointer<ffi.Void> arg,
  ffi.Pointer<ffi.Int32> ret,
  ffi.Int32 count,
);

typedef _dart_avcodec_default_execute2 = int Function(
  ffi.Pointer<AVCodecContext> c,
  ffi.Pointer<ffi.NativeFunction<_typedefC_42>> func,
  ffi.Pointer<ffi.Void> arg,
  ffi.Pointer<ffi.Int32> ret,
  int count,
);

typedef _c_avcodec_fill_audio_frame = ffi.Int32 Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 nb_channels,
  ffi.Int32 sample_fmt,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 buf_size,
  ffi.Int32 align,
);

typedef _dart_avcodec_fill_audio_frame = int Function(
  ffi.Pointer<AVFrame> frame,
  int nb_channels,
  int sample_fmt,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
  int align,
);

typedef _c_avcodec_flush_buffers = ffi.Void Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_avcodec_flush_buffers = void Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_get_bits_per_sample = ffi.Int32 Function(
  ffi.Int32 codec_id,
);

typedef _dart_av_get_bits_per_sample = int Function(
  int codec_id,
);

typedef _c_av_get_pcm_codec = ffi.Int32 Function(
  ffi.Int32 fmt,
  ffi.Int32 be,
);

typedef _dart_av_get_pcm_codec = int Function(
  int fmt,
  int be,
);

typedef _c_av_get_exact_bits_per_sample = ffi.Int32 Function(
  ffi.Int32 codec_id,
);

typedef _dart_av_get_exact_bits_per_sample = int Function(
  int codec_id,
);

typedef _c_av_get_audio_frame_duration = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Int32 frame_bytes,
);

typedef _dart_av_get_audio_frame_duration = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  int frame_bytes,
);

typedef _c_av_get_audio_frame_duration2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecParameters> par,
  ffi.Int32 frame_bytes,
);

typedef _dart_av_get_audio_frame_duration2 = int Function(
  ffi.Pointer<AVCodecParameters> par,
  int frame_bytes,
);

typedef _c_av_register_bitstream_filter = ffi.Void Function(
  ffi.Pointer<AVBitStreamFilter> bsf,
);

typedef _dart_av_register_bitstream_filter = void Function(
  ffi.Pointer<AVBitStreamFilter> bsf,
);

typedef _c_av_bitstream_filter_init = ffi.Pointer<AVBitStreamFilterContext>
    Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_bitstream_filter_init = ffi.Pointer<AVBitStreamFilterContext>
    Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_bitstream_filter_filter = ffi.Int32 Function(
  ffi.Pointer<AVBitStreamFilterContext> bsfc,
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Int8> args,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
  ffi.Pointer<ffi.Int32> poutbuf_size,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 buf_size,
  ffi.Int32 keyframe,
);

typedef _dart_av_bitstream_filter_filter = int Function(
  ffi.Pointer<AVBitStreamFilterContext> bsfc,
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Int8> args,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> poutbuf,
  ffi.Pointer<ffi.Int32> poutbuf_size,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
  int keyframe,
);

typedef _c_av_bitstream_filter_close = ffi.Void Function(
  ffi.Pointer<AVBitStreamFilterContext> bsf,
);

typedef _dart_av_bitstream_filter_close = void Function(
  ffi.Pointer<AVBitStreamFilterContext> bsf,
);

typedef _c_av_bitstream_filter_next = ffi.Pointer<AVBitStreamFilter> Function(
  ffi.Pointer<AVBitStreamFilter> f,
);

typedef _dart_av_bitstream_filter_next = ffi.Pointer<AVBitStreamFilter>
    Function(
  ffi.Pointer<AVBitStreamFilter> f,
);

typedef _c_av_bsf_next = ffi.Pointer<AVBitStreamFilter> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _dart_av_bsf_next = ffi.Pointer<AVBitStreamFilter> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _c_av_fast_padded_malloc = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  ffi.Uint64 min_size,
);

typedef _dart_av_fast_padded_malloc = void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  int min_size,
);

typedef _c_av_fast_padded_mallocz = ffi.Void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  ffi.Uint64 min_size,
);

typedef _dart_av_fast_padded_mallocz = void Function(
  ffi.Pointer<ffi.Void> ptr,
  ffi.Pointer<ffi.Uint32> size,
  int min_size,
);

typedef _c_av_xiphlacing = ffi.Uint32 Function(
  ffi.Pointer<ffi.Uint8> s,
  ffi.Uint32 v,
);

typedef _dart_av_xiphlacing = int Function(
  ffi.Pointer<ffi.Uint8> s,
  int v,
);

typedef _c_av_register_hwaccel = ffi.Void Function(
  ffi.Pointer<AVHWAccel> hwaccel,
);

typedef _dart_av_register_hwaccel = void Function(
  ffi.Pointer<AVHWAccel> hwaccel,
);

typedef _c_av_hwaccel_next = ffi.Pointer<AVHWAccel> Function(
  ffi.Pointer<AVHWAccel> hwaccel,
);

typedef _dart_av_hwaccel_next = ffi.Pointer<AVHWAccel> Function(
  ffi.Pointer<AVHWAccel> hwaccel,
);

typedef _typedefC_43 = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>>,
  ffi.Int32,
);

typedef _c_av_lockmgr_register = ffi.Int32 Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_43>> cb,
);

typedef _dart_av_lockmgr_register = int Function(
  ffi.Pointer<ffi.NativeFunction<_typedefC_43>> cb,
);

typedef _c_avcodec_is_open = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> s,
);

typedef _dart_avcodec_is_open = int Function(
  ffi.Pointer<AVCodecContext> s,
);

typedef _c_av_cpb_properties_alloc = ffi.Pointer<AVCPBProperties> Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_av_cpb_properties_alloc = ffi.Pointer<AVCPBProperties> Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_av_opt_show2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Void> av_log_obj,
  ffi.Int32 req_flags,
  ffi.Int32 rej_flags,
);

typedef _dart_av_opt_show2 = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Void> av_log_obj,
  int req_flags,
  int rej_flags,
);

typedef _c_av_opt_set_defaults = ffi.Void Function(
  ffi.Pointer<ffi.Void> s,
);

typedef _dart_av_opt_set_defaults = void Function(
  ffi.Pointer<ffi.Void> s,
);

typedef _c_av_opt_set_defaults2 = ffi.Void Function(
  ffi.Pointer<ffi.Void> s,
  ffi.Int32 mask,
  ffi.Int32 flags,
);

typedef _dart_av_opt_set_defaults2 = void Function(
  ffi.Pointer<ffi.Void> s,
  int mask,
  int flags,
);

typedef _c_av_set_options_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ctx,
  ffi.Pointer<ffi.Int8> opts,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
);

typedef _dart_av_set_options_string = int Function(
  ffi.Pointer<ffi.Void> ctx,
  ffi.Pointer<ffi.Int8> opts,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
);

typedef _c_av_opt_set_from_string = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> ctx,
  ffi.Pointer<ffi.Int8> opts,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> shorthand,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
);

typedef _dart_av_opt_set_from_string = int Function(
  ffi.Pointer<ffi.Void> ctx,
  ffi.Pointer<ffi.Int8> opts,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> shorthand,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
);

typedef _c_av_opt_free = ffi.Void Function(
  ffi.Pointer<ffi.Void> obj,
);

typedef _dart_av_opt_free = void Function(
  ffi.Pointer<ffi.Void> obj,
);

typedef _c_av_opt_flag_is_set = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> field_name,
  ffi.Pointer<ffi.Int8> flag_name,
);

typedef _dart_av_opt_flag_is_set = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> field_name,
  ffi.Pointer<ffi.Int8> flag_name,
);

typedef _c_av_opt_set_dict = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_av_opt_set_dict = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_av_opt_set_dict2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_dict2 = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
  int search_flags,
);

typedef _c_av_opt_get_key_value = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ropts,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
  ffi.Uint32 flags,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> rkey,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> rval,
);

typedef _dart_av_opt_get_key_value = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ropts,
  ffi.Pointer<ffi.Int8> key_val_sep,
  ffi.Pointer<ffi.Int8> pairs_sep,
  int flags,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> rkey,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> rval,
);

typedef _c_av_opt_eval_flags = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Int32> flags_out,
);

typedef _dart_av_opt_eval_flags = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Int32> flags_out,
);

typedef _c_av_opt_eval_int = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Int32> int_out,
);

typedef _dart_av_opt_eval_int = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Int32> int_out,
);

typedef _c_av_opt_eval_int64 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Int64> int64_out,
);

typedef _dart_av_opt_eval_int64 = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Int64> int64_out,
);

typedef _c_av_opt_eval_float = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Float> float_out,
);

typedef _dart_av_opt_eval_float = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Float> float_out,
);

typedef _c_av_opt_eval_double = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Double> double_out,
);

typedef _dart_av_opt_eval_double = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<ffi.Double> double_out,
);

typedef _c_av_opt_eval_q = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<AVRational> q_out,
);

typedef _dart_av_opt_eval_q = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
  ffi.Pointer<ffi.Int8> val,
  ffi.Pointer<AVRational> q_out,
);

typedef _c_av_opt_find = ffi.Pointer<AVOption> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> unit,
  ffi.Int32 opt_flags,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_find = ffi.Pointer<AVOption> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> unit,
  int opt_flags,
  int search_flags,
);

typedef _c_av_opt_find2 = ffi.Pointer<AVOption> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> unit,
  ffi.Int32 opt_flags,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Pointer<ffi.Void>> target_obj,
);

typedef _dart_av_opt_find2 = ffi.Pointer<AVOption> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> unit,
  int opt_flags,
  int search_flags,
  ffi.Pointer<ffi.Pointer<ffi.Void>> target_obj,
);

typedef _c_av_opt_next = ffi.Pointer<AVOption> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> prev,
);

typedef _dart_av_opt_next = ffi.Pointer<AVOption> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> prev,
);

typedef _c_av_opt_child_next = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Void> prev,
);

typedef _dart_av_opt_child_next = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Void> prev,
);

typedef _c_av_opt_child_class_next = ffi.Pointer<AVClass> Function(
  ffi.Pointer<AVClass> parent,
  ffi.Pointer<AVClass> prev,
);

typedef _dart_av_opt_child_class_next = ffi.Pointer<AVClass> Function(
  ffi.Pointer<AVClass> parent,
  ffi.Pointer<AVClass> prev,
);

typedef _c_av_opt_child_class_iterate = ffi.Pointer<AVClass> Function(
  ffi.Pointer<AVClass> parent,
  ffi.Pointer<ffi.Pointer<ffi.Void>> iter,
);

typedef _dart_av_opt_child_class_iterate = ffi.Pointer<AVClass> Function(
  ffi.Pointer<AVClass> parent,
  ffi.Pointer<ffi.Pointer<ffi.Void>> iter,
);

typedef _c_av_opt_set = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> val,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> val,
  int search_flags,
);

typedef _c_av_opt_set_int = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int64 val,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_int = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int val,
  int search_flags,
);

typedef _c_av_opt_set_double = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Double val,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_double = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  double val,
  int search_flags,
);

typedef _c_av_opt_set_bin = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Uint8> val,
  ffi.Int32 size,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_bin = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Uint8> val,
  int size,
  int search_flags,
);

typedef _c_av_opt_set_image_size = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 w,
  ffi.Int32 h,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_image_size = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int w,
  int h,
  int search_flags,
);

typedef _c_av_opt_set_pixel_fmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 fmt,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_pixel_fmt = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int fmt,
  int search_flags,
);

typedef _c_av_opt_set_sample_fmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 fmt,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_sample_fmt = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int fmt,
  int search_flags,
);

typedef _c_av_opt_set_channel_layout = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int64 ch_layout,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_channel_layout = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int ch_layout,
  int search_flags,
);

typedef _c_av_opt_set_dict_val = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<AVDictionary> val,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_set_dict_val = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<AVDictionary> val,
  int search_flags,
);

typedef _c_av_opt_get = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> out_val,
);

typedef _dart_av_opt_get = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> out_val,
);

typedef _c_av_opt_get_int = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Int64> out_val,
);

typedef _dart_av_opt_get_int = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Int64> out_val,
);

typedef _c_av_opt_get_double = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Double> out_val,
);

typedef _dart_av_opt_get_double = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Double> out_val,
);

typedef _c_av_opt_get_q = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<AVRational> out_val,
);

typedef _dart_av_opt_get_q = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<AVRational> out_val,
);

typedef _c_av_opt_get_image_size = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Int32> w_out,
  ffi.Pointer<ffi.Int32> h_out,
);

typedef _dart_av_opt_get_image_size = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Int32> w_out,
  ffi.Pointer<ffi.Int32> h_out,
);

typedef _c_av_opt_get_pixel_fmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Int32> out_fmt,
);

typedef _dart_av_opt_get_pixel_fmt = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Int32> out_fmt,
);

typedef _c_av_opt_get_sample_fmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Int32> out_fmt,
);

typedef _dart_av_opt_get_sample_fmt = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Int32> out_fmt,
);

typedef _c_av_opt_get_video_rate = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<AVRational> out_val,
);

typedef _dart_av_opt_get_video_rate = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<AVRational> out_val,
);

typedef _c_av_opt_get_channel_layout = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Int64> ch_layout,
);

typedef _dart_av_opt_get_channel_layout = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Int64> ch_layout,
);

typedef _c_av_opt_get_dict_val = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
  ffi.Pointer<ffi.Pointer<AVDictionary>> out_val,
);

typedef _dart_av_opt_get_dict_val = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
  ffi.Pointer<ffi.Pointer<AVDictionary>> out_val,
);

typedef _c_av_opt_ptr = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVClass> avclass,
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_opt_ptr = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVClass> avclass,
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_opt_freep_ranges = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVOptionRanges>> ranges,
);

typedef _dart_av_opt_freep_ranges = void Function(
  ffi.Pointer<ffi.Pointer<AVOptionRanges>> ranges,
);

typedef _c_av_opt_query_ranges = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> key,
  ffi.Int32 flags,
);

typedef _dart_av_opt_query_ranges = int Function(
  ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> key,
  int flags,
);

typedef _c_av_opt_copy = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> dest,
  ffi.Pointer<ffi.Void> src,
);

typedef _dart_av_opt_copy = int Function(
  ffi.Pointer<ffi.Void> dest,
  ffi.Pointer<ffi.Void> src,
);

typedef _c_av_opt_query_ranges_default = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> key,
  ffi.Int32 flags,
);

typedef _dart_av_opt_query_ranges_default = int Function(
  ffi.Pointer<ffi.Pointer<AVOptionRanges>> arg0,
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> key,
  int flags,
);

typedef _c_av_opt_is_set_to_default = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
);

typedef _dart_av_opt_is_set_to_default = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<AVOption> o,
);

typedef _c_av_opt_is_set_to_default_by_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  ffi.Int32 search_flags,
);

typedef _dart_av_opt_is_set_to_default_by_name = int Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Pointer<ffi.Int8> name,
  int search_flags,
);

typedef _c_av_opt_serialize = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> obj,
  ffi.Int32 opt_flags,
  ffi.Int32 flags,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> buffer,
  ffi.Int8 key_val_sep,
  ffi.Int8 pairs_sep,
);

typedef _dart_av_opt_serialize = int Function(
  ffi.Pointer<ffi.Void> obj,
  int opt_flags,
  int flags,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> buffer,
  int key_val_sep,
  int pairs_sep,
);

typedef _c_avcodec_dct_alloc = ffi.Pointer<AVDCT> Function();

typedef _dart_avcodec_dct_alloc = ffi.Pointer<AVDCT> Function();

typedef _c_avcodec_dct_init = ffi.Int32 Function(
  ffi.Pointer<AVDCT> arg0,
);

typedef _dart_avcodec_dct_init = int Function(
  ffi.Pointer<AVDCT> arg0,
);

typedef _c_avcodec_dct_get_class = ffi.Pointer<AVClass> Function();

typedef _dart_avcodec_dct_get_class = ffi.Pointer<AVClass> Function();

typedef _c_av_fft_init = ffi.Pointer<FFTContext> Function(
  ffi.Int32 nbits,
  ffi.Int32 inverse,
);

typedef _dart_av_fft_init = ffi.Pointer<FFTContext> Function(
  int nbits,
  int inverse,
);

typedef _c_av_fft_permute = ffi.Void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<FFTComplex> z,
);

typedef _dart_av_fft_permute = void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<FFTComplex> z,
);

typedef _c_av_fft_calc = ffi.Void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<FFTComplex> z,
);

typedef _dart_av_fft_calc = void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<FFTComplex> z,
);

typedef _c_av_fft_end = ffi.Void Function(
  ffi.Pointer<FFTContext> s,
);

typedef _dart_av_fft_end = void Function(
  ffi.Pointer<FFTContext> s,
);

typedef _c_av_mdct_init = ffi.Pointer<FFTContext> Function(
  ffi.Int32 nbits,
  ffi.Int32 inverse,
  ffi.Double scale,
);

typedef _dart_av_mdct_init = ffi.Pointer<FFTContext> Function(
  int nbits,
  int inverse,
  double scale,
);

typedef _c_av_imdct_calc = ffi.Void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<ffi.Float> output,
  ffi.Pointer<ffi.Float> input,
);

typedef _dart_av_imdct_calc = void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<ffi.Float> output,
  ffi.Pointer<ffi.Float> input,
);

typedef _c_av_imdct_half = ffi.Void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<ffi.Float> output,
  ffi.Pointer<ffi.Float> input,
);

typedef _dart_av_imdct_half = void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<ffi.Float> output,
  ffi.Pointer<ffi.Float> input,
);

typedef _c_av_mdct_calc = ffi.Void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<ffi.Float> output,
  ffi.Pointer<ffi.Float> input,
);

typedef _dart_av_mdct_calc = void Function(
  ffi.Pointer<FFTContext> s,
  ffi.Pointer<ffi.Float> output,
  ffi.Pointer<ffi.Float> input,
);

typedef _c_av_mdct_end = ffi.Void Function(
  ffi.Pointer<FFTContext> s,
);

typedef _dart_av_mdct_end = void Function(
  ffi.Pointer<FFTContext> s,
);

typedef _c_av_rdft_init = ffi.Pointer<RDFTContext> Function(
  ffi.Int32 nbits,
  ffi.Int32 trans,
);

typedef _dart_av_rdft_init = ffi.Pointer<RDFTContext> Function(
  int nbits,
  int trans,
);

typedef _c_av_rdft_calc = ffi.Void Function(
  ffi.Pointer<RDFTContext> s,
  ffi.Pointer<ffi.Float> data,
);

typedef _dart_av_rdft_calc = void Function(
  ffi.Pointer<RDFTContext> s,
  ffi.Pointer<ffi.Float> data,
);

typedef _c_av_rdft_end = ffi.Void Function(
  ffi.Pointer<RDFTContext> s,
);

typedef _dart_av_rdft_end = void Function(
  ffi.Pointer<RDFTContext> s,
);

typedef _c_av_dct_init = ffi.Pointer<DCTContext> Function(
  ffi.Int32 nbits,
  ffi.Int32 type,
);

typedef _dart_av_dct_init = ffi.Pointer<DCTContext> Function(
  int nbits,
  int type,
);

typedef _c_av_dct_calc = ffi.Void Function(
  ffi.Pointer<DCTContext> s,
  ffi.Pointer<ffi.Float> data,
);

typedef _dart_av_dct_calc = void Function(
  ffi.Pointer<DCTContext> s,
  ffi.Pointer<ffi.Float> data,
);

typedef _c_av_dct_end = ffi.Void Function(
  ffi.Pointer<DCTContext> s,
);

typedef _dart_av_dct_end = void Function(
  ffi.Pointer<DCTContext> s,
);

typedef _c_av_d3d11va_alloc_context = ffi.Pointer<AVD3D11VAContext> Function();

typedef _dart_av_d3d11va_alloc_context = ffi.Pointer<AVD3D11VAContext>
    Function();

typedef _c_av_dirac_parse_sequence_header = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVDiracSeqHeader>> dsh,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Uint64 buf_size,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_dirac_parse_sequence_header = int Function(
  ffi.Pointer<ffi.Pointer<AVDiracSeqHeader>> dsh,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_dv_frame_profile = ffi.Pointer<AVDVProfile> Function(
  ffi.Pointer<AVDVProfile> sys,
  ffi.Pointer<ffi.Uint8> frame,
  ffi.Uint32 buf_size,
);

typedef _dart_av_dv_frame_profile = ffi.Pointer<AVDVProfile> Function(
  ffi.Pointer<AVDVProfile> sys,
  ffi.Pointer<ffi.Uint8> frame,
  int buf_size,
);

typedef _c_av_dv_codec_profile = ffi.Pointer<AVDVProfile> Function(
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 pix_fmt,
);

typedef _dart_av_dv_codec_profile = ffi.Pointer<AVDVProfile> Function(
  int width,
  int height,
  int pix_fmt,
);

typedef _c_av_jni_set_java_vm = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> vm,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_jni_set_java_vm = int Function(
  ffi.Pointer<ffi.Void> vm,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_jni_get_java_vm = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_jni_get_java_vm = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_mediacodec_alloc_context = ffi.Pointer<AVMediaCodecContext>
    Function();

typedef _dart_av_mediacodec_alloc_context = ffi.Pointer<AVMediaCodecContext>
    Function();

typedef _c_av_mediacodec_default_init = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVMediaCodecContext> ctx,
  ffi.Pointer<ffi.Void> surface,
);

typedef _dart_av_mediacodec_default_init = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVMediaCodecContext> ctx,
  ffi.Pointer<ffi.Void> surface,
);

typedef _c_av_mediacodec_default_free = ffi.Void Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_mediacodec_default_free = void Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_mediacodec_release_buffer = ffi.Int32 Function(
  ffi.Pointer<MediaCodecBuffer> buffer,
  ffi.Int32 render,
);

typedef _dart_av_mediacodec_release_buffer = int Function(
  ffi.Pointer<MediaCodecBuffer> buffer,
  int render,
);

typedef _c_av_mediacodec_render_buffer_at_time = ffi.Int32 Function(
  ffi.Pointer<MediaCodecBuffer> buffer,
  ffi.Int64 time,
);

typedef _dart_av_mediacodec_render_buffer_at_time = int Function(
  ffi.Pointer<MediaCodecBuffer> buffer,
  int time,
);

typedef _c_av_qsv_alloc_context = ffi.Pointer<AVQSVContext> Function();

typedef _dart_av_qsv_alloc_context = ffi.Pointer<AVQSVContext> Function();

typedef _c_av_alloc_vdpaucontext = ffi.Pointer<AVVDPAUContext> Function();

typedef _dart_av_alloc_vdpaucontext = ffi.Pointer<AVVDPAUContext> Function();

typedef AVVDPAU_Render2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<AVFrame>,
  ffi.Pointer<ffi.Int32>,
  ffi.Uint32,
  ffi.Pointer<ffi.Int32>,
);

typedef _c_av_vdpau_hwaccel_get_render2
    = ffi.Pointer<ffi.NativeFunction<AVVDPAU_Render2>> Function(
  ffi.Pointer<AVVDPAUContext> arg0,
);

typedef _dart_av_vdpau_hwaccel_get_render2
    = ffi.Pointer<ffi.NativeFunction<AVVDPAU_Render2>> Function(
  ffi.Pointer<AVVDPAUContext> arg0,
);

typedef _c_av_vdpau_hwaccel_set_render2 = ffi.Void Function(
  ffi.Pointer<AVVDPAUContext> arg0,
  ffi.Pointer<ffi.NativeFunction<AVVDPAU_Render2>> arg1,
);

typedef _dart_av_vdpau_hwaccel_set_render2 = void Function(
  ffi.Pointer<AVVDPAUContext> arg0,
  ffi.Pointer<ffi.NativeFunction<AVVDPAU_Render2>> arg1,
);

typedef _c_av_vdpau_bind_context = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Int32 device,
  ffi.Pointer<ffi.Int32> get_proc_address,
  ffi.Uint32 flags,
);

typedef _dart_av_vdpau_bind_context = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  int device,
  ffi.Pointer<ffi.Int32> get_proc_address,
  int flags,
);

typedef _c_av_vdpau_get_surface_parameters = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Int32> type,
  ffi.Pointer<ffi.Uint32> width,
  ffi.Pointer<ffi.Uint32> height,
);

typedef _dart_av_vdpau_get_surface_parameters = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Int32> type,
  ffi.Pointer<ffi.Uint32> width,
  ffi.Pointer<ffi.Uint32> height,
);

typedef _c_av_vdpau_alloc_context = ffi.Pointer<AVVDPAUContext> Function();

typedef _dart_av_vdpau_alloc_context = ffi.Pointer<AVVDPAUContext> Function();

typedef _c_av_vdpau_get_profile = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Int32> profile,
);

typedef _dart_av_vdpau_get_profile = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<ffi.Int32> profile,
);

typedef _c_av_videotoolbox_alloc_context = ffi.Pointer<AVVideotoolboxContext>
    Function();

typedef _dart_av_videotoolbox_alloc_context = ffi.Pointer<AVVideotoolboxContext>
    Function();

typedef _c_av_videotoolbox_default_init = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_videotoolbox_default_init = int Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_videotoolbox_default_init2 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVVideotoolboxContext> vtctx,
);

typedef _dart_av_videotoolbox_default_init2 = int Function(
  ffi.Pointer<AVCodecContext> avctx,
  ffi.Pointer<AVVideotoolboxContext> vtctx,
);

typedef _c_av_videotoolbox_default_free = ffi.Void Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _dart_av_videotoolbox_default_free = void Function(
  ffi.Pointer<AVCodecContext> avctx,
);

typedef _c_av_vorbis_parse_init = ffi.Pointer<AVVorbisParseContext> Function(
  ffi.Pointer<ffi.Uint8> extradata,
  ffi.Int32 extradata_size,
);

typedef _dart_av_vorbis_parse_init = ffi.Pointer<AVVorbisParseContext> Function(
  ffi.Pointer<ffi.Uint8> extradata,
  int extradata_size,
);

typedef _c_av_vorbis_parse_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVVorbisParseContext>> s,
);

typedef _dart_av_vorbis_parse_free = void Function(
  ffi.Pointer<ffi.Pointer<AVVorbisParseContext>> s,
);

typedef _c_av_vorbis_parse_frame_flags = ffi.Int32 Function(
  ffi.Pointer<AVVorbisParseContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 buf_size,
  ffi.Pointer<ffi.Int32> flags,
);

typedef _dart_av_vorbis_parse_frame_flags = int Function(
  ffi.Pointer<AVVorbisParseContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
  ffi.Pointer<ffi.Int32> flags,
);

typedef _c_av_vorbis_parse_frame = ffi.Int32 Function(
  ffi.Pointer<AVVorbisParseContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 buf_size,
);

typedef _dart_av_vorbis_parse_frame = int Function(
  ffi.Pointer<AVVorbisParseContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_size,
);

typedef _c_av_vorbis_parse_reset = ffi.Void Function(
  ffi.Pointer<AVVorbisParseContext> s,
);

typedef _dart_av_vorbis_parse_reset = void Function(
  ffi.Pointer<AVVorbisParseContext> s,
);

typedef _c_avio_find_protocol_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_avio_find_protocol_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_avio_check = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> url,
  ffi.Int32 flags,
);

typedef _dart_avio_check = int Function(
  ffi.Pointer<ffi.Int8> url,
  int flags,
);

typedef _c_avpriv_io_move = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> url_src,
  ffi.Pointer<ffi.Int8> url_dst,
);

typedef _dart_avpriv_io_move = int Function(
  ffi.Pointer<ffi.Int8> url_src,
  ffi.Pointer<ffi.Int8> url_dst,
);

typedef _c_avpriv_io_delete = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_avpriv_io_delete = int Function(
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_avio_open_dir = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avio_open_dir = int Function(
  ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_avio_read_dir = ffi.Int32 Function(
  ffi.Pointer<AVIODirContext> s,
  ffi.Pointer<ffi.Pointer<AVIODirEntry>> next,
);

typedef _dart_avio_read_dir = int Function(
  ffi.Pointer<AVIODirContext> s,
  ffi.Pointer<ffi.Pointer<AVIODirEntry>> next,
);

typedef _c_avio_close_dir = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
);

typedef _dart_avio_close_dir = int Function(
  ffi.Pointer<ffi.Pointer<AVIODirContext>> s,
);

typedef _c_avio_free_directory_entry = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVIODirEntry>> entry,
);

typedef _dart_avio_free_directory_entry = void Function(
  ffi.Pointer<ffi.Pointer<AVIODirEntry>> entry,
);

typedef _typedefC_57 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);

typedef _typedefC_58 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);

typedef _typedefC_59 = ffi.Int64 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int64,
  ffi.Int32,
);

typedef _c_avio_alloc_context = ffi.Pointer<AVIOContext> Function(
  ffi.Pointer<ffi.Uint8> buffer,
  ffi.Int32 buffer_size,
  ffi.Int32 write_flag,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.NativeFunction<_typedefC_57>> read_packet,
  ffi.Pointer<ffi.NativeFunction<_typedefC_58>> write_packet,
  ffi.Pointer<ffi.NativeFunction<_typedefC_59>> seek,
);

typedef _dart_avio_alloc_context = ffi.Pointer<AVIOContext> Function(
  ffi.Pointer<ffi.Uint8> buffer,
  int buffer_size,
  int write_flag,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.NativeFunction<_typedefC_57>> read_packet,
  ffi.Pointer<ffi.NativeFunction<_typedefC_58>> write_packet,
  ffi.Pointer<ffi.NativeFunction<_typedefC_59>> seek,
);

typedef _c_avio_context_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
);

typedef _dart_avio_context_free = void Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
);

typedef _c_avio_w8 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Int32 b,
);

typedef _dart_avio_w8 = void Function(
  ffi.Pointer<AVIOContext> s,
  int b,
);

typedef _c_avio_write = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 size,
);

typedef _dart_avio_write = void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  int size,
);

typedef _c_avio_wl64 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint64 val,
);

typedef _dart_avio_wl64 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_wb64 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint64 val,
);

typedef _dart_avio_wb64 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_wl32 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint32 val,
);

typedef _dart_avio_wl32 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_wb32 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint32 val,
);

typedef _dart_avio_wb32 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_wl24 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint32 val,
);

typedef _dart_avio_wl24 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_wb24 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint32 val,
);

typedef _dart_avio_wb24 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_wl16 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint32 val,
);

typedef _dart_avio_wl16 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_wb16 = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Uint32 val,
);

typedef _dart_avio_wb16 = void Function(
  ffi.Pointer<AVIOContext> s,
  int val,
);

typedef _c_avio_put_str = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_avio_put_str = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_avio_put_str16le = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_avio_put_str16le = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_avio_put_str16be = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_avio_put_str16be = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_avio_write_marker = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Int64 time,
  ffi.Int32 type,
);

typedef _dart_avio_write_marker = void Function(
  ffi.Pointer<AVIOContext> s,
  int time,
  int type,
);

typedef _c_avio_seek = ffi.Int64 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Int64 offset,
  ffi.Int32 whence,
);

typedef _dart_avio_seek = int Function(
  ffi.Pointer<AVIOContext> s,
  int offset,
  int whence,
);

typedef _c_avio_skip = ffi.Int64 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Int64 offset,
);

typedef _dart_avio_skip = int Function(
  ffi.Pointer<AVIOContext> s,
  int offset,
);

typedef _c_avio_tell = ffi.Int64 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_tell = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_size = ffi.Int64 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_size = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_feof = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_feof = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_printf = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_avio_printf = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_avio_print_string_array = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> strings,
);

typedef _dart_avio_print_string_array = void Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> strings,
);

typedef _c_avio_flush = ffi.Void Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_flush = void Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_read = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 size,
);

typedef _dart_avio_read = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  int size,
);

typedef _c_avio_read_partial = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 size,
);

typedef _dart_avio_read_partial = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Uint8> buf,
  int size,
);

typedef _c_avio_r8 = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_r8 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rl16 = ffi.Uint32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rl16 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rl24 = ffi.Uint32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rl24 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rl32 = ffi.Uint32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rl32 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rl64 = ffi.Uint64 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rl64 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rb16 = ffi.Uint32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rb16 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rb24 = ffi.Uint32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rb24 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rb32 = ffi.Uint32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rb32 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_rb64 = ffi.Uint64 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_rb64 = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_get_str = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> pb,
  ffi.Int32 maxlen,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buflen,
);

typedef _dart_avio_get_str = int Function(
  ffi.Pointer<AVIOContext> pb,
  int maxlen,
  ffi.Pointer<ffi.Int8> buf,
  int buflen,
);

typedef _c_avio_get_str16le = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> pb,
  ffi.Int32 maxlen,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buflen,
);

typedef _dart_avio_get_str16le = int Function(
  ffi.Pointer<AVIOContext> pb,
  int maxlen,
  ffi.Pointer<ffi.Int8> buf,
  int buflen,
);

typedef _c_avio_get_str16be = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> pb,
  ffi.Int32 maxlen,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buflen,
);

typedef _dart_avio_get_str16be = int Function(
  ffi.Pointer<AVIOContext> pb,
  int maxlen,
  ffi.Pointer<ffi.Int8> buf,
  int buflen,
);

typedef _c_avio_open = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ffi.Pointer<ffi.Int8> url,
  ffi.Int32 flags,
);

typedef _dart_avio_open = int Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ffi.Pointer<ffi.Int8> url,
  int flags,
);

typedef _c_avio_open2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ffi.Pointer<ffi.Int8> url,
  ffi.Int32 flags,
  ffi.Pointer<AVIOInterruptCB> int_cb,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avio_open2 = int Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
  ffi.Pointer<ffi.Int8> url,
  int flags,
  ffi.Pointer<AVIOInterruptCB> int_cb,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_avio_close = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _dart_avio_close = int Function(
  ffi.Pointer<AVIOContext> s,
);

typedef _c_avio_closep = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
);

typedef _dart_avio_closep = int Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
);

typedef _c_avio_open_dyn_buf = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
);

typedef _dart_avio_open_dyn_buf = int Function(
  ffi.Pointer<ffi.Pointer<AVIOContext>> s,
);

typedef _c_avio_get_dyn_buf = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
);

typedef _dart_avio_get_dyn_buf = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
);

typedef _c_avio_close_dyn_buf = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
);

typedef _dart_avio_close_dyn_buf = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> pbuffer,
);

typedef _c_avio_enum_protocols = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  ffi.Int32 output,
);

typedef _dart_avio_enum_protocols = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
  int output,
);

typedef _c_avio_protocol_get_class = ffi.Pointer<AVClass> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_avio_protocol_get_class = ffi.Pointer<AVClass> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_avio_pause = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> h,
  ffi.Int32 pause,
);

typedef _dart_avio_pause = int Function(
  ffi.Pointer<AVIOContext> h,
  int pause,
);

typedef _c_avio_seek_time = ffi.Int64 Function(
  ffi.Pointer<AVIOContext> h,
  ffi.Int32 stream_index,
  ffi.Int64 timestamp,
  ffi.Int32 flags,
);

typedef _dart_avio_seek_time = int Function(
  ffi.Pointer<AVIOContext> h,
  int stream_index,
  int timestamp,
  int flags,
);

typedef _c_avio_read_to_bprint = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> h,
  ffi.Pointer<AVBPrint> pb,
  ffi.Uint64 max_size,
);

typedef _dart_avio_read_to_bprint = int Function(
  ffi.Pointer<AVIOContext> h,
  ffi.Pointer<AVBPrint> pb,
  int max_size,
);

typedef _c_avio_accept = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<AVIOContext>> c,
);

typedef _dart_avio_accept = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<ffi.Pointer<AVIOContext>> c,
);

typedef _c_avio_handshake = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> c,
);

typedef _dart_avio_handshake = int Function(
  ffi.Pointer<AVIOContext> c,
);

typedef _c_av_get_packet = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 size,
);

typedef _dart_av_get_packet = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<AVPacket> pkt,
  int size,
);

typedef _c_av_append_packet = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 size,
);

typedef _dart_av_append_packet = int Function(
  ffi.Pointer<AVIOContext> s,
  ffi.Pointer<AVPacket> pkt,
  int size,
);

typedef _c_av_stream_get_recommended_encoder_configuration
    = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVStream> s,
);

typedef _dart_av_stream_get_recommended_encoder_configuration
    = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVStream> s,
);

typedef _c_av_stream_set_recommended_encoder_configuration = ffi.Void Function(
  ffi.Pointer<AVStream> s,
  ffi.Pointer<ffi.Int8> configuration,
);

typedef _dart_av_stream_set_recommended_encoder_configuration = void Function(
  ffi.Pointer<AVStream> s,
  ffi.Pointer<ffi.Int8> configuration,
);

typedef _c_av_stream_get_parser = ffi.Pointer<AVCodecParserContext> Function(
  ffi.Pointer<AVStream> s,
);

typedef _dart_av_stream_get_parser = ffi.Pointer<AVCodecParserContext> Function(
  ffi.Pointer<AVStream> s,
);

typedef _c_av_stream_get_end_pts = ffi.Int64 Function(
  ffi.Pointer<AVStream> st,
);

typedef _dart_av_stream_get_end_pts = int Function(
  ffi.Pointer<AVStream> st,
);

typedef _c_av_format_get_probe_score = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_probe_score = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_get_video_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_video_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_video_codec = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _dart_av_format_set_video_codec = void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _c_av_format_get_audio_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_audio_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_audio_codec = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _dart_av_format_set_audio_codec = void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _c_av_format_get_subtitle_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_subtitle_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_subtitle_codec = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _dart_av_format_set_subtitle_codec = void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _c_av_format_get_data_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_data_codec = ffi.Pointer<AVCodec> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_data_codec = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _dart_av_format_set_data_codec = void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _c_av_format_get_metadata_header_padding = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_metadata_header_padding = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_metadata_header_padding = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 c,
);

typedef _dart_av_format_set_metadata_header_padding = void Function(
  ffi.Pointer<AVFormatContext> s,
  int c,
);

typedef _c_av_format_get_opaque = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_opaque = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_opaque = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Void> opaque,
);

typedef _dart_av_format_set_opaque = void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Void> opaque,
);

typedef av_format_control_message = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
  ffi.Uint64,
);

typedef _c_av_format_get_control_message_cb
    = ffi.Pointer<ffi.NativeFunction<av_format_control_message>> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_control_message_cb
    = ffi.Pointer<ffi.NativeFunction<av_format_control_message>> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_control_message_cb = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.NativeFunction<av_format_control_message>> callback,
);

typedef _dart_av_format_set_control_message_cb = void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.NativeFunction<av_format_control_message>> callback,
);

typedef AVOpenCallback = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<ffi.Pointer<AVIOContext>>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Pointer<AVIOInterruptCB>,
  ffi.Pointer<ffi.Pointer<AVDictionary>>,
);

typedef _c_av_format_get_open_cb
    = ffi.Pointer<ffi.NativeFunction<AVOpenCallback>> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_get_open_cb
    = ffi.Pointer<ffi.NativeFunction<AVOpenCallback>> Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_format_set_open_cb = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.NativeFunction<AVOpenCallback>> callback,
);

typedef _dart_av_format_set_open_cb = void Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.NativeFunction<AVOpenCallback>> callback,
);

typedef _c_av_format_inject_global_side_data = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_format_inject_global_side_data = void Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_fmt_ctx_get_duration_estimation_method = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> ctx,
);

typedef _dart_av_fmt_ctx_get_duration_estimation_method = int Function(
  ffi.Pointer<AVFormatContext> ctx,
);

typedef _c_avformat_version = ffi.Uint32 Function();

typedef _dart_avformat_version = int Function();

typedef _c_avformat_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avformat_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _c_avformat_license = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avformat_license = ffi.Pointer<ffi.Int8> Function();

typedef _c_av_register_all = ffi.Void Function();

typedef _dart_av_register_all = void Function();

typedef _c_av_register_input_format = ffi.Void Function(
  ffi.Pointer<AVInputFormat> format,
);

typedef _dart_av_register_input_format = void Function(
  ffi.Pointer<AVInputFormat> format,
);

typedef _c_av_register_output_format = ffi.Void Function(
  ffi.Pointer<AVOutputFormat> format,
);

typedef _dart_av_register_output_format = void Function(
  ffi.Pointer<AVOutputFormat> format,
);

typedef _c_avformat_network_init = ffi.Int32 Function();

typedef _dart_avformat_network_init = int Function();

typedef _c_avformat_network_deinit = ffi.Int32 Function();

typedef _dart_avformat_network_deinit = int Function();

typedef _c_av_iformat_next = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVInputFormat> f,
);

typedef _dart_av_iformat_next = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVInputFormat> f,
);

typedef _c_av_oformat_next = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<AVOutputFormat> f,
);

typedef _dart_av_oformat_next = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<AVOutputFormat> f,
);

typedef _c_av_muxer_iterate = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _dart_av_muxer_iterate = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _c_av_demuxer_iterate = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _dart_av_demuxer_iterate = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _c_avformat_alloc_context = ffi.Pointer<AVFormatContext> Function();

typedef _dart_avformat_alloc_context = ffi.Pointer<AVFormatContext> Function();

typedef _c_avformat_free_context = ffi.Void Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_avformat_free_context = void Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_avformat_get_class = ffi.Pointer<AVClass> Function();

typedef _dart_avformat_get_class = ffi.Pointer<AVClass> Function();

typedef _c_avformat_new_stream = ffi.Pointer<AVStream> Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _dart_avformat_new_stream = ffi.Pointer<AVStream> Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVCodec> c,
);

typedef _c_av_stream_add_side_data = ffi.Int32 Function(
  ffi.Pointer<AVStream> st,
  ffi.Int32 type,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint64 size,
);

typedef _dart_av_stream_add_side_data = int Function(
  ffi.Pointer<AVStream> st,
  int type,
  ffi.Pointer<ffi.Uint8> data,
  int size,
);

typedef _c_av_stream_new_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVStream> stream,
  ffi.Int32 type,
  ffi.Int32 size,
);

typedef _dart_av_stream_new_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVStream> stream,
  int type,
  int size,
);

typedef _c_av_stream_get_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVStream> stream,
  ffi.Int32 type,
  ffi.Pointer<ffi.Int32> size,
);

typedef _dart_av_stream_get_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVStream> stream,
  int type,
  ffi.Pointer<ffi.Int32> size,
);

typedef _c_av_new_program = ffi.Pointer<AVProgram> Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 id,
);

typedef _dart_av_new_program = ffi.Pointer<AVProgram> Function(
  ffi.Pointer<AVFormatContext> s,
  int id,
);

typedef _c_avformat_alloc_output_context2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> ctx,
  ffi.Pointer<AVOutputFormat> oformat,
  ffi.Pointer<ffi.Int8> format_name,
  ffi.Pointer<ffi.Int8> filename,
);

typedef _dart_avformat_alloc_output_context2 = int Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> ctx,
  ffi.Pointer<AVOutputFormat> oformat,
  ffi.Pointer<ffi.Int8> format_name,
  ffi.Pointer<ffi.Int8> filename,
);

typedef _c_av_find_input_format = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<ffi.Int8> short_name,
);

typedef _dart_av_find_input_format = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<ffi.Int8> short_name,
);

typedef _c_av_probe_input_format = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVProbeData> pd,
  ffi.Int32 is_opened,
);

typedef _dart_av_probe_input_format = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVProbeData> pd,
  int is_opened,
);

typedef _c_av_probe_input_format2 = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVProbeData> pd,
  ffi.Int32 is_opened,
  ffi.Pointer<ffi.Int32> score_max,
);

typedef _dart_av_probe_input_format2 = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVProbeData> pd,
  int is_opened,
  ffi.Pointer<ffi.Int32> score_max,
);

typedef _c_av_probe_input_format3 = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVProbeData> pd,
  ffi.Int32 is_opened,
  ffi.Pointer<ffi.Int32> score_ret,
);

typedef _dart_av_probe_input_format3 = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVProbeData> pd,
  int is_opened,
  ffi.Pointer<ffi.Int32> score_ret,
);

typedef _c_av_probe_input_buffer2 = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> pb,
  ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Void> logctx,
  ffi.Uint32 offset,
  ffi.Uint32 max_probe_size,
);

typedef _dart_av_probe_input_buffer2 = int Function(
  ffi.Pointer<AVIOContext> pb,
  ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Void> logctx,
  int offset,
  int max_probe_size,
);

typedef _c_av_probe_input_buffer = ffi.Int32 Function(
  ffi.Pointer<AVIOContext> pb,
  ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Void> logctx,
  ffi.Uint32 offset,
  ffi.Uint32 max_probe_size,
);

typedef _dart_av_probe_input_buffer = int Function(
  ffi.Pointer<AVIOContext> pb,
  ffi.Pointer<ffi.Pointer<AVInputFormat>> fmt,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<ffi.Void> logctx,
  int offset,
  int max_probe_size,
);

typedef _c_avformat_open_input = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> ps,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<AVInputFormat> fmt,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avformat_open_input = int Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> ps,
  ffi.Pointer<ffi.Int8> url,
  ffi.Pointer<AVInputFormat> fmt,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_av_demuxer_open = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> ic,
);

typedef _dart_av_demuxer_open = int Function(
  ffi.Pointer<AVFormatContext> ic,
);

typedef _c_avformat_find_stream_info = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> ic,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avformat_find_stream_info = int Function(
  ffi.Pointer<AVFormatContext> ic,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_av_find_program_from_stream = ffi.Pointer<AVProgram> Function(
  ffi.Pointer<AVFormatContext> ic,
  ffi.Pointer<AVProgram> last,
  ffi.Int32 s,
);

typedef _dart_av_find_program_from_stream = ffi.Pointer<AVProgram> Function(
  ffi.Pointer<AVFormatContext> ic,
  ffi.Pointer<AVProgram> last,
  int s,
);

typedef _c_av_program_add_stream_index = ffi.Void Function(
  ffi.Pointer<AVFormatContext> ac,
  ffi.Int32 progid,
  ffi.Uint32 idx,
);

typedef _dart_av_program_add_stream_index = void Function(
  ffi.Pointer<AVFormatContext> ac,
  int progid,
  int idx,
);

typedef _c_av_find_best_stream = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> ic,
  ffi.Int32 type,
  ffi.Int32 wanted_stream_nb,
  ffi.Int32 related_stream,
  ffi.Pointer<ffi.Pointer<AVCodec>> decoder_ret,
  ffi.Int32 flags,
);

typedef _dart_av_find_best_stream = int Function(
  ffi.Pointer<AVFormatContext> ic,
  int type,
  int wanted_stream_nb,
  int related_stream,
  ffi.Pointer<ffi.Pointer<AVCodec>> decoder_ret,
  int flags,
);

typedef _c_av_read_frame = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_read_frame = int Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_seek_frame = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 stream_index,
  ffi.Int64 timestamp,
  ffi.Int32 flags,
);

typedef _dart_av_seek_frame = int Function(
  ffi.Pointer<AVFormatContext> s,
  int stream_index,
  int timestamp,
  int flags,
);

typedef _c_avformat_seek_file = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 stream_index,
  ffi.Int64 min_ts,
  ffi.Int64 ts,
  ffi.Int64 max_ts,
  ffi.Int32 flags,
);

typedef _dart_avformat_seek_file = int Function(
  ffi.Pointer<AVFormatContext> s,
  int stream_index,
  int min_ts,
  int ts,
  int max_ts,
  int flags,
);

typedef _c_avformat_flush = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_avformat_flush = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_read_play = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_read_play = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_read_pause = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_read_pause = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_avformat_close_input = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> s,
);

typedef _dart_avformat_close_input = void Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> s,
);

typedef _c_avformat_write_header = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avformat_write_header = int Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_avformat_init_output = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avformat_init_output = int Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_av_write_frame = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_write_frame = int Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_interleaved_write_frame = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVPacket> pkt,
);

typedef _dart_av_interleaved_write_frame = int Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVPacket> pkt,
);

typedef _c_av_write_uncoded_frame = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 stream_index,
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_write_uncoded_frame = int Function(
  ffi.Pointer<AVFormatContext> s,
  int stream_index,
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_interleaved_write_uncoded_frame = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 stream_index,
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_interleaved_write_uncoded_frame = int Function(
  ffi.Pointer<AVFormatContext> s,
  int stream_index,
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_write_uncoded_frame_query = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 stream_index,
);

typedef _dart_av_write_uncoded_frame_query = int Function(
  ffi.Pointer<AVFormatContext> s,
  int stream_index,
);

typedef _c_av_write_trailer = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_write_trailer = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_guess_format = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<ffi.Int8> short_name,
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Int8> mime_type,
);

typedef _dart_av_guess_format = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<ffi.Int8> short_name,
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Int8> mime_type,
);

typedef _c_av_guess_codec = ffi.Int32 Function(
  ffi.Pointer<AVOutputFormat> fmt,
  ffi.Pointer<ffi.Int8> short_name,
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Int8> mime_type,
  ffi.Int32 type,
);

typedef _dart_av_guess_codec = int Function(
  ffi.Pointer<AVOutputFormat> fmt,
  ffi.Pointer<ffi.Int8> short_name,
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Int8> mime_type,
  int type,
);

typedef _c_av_get_output_timestamp = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 stream,
  ffi.Pointer<ffi.Int64> dts,
  ffi.Pointer<ffi.Int64> wall,
);

typedef _dart_av_get_output_timestamp = int Function(
  ffi.Pointer<AVFormatContext> s,
  int stream,
  ffi.Pointer<ffi.Int64> dts,
  ffi.Pointer<ffi.Int64> wall,
);

typedef _c_av_hex_dump = ffi.Void Function(
  ffi.Pointer<_IO_FILE> f,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 size,
);

typedef _dart_av_hex_dump = void Function(
  ffi.Pointer<_IO_FILE> f,
  ffi.Pointer<ffi.Uint8> buf,
  int size,
);

typedef _c_av_hex_dump_log = ffi.Void Function(
  ffi.Pointer<ffi.Void> avcl,
  ffi.Int32 level,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Int32 size,
);

typedef _dart_av_hex_dump_log = void Function(
  ffi.Pointer<ffi.Void> avcl,
  int level,
  ffi.Pointer<ffi.Uint8> buf,
  int size,
);

typedef _c_av_pkt_dump2 = ffi.Void Function(
  ffi.Pointer<_IO_FILE> f,
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 dump_payload,
  ffi.Pointer<AVStream> st,
);

typedef _dart_av_pkt_dump2 = void Function(
  ffi.Pointer<_IO_FILE> f,
  ffi.Pointer<AVPacket> pkt,
  int dump_payload,
  ffi.Pointer<AVStream> st,
);

typedef _c_av_pkt_dump_log2 = ffi.Void Function(
  ffi.Pointer<ffi.Void> avcl,
  ffi.Int32 level,
  ffi.Pointer<AVPacket> pkt,
  ffi.Int32 dump_payload,
  ffi.Pointer<AVStream> st,
);

typedef _dart_av_pkt_dump_log2 = void Function(
  ffi.Pointer<ffi.Void> avcl,
  int level,
  ffi.Pointer<AVPacket> pkt,
  int dump_payload,
  ffi.Pointer<AVStream> st,
);

typedef _c_av_codec_get_id = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
  ffi.Uint32 tag,
);

typedef _dart_av_codec_get_id = int Function(
  ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
  int tag,
);

typedef _c_av_codec_get_tag = ffi.Uint32 Function(
  ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
  ffi.Int32 id,
);

typedef _dart_av_codec_get_tag = int Function(
  ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
  int id,
);

typedef _c_av_codec_get_tag2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
  ffi.Int32 id,
  ffi.Pointer<ffi.Uint32> tag,
);

typedef _dart_av_codec_get_tag2 = int Function(
  ffi.Pointer<ffi.Pointer<AVCodecTag>> tags,
  int id,
  ffi.Pointer<ffi.Uint32> tag,
);

typedef _c_av_find_default_stream_index = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_av_find_default_stream_index = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_index_search_timestamp = ffi.Int32 Function(
  ffi.Pointer<AVStream> st,
  ffi.Int64 timestamp,
  ffi.Int32 flags,
);

typedef _dart_av_index_search_timestamp = int Function(
  ffi.Pointer<AVStream> st,
  int timestamp,
  int flags,
);

typedef _c_av_add_index_entry = ffi.Int32 Function(
  ffi.Pointer<AVStream> st,
  ffi.Int64 pos,
  ffi.Int64 timestamp,
  ffi.Int32 size,
  ffi.Int32 distance,
  ffi.Int32 flags,
);

typedef _dart_av_add_index_entry = int Function(
  ffi.Pointer<AVStream> st,
  int pos,
  int timestamp,
  int size,
  int distance,
  int flags,
);

typedef _c_av_url_split = ffi.Void Function(
  ffi.Pointer<ffi.Int8> proto,
  ffi.Int32 proto_size,
  ffi.Pointer<ffi.Int8> authorization,
  ffi.Int32 authorization_size,
  ffi.Pointer<ffi.Int8> hostname,
  ffi.Int32 hostname_size,
  ffi.Pointer<ffi.Int32> port_ptr,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 path_size,
  ffi.Pointer<ffi.Int8> url,
);

typedef _dart_av_url_split = void Function(
  ffi.Pointer<ffi.Int8> proto,
  int proto_size,
  ffi.Pointer<ffi.Int8> authorization,
  int authorization_size,
  ffi.Pointer<ffi.Int8> hostname,
  int hostname_size,
  ffi.Pointer<ffi.Int32> port_ptr,
  ffi.Pointer<ffi.Int8> path,
  int path_size,
  ffi.Pointer<ffi.Int8> url,
);

typedef _c_av_dump_format = ffi.Void Function(
  ffi.Pointer<AVFormatContext> ic,
  ffi.Int32 index,
  ffi.Pointer<ffi.Int8> url,
  ffi.Int32 is_output,
);

typedef _dart_av_dump_format = void Function(
  ffi.Pointer<AVFormatContext> ic,
  int index,
  ffi.Pointer<ffi.Int8> url,
  int is_output,
);

typedef _c_av_get_frame_filename2 = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buf_size,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 number,
  ffi.Int32 flags,
);

typedef _dart_av_get_frame_filename2 = int Function(
  ffi.Pointer<ffi.Int8> buf,
  int buf_size,
  ffi.Pointer<ffi.Int8> path,
  int number,
  int flags,
);

typedef _c_av_get_frame_filename = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buf_size,
  ffi.Pointer<ffi.Int8> path,
  ffi.Int32 number,
);

typedef _dart_av_get_frame_filename = int Function(
  ffi.Pointer<ffi.Int8> buf,
  int buf_size,
  ffi.Pointer<ffi.Int8> path,
  int number,
);

typedef _c_av_filename_number_test = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> filename,
);

typedef _dart_av_filename_number_test = int Function(
  ffi.Pointer<ffi.Int8> filename,
);

typedef _c_av_sdp_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> ac,
  ffi.Int32 n_files,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 size,
);

typedef _dart_av_sdp_create = int Function(
  ffi.Pointer<ffi.Pointer<AVFormatContext>> ac,
  int n_files,
  ffi.Pointer<ffi.Int8> buf,
  int size,
);

typedef _c_av_match_ext = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Int8> extensions,
);

typedef _dart_av_match_ext = int Function(
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Int8> extensions,
);

typedef _c_avformat_query_codec = ffi.Int32 Function(
  ffi.Pointer<AVOutputFormat> ofmt,
  ffi.Int32 codec_id,
  ffi.Int32 std_compliance,
);

typedef _dart_avformat_query_codec = int Function(
  ffi.Pointer<AVOutputFormat> ofmt,
  int codec_id,
  int std_compliance,
);

typedef _c_avformat_get_riff_video_tags = ffi.Pointer<AVCodecTag> Function();

typedef _dart_avformat_get_riff_video_tags = ffi.Pointer<AVCodecTag> Function();

typedef _c_avformat_get_riff_audio_tags = ffi.Pointer<AVCodecTag> Function();

typedef _dart_avformat_get_riff_audio_tags = ffi.Pointer<AVCodecTag> Function();

typedef _c_avformat_get_mov_video_tags = ffi.Pointer<AVCodecTag> Function();

typedef _dart_avformat_get_mov_video_tags = ffi.Pointer<AVCodecTag> Function();

typedef _c_avformat_get_mov_audio_tags = ffi.Pointer<AVCodecTag> Function();

typedef _dart_avformat_get_mov_audio_tags = ffi.Pointer<AVCodecTag> Function();

typedef _c_avformat_match_stream_specifier = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVStream> st,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _dart_avformat_match_stream_specifier = int Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<AVStream> st,
  ffi.Pointer<ffi.Int8> spec,
);

typedef _c_avformat_queue_attached_pictures = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_avformat_queue_attached_pictures = int Function(
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_av_apply_bitstream_filters = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext> codec,
  ffi.Pointer<AVPacket> pkt,
  ffi.Pointer<AVBitStreamFilterContext> bsfc,
);

typedef _dart_av_apply_bitstream_filters = int Function(
  ffi.Pointer<AVCodecContext> codec,
  ffi.Pointer<AVPacket> pkt,
  ffi.Pointer<AVBitStreamFilterContext> bsfc,
);

typedef _c_avformat_transfer_internal_stream_timing_info = ffi.Int32 Function(
  ffi.Pointer<AVOutputFormat> ofmt,
  ffi.Pointer<AVStream> ost,
  ffi.Pointer<AVStream> ist,
  ffi.Int32 copy_tb,
);

typedef _dart_avformat_transfer_internal_stream_timing_info = int Function(
  ffi.Pointer<AVOutputFormat> ofmt,
  ffi.Pointer<AVStream> ost,
  ffi.Pointer<AVStream> ist,
  int copy_tb,
);

typedef _c_avdevice_version = ffi.Uint32 Function();

typedef _dart_avdevice_version = int Function();

typedef _c_avdevice_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avdevice_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _c_avdevice_license = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avdevice_license = ffi.Pointer<ffi.Int8> Function();

typedef _c_avdevice_register_all = ffi.Void Function();

typedef _dart_avdevice_register_all = void Function();

typedef _c_av_input_audio_device_next = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVInputFormat> d,
);

typedef _dart_av_input_audio_device_next = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVInputFormat> d,
);

typedef _c_av_input_video_device_next = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVInputFormat> d,
);

typedef _dart_av_input_video_device_next = ffi.Pointer<AVInputFormat> Function(
  ffi.Pointer<AVInputFormat> d,
);

typedef _c_av_output_audio_device_next = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<AVOutputFormat> d,
);

typedef _dart_av_output_audio_device_next = ffi.Pointer<AVOutputFormat>
    Function(
  ffi.Pointer<AVOutputFormat> d,
);

typedef _c_av_output_video_device_next = ffi.Pointer<AVOutputFormat> Function(
  ffi.Pointer<AVOutputFormat> d,
);

typedef _dart_av_output_video_device_next = ffi.Pointer<AVOutputFormat>
    Function(
  ffi.Pointer<AVOutputFormat> d,
);

typedef _c_avdevice_app_to_dev_control_message = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 type,
  ffi.Pointer<ffi.Void> data,
  ffi.Uint64 data_size,
);

typedef _dart_avdevice_app_to_dev_control_message = int Function(
  ffi.Pointer<AVFormatContext> s,
  int type,
  ffi.Pointer<ffi.Void> data,
  int data_size,
);

typedef _c_avdevice_dev_to_app_control_message = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Int32 type,
  ffi.Pointer<ffi.Void> data,
  ffi.Uint64 data_size,
);

typedef _dart_avdevice_dev_to_app_control_message = int Function(
  ffi.Pointer<AVFormatContext> s,
  int type,
  ffi.Pointer<ffi.Void> data,
  int data_size,
);

typedef _c_avdevice_capabilities_create = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVDeviceCapabilitiesQuery>> caps,
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDictionary>> device_options,
);

typedef _dart_avdevice_capabilities_create = int Function(
  ffi.Pointer<ffi.Pointer<AVDeviceCapabilitiesQuery>> caps,
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDictionary>> device_options,
);

typedef _c_avdevice_capabilities_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVDeviceCapabilitiesQuery>> caps,
  ffi.Pointer<AVFormatContext> s,
);

typedef _dart_avdevice_capabilities_free = void Function(
  ffi.Pointer<ffi.Pointer<AVDeviceCapabilitiesQuery>> caps,
  ffi.Pointer<AVFormatContext> s,
);

typedef _c_avdevice_list_devices = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _dart_avdevice_list_devices = int Function(
  ffi.Pointer<AVFormatContext> s,
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _c_avdevice_free_list_devices = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _dart_avdevice_free_list_devices = void Function(
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _c_avdevice_list_input_sources = ffi.Int32 Function(
  ffi.Pointer<AVInputFormat> device,
  ffi.Pointer<ffi.Int8> device_name,
  ffi.Pointer<AVDictionary> device_options,
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _dart_avdevice_list_input_sources = int Function(
  ffi.Pointer<AVInputFormat> device,
  ffi.Pointer<ffi.Int8> device_name,
  ffi.Pointer<AVDictionary> device_options,
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _c_avdevice_list_output_sinks = ffi.Int32 Function(
  ffi.Pointer<AVOutputFormat> device,
  ffi.Pointer<ffi.Int8> device_name,
  ffi.Pointer<AVDictionary> device_options,
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _dart_avdevice_list_output_sinks = int Function(
  ffi.Pointer<AVOutputFormat> device,
  ffi.Pointer<ffi.Int8> device_name,
  ffi.Pointer<AVDictionary> device_options,
  ffi.Pointer<ffi.Pointer<AVDeviceInfoList>> device_list,
);

typedef _c_avfilter_version = ffi.Uint32 Function();

typedef _dart_avfilter_version = int Function();

typedef _c_avfilter_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avfilter_configuration = ffi.Pointer<ffi.Int8> Function();

typedef _c_avfilter_license = ffi.Pointer<ffi.Int8> Function();

typedef _dart_avfilter_license = ffi.Pointer<ffi.Int8> Function();

typedef _c_avfilter_pad_count = ffi.Int32 Function(
  ffi.Pointer<AVFilterPad> pads,
);

typedef _dart_avfilter_pad_count = int Function(
  ffi.Pointer<AVFilterPad> pads,
);

typedef _c_avfilter_pad_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVFilterPad> pads,
  ffi.Int32 pad_idx,
);

typedef _dart_avfilter_pad_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVFilterPad> pads,
  int pad_idx,
);

typedef _c_avfilter_pad_get_type = ffi.Int32 Function(
  ffi.Pointer<AVFilterPad> pads,
  ffi.Int32 pad_idx,
);

typedef _dart_avfilter_pad_get_type = int Function(
  ffi.Pointer<AVFilterPad> pads,
  int pad_idx,
);

typedef _c_avfilter_link = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> src,
  ffi.Uint32 srcpad,
  ffi.Pointer<AVFilterContext> dst,
  ffi.Uint32 dstpad,
);

typedef _dart_avfilter_link = int Function(
  ffi.Pointer<AVFilterContext> src,
  int srcpad,
  ffi.Pointer<AVFilterContext> dst,
  int dstpad,
);

typedef _c_avfilter_link_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVFilterLink>> link,
);

typedef _dart_avfilter_link_free = void Function(
  ffi.Pointer<ffi.Pointer<AVFilterLink>> link,
);

typedef _c_avfilter_link_get_channels = ffi.Int32 Function(
  ffi.Pointer<AVFilterLink> link,
);

typedef _dart_avfilter_link_get_channels = int Function(
  ffi.Pointer<AVFilterLink> link,
);

typedef _c_avfilter_link_set_closed = ffi.Void Function(
  ffi.Pointer<AVFilterLink> link,
  ffi.Int32 closed,
);

typedef _dart_avfilter_link_set_closed = void Function(
  ffi.Pointer<AVFilterLink> link,
  int closed,
);

typedef _c_avfilter_config_links = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> filter,
);

typedef _dart_avfilter_config_links = int Function(
  ffi.Pointer<AVFilterContext> filter,
);

typedef _c_avfilter_process_command = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> filter,
  ffi.Pointer<ffi.Int8> cmd,
  ffi.Pointer<ffi.Int8> arg,
  ffi.Pointer<ffi.Int8> res,
  ffi.Int32 res_len,
  ffi.Int32 flags,
);

typedef _dart_avfilter_process_command = int Function(
  ffi.Pointer<AVFilterContext> filter,
  ffi.Pointer<ffi.Int8> cmd,
  ffi.Pointer<ffi.Int8> arg,
  ffi.Pointer<ffi.Int8> res,
  int res_len,
  int flags,
);

typedef _c_av_filter_iterate = ffi.Pointer<AVFilter> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _dart_av_filter_iterate = ffi.Pointer<AVFilter> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>> opaque,
);

typedef _c_avfilter_register_all = ffi.Void Function();

typedef _dart_avfilter_register_all = void Function();

typedef _c_avfilter_register = ffi.Int32 Function(
  ffi.Pointer<AVFilter> filter,
);

typedef _dart_avfilter_register = int Function(
  ffi.Pointer<AVFilter> filter,
);

typedef _c_avfilter_next = ffi.Pointer<AVFilter> Function(
  ffi.Pointer<AVFilter> prev,
);

typedef _dart_avfilter_next = ffi.Pointer<AVFilter> Function(
  ffi.Pointer<AVFilter> prev,
);

typedef _c_avfilter_get_by_name = ffi.Pointer<AVFilter> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_avfilter_get_by_name = ffi.Pointer<AVFilter> Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_avfilter_init_str = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<ffi.Int8> args,
);

typedef _dart_avfilter_init_str = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<ffi.Int8> args,
);

typedef _c_avfilter_init_dict = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _dart_avfilter_init_dict = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<ffi.Pointer<AVDictionary>> options,
);

typedef _c_avfilter_free = ffi.Void Function(
  ffi.Pointer<AVFilterContext> filter,
);

typedef _dart_avfilter_free = void Function(
  ffi.Pointer<AVFilterContext> filter,
);

typedef _c_avfilter_insert_filter = ffi.Int32 Function(
  ffi.Pointer<AVFilterLink> link,
  ffi.Pointer<AVFilterContext> filt,
  ffi.Uint32 filt_srcpad_idx,
  ffi.Uint32 filt_dstpad_idx,
);

typedef _dart_avfilter_insert_filter = int Function(
  ffi.Pointer<AVFilterLink> link,
  ffi.Pointer<AVFilterContext> filt,
  int filt_srcpad_idx,
  int filt_dstpad_idx,
);

typedef _c_avfilter_get_class = ffi.Pointer<AVClass> Function();

typedef _dart_avfilter_get_class = ffi.Pointer<AVClass> Function();

typedef _c_avfilter_graph_alloc = ffi.Pointer<AVFilterGraph> Function();

typedef _dart_avfilter_graph_alloc = ffi.Pointer<AVFilterGraph> Function();

typedef _c_avfilter_graph_alloc_filter = ffi.Pointer<AVFilterContext> Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<AVFilter> filter,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_avfilter_graph_alloc_filter = ffi.Pointer<AVFilterContext>
    Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<AVFilter> filter,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_avfilter_graph_get_filter = ffi.Pointer<AVFilterContext> Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_avfilter_graph_get_filter = ffi.Pointer<AVFilterContext> Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_avfilter_graph_create_filter = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVFilterContext>> filt_ctx,
  ffi.Pointer<AVFilter> filt,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> args,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<AVFilterGraph> graph_ctx,
);

typedef _dart_avfilter_graph_create_filter = int Function(
  ffi.Pointer<ffi.Pointer<AVFilterContext>> filt_ctx,
  ffi.Pointer<AVFilter> filt,
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> args,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<AVFilterGraph> graph_ctx,
);

typedef _c_avfilter_graph_set_auto_convert = ffi.Void Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Uint32 flags,
);

typedef _dart_avfilter_graph_set_auto_convert = void Function(
  ffi.Pointer<AVFilterGraph> graph,
  int flags,
);

typedef _c_avfilter_graph_config = ffi.Int32 Function(
  ffi.Pointer<AVFilterGraph> graphctx,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_avfilter_graph_config = int Function(
  ffi.Pointer<AVFilterGraph> graphctx,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_avfilter_graph_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVFilterGraph>> graph,
);

typedef _dart_avfilter_graph_free = void Function(
  ffi.Pointer<ffi.Pointer<AVFilterGraph>> graph,
);

typedef _c_avfilter_inout_alloc = ffi.Pointer<AVFilterInOut> Function();

typedef _dart_avfilter_inout_alloc = ffi.Pointer<AVFilterInOut> Function();

typedef _c_avfilter_inout_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> inout,
);

typedef _dart_avfilter_inout_free = void Function(
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> inout,
);

typedef _c_avfilter_graph_parse = ffi.Int32 Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> filters,
  ffi.Pointer<AVFilterInOut> inputs,
  ffi.Pointer<AVFilterInOut> outputs,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_avfilter_graph_parse = int Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> filters,
  ffi.Pointer<AVFilterInOut> inputs,
  ffi.Pointer<AVFilterInOut> outputs,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_avfilter_graph_parse_ptr = ffi.Int32 Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> filters,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_avfilter_graph_parse_ptr = int Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> filters,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_avfilter_graph_parse2 = ffi.Int32 Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> filters,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
);

typedef _dart_avfilter_graph_parse2 = int Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> filters,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> inputs,
  ffi.Pointer<ffi.Pointer<AVFilterInOut>> outputs,
);

typedef _c_avfilter_graph_send_command = ffi.Int32 Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<ffi.Int8> cmd,
  ffi.Pointer<ffi.Int8> arg,
  ffi.Pointer<ffi.Int8> res,
  ffi.Int32 res_len,
  ffi.Int32 flags,
);

typedef _dart_avfilter_graph_send_command = int Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<ffi.Int8> cmd,
  ffi.Pointer<ffi.Int8> arg,
  ffi.Pointer<ffi.Int8> res,
  int res_len,
  int flags,
);

typedef _c_avfilter_graph_queue_command = ffi.Int32 Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<ffi.Int8> cmd,
  ffi.Pointer<ffi.Int8> arg,
  ffi.Int32 flags,
  ffi.Double ts,
);

typedef _dart_avfilter_graph_queue_command = int Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> target,
  ffi.Pointer<ffi.Int8> cmd,
  ffi.Pointer<ffi.Int8> arg,
  int flags,
  double ts,
);

typedef _c_avfilter_graph_dump = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> options,
);

typedef _dart_avfilter_graph_dump = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVFilterGraph> graph,
  ffi.Pointer<ffi.Int8> options,
);

typedef _c_avfilter_graph_request_oldest = ffi.Int32 Function(
  ffi.Pointer<AVFilterGraph> graph,
);

typedef _dart_avfilter_graph_request_oldest = int Function(
  ffi.Pointer<AVFilterGraph> graph,
);

typedef _c_av_buffersink_get_frame_flags = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 flags,
);

typedef _dart_av_buffersink_get_frame_flags = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
  int flags,
);

typedef _c_av_buffersink_params_alloc = ffi.Pointer<AVBufferSinkParams>
    Function();

typedef _dart_av_buffersink_params_alloc = ffi.Pointer<AVBufferSinkParams>
    Function();

typedef _c_av_abuffersink_params_alloc = ffi.Pointer<AVABufferSinkParams>
    Function();

typedef _dart_av_abuffersink_params_alloc = ffi.Pointer<AVABufferSinkParams>
    Function();

typedef _c_av_buffersink_set_frame_size = ffi.Void Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Uint32 frame_size,
);

typedef _dart_av_buffersink_set_frame_size = void Function(
  ffi.Pointer<AVFilterContext> ctx,
  int frame_size,
);

typedef _c_av_buffersink_get_type = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_type = int Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_format = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_format = int Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_w = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_w = int Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_h = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_h = int Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_channels = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_channels = int Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_channel_layout = ffi.Uint64 Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_channel_layout = int Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_sample_rate = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_sample_rate = int Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_hw_frames_ctx = ffi.Pointer<AVBufferRef> Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _dart_av_buffersink_get_hw_frames_ctx = ffi.Pointer<AVBufferRef>
    Function(
  ffi.Pointer<AVFilterContext> ctx,
);

typedef _c_av_buffersink_get_frame = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_buffersink_get_frame = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_buffersink_get_samples = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 nb_samples,
);

typedef _dart_av_buffersink_get_samples = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
  int nb_samples,
);

typedef _c_av_buffersrc_get_nb_failed_requests = ffi.Uint32 Function(
  ffi.Pointer<AVFilterContext> buffer_src,
);

typedef _dart_av_buffersrc_get_nb_failed_requests = int Function(
  ffi.Pointer<AVFilterContext> buffer_src,
);

typedef _c_av_buffersrc_parameters_alloc = ffi.Pointer<AVBufferSrcParameters>
    Function();

typedef _dart_av_buffersrc_parameters_alloc = ffi.Pointer<AVBufferSrcParameters>
    Function();

typedef _c_av_buffersrc_parameters_set = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVBufferSrcParameters> param,
);

typedef _dart_av_buffersrc_parameters_set = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVBufferSrcParameters> param,
);

typedef _c_av_buffersrc_write_frame = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_buffersrc_write_frame = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_buffersrc_add_frame = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_buffersrc_add_frame = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_buffersrc_add_frame_flags = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> buffer_src,
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 flags,
);

typedef _dart_av_buffersrc_add_frame_flags = int Function(
  ffi.Pointer<AVFilterContext> buffer_src,
  ffi.Pointer<AVFrame> frame,
  int flags,
);

typedef _c_av_buffersrc_close = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext> ctx,
  ffi.Int64 pts,
  ffi.Uint32 flags,
);

typedef _dart_av_buffersrc_close = int Function(
  ffi.Pointer<AVFilterContext> ctx,
  int pts,
  int flags,
);

typedef _c_av_adler32_update = ffi.Uint64 Function(
  ffi.Uint64 adler,
  ffi.Pointer<ffi.Uint8> buf,
  ffi.Uint32 len,
);

typedef _dart_av_adler32_update = int Function(
  int adler,
  ffi.Pointer<ffi.Uint8> buf,
  int len,
);

typedef _c_av_aes_alloc = ffi.Pointer<AVAES> Function();

typedef _dart_av_aes_alloc = ffi.Pointer<AVAES> Function();

typedef _c_av_aes_init = ffi.Int32 Function(
  ffi.Pointer<AVAES> a,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 key_bits,
  ffi.Int32 decrypt,
);

typedef _dart_av_aes_init = int Function(
  ffi.Pointer<AVAES> a,
  ffi.Pointer<ffi.Uint8> key,
  int key_bits,
  int decrypt,
);

typedef _c_av_aes_crypt = ffi.Void Function(
  ffi.Pointer<AVAES> a,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_aes_crypt = void Function(
  ffi.Pointer<AVAES> a,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_aes_ctr_alloc = ffi.Pointer<AVAESCTR> Function();

typedef _dart_av_aes_ctr_alloc = ffi.Pointer<AVAESCTR> Function();

typedef _c_av_aes_ctr_init = ffi.Int32 Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> key,
);

typedef _dart_av_aes_ctr_init = int Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> key,
);

typedef _c_av_aes_ctr_free = ffi.Void Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _dart_av_aes_ctr_free = void Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _c_av_aes_ctr_crypt = ffi.Void Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 size,
);

typedef _dart_av_aes_ctr_crypt = void Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int size,
);

typedef _c_av_aes_ctr_get_iv = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _dart_av_aes_ctr_get_iv = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _c_av_aes_ctr_set_random_iv = ffi.Void Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _dart_av_aes_ctr_set_random_iv = void Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _c_av_aes_ctr_set_iv = ffi.Void Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> iv,
);

typedef _dart_av_aes_ctr_set_iv = void Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> iv,
);

typedef _c_av_aes_ctr_set_full_iv = ffi.Void Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> iv,
);

typedef _dart_av_aes_ctr_set_full_iv = void Function(
  ffi.Pointer<AVAESCTR> a,
  ffi.Pointer<ffi.Uint8> iv,
);

typedef _c_av_aes_ctr_increment_iv = ffi.Void Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _dart_av_aes_ctr_increment_iv = void Function(
  ffi.Pointer<AVAESCTR> a,
);

typedef _c_av_fifo_alloc = ffi.Pointer<AVFifoBuffer> Function(
  ffi.Uint32 size,
);

typedef _dart_av_fifo_alloc = ffi.Pointer<AVFifoBuffer> Function(
  int size,
);

typedef _c_av_fifo_alloc_array = ffi.Pointer<AVFifoBuffer> Function(
  ffi.Uint64 nmemb,
  ffi.Uint64 size,
);

typedef _dart_av_fifo_alloc_array = ffi.Pointer<AVFifoBuffer> Function(
  int nmemb,
  int size,
);

typedef _c_av_fifo_free = ffi.Void Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _dart_av_fifo_free = void Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _c_av_fifo_freep = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVFifoBuffer>> f,
);

typedef _dart_av_fifo_freep = void Function(
  ffi.Pointer<ffi.Pointer<AVFifoBuffer>> f,
);

typedef _c_av_fifo_reset = ffi.Void Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _dart_av_fifo_reset = void Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _c_av_fifo_size = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _dart_av_fifo_size = int Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _c_av_fifo_space = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _dart_av_fifo_space = int Function(
  ffi.Pointer<AVFifoBuffer> f,
);

typedef _typedefC_94 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
);

typedef _c_av_fifo_generic_peek_at = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> dest,
  ffi.Int32 offset,
  ffi.Int32 buf_size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_94>> func,
);

typedef _dart_av_fifo_generic_peek_at = int Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> dest,
  int offset,
  int buf_size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_94>> func,
);

typedef _typedefC_95 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
);

typedef _c_av_fifo_generic_peek = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> dest,
  ffi.Int32 buf_size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_95>> func,
);

typedef _dart_av_fifo_generic_peek = int Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> dest,
  int buf_size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_95>> func,
);

typedef _typedefC_96 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
);

typedef _c_av_fifo_generic_read = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> dest,
  ffi.Int32 buf_size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_96>> func,
);

typedef _dart_av_fifo_generic_read = int Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> dest,
  int buf_size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_96>> func,
);

typedef _typedefC_97 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
);

typedef _c_av_fifo_generic_write = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> src,
  ffi.Int32 size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_97>> func,
);

typedef _dart_av_fifo_generic_write = int Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Pointer<ffi.Void> src,
  int size,
  ffi.Pointer<ffi.NativeFunction<_typedefC_97>> func,
);

typedef _c_av_fifo_realloc2 = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Uint32 size,
);

typedef _dart_av_fifo_realloc2 = int Function(
  ffi.Pointer<AVFifoBuffer> f,
  int size,
);

typedef _c_av_fifo_grow = ffi.Int32 Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Uint32 additional_space,
);

typedef _dart_av_fifo_grow = int Function(
  ffi.Pointer<AVFifoBuffer> f,
  int additional_space,
);

typedef _c_av_fifo_drain = ffi.Void Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Int32 size,
);

typedef _dart_av_fifo_drain = void Function(
  ffi.Pointer<AVFifoBuffer> f,
  int size,
);

typedef _c_av_fifo_peek2 = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVFifoBuffer> f,
  ffi.Int32 offs,
);

typedef _dart_av_fifo_peek2 = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVFifoBuffer> f,
  int offs,
);

typedef _c_av_audio_fifo_free = ffi.Void Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _dart_av_audio_fifo_free = void Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _c_av_audio_fifo_alloc = ffi.Pointer<AVAudioFifo> Function(
  ffi.Int32 sample_fmt,
  ffi.Int32 channels,
  ffi.Int32 nb_samples,
);

typedef _dart_av_audio_fifo_alloc = ffi.Pointer<AVAudioFifo> Function(
  int sample_fmt,
  int channels,
  int nb_samples,
);

typedef _c_av_audio_fifo_realloc = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Int32 nb_samples,
);

typedef _dart_av_audio_fifo_realloc = int Function(
  ffi.Pointer<AVAudioFifo> af,
  int nb_samples,
);

typedef _c_av_audio_fifo_write = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  ffi.Int32 nb_samples,
);

typedef _dart_av_audio_fifo_write = int Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  int nb_samples,
);

typedef _c_av_audio_fifo_peek = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  ffi.Int32 nb_samples,
);

typedef _dart_av_audio_fifo_peek = int Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  int nb_samples,
);

typedef _c_av_audio_fifo_peek_at = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  ffi.Int32 nb_samples,
  ffi.Int32 offset,
);

typedef _dart_av_audio_fifo_peek_at = int Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  int nb_samples,
  int offset,
);

typedef _c_av_audio_fifo_read = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  ffi.Int32 nb_samples,
);

typedef _dart_av_audio_fifo_read = int Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Pointer<ffi.Pointer<ffi.Void>> data,
  int nb_samples,
);

typedef _c_av_audio_fifo_drain = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
  ffi.Int32 nb_samples,
);

typedef _dart_av_audio_fifo_drain = int Function(
  ffi.Pointer<AVAudioFifo> af,
  int nb_samples,
);

typedef _c_av_audio_fifo_reset = ffi.Void Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _dart_av_audio_fifo_reset = void Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _c_av_audio_fifo_size = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _dart_av_audio_fifo_size = int Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _c_av_audio_fifo_space = ffi.Int32 Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _dart_av_audio_fifo_space = int Function(
  ffi.Pointer<AVAudioFifo> af,
);

typedef _c_av_assert0_fpu = ffi.Void Function();

typedef _dart_av_assert0_fpu = void Function();

typedef _c_av_strstart = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> pfx,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ptr,
);

typedef _dart_av_strstart = int Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> pfx,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ptr,
);

typedef _c_av_stristart = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> pfx,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ptr,
);

typedef _dart_av_stristart = int Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> pfx,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ptr,
);

typedef _c_av_stristr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> haystack,
  ffi.Pointer<ffi.Int8> needle,
);

typedef _dart_av_stristr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> haystack,
  ffi.Pointer<ffi.Int8> needle,
);

typedef _c_av_strnstr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> haystack,
  ffi.Pointer<ffi.Int8> needle,
  ffi.Uint64 hay_length,
);

typedef _dart_av_strnstr = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> haystack,
  ffi.Pointer<ffi.Int8> needle,
  int hay_length,
);

typedef _c_av_strlcpy = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 size,
);

typedef _dart_av_strlcpy = int Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  int size,
);

typedef _c_av_strlcat = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  ffi.Uint64 size,
);

typedef _dart_av_strlcat = int Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Pointer<ffi.Int8> src,
  int size,
);

typedef _c_av_strlcatf = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> dst,
  ffi.Uint64 size,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_av_strlcatf = int Function(
  ffi.Pointer<ffi.Int8> dst,
  int size,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_av_strnlen = ffi.Uint64 Function(
  ffi.Pointer<ffi.Int8> s,
  ffi.Uint64 len,
);

typedef _dart_av_strnlen = int Function(
  ffi.Pointer<ffi.Int8> s,
  int len,
);

typedef _c_av_asprintf = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_av_asprintf = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_av_d2str = ffi.Pointer<ffi.Int8> Function(
  ffi.Double d,
);

typedef _dart_av_d2str = ffi.Pointer<ffi.Int8> Function(
  double d,
);

typedef _c_av_get_token = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> buf,
  ffi.Pointer<ffi.Int8> term,
);

typedef _dart_av_get_token = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> buf,
  ffi.Pointer<ffi.Int8> term,
);

typedef _c_av_strtok = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s,
  ffi.Pointer<ffi.Int8> delim,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> saveptr,
);

typedef _dart_av_strtok = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> s,
  ffi.Pointer<ffi.Int8> delim,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> saveptr,
);

typedef _c_av_isdigit = ffi.Int32 Function(
  ffi.Int32 c,
);

typedef _dart_av_isdigit = int Function(
  int c,
);

typedef _c_av_isgraph = ffi.Int32 Function(
  ffi.Int32 c,
);

typedef _dart_av_isgraph = int Function(
  int c,
);

typedef _c_av_isspace = ffi.Int32 Function(
  ffi.Int32 c,
);

typedef _dart_av_isspace = int Function(
  int c,
);

typedef _c_av_toupper = ffi.Int32 Function(
  ffi.Int32 c,
);

typedef _dart_av_toupper = int Function(
  int c,
);

typedef _c_av_tolower = ffi.Int32 Function(
  ffi.Int32 c,
);

typedef _dart_av_tolower = int Function(
  int c,
);

typedef _c_av_isxdigit = ffi.Int32 Function(
  ffi.Int32 c,
);

typedef _dart_av_isxdigit = int Function(
  int c,
);

typedef _c_av_strcasecmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> a,
  ffi.Pointer<ffi.Int8> b,
);

typedef _dart_av_strcasecmp = int Function(
  ffi.Pointer<ffi.Int8> a,
  ffi.Pointer<ffi.Int8> b,
);

typedef _c_av_strncasecmp = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> a,
  ffi.Pointer<ffi.Int8> b,
  ffi.Uint64 n,
);

typedef _dart_av_strncasecmp = int Function(
  ffi.Pointer<ffi.Int8> a,
  ffi.Pointer<ffi.Int8> b,
  int n,
);

typedef _c_av_strireplace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> from,
  ffi.Pointer<ffi.Int8> to,
);

typedef _dart_av_strireplace = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> str,
  ffi.Pointer<ffi.Int8> from,
  ffi.Pointer<ffi.Int8> to,
);

typedef _c_av_basename = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_av_basename = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_av_dirname = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _dart_av_dirname = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> path,
);

typedef _c_av_match_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> names,
);

typedef _dart_av_match_name = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> names,
);

typedef _c_av_append_path_component = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> component,
);

typedef _dart_av_append_path_component = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> path,
  ffi.Pointer<ffi.Int8> component,
);

typedef _c_av_escape = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> dst,
  ffi.Pointer<ffi.Int8> src,
  ffi.Pointer<ffi.Int8> special_chars,
  ffi.Int32 mode,
  ffi.Int32 flags,
);

typedef _dart_av_escape = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Int8>> dst,
  ffi.Pointer<ffi.Int8> src,
  ffi.Pointer<ffi.Int8> special_chars,
  int mode,
  int flags,
);

typedef _c_av_utf8_decode = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> codep,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufp,
  ffi.Pointer<ffi.Uint8> buf_end,
  ffi.Uint32 flags,
);

typedef _dart_av_utf8_decode = int Function(
  ffi.Pointer<ffi.Int32> codep,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufp,
  ffi.Pointer<ffi.Uint8> buf_end,
  int flags,
);

typedef _c_av_match_list = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> list,
  ffi.Int8 separator,
);

typedef _dart_av_match_list = int Function(
  ffi.Pointer<ffi.Int8> name,
  ffi.Pointer<ffi.Int8> list,
  int separator,
);

typedef _c_av_sscanf = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> string,
  ffi.Pointer<ffi.Int8> format,
);

typedef _dart_av_sscanf = int Function(
  ffi.Pointer<ffi.Int8> string,
  ffi.Pointer<ffi.Int8> format,
);

typedef _c_av_base64_decode = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Int8> in_1,
  ffi.Int32 out_size,
);

typedef _dart_av_base64_decode = int Function(
  ffi.Pointer<ffi.Uint8> out,
  ffi.Pointer<ffi.Int8> in_1,
  int out_size,
);

typedef _c_av_base64_encode = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> out,
  ffi.Int32 out_size,
  ffi.Pointer<ffi.Uint8> in_1,
  ffi.Int32 in_size,
);

typedef _dart_av_base64_encode = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> out,
  int out_size,
  ffi.Pointer<ffi.Uint8> in_1,
  int in_size,
);

typedef _c_av_blowfish_alloc = ffi.Pointer<AVBlowfish> Function();

typedef _dart_av_blowfish_alloc = ffi.Pointer<AVBlowfish> Function();

typedef _c_av_blowfish_init = ffi.Void Function(
  ffi.Pointer<AVBlowfish> ctx,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 key_len,
);

typedef _dart_av_blowfish_init = void Function(
  ffi.Pointer<AVBlowfish> ctx,
  ffi.Pointer<ffi.Uint8> key,
  int key_len,
);

typedef _c_av_blowfish_crypt_ecb = ffi.Void Function(
  ffi.Pointer<AVBlowfish> ctx,
  ffi.Pointer<ffi.Uint32> xl,
  ffi.Pointer<ffi.Uint32> xr,
  ffi.Int32 decrypt,
);

typedef _dart_av_blowfish_crypt_ecb = void Function(
  ffi.Pointer<AVBlowfish> ctx,
  ffi.Pointer<ffi.Uint32> xl,
  ffi.Pointer<ffi.Uint32> xr,
  int decrypt,
);

typedef _c_av_blowfish_crypt = ffi.Void Function(
  ffi.Pointer<AVBlowfish> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_blowfish_crypt = void Function(
  ffi.Pointer<AVBlowfish> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_bprint_init = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Uint32 size_init,
  ffi.Uint32 size_max,
);

typedef _dart_av_bprint_init = void Function(
  ffi.Pointer<AVBPrint> buf,
  int size_init,
  int size_max,
);

typedef _c_av_bprint_init_for_buffer = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> buffer,
  ffi.Uint32 size,
);

typedef _dart_av_bprint_init_for_buffer = void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> buffer,
  int size,
);

typedef _c_av_bprintf = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _dart_av_bprintf = void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> fmt,
);

typedef _c_av_vbprintf = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl_arg,
);

typedef _dart_av_vbprintf = void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<__va_list_tag> vl_arg,
);

typedef _c_av_bprint_chars = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Int8 c,
  ffi.Uint32 n,
);

typedef _dart_av_bprint_chars = void Function(
  ffi.Pointer<AVBPrint> buf,
  int c,
  int n,
);

typedef _c_av_bprint_append_data = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> data,
  ffi.Uint32 size,
);

typedef _dart_av_bprint_append_data = void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> data,
  int size,
);

typedef _c_av_bprint_strftime = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<tm> tm,
);

typedef _dart_av_bprint_strftime = void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<tm> tm,
);

typedef _c_av_bprint_get_buffer = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Uint32 size,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> mem,
  ffi.Pointer<ffi.Uint32> actual_size,
);

typedef _dart_av_bprint_get_buffer = void Function(
  ffi.Pointer<AVBPrint> buf,
  int size,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> mem,
  ffi.Pointer<ffi.Uint32> actual_size,
);

typedef _c_av_bprint_clear = ffi.Void Function(
  ffi.Pointer<AVBPrint> buf,
);

typedef _dart_av_bprint_clear = void Function(
  ffi.Pointer<AVBPrint> buf,
);

typedef _c_av_bprint_is_complete = ffi.Int32 Function(
  ffi.Pointer<AVBPrint> buf,
);

typedef _dart_av_bprint_is_complete = int Function(
  ffi.Pointer<AVBPrint> buf,
);

typedef _c_av_bprint_finalize = ffi.Int32 Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ret_str,
);

typedef _dart_av_bprint_finalize = int Function(
  ffi.Pointer<AVBPrint> buf,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> ret_str,
);

typedef _c_av_bprint_escape = ffi.Void Function(
  ffi.Pointer<AVBPrint> dstbuf,
  ffi.Pointer<ffi.Int8> src,
  ffi.Pointer<ffi.Int8> special_chars,
  ffi.Int32 mode,
  ffi.Int32 flags,
);

typedef _dart_av_bprint_escape = void Function(
  ffi.Pointer<AVBPrint> dstbuf,
  ffi.Pointer<ffi.Int8> src,
  ffi.Pointer<ffi.Int8> special_chars,
  int mode,
  int flags,
);

typedef _c_av_bswap16 = ffi.Uint16 Function(
  ffi.Uint16 x,
);

typedef _dart_av_bswap16 = int Function(
  int x,
);

typedef _c_av_bswap32 = ffi.Uint32 Function(
  ffi.Uint32 x,
);

typedef _dart_av_bswap32 = int Function(
  int x,
);

typedef _c_av_bswap64 = ffi.Uint64 Function(
  ffi.Uint64 x,
);

typedef _dart_av_bswap64 = int Function(
  int x,
);

typedef _c_av_camellia_alloc = ffi.Pointer<AVCAMELLIA> Function();

typedef _dart_av_camellia_alloc = ffi.Pointer<AVCAMELLIA> Function();

typedef _c_av_camellia_init = ffi.Int32 Function(
  ffi.Pointer<AVCAMELLIA> ctx,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 key_bits,
);

typedef _dart_av_camellia_init = int Function(
  ffi.Pointer<AVCAMELLIA> ctx,
  ffi.Pointer<ffi.Uint8> key,
  int key_bits,
);

typedef _c_av_camellia_crypt = ffi.Void Function(
  ffi.Pointer<AVCAMELLIA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_camellia_crypt = void Function(
  ffi.Pointer<AVCAMELLIA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_cast5_alloc = ffi.Pointer<AVCAST5> Function();

typedef _dart_av_cast5_alloc = ffi.Pointer<AVCAST5> Function();

typedef _c_av_cast5_init = ffi.Int32 Function(
  ffi.Pointer<AVCAST5> ctx,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 key_bits,
);

typedef _dart_av_cast5_init = int Function(
  ffi.Pointer<AVCAST5> ctx,
  ffi.Pointer<ffi.Uint8> key,
  int key_bits,
);

typedef _c_av_cast5_crypt = ffi.Void Function(
  ffi.Pointer<AVCAST5> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Int32 decrypt,
);

typedef _dart_av_cast5_crypt = void Function(
  ffi.Pointer<AVCAST5> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  int decrypt,
);

typedef _c_av_cast5_crypt2 = ffi.Void Function(
  ffi.Pointer<AVCAST5> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_cast5_crypt2 = void Function(
  ffi.Pointer<AVCAST5> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_crc_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint32> ctx,
  ffi.Int32 le,
  ffi.Int32 bits,
  ffi.Uint32 poly,
  ffi.Int32 ctx_size,
);

typedef _dart_av_crc_init = int Function(
  ffi.Pointer<ffi.Uint32> ctx,
  int le,
  int bits,
  int poly,
  int ctx_size,
);

typedef _c_av_crc_get_table = ffi.Pointer<ffi.Uint32> Function(
  ffi.Int32 crc_id,
);

typedef _dart_av_crc_get_table = ffi.Pointer<ffi.Uint32> Function(
  int crc_id,
);

typedef _c_av_crc = ffi.Uint32 Function(
  ffi.Pointer<ffi.Uint32> ctx,
  ffi.Uint32 crc,
  ffi.Pointer<ffi.Uint8> buffer,
  ffi.Uint64 length,
);

typedef _dart_av_crc = int Function(
  ffi.Pointer<ffi.Uint32> ctx,
  int crc,
  ffi.Pointer<ffi.Uint8> buffer,
  int length,
);

typedef _c_av_des_alloc = ffi.Pointer<AVDES> Function();

typedef _dart_av_des_alloc = ffi.Pointer<AVDES> Function();

typedef _c_av_des_init = ffi.Int32 Function(
  ffi.Pointer<AVDES> d,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 key_bits,
  ffi.Int32 decrypt,
);

typedef _dart_av_des_init = int Function(
  ffi.Pointer<AVDES> d,
  ffi.Pointer<ffi.Uint8> key,
  int key_bits,
  int decrypt,
);

typedef _c_av_des_crypt = ffi.Void Function(
  ffi.Pointer<AVDES> d,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_des_crypt = void Function(
  ffi.Pointer<AVDES> d,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_des_mac = ffi.Void Function(
  ffi.Pointer<AVDES> d,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
);

typedef _dart_av_des_mac = void Function(
  ffi.Pointer<AVDES> d,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
);

typedef _c_av_display_rotation_get = ffi.Double Function(
  ffi.Pointer<ffi.Int32> matrix,
);

typedef _dart_av_display_rotation_get = double Function(
  ffi.Pointer<ffi.Int32> matrix,
);

typedef _c_av_display_rotation_set = ffi.Void Function(
  ffi.Pointer<ffi.Int32> matrix,
  ffi.Double angle,
);

typedef _dart_av_display_rotation_set = void Function(
  ffi.Pointer<ffi.Int32> matrix,
  double angle,
);

typedef _c_av_display_matrix_flip = ffi.Void Function(
  ffi.Pointer<ffi.Int32> matrix,
  ffi.Int32 hflip,
  ffi.Int32 vflip,
);

typedef _dart_av_display_matrix_flip = void Function(
  ffi.Pointer<ffi.Int32> matrix,
  int hflip,
  int vflip,
);

typedef _c_av_dovi_alloc = ffi.Pointer<AVDOVIDecoderConfigurationRecord>
    Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_av_dovi_alloc = ffi.Pointer<AVDOVIDecoderConfigurationRecord>
    Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_av_downmix_info_update_side_data = ffi.Pointer<AVDownmixInfo>
    Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_downmix_info_update_side_data = ffi.Pointer<AVDownmixInfo>
    Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_encryption_info_alloc = ffi.Pointer<AVEncryptionInfo> Function(
  ffi.Uint32 subsample_count,
  ffi.Uint32 key_id_size,
  ffi.Uint32 iv_size,
);

typedef _dart_av_encryption_info_alloc = ffi.Pointer<AVEncryptionInfo> Function(
  int subsample_count,
  int key_id_size,
  int iv_size,
);

typedef _c_av_encryption_info_clone = ffi.Pointer<AVEncryptionInfo> Function(
  ffi.Pointer<AVEncryptionInfo> info,
);

typedef _dart_av_encryption_info_clone = ffi.Pointer<AVEncryptionInfo> Function(
  ffi.Pointer<AVEncryptionInfo> info,
);

typedef _c_av_encryption_info_free = ffi.Void Function(
  ffi.Pointer<AVEncryptionInfo> info,
);

typedef _dart_av_encryption_info_free = void Function(
  ffi.Pointer<AVEncryptionInfo> info,
);

typedef _c_av_encryption_info_get_side_data = ffi.Pointer<AVEncryptionInfo>
    Function(
  ffi.Pointer<ffi.Uint8> side_data,
  ffi.Uint64 side_data_size,
);

typedef _dart_av_encryption_info_get_side_data = ffi.Pointer<AVEncryptionInfo>
    Function(
  ffi.Pointer<ffi.Uint8> side_data,
  int side_data_size,
);

typedef _c_av_encryption_info_add_side_data = ffi.Pointer<ffi.Uint8> Function(
  ffi.Pointer<AVEncryptionInfo> info,
  ffi.Pointer<ffi.Uint64> side_data_size,
);

typedef _dart_av_encryption_info_add_side_data = ffi.Pointer<ffi.Uint8>
    Function(
  ffi.Pointer<AVEncryptionInfo> info,
  ffi.Pointer<ffi.Uint64> side_data_size,
);

typedef _c_av_encryption_init_info_alloc = ffi.Pointer<AVEncryptionInitInfo>
    Function(
  ffi.Uint32 system_id_size,
  ffi.Uint32 num_key_ids,
  ffi.Uint32 key_id_size,
  ffi.Uint32 data_size,
);

typedef _dart_av_encryption_init_info_alloc = ffi.Pointer<AVEncryptionInitInfo>
    Function(
  int system_id_size,
  int num_key_ids,
  int key_id_size,
  int data_size,
);

typedef _c_av_encryption_init_info_free = ffi.Void Function(
  ffi.Pointer<AVEncryptionInitInfo> info,
);

typedef _dart_av_encryption_init_info_free = void Function(
  ffi.Pointer<AVEncryptionInitInfo> info,
);

typedef _c_av_encryption_init_info_get_side_data
    = ffi.Pointer<AVEncryptionInitInfo> Function(
  ffi.Pointer<ffi.Uint8> side_data,
  ffi.Uint64 side_data_size,
);

typedef _dart_av_encryption_init_info_get_side_data
    = ffi.Pointer<AVEncryptionInitInfo> Function(
  ffi.Pointer<ffi.Uint8> side_data,
  int side_data_size,
);

typedef _c_av_encryption_init_info_add_side_data = ffi.Pointer<ffi.Uint8>
    Function(
  ffi.Pointer<AVEncryptionInitInfo> info,
  ffi.Pointer<ffi.Uint64> side_data_size,
);

typedef _dart_av_encryption_init_info_add_side_data = ffi.Pointer<ffi.Uint8>
    Function(
  ffi.Pointer<AVEncryptionInitInfo> info,
  ffi.Pointer<ffi.Uint64> side_data_size,
);

typedef _typedefC_98 = ffi.Double Function(
  ffi.Pointer<ffi.Void>,
  ffi.Double,
);

typedef _typedefC_99 = ffi.Double Function(
  ffi.Pointer<ffi.Void>,
  ffi.Double,
  ffi.Double,
);

typedef _c_av_expr_parse_and_eval = ffi.Int32 Function(
  ffi.Pointer<ffi.Double> res,
  ffi.Pointer<ffi.Int8> s,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> const_names,
  ffi.Pointer<ffi.Double> const_values,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func1_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_98>>> funcs1,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func2_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_99>>> funcs2,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Int32 log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_expr_parse_and_eval = int Function(
  ffi.Pointer<ffi.Double> res,
  ffi.Pointer<ffi.Int8> s,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> const_names,
  ffi.Pointer<ffi.Double> const_values,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func1_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_98>>> funcs1,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func2_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_99>>> funcs2,
  ffi.Pointer<ffi.Void> opaque,
  int log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _typedefC_100 = ffi.Double Function(
  ffi.Pointer<ffi.Void>,
  ffi.Double,
);

typedef _typedefC_101 = ffi.Double Function(
  ffi.Pointer<ffi.Void>,
  ffi.Double,
  ffi.Double,
);

typedef _c_av_expr_parse = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVExpr>> expr,
  ffi.Pointer<ffi.Int8> s,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> const_names,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func1_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_100>>> funcs1,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func2_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_101>>> funcs2,
  ffi.Int32 log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_expr_parse = int Function(
  ffi.Pointer<ffi.Pointer<AVExpr>> expr,
  ffi.Pointer<ffi.Int8> s,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> const_names,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func1_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_100>>> funcs1,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> func2_names,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<_typedefC_101>>> funcs2,
  int log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_expr_eval = ffi.Double Function(
  ffi.Pointer<AVExpr> e,
  ffi.Pointer<ffi.Double> const_values,
  ffi.Pointer<ffi.Void> opaque,
);

typedef _dart_av_expr_eval = double Function(
  ffi.Pointer<AVExpr> e,
  ffi.Pointer<ffi.Double> const_values,
  ffi.Pointer<ffi.Void> opaque,
);

typedef _c_av_expr_count_vars = ffi.Int32 Function(
  ffi.Pointer<AVExpr> e,
  ffi.Pointer<ffi.Uint32> counter,
  ffi.Int32 size,
);

typedef _dart_av_expr_count_vars = int Function(
  ffi.Pointer<AVExpr> e,
  ffi.Pointer<ffi.Uint32> counter,
  int size,
);

typedef _c_av_expr_count_func = ffi.Int32 Function(
  ffi.Pointer<AVExpr> e,
  ffi.Pointer<ffi.Uint32> counter,
  ffi.Int32 size,
  ffi.Int32 arg,
);

typedef _dart_av_expr_count_func = int Function(
  ffi.Pointer<AVExpr> e,
  ffi.Pointer<ffi.Uint32> counter,
  int size,
  int arg,
);

typedef _c_av_expr_free = ffi.Void Function(
  ffi.Pointer<AVExpr> e,
);

typedef _dart_av_expr_free = void Function(
  ffi.Pointer<AVExpr> e,
);

typedef _c_av_strtod = ffi.Double Function(
  ffi.Pointer<ffi.Int8> numstr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> tail,
);

typedef _dart_av_strtod = double Function(
  ffi.Pointer<ffi.Int8> numstr,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> tail,
);

typedef _c_av_file_map = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufptr,
  ffi.Pointer<ffi.Uint64> size,
  ffi.Int32 log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_file_map = int Function(
  ffi.Pointer<ffi.Int8> filename,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> bufptr,
  ffi.Pointer<ffi.Uint64> size,
  int log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_file_unmap = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> bufptr,
  ffi.Uint64 size,
);

typedef _dart_av_file_unmap = void Function(
  ffi.Pointer<ffi.Uint8> bufptr,
  int size,
);

typedef _c_av_tempfile = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> prefix,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> filename,
  ffi.Int32 log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_tempfile = int Function(
  ffi.Pointer<ffi.Int8> prefix,
  ffi.Pointer<ffi.Pointer<ffi.Int8>> filename,
  int log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_film_grain_params_alloc = ffi.Pointer<AVFilmGrainParams> Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_av_film_grain_params_alloc = ffi.Pointer<AVFilmGrainParams>
    Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_av_film_grain_params_create_side_data
    = ffi.Pointer<AVFilmGrainParams> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_film_grain_params_create_side_data
    = ffi.Pointer<AVFilmGrainParams> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_hash_alloc = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_hash_alloc = int Function(
  ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_hash_names = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 i,
);

typedef _dart_av_hash_names = ffi.Pointer<ffi.Int8> Function(
  int i,
);

typedef _c_av_hash_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVHashContext> ctx,
);

typedef _dart_av_hash_get_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVHashContext> ctx,
);

typedef _c_av_hash_get_size = ffi.Int32 Function(
  ffi.Pointer<AVHashContext> ctx,
);

typedef _dart_av_hash_get_size = int Function(
  ffi.Pointer<AVHashContext> ctx,
);

typedef _c_av_hash_init = ffi.Void Function(
  ffi.Pointer<AVHashContext> ctx,
);

typedef _dart_av_hash_init = void Function(
  ffi.Pointer<AVHashContext> ctx,
);

typedef _c_av_hash_update = ffi.Void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 len,
);

typedef _dart_av_hash_update = void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> src,
  int len,
);

typedef _c_av_hash_final = ffi.Void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
);

typedef _dart_av_hash_final = void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
);

typedef _c_av_hash_final_bin = ffi.Void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Int32 size,
);

typedef _dart_av_hash_final_bin = void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  int size,
);

typedef _c_av_hash_final_hex = ffi.Void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Int32 size,
);

typedef _dart_av_hash_final_hex = void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  int size,
);

typedef _c_av_hash_final_b64 = ffi.Void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Int32 size,
);

typedef _dart_av_hash_final_b64 = void Function(
  ffi.Pointer<AVHashContext> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  int size,
);

typedef _c_av_hash_freep = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
);

typedef _dart_av_hash_freep = void Function(
  ffi.Pointer<ffi.Pointer<AVHashContext>> ctx,
);

typedef _c_av_dynamic_hdr_plus_alloc = ffi.Pointer<AVDynamicHDRPlus> Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_av_dynamic_hdr_plus_alloc = ffi.Pointer<AVDynamicHDRPlus>
    Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_av_dynamic_hdr_plus_create_side_data = ffi.Pointer<AVDynamicHDRPlus>
    Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_dynamic_hdr_plus_create_side_data
    = ffi.Pointer<AVDynamicHDRPlus> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_hmac_alloc = ffi.Pointer<AVHMAC> Function(
  ffi.Int32 type,
);

typedef _dart_av_hmac_alloc = ffi.Pointer<AVHMAC> Function(
  int type,
);

typedef _c_av_hmac_free = ffi.Void Function(
  ffi.Pointer<AVHMAC> ctx,
);

typedef _dart_av_hmac_free = void Function(
  ffi.Pointer<AVHMAC> ctx,
);

typedef _c_av_hmac_init = ffi.Void Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Uint32 keylen,
);

typedef _dart_av_hmac_init = void Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> key,
  int keylen,
);

typedef _c_av_hmac_update = ffi.Void Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint32 len,
);

typedef _dart_av_hmac_update = void Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> data,
  int len,
);

typedef _c_av_hmac_final = ffi.Int32 Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Uint32 outlen,
);

typedef _dart_av_hmac_final = int Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> out,
  int outlen,
);

typedef _c_av_hmac_calc = ffi.Int32 Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint32 len,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Uint32 keylen,
  ffi.Pointer<ffi.Uint8> out,
  ffi.Uint32 outlen,
);

typedef _dart_av_hmac_calc = int Function(
  ffi.Pointer<AVHMAC> ctx,
  ffi.Pointer<ffi.Uint8> data,
  int len,
  ffi.Pointer<ffi.Uint8> key,
  int keylen,
  ffi.Pointer<ffi.Uint8> out,
  int outlen,
);

typedef _c_av_map_videotoolbox_format_to_pixfmt = ffi.Int32 Function(
  ffi.Uint32 cv_fmt,
);

typedef _dart_av_map_videotoolbox_format_to_pixfmt = int Function(
  int cv_fmt,
);

typedef _c_av_map_videotoolbox_format_from_pixfmt = ffi.Uint32 Function(
  ffi.Int32 pix_fmt,
);

typedef _dart_av_map_videotoolbox_format_from_pixfmt = int Function(
  int pix_fmt,
);

typedef _c_av_map_videotoolbox_format_from_pixfmt2 = ffi.Uint32 Function(
  ffi.Int32 pix_fmt,
  ffi.Int32 full_range,
);

typedef _dart_av_map_videotoolbox_format_from_pixfmt2 = int Function(
  int pix_fmt,
  int full_range,
);

typedef _c_av_vk_frame_alloc = ffi.Pointer<AVVkFrame> Function();

typedef _dart_av_vk_frame_alloc = ffi.Pointer<AVVkFrame> Function();

typedef _c_av_vkfmt_from_pixfmt = ffi.Pointer<ffi.Int32> Function(
  ffi.Int32 p,
);

typedef _dart_av_vkfmt_from_pixfmt = ffi.Pointer<ffi.Int32> Function(
  int p,
);

typedef _c_av_get_bits_per_pixel = ffi.Int32 Function(
  ffi.Pointer<AVPixFmtDescriptor> pixdesc,
);

typedef _dart_av_get_bits_per_pixel = int Function(
  ffi.Pointer<AVPixFmtDescriptor> pixdesc,
);

typedef _c_av_get_padded_bits_per_pixel = ffi.Int32 Function(
  ffi.Pointer<AVPixFmtDescriptor> pixdesc,
);

typedef _dart_av_get_padded_bits_per_pixel = int Function(
  ffi.Pointer<AVPixFmtDescriptor> pixdesc,
);

typedef _c_av_pix_fmt_desc_get = ffi.Pointer<AVPixFmtDescriptor> Function(
  ffi.Int32 pix_fmt,
);

typedef _dart_av_pix_fmt_desc_get = ffi.Pointer<AVPixFmtDescriptor> Function(
  int pix_fmt,
);

typedef _c_av_pix_fmt_desc_next = ffi.Pointer<AVPixFmtDescriptor> Function(
  ffi.Pointer<AVPixFmtDescriptor> prev,
);

typedef _dart_av_pix_fmt_desc_next = ffi.Pointer<AVPixFmtDescriptor> Function(
  ffi.Pointer<AVPixFmtDescriptor> prev,
);

typedef _c_av_pix_fmt_desc_get_id = ffi.Int32 Function(
  ffi.Pointer<AVPixFmtDescriptor> desc,
);

typedef _dart_av_pix_fmt_desc_get_id = int Function(
  ffi.Pointer<AVPixFmtDescriptor> desc,
);

typedef _c_av_pix_fmt_get_chroma_sub_sample = ffi.Int32 Function(
  ffi.Int32 pix_fmt,
  ffi.Pointer<ffi.Int32> h_shift,
  ffi.Pointer<ffi.Int32> v_shift,
);

typedef _dart_av_pix_fmt_get_chroma_sub_sample = int Function(
  int pix_fmt,
  ffi.Pointer<ffi.Int32> h_shift,
  ffi.Pointer<ffi.Int32> v_shift,
);

typedef _c_av_pix_fmt_count_planes = ffi.Int32 Function(
  ffi.Int32 pix_fmt,
);

typedef _dart_av_pix_fmt_count_planes = int Function(
  int pix_fmt,
);

typedef _c_av_color_range_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 range,
);

typedef _dart_av_color_range_name = ffi.Pointer<ffi.Int8> Function(
  int range,
);

typedef _c_av_color_range_from_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_color_range_from_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_color_primaries_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 primaries,
);

typedef _dart_av_color_primaries_name = ffi.Pointer<ffi.Int8> Function(
  int primaries,
);

typedef _c_av_color_primaries_from_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_color_primaries_from_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_color_transfer_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 transfer,
);

typedef _dart_av_color_transfer_name = ffi.Pointer<ffi.Int8> Function(
  int transfer,
);

typedef _c_av_color_transfer_from_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_color_transfer_from_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_color_space_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 space,
);

typedef _dart_av_color_space_name = ffi.Pointer<ffi.Int8> Function(
  int space,
);

typedef _c_av_color_space_from_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_color_space_from_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_chroma_location_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 location,
);

typedef _dart_av_chroma_location_name = ffi.Pointer<ffi.Int8> Function(
  int location,
);

typedef _c_av_chroma_location_from_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_chroma_location_from_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_get_pix_fmt = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_get_pix_fmt = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_get_pix_fmt_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 pix_fmt,
);

typedef _dart_av_get_pix_fmt_name = ffi.Pointer<ffi.Int8> Function(
  int pix_fmt,
);

typedef _c_av_get_pix_fmt_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 buf_size,
  ffi.Int32 pix_fmt,
);

typedef _dart_av_get_pix_fmt_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  int buf_size,
  int pix_fmt,
);

typedef _c_av_read_image_line2 = ffi.Void Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  ffi.Int32 x,
  ffi.Int32 y,
  ffi.Int32 c,
  ffi.Int32 w,
  ffi.Int32 read_pal_component,
  ffi.Int32 dst_element_size,
);

typedef _dart_av_read_image_line2 = void Function(
  ffi.Pointer<ffi.Void> dst,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  int x,
  int y,
  int c,
  int w,
  int read_pal_component,
  int dst_element_size,
);

typedef _c_av_read_image_line = ffi.Void Function(
  ffi.Pointer<ffi.Uint16> dst,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  ffi.Int32 x,
  ffi.Int32 y,
  ffi.Int32 c,
  ffi.Int32 w,
  ffi.Int32 read_pal_component,
);

typedef _dart_av_read_image_line = void Function(
  ffi.Pointer<ffi.Uint16> dst,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  int x,
  int y,
  int c,
  int w,
  int read_pal_component,
);

typedef _c_av_write_image_line2 = ffi.Void Function(
  ffi.Pointer<ffi.Void> src,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  ffi.Int32 x,
  ffi.Int32 y,
  ffi.Int32 c,
  ffi.Int32 w,
  ffi.Int32 src_element_size,
);

typedef _dart_av_write_image_line2 = void Function(
  ffi.Pointer<ffi.Void> src,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  int x,
  int y,
  int c,
  int w,
  int src_element_size,
);

typedef _c_av_write_image_line = ffi.Void Function(
  ffi.Pointer<ffi.Uint16> src,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  ffi.Int32 x,
  ffi.Int32 y,
  ffi.Int32 c,
  ffi.Int32 w,
);

typedef _dart_av_write_image_line = void Function(
  ffi.Pointer<ffi.Uint16> src,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Pointer<ffi.Int32> linesize,
  ffi.Pointer<AVPixFmtDescriptor> desc,
  int x,
  int y,
  int c,
  int w,
);

typedef _c_av_pix_fmt_swap_endianness = ffi.Int32 Function(
  ffi.Int32 pix_fmt,
);

typedef _dart_av_pix_fmt_swap_endianness = int Function(
  int pix_fmt,
);

typedef _c_av_get_pix_fmt_loss = ffi.Int32 Function(
  ffi.Int32 dst_pix_fmt,
  ffi.Int32 src_pix_fmt,
  ffi.Int32 has_alpha,
);

typedef _dart_av_get_pix_fmt_loss = int Function(
  int dst_pix_fmt,
  int src_pix_fmt,
  int has_alpha,
);

typedef _c_av_find_best_pix_fmt_of_2 = ffi.Int32 Function(
  ffi.Int32 dst_pix_fmt1,
  ffi.Int32 dst_pix_fmt2,
  ffi.Int32 src_pix_fmt,
  ffi.Int32 has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _dart_av_find_best_pix_fmt_of_2 = int Function(
  int dst_pix_fmt1,
  int dst_pix_fmt2,
  int src_pix_fmt,
  int has_alpha,
  ffi.Pointer<ffi.Int32> loss_ptr,
);

typedef _c_av_image_fill_max_pixsteps = ffi.Void Function(
  ffi.Pointer<ffi.Int32> max_pixsteps,
  ffi.Pointer<ffi.Int32> max_pixstep_comps,
  ffi.Pointer<AVPixFmtDescriptor> pixdesc,
);

typedef _dart_av_image_fill_max_pixsteps = void Function(
  ffi.Pointer<ffi.Int32> max_pixsteps,
  ffi.Pointer<ffi.Int32> max_pixstep_comps,
  ffi.Pointer<AVPixFmtDescriptor> pixdesc,
);

typedef _c_av_image_get_linesize = ffi.Int32 Function(
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 plane,
);

typedef _dart_av_image_get_linesize = int Function(
  int pix_fmt,
  int width,
  int plane,
);

typedef _c_av_image_fill_linesizes = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> linesizes,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
);

typedef _dart_av_image_fill_linesizes = int Function(
  ffi.Pointer<ffi.Int32> linesizes,
  int pix_fmt,
  int width,
);

typedef _c_av_image_fill_plane_sizes = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint64> size,
  ffi.Int32 pix_fmt,
  ffi.Int32 height,
  ffi.Pointer<ffi.Int64> linesizes,
);

typedef _dart_av_image_fill_plane_sizes = int Function(
  ffi.Pointer<ffi.Uint64> size,
  int pix_fmt,
  int height,
  ffi.Pointer<ffi.Int64> linesizes,
);

typedef _c_av_image_fill_pointers = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  ffi.Int32 pix_fmt,
  ffi.Int32 height,
  ffi.Pointer<ffi.Uint8> ptr,
  ffi.Pointer<ffi.Int32> linesizes,
);

typedef _dart_av_image_fill_pointers = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> data,
  int pix_fmt,
  int height,
  ffi.Pointer<ffi.Uint8> ptr,
  ffi.Pointer<ffi.Int32> linesizes,
);

typedef _c_av_image_alloc = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> pointers,
  ffi.Pointer<ffi.Int32> linesizes,
  ffi.Int32 w,
  ffi.Int32 h,
  ffi.Int32 pix_fmt,
  ffi.Int32 align,
);

typedef _dart_av_image_alloc = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> pointers,
  ffi.Pointer<ffi.Int32> linesizes,
  int w,
  int h,
  int pix_fmt,
  int align,
);

typedef _c_av_image_copy_plane = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Int32 dst_linesize,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 src_linesize,
  ffi.Int32 bytewidth,
  ffi.Int32 height,
);

typedef _dart_av_image_copy_plane = void Function(
  ffi.Pointer<ffi.Uint8> dst,
  int dst_linesize,
  ffi.Pointer<ffi.Uint8> src,
  int src_linesize,
  int bytewidth,
  int height,
);

typedef _c_av_image_copy = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int32> dst_linesizes,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
  ffi.Pointer<ffi.Int32> src_linesizes,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_av_image_copy = void Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int32> dst_linesizes,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
  ffi.Pointer<ffi.Int32> src_linesizes,
  int pix_fmt,
  int width,
  int height,
);

typedef _c_av_image_copy_uc_from = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int64> dst_linesizes,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
  ffi.Pointer<ffi.Int64> src_linesizes,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_av_image_copy_uc_from = void Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int64> dst_linesizes,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
  ffi.Pointer<ffi.Int64> src_linesizes,
  int pix_fmt,
  int width,
  int height,
);

typedef _c_av_image_fill_arrays = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int32> dst_linesize,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 align,
);

typedef _dart_av_image_fill_arrays = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int32> dst_linesize,
  ffi.Pointer<ffi.Uint8> src,
  int pix_fmt,
  int width,
  int height,
  int align,
);

typedef _c_av_image_get_buffer_size = ffi.Int32 Function(
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 align,
);

typedef _dart_av_image_get_buffer_size = int Function(
  int pix_fmt,
  int width,
  int height,
  int align,
);

typedef _c_av_image_copy_to_buffer = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Int32 dst_size,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
  ffi.Pointer<ffi.Int32> src_linesize,
  ffi.Int32 pix_fmt,
  ffi.Int32 width,
  ffi.Int32 height,
  ffi.Int32 align,
);

typedef _dart_av_image_copy_to_buffer = int Function(
  ffi.Pointer<ffi.Uint8> dst,
  int dst_size,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> src_data,
  ffi.Pointer<ffi.Int32> src_linesize,
  int pix_fmt,
  int width,
  int height,
  int align,
);

typedef _c_av_image_check_size = ffi.Int32 Function(
  ffi.Uint32 w,
  ffi.Uint32 h,
  ffi.Int32 log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_image_check_size = int Function(
  int w,
  int h,
  int log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_image_check_size2 = ffi.Int32 Function(
  ffi.Uint32 w,
  ffi.Uint32 h,
  ffi.Int64 max_pixels,
  ffi.Int32 pix_fmt,
  ffi.Int32 log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_image_check_size2 = int Function(
  int w,
  int h,
  int max_pixels,
  int pix_fmt,
  int log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_image_fill_black = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int64> dst_linesize,
  ffi.Int32 pix_fmt,
  ffi.Int32 range,
  ffi.Int32 width,
  ffi.Int32 height,
);

typedef _dart_av_image_fill_black = int Function(
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> dst_data,
  ffi.Pointer<ffi.Int64> dst_linesize,
  int pix_fmt,
  int range,
  int width,
  int height,
);

typedef _c_av_lfg_init = ffi.Void Function(
  ffi.Pointer<AVLFG> c,
  ffi.Uint32 seed,
);

typedef _dart_av_lfg_init = void Function(
  ffi.Pointer<AVLFG> c,
  int seed,
);

typedef _c_av_lfg_init_from_data = ffi.Int32 Function(
  ffi.Pointer<AVLFG> c,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint32 length,
);

typedef _dart_av_lfg_init_from_data = int Function(
  ffi.Pointer<AVLFG> c,
  ffi.Pointer<ffi.Uint8> data,
  int length,
);

typedef _c_av_lfg_get = ffi.Uint32 Function(
  ffi.Pointer<AVLFG> c,
);

typedef _dart_av_lfg_get = int Function(
  ffi.Pointer<AVLFG> c,
);

typedef _c_av_mlfg_get = ffi.Uint32 Function(
  ffi.Pointer<AVLFG> c,
);

typedef _dart_av_mlfg_get = int Function(
  ffi.Pointer<AVLFG> c,
);

typedef _c_av_bmg_get = ffi.Void Function(
  ffi.Pointer<AVLFG> lfg,
  ffi.Pointer<ffi.Double> out,
);

typedef _dart_av_bmg_get = void Function(
  ffi.Pointer<AVLFG> lfg,
  ffi.Pointer<ffi.Double> out,
);

typedef _c_av_lzo1x_decode = ffi.Int32 Function(
  ffi.Pointer<ffi.Void> out,
  ffi.Pointer<ffi.Int32> outlen,
  ffi.Pointer<ffi.Void> in_1,
  ffi.Pointer<ffi.Int32> inlen,
);

typedef _dart_av_lzo1x_decode = int Function(
  ffi.Pointer<ffi.Void> out,
  ffi.Pointer<ffi.Int32> outlen,
  ffi.Pointer<ffi.Void> in_1,
  ffi.Pointer<ffi.Int32> inlen,
);

typedef _c_av_mastering_display_metadata_alloc
    = ffi.Pointer<AVMasteringDisplayMetadata> Function();

typedef _dart_av_mastering_display_metadata_alloc
    = ffi.Pointer<AVMasteringDisplayMetadata> Function();

typedef _c_av_mastering_display_metadata_create_side_data
    = ffi.Pointer<AVMasteringDisplayMetadata> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_mastering_display_metadata_create_side_data
    = ffi.Pointer<AVMasteringDisplayMetadata> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_content_light_metadata_alloc = ffi.Pointer<AVContentLightMetadata>
    Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_av_content_light_metadata_alloc
    = ffi.Pointer<AVContentLightMetadata> Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_av_content_light_metadata_create_side_data
    = ffi.Pointer<AVContentLightMetadata> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_content_light_metadata_create_side_data
    = ffi.Pointer<AVContentLightMetadata> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_md5_alloc = ffi.Pointer<AVMD5> Function();

typedef _dart_av_md5_alloc = ffi.Pointer<AVMD5> Function();

typedef _c_av_md5_init = ffi.Void Function(
  ffi.Pointer<AVMD5> ctx,
);

typedef _dart_av_md5_init = void Function(
  ffi.Pointer<AVMD5> ctx,
);

typedef _c_av_md5_update = ffi.Void Function(
  ffi.Pointer<AVMD5> ctx,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 len,
);

typedef _dart_av_md5_update = void Function(
  ffi.Pointer<AVMD5> ctx,
  ffi.Pointer<ffi.Uint8> src,
  int len,
);

typedef _c_av_md5_final = ffi.Void Function(
  ffi.Pointer<AVMD5> ctx,
  ffi.Pointer<ffi.Uint8> dst,
);

typedef _dart_av_md5_final = void Function(
  ffi.Pointer<AVMD5> ctx,
  ffi.Pointer<ffi.Uint8> dst,
);

typedef _c_av_md5_sum = ffi.Void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 len,
);

typedef _dart_av_md5_sum = void Function(
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int len,
);

typedef _c_av_murmur3_alloc = ffi.Pointer<AVMurMur3> Function();

typedef _dart_av_murmur3_alloc = ffi.Pointer<AVMurMur3> Function();

typedef _c_av_murmur3_init_seeded = ffi.Void Function(
  ffi.Pointer<AVMurMur3> c,
  ffi.Uint64 seed,
);

typedef _dart_av_murmur3_init_seeded = void Function(
  ffi.Pointer<AVMurMur3> c,
  int seed,
);

typedef _c_av_murmur3_init = ffi.Void Function(
  ffi.Pointer<AVMurMur3> c,
);

typedef _dart_av_murmur3_init = void Function(
  ffi.Pointer<AVMurMur3> c,
);

typedef _c_av_murmur3_update = ffi.Void Function(
  ffi.Pointer<AVMurMur3> c,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 len,
);

typedef _dart_av_murmur3_update = void Function(
  ffi.Pointer<AVMurMur3> c,
  ffi.Pointer<ffi.Uint8> src,
  int len,
);

typedef _c_av_murmur3_final = ffi.Void Function(
  ffi.Pointer<AVMurMur3> c,
  ffi.Pointer<ffi.Uint8> dst,
);

typedef _dart_av_murmur3_final = void Function(
  ffi.Pointer<AVMurMur3> c,
  ffi.Pointer<ffi.Uint8> dst,
);

typedef _c_av_parse_ratio = ffi.Int32 Function(
  ffi.Pointer<AVRational> q,
  ffi.Pointer<ffi.Int8> str,
  ffi.Int32 max,
  ffi.Int32 log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_parse_ratio = int Function(
  ffi.Pointer<AVRational> q,
  ffi.Pointer<ffi.Int8> str,
  int max,
  int log_offset,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_parse_video_size = ffi.Int32 Function(
  ffi.Pointer<ffi.Int32> width_ptr,
  ffi.Pointer<ffi.Int32> height_ptr,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_av_parse_video_size = int Function(
  ffi.Pointer<ffi.Int32> width_ptr,
  ffi.Pointer<ffi.Int32> height_ptr,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_av_parse_video_rate = ffi.Int32 Function(
  ffi.Pointer<AVRational> rate,
  ffi.Pointer<ffi.Int8> str,
);

typedef _dart_av_parse_video_rate = int Function(
  ffi.Pointer<AVRational> rate,
  ffi.Pointer<ffi.Int8> str,
);

typedef _c_av_parse_color = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8> rgba_color,
  ffi.Pointer<ffi.Int8> color_string,
  ffi.Int32 slen,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_parse_color = int Function(
  ffi.Pointer<ffi.Uint8> rgba_color,
  ffi.Pointer<ffi.Int8> color_string,
  int slen,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_get_known_color_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 color_idx,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> rgb,
);

typedef _dart_av_get_known_color_name = ffi.Pointer<ffi.Int8> Function(
  int color_idx,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>> rgb,
);

typedef _c_av_parse_time = ffi.Int32 Function(
  ffi.Pointer<ffi.Int64> timeval,
  ffi.Pointer<ffi.Int8> timestr,
  ffi.Int32 duration,
);

typedef _dart_av_parse_time = int Function(
  ffi.Pointer<ffi.Int64> timeval,
  ffi.Pointer<ffi.Int8> timestr,
  int duration,
);

typedef _c_av_find_info_tag = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> arg,
  ffi.Int32 arg_size,
  ffi.Pointer<ffi.Int8> tag1,
  ffi.Pointer<ffi.Int8> info,
);

typedef _dart_av_find_info_tag = int Function(
  ffi.Pointer<ffi.Int8> arg,
  int arg_size,
  ffi.Pointer<ffi.Int8> tag1,
  ffi.Pointer<ffi.Int8> info,
);

typedef _c_av_small_strptime = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> p,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<tm> dt,
);

typedef _dart_av_small_strptime = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> p,
  ffi.Pointer<ffi.Int8> fmt,
  ffi.Pointer<tm> dt,
);

typedef _c_av_timegm = ffi.Int64 Function(
  ffi.Pointer<tm> tm,
);

typedef _dart_av_timegm = int Function(
  ffi.Pointer<tm> tm,
);

typedef av_pixelutils_sad_fn = ffi.Int32 Function(
  ffi.Pointer<ffi.Uint8>,
  ffi.Int64,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int64,
);

typedef _c_av_pixelutils_get_sad_fn
    = ffi.Pointer<ffi.NativeFunction<av_pixelutils_sad_fn>> Function(
  ffi.Int32 w_bits,
  ffi.Int32 h_bits,
  ffi.Int32 aligned,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _dart_av_pixelutils_get_sad_fn
    = ffi.Pointer<ffi.NativeFunction<av_pixelutils_sad_fn>> Function(
  int w_bits,
  int h_bits,
  int aligned,
  ffi.Pointer<ffi.Void> log_ctx,
);

typedef _c_av_get_random_seed = ffi.Uint32 Function();

typedef _dart_av_get_random_seed = int Function();

typedef _c_av_rc4_alloc = ffi.Pointer<AVRC4> Function();

typedef _dart_av_rc4_alloc = ffi.Pointer<AVRC4> Function();

typedef _c_av_rc4_init = ffi.Int32 Function(
  ffi.Pointer<AVRC4> d,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 key_bits,
  ffi.Int32 decrypt,
);

typedef _dart_av_rc4_init = int Function(
  ffi.Pointer<AVRC4> d,
  ffi.Pointer<ffi.Uint8> key,
  int key_bits,
  int decrypt,
);

typedef _c_av_rc4_crypt = ffi.Void Function(
  ffi.Pointer<AVRC4> d,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_rc4_crypt = void Function(
  ffi.Pointer<AVRC4> d,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_ripemd_alloc = ffi.Pointer<AVRIPEMD> Function();

typedef _dart_av_ripemd_alloc = ffi.Pointer<AVRIPEMD> Function();

typedef _c_av_ripemd_init = ffi.Int32 Function(
  ffi.Pointer<AVRIPEMD> context,
  ffi.Int32 bits,
);

typedef _dart_av_ripemd_init = int Function(
  ffi.Pointer<AVRIPEMD> context,
  int bits,
);

typedef _c_av_ripemd_update = ffi.Void Function(
  ffi.Pointer<AVRIPEMD> context,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint32 len,
);

typedef _dart_av_ripemd_update = void Function(
  ffi.Pointer<AVRIPEMD> context,
  ffi.Pointer<ffi.Uint8> data,
  int len,
);

typedef _c_av_ripemd_final = ffi.Void Function(
  ffi.Pointer<AVRIPEMD> context,
  ffi.Pointer<ffi.Uint8> digest,
);

typedef _dart_av_ripemd_final = void Function(
  ffi.Pointer<AVRIPEMD> context,
  ffi.Pointer<ffi.Uint8> digest,
);

typedef _c_av_sha_alloc = ffi.Pointer<AVSHA> Function();

typedef _dart_av_sha_alloc = ffi.Pointer<AVSHA> Function();

typedef _c_av_sha_init = ffi.Int32 Function(
  ffi.Pointer<AVSHA> context,
  ffi.Int32 bits,
);

typedef _dart_av_sha_init = int Function(
  ffi.Pointer<AVSHA> context,
  int bits,
);

typedef _c_av_sha_update = ffi.Void Function(
  ffi.Pointer<AVSHA> ctx,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint32 len,
);

typedef _dart_av_sha_update = void Function(
  ffi.Pointer<AVSHA> ctx,
  ffi.Pointer<ffi.Uint8> data,
  int len,
);

typedef _c_av_sha_final = ffi.Void Function(
  ffi.Pointer<AVSHA> context,
  ffi.Pointer<ffi.Uint8> digest,
);

typedef _dart_av_sha_final = void Function(
  ffi.Pointer<AVSHA> context,
  ffi.Pointer<ffi.Uint8> digest,
);

typedef _c_av_sha512_alloc = ffi.Pointer<AVSHA512> Function();

typedef _dart_av_sha512_alloc = ffi.Pointer<AVSHA512> Function();

typedef _c_av_sha512_init = ffi.Int32 Function(
  ffi.Pointer<AVSHA512> context,
  ffi.Int32 bits,
);

typedef _dart_av_sha512_init = int Function(
  ffi.Pointer<AVSHA512> context,
  int bits,
);

typedef _c_av_sha512_update = ffi.Void Function(
  ffi.Pointer<AVSHA512> context,
  ffi.Pointer<ffi.Uint8> data,
  ffi.Uint32 len,
);

typedef _dart_av_sha512_update = void Function(
  ffi.Pointer<AVSHA512> context,
  ffi.Pointer<ffi.Uint8> data,
  int len,
);

typedef _c_av_sha512_final = ffi.Void Function(
  ffi.Pointer<AVSHA512> context,
  ffi.Pointer<ffi.Uint8> digest,
);

typedef _dart_av_sha512_final = void Function(
  ffi.Pointer<AVSHA512> context,
  ffi.Pointer<ffi.Uint8> digest,
);

typedef _c_av_spherical_alloc = ffi.Pointer<AVSphericalMapping> Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _dart_av_spherical_alloc = ffi.Pointer<AVSphericalMapping> Function(
  ffi.Pointer<ffi.Uint64> size,
);

typedef _c_av_spherical_tile_bounds = ffi.Void Function(
  ffi.Pointer<AVSphericalMapping> map,
  ffi.Uint64 width,
  ffi.Uint64 height,
  ffi.Pointer<ffi.Uint64> left,
  ffi.Pointer<ffi.Uint64> top,
  ffi.Pointer<ffi.Uint64> right,
  ffi.Pointer<ffi.Uint64> bottom,
);

typedef _dart_av_spherical_tile_bounds = void Function(
  ffi.Pointer<AVSphericalMapping> map,
  int width,
  int height,
  ffi.Pointer<ffi.Uint64> left,
  ffi.Pointer<ffi.Uint64> top,
  ffi.Pointer<ffi.Uint64> right,
  ffi.Pointer<ffi.Uint64> bottom,
);

typedef _c_av_spherical_projection_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Int32 projection,
);

typedef _dart_av_spherical_projection_name = ffi.Pointer<ffi.Int8> Function(
  int projection,
);

typedef _c_av_spherical_from_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_spherical_from_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_stereo3d_alloc = ffi.Pointer<AVStereo3D> Function();

typedef _dart_av_stereo3d_alloc = ffi.Pointer<AVStereo3D> Function();

typedef _c_av_stereo3d_create_side_data = ffi.Pointer<AVStereo3D> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _dart_av_stereo3d_create_side_data = ffi.Pointer<AVStereo3D> Function(
  ffi.Pointer<AVFrame> frame,
);

typedef _c_av_stereo3d_type_name = ffi.Pointer<ffi.Int8> Function(
  ffi.Uint32 type,
);

typedef _dart_av_stereo3d_type_name = ffi.Pointer<ffi.Int8> Function(
  int type,
);

typedef _c_av_stereo3d_from_name = ffi.Int32 Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _dart_av_stereo3d_from_name = int Function(
  ffi.Pointer<ffi.Int8> name,
);

typedef _c_av_tea_alloc = ffi.Pointer<AVTEA> Function();

typedef _dart_av_tea_alloc = ffi.Pointer<AVTEA> Function();

typedef _c_av_tea_init = ffi.Void Function(
  ffi.Pointer<AVTEA> ctx,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 rounds,
);

typedef _dart_av_tea_init = void Function(
  ffi.Pointer<AVTEA> ctx,
  ffi.Pointer<ffi.Uint8> key,
  int rounds,
);

typedef _c_av_tea_crypt = ffi.Void Function(
  ffi.Pointer<AVTEA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_tea_crypt = void Function(
  ffi.Pointer<AVTEA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_thread_message_queue_alloc = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
  ffi.Uint32 nelem,
  ffi.Uint32 elsize,
);

typedef _dart_av_thread_message_queue_alloc = int Function(
  ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
  int nelem,
  int elsize,
);

typedef _c_av_thread_message_queue_free = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
);

typedef _dart_av_thread_message_queue_free = void Function(
  ffi.Pointer<ffi.Pointer<AVThreadMessageQueue>> mq,
);

typedef _c_av_thread_message_queue_send = ffi.Int32 Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Pointer<ffi.Void> msg,
  ffi.Uint32 flags,
);

typedef _dart_av_thread_message_queue_send = int Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Pointer<ffi.Void> msg,
  int flags,
);

typedef _c_av_thread_message_queue_recv = ffi.Int32 Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Pointer<ffi.Void> msg,
  ffi.Uint32 flags,
);

typedef _dart_av_thread_message_queue_recv = int Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Pointer<ffi.Void> msg,
  int flags,
);

typedef _c_av_thread_message_queue_set_err_send = ffi.Void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Int32 err,
);

typedef _dart_av_thread_message_queue_set_err_send = void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  int err,
);

typedef _c_av_thread_message_queue_set_err_recv = ffi.Void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Int32 err,
);

typedef _dart_av_thread_message_queue_set_err_recv = void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  int err,
);

typedef _typedefC_104 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _c_av_thread_message_queue_set_free_func = ffi.Void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Pointer<ffi.NativeFunction<_typedefC_104>> free_func,
);

typedef _dart_av_thread_message_queue_set_free_func = void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
  ffi.Pointer<ffi.NativeFunction<_typedefC_104>> free_func,
);

typedef _c_av_thread_message_queue_nb_elems = ffi.Int32 Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
);

typedef _dart_av_thread_message_queue_nb_elems = int Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
);

typedef _c_av_thread_message_flush = ffi.Void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
);

typedef _dart_av_thread_message_flush = void Function(
  ffi.Pointer<AVThreadMessageQueue> mq,
);

typedef _c_av_gettime = ffi.Int64 Function();

typedef _dart_av_gettime = int Function();

typedef _c_av_gettime_relative = ffi.Int64 Function();

typedef _dart_av_gettime_relative = int Function();

typedef _c_av_gettime_relative_is_monotonic = ffi.Int32 Function();

typedef _dart_av_gettime_relative_is_monotonic = int Function();

typedef _c_av_usleep = ffi.Int32 Function(
  ffi.Uint32 usec,
);

typedef _dart_av_usleep = int Function(
  int usec,
);

typedef _c_av_timecode_adjust_ntsc_framenum2 = ffi.Int32 Function(
  ffi.Int32 framenum,
  ffi.Int32 fps,
);

typedef _dart_av_timecode_adjust_ntsc_framenum2 = int Function(
  int framenum,
  int fps,
);

typedef _c_av_timecode_get_smpte_from_framenum = ffi.Uint32 Function(
  ffi.Pointer<AVTimecode> tc,
  ffi.Int32 framenum,
);

typedef _dart_av_timecode_get_smpte_from_framenum = int Function(
  ffi.Pointer<AVTimecode> tc,
  int framenum,
);

typedef _c_av_timecode_make_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVTimecode> tc,
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int32 framenum,
);

typedef _dart_av_timecode_make_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<AVTimecode> tc,
  ffi.Pointer<ffi.Int8> buf,
  int framenum,
);

typedef _c_av_timecode_make_smpte_tc_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Uint32 tcsmpte,
  ffi.Int32 prevent_df,
);

typedef _dart_av_timecode_make_smpte_tc_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  int tcsmpte,
  int prevent_df,
);

typedef _c_av_timecode_make_mpeg_tc_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Uint32 tc25bit,
);

typedef _dart_av_timecode_make_mpeg_tc_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  int tc25bit,
);

typedef _c_av_ts_make_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int64 ts,
);

typedef _dart_av_ts_make_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  int ts,
);

typedef _c_av_ts_make_time_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  ffi.Int64 ts,
  ffi.Pointer<AVRational> tb,
);

typedef _dart_av_ts_make_time_string = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Int8> buf,
  int ts,
  ffi.Pointer<AVRational> tb,
);

typedef _c_av_tree_node_alloc = ffi.Pointer<AVTreeNode> Function();

typedef _dart_av_tree_node_alloc = ffi.Pointer<AVTreeNode> Function();

typedef _typedefC_105 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_av_tree_find = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVTreeNode> root,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.NativeFunction<_typedefC_105>> cmp,
  ffi.Pointer<ffi.Pointer<ffi.Void>> next,
);

typedef _dart_av_tree_find = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<AVTreeNode> root,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.NativeFunction<_typedefC_105>> cmp,
  ffi.Pointer<ffi.Pointer<ffi.Void>> next,
);

typedef _typedefC_106 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_av_tree_insert = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<AVTreeNode>> rootp,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.NativeFunction<_typedefC_106>> cmp,
  ffi.Pointer<ffi.Pointer<AVTreeNode>> next,
);

typedef _dart_av_tree_insert = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Pointer<AVTreeNode>> rootp,
  ffi.Pointer<ffi.Void> key,
  ffi.Pointer<ffi.NativeFunction<_typedefC_106>> cmp,
  ffi.Pointer<ffi.Pointer<AVTreeNode>> next,
);

typedef _c_av_tree_destroy = ffi.Void Function(
  ffi.Pointer<AVTreeNode> t,
);

typedef _dart_av_tree_destroy = void Function(
  ffi.Pointer<AVTreeNode> t,
);

typedef _typedefC_107 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_108 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _c_av_tree_enumerate = ffi.Void Function(
  ffi.Pointer<AVTreeNode> t,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.NativeFunction<_typedefC_107>> cmp,
  ffi.Pointer<ffi.NativeFunction<_typedefC_108>> enu,
);

typedef _dart_av_tree_enumerate = void Function(
  ffi.Pointer<AVTreeNode> t,
  ffi.Pointer<ffi.Void> opaque,
  ffi.Pointer<ffi.NativeFunction<_typedefC_107>> cmp,
  ffi.Pointer<ffi.NativeFunction<_typedefC_108>> enu,
);

typedef _c_av_twofish_alloc = ffi.Pointer<AVTWOFISH> Function();

typedef _dart_av_twofish_alloc = ffi.Pointer<AVTWOFISH> Function();

typedef _c_av_twofish_init = ffi.Int32 Function(
  ffi.Pointer<AVTWOFISH> ctx,
  ffi.Pointer<ffi.Uint8> key,
  ffi.Int32 key_bits,
);

typedef _dart_av_twofish_init = int Function(
  ffi.Pointer<AVTWOFISH> ctx,
  ffi.Pointer<ffi.Uint8> key,
  int key_bits,
);

typedef _c_av_twofish_crypt = ffi.Void Function(
  ffi.Pointer<AVTWOFISH> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_twofish_crypt = void Function(
  ffi.Pointer<AVTWOFISH> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef av_tx_fn = ffi.Void Function(
  ffi.Pointer<AVTXContext>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
  ffi.Int64,
);

typedef _c_av_tx_init = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<av_tx_fn>>> tx,
  ffi.Int32 type,
  ffi.Int32 inv,
  ffi.Int32 len,
  ffi.Pointer<ffi.Void> scale,
  ffi.Uint64 flags,
);

typedef _dart_av_tx_init = int Function(
  ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
  ffi.Pointer<ffi.Pointer<ffi.NativeFunction<av_tx_fn>>> tx,
  int type,
  int inv,
  int len,
  ffi.Pointer<ffi.Void> scale,
  int flags,
);

typedef _c_av_tx_uninit = ffi.Void Function(
  ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
);

typedef _dart_av_tx_uninit = void Function(
  ffi.Pointer<ffi.Pointer<AVTXContext>> ctx,
);

typedef _c_av_video_enc_params_block = ffi.Pointer<AVVideoBlockParams> Function(
  ffi.Pointer<AVVideoEncParams> par,
  ffi.Uint32 idx,
);

typedef _dart_av_video_enc_params_block = ffi.Pointer<AVVideoBlockParams>
    Function(
  ffi.Pointer<AVVideoEncParams> par,
  int idx,
);

typedef _c_av_video_enc_params_alloc = ffi.Pointer<AVVideoEncParams> Function(
  ffi.Int32 type,
  ffi.Uint32 nb_blocks,
  ffi.Pointer<ffi.Uint64> out_size,
);

typedef _dart_av_video_enc_params_alloc = ffi.Pointer<AVVideoEncParams>
    Function(
  int type,
  int nb_blocks,
  ffi.Pointer<ffi.Uint64> out_size,
);

typedef _c_av_video_enc_params_create_side_data = ffi.Pointer<AVVideoEncParams>
    Function(
  ffi.Pointer<AVFrame> frame,
  ffi.Int32 type,
  ffi.Uint32 nb_blocks,
);

typedef _dart_av_video_enc_params_create_side_data
    = ffi.Pointer<AVVideoEncParams> Function(
  ffi.Pointer<AVFrame> frame,
  int type,
  int nb_blocks,
);

typedef _c_av_xtea_alloc = ffi.Pointer<AVXTEA> Function();

typedef _dart_av_xtea_alloc = ffi.Pointer<AVXTEA> Function();

typedef _c_av_xtea_init = ffi.Void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> key,
);

typedef _dart_av_xtea_init = void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> key,
);

typedef _c_av_xtea_le_init = ffi.Void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> key,
);

typedef _dart_av_xtea_le_init = void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> key,
);

typedef _c_av_xtea_crypt = ffi.Void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_xtea_crypt = void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _c_av_xtea_le_crypt = ffi.Void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  ffi.Int32 count,
  ffi.Pointer<ffi.Uint8> iv,
  ffi.Int32 decrypt,
);

typedef _dart_av_xtea_le_crypt = void Function(
  ffi.Pointer<AVXTEA> ctx,
  ffi.Pointer<ffi.Uint8> dst,
  ffi.Pointer<ffi.Uint8> src,
  int count,
  ffi.Pointer<ffi.Uint8> iv,
  int decrypt,
);

typedef _typedefC_1 = ffi.Pointer<ffi.Int8> Function(
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_2 = ffi.Pointer<ffi.Void> Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_3 = ffi.Pointer<AVClass> Function(
  ffi.Pointer<AVClass>,
);

typedef _typedefC_4 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_5 = ffi.Int32 Function(
  ffi.Pointer<ffi.Pointer<AVOptionRanges>>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
);

typedef _typedefC_6 = ffi.Pointer<AVClass> Function(
  ffi.Pointer<ffi.Pointer<ffi.Void>>,
);

typedef _typedefC_12 = ffi.Void Function(
  ffi.Pointer<AVHWDeviceContext>,
);

typedef _typedefC_13 = ffi.Void Function(
  ffi.Pointer<AVHWFramesContext>,
);

typedef _typedefC_14 = ffi.Int32 Function(
  ffi.Pointer<AVBSFContext>,
);

typedef _typedefC_15 = ffi.Int32 Function(
  ffi.Pointer<AVBSFContext>,
  ffi.Pointer<AVPacket>,
);

typedef _typedefC_16 = ffi.Void Function(
  ffi.Pointer<AVBSFContext>,
);

typedef _typedefC_17 = ffi.Void Function(
  ffi.Pointer<AVBSFContext>,
);

typedef _typedefC_18 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<AVCodecContext>,
);

typedef _typedefC_19 = ffi.Void Function(
  ffi.Pointer<AVCodec>,
);

typedef _typedefC_20 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
);

typedef _typedefC_21 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
  ffi.Pointer<AVSubtitle>,
);

typedef _typedefC_22 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<AVPacket>,
  ffi.Pointer<AVFrame>,
  ffi.Pointer<ffi.Int32>,
);

typedef _typedefC_23 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int32>,
  ffi.Pointer<AVPacket>,
);

typedef _typedefC_24 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
);

typedef _typedefC_25 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<AVPacket>,
);

typedef _typedefC_26 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<AVFrame>,
);

typedef _typedefC_27 = ffi.Void Function(
  ffi.Pointer<AVCodecContext>,
);

typedef _typedefC_28 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<AVFrame>,
);

typedef _typedefC_29 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Uint32,
);

typedef _typedefC_30 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Int32,
  ffi.Pointer<ffi.Uint8>,
  ffi.Uint32,
);

typedef _typedefC_31 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Uint32,
);

typedef _typedefC_32 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
);

typedef _typedefC_33 = ffi.Void Function(
  ffi.Pointer<MpegEncContext>,
);

typedef _typedefC_34 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
);

typedef _typedefC_35 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
);

typedef _typedefC_36 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<AVBufferRef>,
);

typedef _typedefC_37 = ffi.Int32 Function(
  ffi.Pointer<AVCodecParserContext>,
);

typedef _typedefC_38 = ffi.Int32 Function(
  ffi.Pointer<AVCodecParserContext>,
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Pointer<ffi.Uint8>>,
  ffi.Pointer<ffi.Int32>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);

typedef _typedefC_39 = ffi.Void Function(
  ffi.Pointer<AVCodecParserContext>,
);

typedef _typedefC_40 = ffi.Int32 Function(
  ffi.Pointer<AVCodecContext>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);

typedef _typedefC_44 = ffi.Void Function(
  ffi.Pointer<ffi.Int16>,
);

typedef _typedefC_45 = ffi.Void Function(
  ffi.Pointer<ffi.Int16>,
);

typedef _typedefC_46 = ffi.Void Function(
  ffi.Pointer<ffi.Int16>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int64,
);

typedef _typedefC_47 = ffi.Void Function(
  ffi.Pointer<ffi.Int16>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int64,
);

typedef _typedefC_48 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_49 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);

typedef _typedefC_50 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
);

typedef _typedefC_51 = ffi.Int64 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int64,
  ffi.Int32,
);

typedef _typedefC_52 = ffi.Uint64 Function(
  ffi.Uint64,
  ffi.Pointer<ffi.Uint8>,
  ffi.Uint32,
);

typedef _typedefC_53 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
);

typedef _typedefC_54 = ffi.Int64 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
  ffi.Int64,
  ffi.Int32,
);

typedef _typedefC_55 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Uint8>,
  ffi.Int32,
  ffi.Int32,
  ffi.Int64,
);

typedef _typedefC_56 = ffi.Int32 Function(
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_60 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_61 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVPacket>,
);

typedef _typedefC_62 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_63 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVPacket>,
  ffi.Pointer<AVPacket>,
  ffi.Int32,
);

typedef _typedefC_64 = ffi.Int32 Function(
  ffi.Int32,
  ffi.Int32,
);

typedef _typedefC_65 = ffi.Void Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Int32,
  ffi.Pointer<ffi.Int64>,
  ffi.Pointer<ffi.Int64>,
);

typedef _typedefC_66 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Int32,
  ffi.Pointer<ffi.Void>,
  ffi.Uint64,
);

typedef _typedefC_67 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Int32,
  ffi.Pointer<ffi.Pointer<AVFrame>>,
  ffi.Uint32,
);

typedef _typedefC_68 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVDeviceInfoList>,
);

typedef _typedefC_69 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVDeviceCapabilitiesQuery>,
);

typedef _typedefC_70 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVDeviceCapabilitiesQuery>,
);

typedef _typedefC_71 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_72 = ffi.Void Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_73 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVPacket>,
);

typedef _typedefC_74 = ffi.Int32 Function(
  ffi.Pointer<AVProbeData>,
);

typedef _typedefC_75 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_76 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVPacket>,
);

typedef _typedefC_77 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_78 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Int32,
  ffi.Int64,
  ffi.Int32,
);

typedef _typedefC_79 = ffi.Int64 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Int32,
  ffi.Pointer<ffi.Int64>,
  ffi.Int64,
);

typedef _typedefC_80 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_81 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
);

typedef _typedefC_82 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Int32,
  ffi.Int64,
  ffi.Int64,
  ffi.Int64,
  ffi.Int32,
);

typedef _typedefC_83 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVDeviceInfoList>,
);

typedef _typedefC_84 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVDeviceCapabilitiesQuery>,
);

typedef _typedefC_85 = ffi.Int32 Function(
  ffi.Pointer<AVFormatContext>,
  ffi.Pointer<AVDeviceCapabilitiesQuery>,
);

typedef _typedefC_86 = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
);

typedef _typedefC_87 = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
);

typedef _typedefC_88 = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
  ffi.Pointer<ffi.Pointer<AVDictionary>>,
);

typedef _typedefC_89 = ffi.Void Function(
  ffi.Pointer<AVFilterContext>,
);

typedef _typedefC_90 = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
);

typedef _typedefC_91 = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Pointer<ffi.Int8>,
  ffi.Int32,
  ffi.Int32,
);

typedef _typedefC_92 = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_93 = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
);

typedef avfilter_action_func = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
  ffi.Pointer<ffi.Void>,
  ffi.Int32,
  ffi.Int32,
);

typedef avfilter_execute_func = ffi.Int32 Function(
  ffi.Pointer<AVFilterContext>,
  ffi.Pointer<ffi.NativeFunction<avfilter_action_func>>,
  ffi.Pointer<ffi.Void>,
  ffi.Pointer<ffi.Int32>,
  ffi.Int32,
);

typedef _typedefC_102 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);

typedef _typedefC_103 = ffi.Void Function(
  ffi.Pointer<ffi.Void>,
);
